
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Artists - Matplotlib 1.5 - W3cubDocs</title>
  
  <meta name="description" content=" Bases&#58; object ">
  <meta name="keywords" content="artists, -, matplotlib, matplotlib~1.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/matplotlib~1.5/artist_api/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/matplotlib~1.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~1.5/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 1.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="artist-api">artists</h1> <img src="http://matplotlib.org/1.5.3/_images/inheritance-1ab6292a2d3e81c4b9fc9a3a9fb212e06390d7c0.png" alt="Inheritance diagram of matplotlib.patches, matplotlib.lines, matplotlib.text, matplotlib.offsetbox, matplotlib.image" usemap="#inheritance78d69db02b" class="inheritance" id="artists"> <map id="inheritance78d69db02b" name="inheritance78d69db02b"> <area shape="rect" id="node1" href="#matplotlib.artist.Artist" target="_top" title="Abstract base class for someone who renders into a" alt="" coords="41,466,116,487"> <area shape="rect" id="node6" href="image_api.html#matplotlib.image.FigureImage" target="_top" title="image.FigureImage" alt="" coords="223,279,339,300"> <area shape="rect" id="node8" href="image_api.html#matplotlib.image.PcolorImage" target="_top" title="Make a pcolor-style plot with an irregular rectangular grid." alt="" coords="222,201,340,221"> <area shape="rect" id="node9" href="lines_api.html#matplotlib.lines.Line2D" target="_top" title="A line - the line can have both a solid linestyle connecting all" alt="" coords="240,712,322,732"> <area shape="rect" id="node12" href="offsetbox_api.html#matplotlib.offsetbox.OffsetBox" target="_top" title="The OffsetBox is a simple container artist. The child artist are meant" alt="" coords="221,319,341,339"> <area shape="rect" id="node14" href="offsetbox_api.html#matplotlib.offsetbox.AnnotationBbox" target="_top" title="Annotation-like class, but with offsetbox instead of Text." alt="" coords="205,790,357,810"> <area shape="rect" id="node30" href="patches_api.html#matplotlib.patches.Patch" target="_top" title="A patch is a 2D artist with a face color and an edge color." alt="" coords="236,614,326,634"> <area shape="rect" id="node49" href="text_api.html#matplotlib.text.Text" target="_top" title="Handle storing and drawing of text in window or data coordinates." alt="" coords="250,672,312,693"> <area shape="rect" id="node2" href="cm_api.html#matplotlib.cm.ScalarMappable" target="_top" title="This is a mixin class to support scalar data to RGBA mapping." alt="" coords="19,240,138,260"> <area shape="rect" id="node3" href="image_api.html#matplotlib.image.AxesImage" target="_top" title="image.AxesImage" alt="" coords="437,83,549,103"> <area shape="rect" id="node7" href="image_api.html#matplotlib.image.NonUniformImage" target="_top" title="image.NonUniformImage" alt="" coords="615,83,764,103"> <area shape="rect" id="node5" href="image_api.html#matplotlib.image.BboxImage" target="_top" title="The Image class whose size is determined by the given bbox." alt="" coords="437,122,549,142"> <area shape="rect" id="node10" href="lines_api.html#matplotlib.lines.VertexSelector" target="_top" title="Manage the callbacks to maintain a list of selected vertices for" alt="" coords="18,201,139,221"> <area shape="rect" id="node11" href="offsetbox_api.html#matplotlib.offsetbox.AnchoredOffsetbox" target="_top" title="An offset box placed according to the legend location" alt="" coords="409,319,577,339"> <area shape="rect" id="node13" href="offsetbox_api.html#matplotlib.offsetbox.AnchoredText" target="_top" title="AnchoredOffsetbox with Text." alt="" coords="620,319,759,339"> <area shape="rect" id="node16" href="offsetbox_api.html#matplotlib.offsetbox.AuxTransformBox" target="_top" title="Offset Box with the aux_transform . Its children will be" alt="" coords="412,358,574,378"> <area shape="rect" id="node20" href="offsetbox_api.html#matplotlib.offsetbox.DrawingArea" target="_top" title="The DrawingArea can contain any Artist as a child. The DrawingArea" alt="" coords="425,397,561,417"> <area shape="rect" id="node22" href="offsetbox_api.html#matplotlib.offsetbox.PackerBase" target="_top" title="offsetbox.PackerBase" alt="" coords="428,161,558,182"> <area shape="rect" id="node23" href="offsetbox_api.html#matplotlib.offsetbox.OffsetImage" target="_top" title="offsetbox.OffsetImage" alt="" coords="426,201,559,221"> <area shape="rect" id="node24" href="offsetbox_api.html#matplotlib.offsetbox.PaddedBox" target="_top" title="offsetbox.PaddedBox" alt="" coords="430,240,556,260"> <area shape="rect" id="node25" href="offsetbox_api.html#matplotlib.offsetbox.TextArea" target="_top" title="The TextArea is contains a single Text instance. The text is" alt="" coords="436,279,550,300"> <area shape="rect" id="node48" href="text_api.html#matplotlib.text.Annotation" target="_top" title="text.Annotation" alt="" coords="444,908,542,928"> <area shape="rect" id="node17" href="offsetbox_api.html#matplotlib.offsetbox.DraggableAnnotation" target="_top" title="offsetbox.DraggableAnnotation" alt="" coords="191,122,371,142"> <area shape="rect" id="node18" href="offsetbox_api.html#matplotlib.offsetbox.DraggableBase" target="_top" title="helper code for a draggable artist (legend, offsetbox)" alt="" coords="4,142,153,163"> <area shape="rect" id="node19" href="offsetbox_api.html#matplotlib.offsetbox.DraggableOffsetBox" target="_top" title="offsetbox.DraggableOffsetBox" alt="" coords="194,161,368,182"> <area shape="rect" id="node21" href="offsetbox_api.html#matplotlib.offsetbox.HPacker" target="_top" title="The HPacker has its children packed horizontally. It automatically" alt="" coords="634,182,745,202"> <area shape="rect" id="node26" href="offsetbox_api.html#matplotlib.offsetbox.VPacker" target="_top" title="The VPacker has its children packed vertically. It automatically" alt="" coords="634,142,745,163"> <area shape="rect" id="node27" href="patches_api.html#matplotlib.patches.Arc" target="_top" title="An elliptical arc.  Because it performs various optimizations, it" alt="" coords="650,575,729,595"> <area shape="rect" id="node28" href="patches_api.html#matplotlib.patches.Ellipse" target="_top" title="A scale-free ellipse." alt="" coords="445,554,541,575"> <area shape="rect" id="node34" href="patches_api.html#matplotlib.patches.Circle" target="_top" title="A circle patch." alt="" coords="644,535,735,556"> <area shape="rect" id="node29" href="patches_api.html#matplotlib.patches.Arrow" target="_top" title="An arrow patch." alt="" coords="447,594,539,614"> <area shape="rect" id="node36" href="patches_api.html#matplotlib.patches.RegularPolygon" target="_top" title="A regular polygon patch." alt="" coords="422,633,564,653"> <area shape="rect" id="node38" href="patches_api.html#matplotlib.patches.FancyArrowPatch" target="_top" title="A fancy arrow patch. It draws an arrow using the :class:ArrowStyle." alt="" coords="419,672,567,693"> <area shape="rect" id="node41" href="patches_api.html#matplotlib.patches.Polygon" target="_top" title="A general polygon patch." alt="" coords="441,712,544,732"> <area shape="rect" id="node42" href="patches_api.html#matplotlib.patches.FancyBboxPatch" target="_top" title="Draw a fancy box around a rectangle with lower left at *xy*=(*x*," alt="" coords="420,751,566,771"> <area shape="rect" id="node43" href="patches_api.html#matplotlib.patches.PathPatch" target="_top" title="A general polycurve path patch." alt="" coords="437,790,549,810"> <area shape="rect" id="node44" href="patches_api.html#matplotlib.patches.Rectangle" target="_top" title="Draw a rectangle with lower left at *xy* = (*x*, *y*) with" alt="" coords="437,830,549,850"> <area shape="rect" id="node45" href="patches_api.html#matplotlib.patches.Shadow" target="_top" title="patches.Shadow" alt="" coords="442,437,544,457"> <area shape="rect" id="node46" href="patches_api.html#matplotlib.patches.Wedge" target="_top" title="Wedge shaped patch." alt="" coords="445,476,541,496"> <area shape="rect" id="node47" href="patches_api.html#matplotlib.patches.YAArrow" target="_top" title="Yet another arrow class." alt="" coords="441,515,545,535"> <area shape="rect" id="node31" href="patches_api.html#matplotlib.patches.ArrowStyle" target="_top" title=":class:`ArrowStyle` is a container class which defines several" alt="" coords="222,4,340,24"> <area shape="rect" id="node32" title="A base class for the Styles. It is meant to be a container class," alt="" coords="32,44,125,64"> <area shape="rect" id="node33" href="patches_api.html#matplotlib.patches.BoxStyle" target="_top" title=":class:`BoxStyle` is a container class which defines several" alt="" coords="227,44,335,64"> <area shape="rect" id="node39" href="patches_api.html#matplotlib.patches.ConnectionStyle" target="_top" title=":class:`ConnectionStyle` is a container class which defines" alt="" coords="208,83,354,103"> <area shape="rect" id="node35" href="patches_api.html#matplotlib.patches.CirclePolygon" target="_top" title="A polygon-approximation of a circle patch." alt="" coords="623,633,756,653"> <area shape="rect" id="node37" href="patches_api.html#matplotlib.patches.ConnectionPatch" target="_top" title="A :class:`~matplotlib.patches.ConnectionPatch` class is to make" alt="" coords="616,672,763,693"> <area shape="rect" id="node40" href="patches_api.html#matplotlib.patches.FancyArrow" target="_top" title="Like Arrow, but lets you set head width and head height independently." alt="" coords="629,712,750,732"> <area shape="rect" id="node51" href="text_api.html#matplotlib.text.TextWithDash" target="_top" title="This is basically a :class:`~matplotlib.text.Text` with a dash" alt="" coords="436,869,550,889"> <area shape="rect" id="node50" href="text_api.html#matplotlib.text.OffsetFrom" target="_top" title="Callable helper class for working with `Annotation`" alt="" coords="30,4,127,24"> </map>  <h2 id="matplotlib-artist">matplotlib.artist</h2> <dl class="class" id="module-matplotlib.artist"> <dt id="matplotlib.artist.Artist">
<code>class matplotlib.artist.Artist</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>Abstract base class for someone who renders into a <code>FigureCanvas</code>.</p> <dl class="method"> <dt id="matplotlib.artist.Artist.add_callback">
<code>add_callback(func)</code> </dt> <dd>
<p>Adds a callback function that will be called whenever one of the <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>‘s properties changes.</p> <p>Returns an <em>id</em> that is useful for removing the callback with <a class="reference internal" href="#matplotlib.artist.Artist.remove_callback" title="matplotlib.artist.Artist.remove_callback"><code>remove_callback()</code></a> later.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.artist.Artist.aname">
<code>aname = 'Artist'</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.artist.Artist.axes">
<code>axes</code> </dt> <dd>
<p>The <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.contains">
<code>contains(mouseevent)</code> </dt> <dd>
<p>Test whether the artist contains the mouse event.</p> <p>Returns the truth value and a dictionary of artist specific details of selection, such as which points are contained in the pick radius. See individual artists for details.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.convert_xunits">
<code>convert_xunits(x)</code> </dt> <dd>
<p>For artists in an axes, if the xaxis has units support, convert <em>x</em> using xaxis unit type</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.convert_yunits">
<code>convert_yunits(y)</code> </dt> <dd>
<p>For artists in an axes, if the yaxis has units support, convert <em>y</em> using yaxis unit type</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.draw">
<code>draw(renderer, *args, **kwargs)</code> </dt> <dd>
<p>Derived classes drawing method</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.findobj">
<code>findobj(match=None, include_self=True)</code> </dt> <dd>
<p>Find artist objects.</p> <p>Recursively find all <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instances contained in self.</p> <p><em>match</em> can be</p>  <ul class="simple"> <li>None: return all objects contained in artist.</li> <li>function with signature <code>boolean = match(artist)</code> used to filter matches</li> <li>class instance: e.g., Line2D. Only return artists of class type.</li> </ul>  <p>If <em>include_self</em> is True (default), include self in the list to be checked for a match.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.format_cursor_data">
<code>format_cursor_data(data)</code> </dt> <dd>
<p>Return <em>cursor data</em> string formatted.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_agg_filter">
<code>get_agg_filter()</code> </dt> <dd>
<p>return filter function to be used for agg filter</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_alpha">
<code>get_alpha()</code> </dt> <dd>
<p>Return the alpha value used for blending - not supported on all backends</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_animated">
<code>get_animated()</code> </dt> <dd>
<p>Return the artist’s animated state</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_axes">
<code>get_axes()</code> </dt> <dd>
<p>Return the <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance the artist resides in, or <em>None</em>.</p> <p>This has been deprecated in mpl 1.5, please use the axes property. Will be removed in 1.7 or 2.0.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_children">
<code>get_children()</code> </dt> <dd>
<p>Return a list of the child <code>Artist`s this
:class:`Artist</code> contains.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_clip_box">
<code>get_clip_box()</code> </dt> <dd>
<p>Return artist clipbox</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_clip_on">
<code>get_clip_on()</code> </dt> <dd>
<p>Return whether artist uses clipping</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_clip_path">
<code>get_clip_path()</code> </dt> <dd>
<p>Return artist clip path</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_contains">
<code>get_contains()</code> </dt> <dd>
<p>Return the _contains test used by the artist, or <em>None</em> for default.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_cursor_data">
<code>get_cursor_data(event)</code> </dt> <dd>
<p>Get the cursor data for a given event.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_figure">
<code>get_figure()</code> </dt> <dd>
<p>Return the <a class="reference internal" href="../figure_api/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_gid">
<code>get_gid()</code> </dt> <dd>
<p>Returns the group id</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_label">
<code>get_label()</code> </dt> <dd>
<p>Get the label used for this artist in the legend.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_path_effects">
<code>get_path_effects()</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_picker">
<code>get_picker()</code> </dt> <dd>
<p>Return the picker object used by this artist</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_rasterized">
<code>get_rasterized()</code> </dt> <dd>
<p>return True if the artist is to be rasterized</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_sketch_params">
<code>get_sketch_params()</code> </dt> <dd>
<p>Returns the sketch parameters for the artist.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>sketch_params</strong> : tuple or <code>None</code></p> <p>A 3-tuple with the following elements:</p>  <ul class="simple"> <li>
<code>scale</code>: The amplitude of the wiggle perpendicular to the source line.</li> <li>
<code>length</code>: The length of the wiggle along the line.</li> <li>
<code>randomness</code>: The scale factor by which the length is shrunken or expanded.</li> </ul>  <p class="last">May return <code>None</code> if no sketch parameters were set.</p> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_snap">
<code>get_snap()</code> </dt> <dd>
<p>Returns the snap setting which may be:</p>  <ul class="simple"> <li>True: snap vertices to the nearest pixel center</li> <li>False: leave vertices as-is</li> <li>None: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center</li> </ul>  <p>Only supported by the Agg and MacOSX backends.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_transform">
<code>get_transform()</code> </dt> <dd>
<p>Return the <a class="reference internal" href="http://matplotlib.org/1.5.3/devel/transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform" target="_blank"><code>Transform</code></a> instance used by this artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_transformed_clip_path_and_affine">
<code>get_transformed_clip_path_and_affine()</code> </dt> <dd>
<p>Return the clip path with the non-affine part of its transformation applied, and the remaining affine part of its transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_url">
<code>get_url()</code> </dt> <dd>
<p>Returns the url</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_visible">
<code>get_visible()</code> </dt> <dd>
<p>Return the artist’s visiblity</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_window_extent">
<code>get_window_extent(renderer)</code> </dt> <dd>
<p>Get the axes bounding box in display space. Subclasses should override for inclusion in the bounding box “tight” calculation. Default is to return an empty bounding box at 0, 0.</p> <p>Be careful when using this function, the results will not update if the artist window extent of the artist changes. The extent can change due to any changes in the transform stack, such as changing the axes limits, the figure size, or the canvas used (as is done when saving a figure). This can lead to unexpected behavior where interactive figures will look fine on the screen, but will save incorrectly.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.get_zorder">
<code>get_zorder()</code> </dt> <dd>
<p>Return the <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>‘s zorder.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.have_units">
<code>have_units()</code> </dt> <dd>
<p>Return <em>True</em> if units are set on the <em>x</em> or <em>y</em> axes</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.hitlist">
<code>hitlist(event)</code> </dt> <dd>
<p>List the children of the artist which contain the mouse event <em>event</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.is_figure_set">
<code>is_figure_set()</code> </dt> <dd>
<p>Returns True if the artist is assigned to a <a class="reference internal" href="../figure_api/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.is_transform_set">
<code>is_transform_set()</code> </dt> <dd>
<p>Returns <em>True</em> if <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> has a transform explicitly set.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.artist.Artist.mouseover">
<code>mouseover</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.pchanged">
<code>pchanged()</code> </dt> <dd>
<p>Fire an event when property changed, calling all of the registered callbacks.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.pick">
<code>pick(mouseevent)</code> </dt> <dd>
<p>call signature:</p> <pre data-language="python">pick(mouseevent)
</pre> <p>each child artist will fire a pick event if <em>mouseevent</em> is over the artist and the artist has picker set</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.pickable">
<code>pickable()</code> </dt> <dd>
<p>Return <em>True</em> if <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> is pickable.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.properties">
<code>properties()</code> </dt> <dd>
<p>return a dictionary mapping property name -&gt; value for all Artist props</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.remove">
<code>remove()</code> </dt> <dd>
<p>Remove the artist from the figure if possible. The effect will not be visible until the figure is redrawn, e.g., with <code>matplotlib.axes.Axes.draw_idle()</code>. Call <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>matplotlib.axes.Axes.relim()</code></a> to update the axes limits if desired.</p> <p>Note: <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes.relim" title="matplotlib.axes.Axes.relim"><code>relim()</code></a> will not see collections even if the collection was added to axes with <em>autolim</em> = True.</p> <p>Note: there is no support for removing the artist’s legend entry.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.remove_callback">
<code>remove_callback(oid)</code> </dt> <dd>
<p>Remove a callback based on its <em>id</em>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.artist.Artist.add_callback" title="matplotlib.artist.Artist.add_callback"><code>add_callback()</code></a>
</dt> <dd>For adding callbacks</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set">
<code>set(**kwargs)</code> </dt> <dd>
<p>A property batch setter. Pass <em>kwargs</em> to set properties. Will handle property name collisions (e.g., if both ‘color’ and ‘facecolor’ are specified, the property with higher priority gets set last).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_agg_filter">
<code>set_agg_filter(filter_func)</code> </dt> <dd>
<p>set agg_filter fuction.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_alpha">
<code>set_alpha(alpha)</code> </dt> <dd>
<p>Set the alpha value used for blending - not supported on all backends.</p> <p>ACCEPTS: float (0.0 transparent through 1.0 opaque)</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_animated">
<code>set_animated(b)</code> </dt> <dd>
<p>Set the artist’s animation state.</p> <p>ACCEPTS: [True | False]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_axes">
<code>set_axes(axes)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance in which the artist resides, if any.</p> <p>This has been deprecated in mpl 1.5, please use the axes property. Will be removed in 1.7 or 2.0.</p> <p>ACCEPTS: an <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> instance</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_clip_box">
<code>set_clip_box(clipbox)</code> </dt> <dd>
<p>Set the artist’s clip <a class="reference internal" href="http://matplotlib.org/1.5.3/devel/transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox" target="_blank"><code>Bbox</code></a>.</p> <p>ACCEPTS: a <a class="reference internal" href="http://matplotlib.org/1.5.3/devel/transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox" target="_blank"><code>matplotlib.transforms.Bbox</code></a> instance</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_clip_on">
<code>set_clip_on(b)</code> </dt> <dd>
<p>Set whether artist uses clipping.</p> <p>When False artists will be visible out side of the axes which can lead to unexpected results.</p> <p>ACCEPTS: [True | False]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_clip_path">
<code>set_clip_path(path, transform=None)</code> </dt> <dd>
<p>Set the artist’s clip path, which may be:</p>  <ul> <li>a <a class="reference internal" href="../patches_api/#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> (or subclass) instance </li> <li>
<dl class="first docutils"> <dt>
<code>a Path instance, in which case</code> </dt> <dd>
<p class="first last">an optional <a class="reference internal" href="http://matplotlib.org/1.5.3/devel/transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform" target="_blank"><code>Transform</code></a> instance may be provided, which will be applied to the path before using it for clipping.</p> </dd> </dl> </li> <li>
<em>None</em>, to remove the clipping path </li> </ul>  <p>For efficiency, if the path happens to be an axis-aligned rectangle, this method will set the clipping box to the corresponding rectangle and set the clipping path to <em>None</em>.</p> <p>ACCEPTS: [ (<a class="reference internal" href="../path_api/#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, <a class="reference internal" href="http://matplotlib.org/1.5.3/devel/transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform" target="_blank"><code>Transform</code></a>) | <a class="reference internal" href="../patches_api/#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code>Patch</code></a> | None ]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_contains">
<code>set_contains(picker)</code> </dt> <dd>
<p>Replace the contains test used by this artist. The new picker should be a callable function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>If the mouse event is over the artist, return <em>hit</em> = <em>True</em> and <em>props</em> is a dictionary of properties you want returned with the contains test.</p> <p>ACCEPTS: a callable function</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_figure">
<code>set_figure(fig)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="../figure_api/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a> instance the artist belongs to.</p> <p>ACCEPTS: a <a class="reference internal" href="../figure_api/#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a> instance</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_gid">
<code>set_gid(gid)</code> </dt> <dd>
<p>Sets the (group) id for the artist</p> <p>ACCEPTS: an id string</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_label">
<code>set_label(s)</code> </dt> <dd>
<p>Set the label to <em>s</em> for auto legend.</p> <p>ACCEPTS: string or anything printable with ‘%s’ conversion.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_path_effects">
<code>set_path_effects(path_effects)</code> </dt> <dd>
<p>set path_effects, which should be a list of instances of matplotlib.patheffect._Base class or its derivatives.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_picker">
<code>set_picker(picker)</code> </dt> <dd>
<p>Set the epsilon for picking used by this artist</p> <p><em>picker</em> can be one of the following:</p>  <ul> <li>
<em>None</em>: picking is disabled for this artist (default) </li> <li>A boolean: if <em>True</em> then picking will be enabled and the artist will fire a pick event if the mouse event is over the artist </li> <li>A float: if picker is a number it is interpreted as an epsilon tolerance in points and the artist will fire off an event if it’s data is within epsilon of the mouse event. For some artists like lines and patch collections, the artist may provide additional data to the pick event that is generated, e.g., the indices of the data within epsilon of the pick event </li> <li>
<p class="first">A function: if picker is callable, it is a user supplied function which determines whether the artist is hit by the mouse event:</p> <pre data-language="python">hit, props = picker(artist, mouseevent)
</pre> <p>to determine the hit test. if the mouse event is over the artist, return <em>hit=True</em> and props is a dictionary of properties you want added to the PickEvent attributes.</p> </li> </ul>  <p>ACCEPTS: [None|float|boolean|callable]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_rasterized">
<code>set_rasterized(rasterized)</code> </dt> <dd>
<p>Force rasterized (bitmap) drawing in vector backend output.</p> <p>Defaults to None, which implies the backend’s default behavior</p> <p>ACCEPTS: [True | False | None]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_sketch_params">
<code>set_sketch_params(scale=None, length=None, randomness=None)</code> </dt> <dd>
<p>Sets the sketch parameters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>scale</strong> : float, optional</p>  <p>The amplitude of the wiggle perpendicular to the source line, in pixels. If scale is <code>None</code>, or not provided, no sketch filter will be provided.</p>  <p><strong>length</strong> : float, optional</p>  <p>The length of the wiggle along the line, in pixels (default 128.0)</p>  <p><strong>randomness</strong> : float, optional</p>  <p>The scale factor by which the length is shrunken or expanded (default 16.0)</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_snap">
<code>set_snap(snap)</code> </dt> <dd>
<p>Sets the snap setting which may be:</p>  <ul class="simple"> <li>True: snap vertices to the nearest pixel center</li> <li>False: leave vertices as-is</li> <li>None: (auto) If the path contains only rectilinear line segments, round to the nearest pixel center</li> </ul>  <p>Only supported by the Agg and MacOSX backends.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_transform">
<code>set_transform(t)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="http://matplotlib.org/1.5.3/devel/transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform" target="_blank"><code>Transform</code></a> instance used by this artist.</p> <p>ACCEPTS: <a class="reference internal" href="http://matplotlib.org/1.5.3/devel/transformations.html#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform" target="_blank"><code>Transform</code></a> instance</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_url">
<code>set_url(url)</code> </dt> <dd>
<p>Sets the url for the artist</p> <p>ACCEPTS: a url string</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_visible">
<code>set_visible(b)</code> </dt> <dd>
<p>Set the artist’s visiblity.</p> <p>ACCEPTS: [True | False]</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.set_zorder">
<code>set_zorder(level)</code> </dt> <dd>
<p>Set the zorder for the artist. Artists with lower zorder values are drawn first.</p> <p>ACCEPTS: any number</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.artist.Artist.stale">
<code>stale</code> </dt> <dd>
<p>If the artist is ‘stale’ and needs to be re-drawn for the output to match the internal state of the artist.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.update">
<code>update(props)</code> </dt> <dd>
<p>Update the properties of this <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> from the dictionary <em>prop</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.Artist.update_from">
<code>update_from(other)</code> </dt> <dd>
<p>Copy properties from <em>other</em> to <em>self</em>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.artist.Artist.zorder">
<code>zorder = 0</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.artist.ArtistInspector">
<code>class matplotlib.artist.ArtistInspector(o)</code> </dt> <dd>
<p>Bases: <code>object</code></p> <p>A helper class to inspect an <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> and return information about it’s settable properties and their current values.</p> <p>Initialize the artist inspector with an <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> or sequence of <code>Artists</code>. If a sequence is used, we assume it is a homogeneous sequence (all <code>Artists</code> are of the same type) and it is your responsibility to make sure this is so.</p> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.aliased_name">
<code>aliased_name(s)</code> </dt> <dd>
<p>return ‘PROPNAME or alias’ if <em>s</em> has an alias, else return PROPNAME.</p> <p>e.g., for the line markerfacecolor property, which has an alias, return ‘markerfacecolor or mfc’ and for the transform property, which does not, return ‘transform’</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.aliased_name_rest">
<code>aliased_name_rest(s, target)</code> </dt> <dd>
<p>return ‘PROPNAME or alias’ if <em>s</em> has an alias, else return PROPNAME formatted for ReST</p> <p>e.g., for the line markerfacecolor property, which has an alias, return ‘markerfacecolor or mfc’ and for the transform property, which does not, return ‘transform’</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.findobj">
<code>findobj(match=None)</code> </dt> <dd>
<p>Recursively find all <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>matplotlib.artist.Artist</code></a> instances contained in <em>self</em>.</p> <p>If <em>match</em> is not None, it can be</p>  <ul class="simple"> <li>function with signature <code>boolean = match(artist)</code>
</li> <li>class instance: e.g., <a class="reference internal" href="../lines_api/#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code>Line2D</code></a>
</li> </ul>  <p>used to filter matches.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.get_aliases">
<code>get_aliases()</code> </dt> <dd>
<p>Get a dict mapping <em>fullname</em> -&gt; <em>alias</em> for each <em>alias</em> in the <a class="reference internal" href="#matplotlib.artist.ArtistInspector" title="matplotlib.artist.ArtistInspector"><code>ArtistInspector</code></a>.</p> <p>e.g., for lines:</p> <pre data-language="python">{'markerfacecolor': 'mfc',
 'linewidth'      : 'lw',
}
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.get_setters">
<code>get_setters()</code> </dt> <dd>
<p>Get the attribute strings with setters for object. e.g., for a line, return <code>['markerfacecolor', 'linewidth', ....]</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.get_valid_values">
<code>get_valid_values(attr)</code> </dt> <dd>
<p>Get the legal arguments for the setter associated with <em>attr</em>.</p> <p>This is done by querying the docstring of the function <em>set_attr</em> for a line that begins with ACCEPTS:</p> <p>e.g., for a line linestyle, return “[ <code>'-'</code> | <code>'--'</code> | <code>'-.'</code> | <code>':'</code> | <code>'steps'</code> | <code>'None'</code> ]”</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.is_alias">
<code>is_alias(o)</code> </dt> <dd>
<p>Return <em>True</em> if method object <em>o</em> is an alias for another function.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.pprint_getters">
<code>pprint_getters()</code> </dt> <dd>
<p>Return the getters and actual values as list of strings.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.pprint_setters">
<code>pprint_setters(prop=None, leadingspace=2)</code> </dt> <dd>
<p>If <em>prop</em> is <em>None</em>, return a list of strings of all settable properies and their valid values.</p> <p>If <em>prop</em> is not <em>None</em>, it is a valid property name and that property will be returned as a string of property : valid values.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.pprint_setters_rest">
<code>pprint_setters_rest(prop=None, leadingspace=2)</code> </dt> <dd>
<p>If <em>prop</em> is <em>None</em>, return a list of strings of all settable properies and their valid values. Format the output for ReST</p> <p>If <em>prop</em> is not <em>None</em>, it is a valid property name and that property will be returned as a string of property : valid values.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.artist.ArtistInspector.properties">
<code>properties()</code> </dt> <dd>
<p>return a dictionary mapping property name -&gt; value</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.artist.allow_rasterization">
<code>matplotlib.artist.allow_rasterization(draw)</code> </dt> <dd>
<p>Decorator for Artist.draw method. Provides routines that run before and after the draw call. The before and after functions are useful for changing artist-dependant renderer attributes or making other setup function calls, such as starting and flushing a mixed-mode renderer.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.artist.get">
<code>matplotlib.artist.get(obj, property=None)</code> </dt> <dd>
<p>Return the value of object’s property. <em>property</em> is an optional string for the property you want to return</p> <p>Example usage:</p> <pre data-language="python">getp(obj)  # get all the object properties
getp(obj, 'linestyle')  # get the linestyle property
</pre> <p><em>obj</em> is a <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instance, e.g., <code>Line2D</code> or an instance of a <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> or <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a>. If the <em>property</em> is ‘somename’, this function returns</p>  obj.get_somename() <p><a class="reference internal" href="#matplotlib.artist.getp" title="matplotlib.artist.getp"><code>getp()</code></a> can be used to query all the gettable properties with <code>getp(obj)</code>. Many properties have aliases for shorter typing, e.g. ‘lw’ is an alias for ‘linewidth’. In the output, aliases and full property names will be listed as:</p>  property or alias = value <p>e.g.:</p>  linewidth or lw = 2 </dd>
</dl> <dl class="function"> <dt id="matplotlib.artist.getp">
<code>matplotlib.artist.getp(obj, property=None)</code> </dt> <dd>
<p>Return the value of object’s property. <em>property</em> is an optional string for the property you want to return</p> <p>Example usage:</p> <pre data-language="python">getp(obj)  # get all the object properties
getp(obj, 'linestyle')  # get the linestyle property
</pre> <p><em>obj</em> is a <a class="reference internal" href="#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> instance, e.g., <code>Line2D</code> or an instance of a <a class="reference internal" href="../axes_api/#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a> or <a class="reference internal" href="../text_api/#matplotlib.text.Text" title="matplotlib.text.Text"><code>matplotlib.text.Text</code></a>. If the <em>property</em> is ‘somename’, this function returns</p>  obj.get_somename() <p><a class="reference internal" href="#matplotlib.artist.getp" title="matplotlib.artist.getp"><code>getp()</code></a> can be used to query all the gettable properties with <code>getp(obj)</code>. Many properties have aliases for shorter typing, e.g. ‘lw’ is an alias for ‘linewidth’. In the output, aliases and full property names will be listed as:</p>  property or alias = value <p>e.g.:</p>  linewidth or lw = 2 </dd>
</dl> <dl class="function"> <dt id="matplotlib.artist.kwdoc">
<code>matplotlib.artist.kwdoc(a)</code> </dt> 
</dl> <dl class="function"> <dt id="matplotlib.artist.setp">
<code>matplotlib.artist.setp(obj, *args, **kwargs)</code> </dt> <dd>
<p>Set a property on an artist object.</p> <p>matplotlib supports the use of <a class="reference internal" href="#matplotlib.artist.setp" title="matplotlib.artist.setp"><code>setp()</code></a> (“set property”) and <a class="reference internal" href="#matplotlib.artist.getp" title="matplotlib.artist.getp"><code>getp()</code></a> to set and get object properties, as well as to do introspection on the object. For example, to set the linestyle of a line to be dashed, you can do:</p> <pre data-language="python">&gt;&gt;&gt; line, = plot([1,2,3])
&gt;&gt;&gt; setp(line, linestyle='--')
</pre> <p>If you want to know the valid types of arguments, you can provide the name of the property you want to set without a value:</p> <pre data-language="python">&gt;&gt;&gt; setp(line, 'linestyle')
    linestyle: [ '-' | '--' | '-.' | ':' | 'steps' | 'None' ]
</pre> <p>If you want to see all the properties that can be set, and their possible values, you can do:</p> <pre data-language="python">&gt;&gt;&gt; setp(line)
    ... long output listing omitted
</pre> <p><a class="reference internal" href="#matplotlib.artist.setp" title="matplotlib.artist.setp"><code>setp()</code></a> operates on a single instance or a list of instances. If you are in query mode introspecting the possible values, only the first instance in the sequence is used. When actually setting values, all the instances will be set. e.g., suppose you have a list of two lines, the following will make both lines thicker and red:</p> <pre data-language="python">&gt;&gt;&gt; x = arange(0,1.0,0.01)
&gt;&gt;&gt; y1 = sin(2*pi*x)
&gt;&gt;&gt; y2 = sin(4*pi*x)
&gt;&gt;&gt; lines = plot(x, y1, x, y2)
&gt;&gt;&gt; setp(lines, linewidth=2, color='r')
</pre> <p><a class="reference internal" href="#matplotlib.artist.setp" title="matplotlib.artist.setp"><code>setp()</code></a> works with the MATLAB style string/value pairs or with python kwargs. For example, the following are equivalent:</p> <pre data-language="python">&gt;&gt;&gt; setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style
&gt;&gt;&gt; setp(lines, linewidth=2, color='r')        # python style
</pre> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2016 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="http://matplotlib.org/1.5.3/api/artist_api.html" class="_attribution-link" target="_blank">http://matplotlib.org/1.5.3/api/artist_api.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
