
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;hash - C++ - W3cubDocs</title>
  
  <meta name="description" content="The hash template defines a function object that implements a hash function. Instances of this function object satisfy Hash. In particular, they &hellip;">
  <meta name="keywords" content="std, hash, -, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/cpp/utility/hash/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _c">
				
<h1 id="firstHeading" class="firstHeading">std::hash</h1>            <table class="t-dcl-begin"><tbody> <tr class="t-dsc-header"> <th> <div>Defined in header <code><a href="../../header/functional/" title="cpp/header/functional">&lt;functional&gt;</a></code> </div>
</th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Key &gt;
struct hash;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </tbody></table> <p>The hash template defines a function object that implements a <a href="http://en.wikipedia.com/wiki/Hash_function" class="extiw" title="enwiki:Hash function" target="_blank">hash function</a>. Instances of this function object satisfy <a href="../../concept/hash/" title="cpp/concept/Hash"><code>Hash</code></a>. In particular, they define an <code>operator()</code> that:</p>
<p>1. Accepts a single parameter of type <code>Key</code>.</p>
<p>2. Returns a value of type <code>size_t</code> that represents the hash value of the parameter.</p>
<p>3. Does not throw exceptions when called.</p>
<p>4. For two parameters <code>k1</code> and <code>k2</code> that are equal, <code>std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)</code>.</p>
<p>5. For two different parameters <code>k1</code> and <code>k2</code> that are not equal, the probability that <code>std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)</code> should be very small, approaching <code><span class="nu16">1.0</span><span class="sy2">/</span><a href="../../types/numeric_limits/"><span class="kw344">std::<span class="me2">numeric_limits</span></span></a><span class="sy1">&lt;</span>size_t<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">max</span><span class="br0">(</span><span class="br0">)</span></code>.</p>
<p>The hash template is <a href="../../concept/defaultconstructible/" title="cpp/concept/DefaultConstructible"><code>DefaultConstructible</code></a>, <a href="../../concept/copyassignable/" title="cpp/concept/CopyAssignable"><code>CopyAssignable</code></a>, <a href="../../concept/swappable/" title="cpp/concept/Swappable"><code>Swappable</code></a> and <a href="../../concept/destructible/" title="cpp/concept/Destructible"><code>Destructible</code></a>.</p>
<p>The unordered associative containers <code><a href="../../container/unordered_set/" title="cpp/container/unordered set">std::unordered_set</a></code>, <code><a href="../../container/unordered_multiset/" title="cpp/container/unordered multiset">std::unordered_multiset</a></code>, <code><a href="../../container/unordered_map/" title="cpp/container/unordered map">std::unordered_map</a></code>, <code><a href="../../container/unordered_multimap/" title="cpp/container/unordered multimap">std::unordered_multimap</a></code> use specializations of the template <code>std::hash</code> as the default hash function.</p>
<h3 id="Notes"> Notes</h3> <p>The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision DoS attacks.</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <p>There is no specialization for C strings. <code>std::hash&lt;const char*&gt;</code> produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</p>
<h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>argument_type</code><span class="t-mark">(deprecated in C++17)</span> </td> <td> <code>Key</code> </td>
</tr> <tr class="t-dsc"> <td> <code>result_type</code><span class="t-mark">(deprecated in C++17)</span> </td> <td> <code><a href="../../types/size_t/" title="cpp/types/size t">std::size_t</a></code> </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div class="t-dsc-member-div t-dsc-member-nobold-div"><div><a href="../hash/hash/" title="cpp/utility/hash/hash"> <span class="t-lines"><span>(constructor)</span></span></a></div></div> </td> <td> constructs a hash function object <br> <span class="t-mark">(public member function)</span> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div"><div><a href="../hash/operator()/" title="cpp/utility/hash/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div> </td> <td> calculate the hash of the argument <br> <span class="t-mark">(public member function)</span> </td>
</tr> </table> <h3 id="Standard_specializations_for_basic_types"> Standard specializations for basic types</h3> <table class="t-dcl-begin"><tbody> <tr class="t-dsc-header"> <th> <div>Defined in header <code><a href="../../header/functional/" title="cpp/header/functional">&lt;functional&gt;</a></code> </div>
</th> <th> </th> <th> </th> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">template&lt;&gt; struct hash&lt;bool&gt;;
template&lt;&gt; struct hash&lt;char&gt;;
template&lt;&gt; struct hash&lt;signed char&gt;;
template&lt;&gt; struct hash&lt;unsigned char&gt;;
template&lt;&gt; struct hash&lt;char16_t&gt;;
template&lt;&gt; struct hash&lt;char32_t&gt;;
template&lt;&gt; struct hash&lt;wchar_t&gt;;
template&lt;&gt; struct hash&lt;short&gt;;
template&lt;&gt; struct hash&lt;unsigned short&gt;;
template&lt;&gt; struct hash&lt;int&gt;;
template&lt;&gt; struct hash&lt;unsigned int&gt;;
template&lt;&gt; struct hash&lt;long&gt;;
template&lt;&gt; struct hash&lt;long long&gt;;
template&lt;&gt; struct hash&lt;unsigned long&gt;;
template&lt;&gt; struct hash&lt;unsigned long long&gt;;
template&lt;&gt; struct hash&lt;float&gt;;
template&lt;&gt; struct hash&lt;double&gt;;
template&lt;&gt; struct hash&lt;long double&gt;;
template&lt; class T &gt; struct hash&lt;T*&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </tbody></table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as <code>std<span class="sy4">::</span><span class="me2">hash</span><span class="sy1">&lt;</span><a href="../../types/underlying_type/"><span class="kw614">std::<span class="me2">underlying_type</span></span></a><span class="sy1">&lt;</span>Enum<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span><span class="sy1">&gt;</span></code>).</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>In addition to the above, the standard library provides specializations for all integral types, including any extended integer types that the implementation supports.</p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Standard_specializations_for_library_types"> Standard specializations for library types</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../string/basic_string/hash/" title="cpp/string/basic string/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u16string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u32string&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::wstring&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for strings <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../error/error_code/hash/" title="cpp/error/error code/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::error_code&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../error/error_code/" title="cpp/error/error code">std::error_code</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../bitset/hash/" title="cpp/utility/bitset/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::bitset&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../bitset/" title="cpp/utility/bitset">std::bitset</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/unique_ptr/hash/" title="cpp/memory/unique ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::unique_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../memory/unique_ptr/" title="cpp/memory/unique ptr">std::unique_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../memory/shared_ptr/hash/" title="cpp/memory/shared ptr/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::shared_ptr&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../memory/shared_ptr/" title="cpp/memory/shared ptr">std::shared_ptr</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../types/type_index/hash/" title="cpp/types/type index/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::type_index&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../types/type_index/" title="cpp/types/type index">std::type_index</a></code> <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../container/vector_bool/hash/" title="cpp/container/vector bool/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::vector&lt;bool&gt;&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../container/vector/"><span class="kw1158">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../thread/thread/id/hash/" title="cpp/thread/thread/id/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::thread::id&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div> </td> <td> hash support for <code><a href="../../thread/thread/id.1/" title="cpp/thread/thread/id">std::thread::id</a></code> <br> <span class="t-mark">(class template specialization)</span> </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../optional/hash/" title="cpp/utility/optional/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::optional&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div>
</div> </td> <td> specializes the <code>std::hash</code> algorithm <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../variant/hash/" title="cpp/utility/variant/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::variant&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div>
</div> </td> <td> specializes the <code>std::hash</code> algorithm <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div class="t-dsc-member-div">
<div><a href="../../string/basic_string_view/hash/" title="cpp/string/basic string view/hash"> <span class="t-lines"><span>std::hash<span class="t-dsc-small">&lt;std::string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::wstring_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u16string_view&gt;</span></span><span>std::hash<span class="t-dsc-small">&lt;std::u32string_view&gt;</span></span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div>
</div> </td> <td> hash support for string views <br> <span class="t-mark">(class template specialization)</span>  </td>
</tr> </table> <p>Note: additional specializations for <code>std::pair</code> and the standard container types, as well as utility functions to compose hashes are available in <a rel="nofollow" class="external text" href="http://www.boost.org/doc/libs/release/doc/html/hash/reference.html" target="_blank">boost.hash</a>.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
 
struct S {
    std::string first_name;
    std::string last_name;
};
bool operator==(const S&amp; lhs, const S&amp; rhs) {
    return lhs.first_name == rhs.first_name &amp;&amp; lhs.last_name == rhs.last_name;
}
 
// custom hash can be a standalone function object:
struct MyHash
{
    std::size_t operator()(S const&amp; s) const 
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine
    }
};
 
// custom specialization of std::hash can be injected in namespace std
namespace std
{
    template&lt;&gt; struct hash&lt;S&gt;
    {
        typedef S argument_type;
        typedef std::size_t result_type;
        result_type operator()(argument_type const&amp; s) const
        {
            result_type const h1 ( std::hash&lt;std::string&gt;{}(s.first_name) );
            result_type const h2 ( std::hash&lt;std::string&gt;{}(s.last_name) );
            return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine
        }
    };
}
 
int main()
{
 
    std::string str = "Meet the new boss...";
    std::size_t str_hash = std::hash&lt;std::string&gt;{}(str);
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(str) &lt;&lt; ") = " &lt;&lt; str_hash &lt;&lt; '\n';
 
    S obj = { "Hubert", "Farnsworth"};
    // using the standalone function object
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(obj.first_name) &lt;&lt; ',' 
               &lt;&lt; std::quoted(obj.last_name) &lt;&lt; ") = "
               &lt;&lt; MyHash{}(obj) &lt;&lt; " (using MyHash)\n                           or "
               &lt;&lt; std::hash&lt;S&gt;{}(obj) &lt;&lt; " (using std::hash) " &lt;&lt; '\n';
 
    // custom hash makes it possible to use custom types in unordered containers
    // The example will use the injected std::hash specialization,
    // to use MyHash instead, pass it as a second template argument
    std::unordered_set&lt;S&gt; names = {obj, {"Bender", "Rodriguez"}, {"Leela", "Turanga"} };
    for(auto&amp; s: names)
        std::cout &lt;&lt; std::quoted(s.first_name) &lt;&lt; ' ' &lt;&lt; std::quoted(s.last_name) &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">hash("Meet the new boss...") = 1861821886482076440
hash("Hubert","Farnsworth") = 17622465712001802105 (using MyHash)
                           or 17622465712001802105 (using std::hash) 
"Leela" "Turanga"
"Bender" "Rodriguez"
"Hubert" "Farnsworth"</pre></div> </div>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/utility/hash" class="_attribution-link" target="_blank">http://en.cppreference.com/w/cpp/utility/hash</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
