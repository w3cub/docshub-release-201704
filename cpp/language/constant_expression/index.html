
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Constant Expressions - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Defines an expression that can be evaluated at compile time. ">
  <meta name="keywords" content="constant, expressions, -, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/cpp/language/constant_expression/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _c">
				
<h1 id="firstHeading" class="firstHeading">Constant expressions</h1>            <p>Defines an <a href="../expressions/" title="cpp/language/expressions">expression</a> that can be evaluated at compile time.</p>
<p>Such expressions can be used as non-type template arguments, array sizes, and in other contexts that require constant expressions, e.g.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int n = 1;
std::array&lt;int, n&gt; a1; // error, n is not a constant expression
const int cn = 2;
std::array&lt;int, cn&gt; a2; // OK, cn is a constant expression</pre></div>  <h3 id="Core_constant_expressions"> Core constant expressions</h3> <p>A <i>core constant expression</i> is any expression that <i>does not</i> have any one of the following in any subexpression (ignoring unevaluated expressions such as the operand of <code>sizeof</code> or the right operand of builtin <code>&amp;&amp;</code> when the left operand evaluates to <code>false</code>).</p>
<div class="t-li1">
<span class="t-li">1)</span> A function call expression that calls a function (or a constructor) that is not declared <a href="../constexpr/" title="cpp/language/constexpr">constexpr</a> <div class="cpp source-cpp"><pre data-language="cpp">constexpr int n = std::numeric_limits&lt;int&gt;::max(); // OK, max() is constexpr
constexpr int m = std::time(NULL); // Error: std::time() is not constexpr</pre></div>
</div> <div class="t-li1">
<span class="t-li">2)</span> A function call to a <code>constexpr</code> function which is declared, but not defined, or a function call to a <code>constexpr</code> function/constructor template instantiation where the instantiation fails to satisfy <a href="../constexpr/" title="cpp/language/constexpr">constexpr function</a>/constructor requirements.</div> <div class="t-li1">
<span class="t-li">3)</span> A function call to a <code>constexpr</code> function with arguments that do not produce a constant expression when substituted <div class="cpp source-cpp"><pre data-language="cpp">constexpr const int* addr(const int&amp; ir) { return &amp;ir; }
static const int x = 5;
constexpr const int* xp = addr(x); // OK
constexpr const int* tp = addr(5); // error: &amp;5 is not a constant expression</pre></div>
</div> <div class="t-li1">
<span class="t-li">4)</span> A function call to a <code>constexpr</code> constructor with arguments that do not produce constant expressions in member-initializer lists that are called from this function <div class="cpp source-cpp"><pre data-language="cpp">int x;
struct A {
    constexpr A(bool b) : m(b?42:x) { }
    int m;
};
constexpr int v = A(true).m; // OK
constexpr int w = A(false).m; // error: non-const x</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <div class="t-li1">
<span class="t-li">5)</span> A function call to a recursive <code>constexpr</code> function that would exceed compile-time recursion depth limit (implementation-defined) </div>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <div class="t-li1">
<span class="t-li">5)</span> an expression that would exceed the implementation-defined limits </div>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <div class="t-li1">
<span class="t-li">6)</span> The <a href="../this/" title="cpp/language/this">this</a> pointer, except if used for class member access inside a non-static member function </div>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr>
<tr class="t-rev t-since-cxx14">
<td> <div class="t-li1">
<span class="t-li">6)</span> The <a href="../this/" title="cpp/language/this">this</a> pointer, except in a <code>constexpr</code> function or a <code>constexpr</code> constructor that is being evaluated as part of the expression </div>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <div class="t-li1">
<span class="t-li">7)</span> An expression whose result is not mathematically defined or is out of range for its type. <div class="cpp source-cpp"><pre data-language="cpp">constexpr double d1 = 2.0/1.0; // OK
constexpr double d2 = 2.0/0.0; // Error: not defined
constexpr int n = std::numeric_limits&lt;int&gt;::max() + 1; // Error: overflow</pre></div> </div>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <div class="t-li1">
<span class="t-li">7)</span> An expression whose evaluation leads to any form of <span class="t-rev-inl t-since-cxx17"><span>core language</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> undefined behavior (including signed integer overflow, division by zero, pointer arithmetic outside array bounds, etc). <span class="t-rev-inl t-since-cxx17"><span>Whether standard library undefined behavior is detected is unspecified.</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> </div>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <div class="t-li1">
<span class="t-li">8)</span> A <a href="../lambda/" title="cpp/language/lambda">lambda expression</a> </div>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">9)</span> An lvalue-to-rvalue <a href="../implicit_cast/" title="cpp/language/implicit cast" class="mw-redirect">implicit conversion</a> <span class="t-rev-inl t-since-cxx14"><span>or modification</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> applied to a non-active member of a <a href="../union/" title="cpp/language/union">union</a> or its subobject</div> <div class="t-li1">
<span class="t-li">10)</span> Any other lvalue-to-rvalue <a href="../implicit_cast/" title="cpp/language/implicit cast" class="mw-redirect">implicit conversion</a>, unless the lvalue...</div> <div class="t-li2">
<span class="t-li">a)</span> has integral or enumeration type and refers to a <a href="../incomplete_type/" title="cpp/language/incomplete type" class="mw-redirect">complete</a> non-volatile const object, which is initialized with a constant expression <div class="cpp source-cpp"><pre data-language="cpp">int main() {
    const std::size_t tabsize = 50;
    int tab[tabsize]; // OK: tabsize is a constant expression
 
    std::size_t n = 50;
    const std::size_t sz = n;
    int tab2[sz]; // error: sz is not a constant expression
                  // because sz is not initialized with a constant expression
}</pre></div>
</div> <div class="t-li2">
<span class="t-li">b)</span> is a non-volatile glvalue that refers to an element of a string literal</div> <div class="t-li2">
<span class="t-li">c)</span> has literal type and refers to a non-volatile object defined with <code>constexpr</code> or to its non-mutable subobject</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <div class="t-li2">
<span class="t-li">d)</span> has literal type and refers to a non-volatile temporary object, initialized with a constant expression </div>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr>
<tr class="t-rev t-since-cxx14">
<td> <div class="t-li2">
<span class="t-li">d)</span> has literal type and refers to a non-volatile object whose lifetime began within the evalution of this expression </div>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">11)</span> an <span class="t-spar">id-expression</span> referring to a variable or a data member of reference type, unless it was initialized with a constant expression or <span class="t-rev-inl t-until-cxx14"><span>is a non-static data member of a temporary object which was initialized with a constant expression</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span><span class="t-rev-inl t-since-cxx14"><span>its lifetime began within the evaluation of this expression</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>
</div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <div class="t-li1">
<span class="t-li">12)</span> conversion from <i>cv</i> <code>void*</code> to any pointer-to-object type </div>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">13)</span> <a href="../dynamic_cast/" title="cpp/language/dynamic cast">dynamic_cast</a>
</div> <div class="t-li1">
<span class="t-li">14)</span> <a href="../reinterpret_cast/" title="cpp/language/reinterpret cast">reinterpret_cast</a>
</div> <div class="t-li1">
<span class="t-li">15)</span> pseudo-destructor call</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <div class="t-li1">
<span class="t-li">16)</span> an increment or a decrement operator </div>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> <tr class="t-rev t-since-cxx14">
<td> <div class="t-li1">
<span class="t-li">16)</span> modification of an object, unless the object has non-volatile literal type and its lifetime began within the evalution of the expression <div class="cpp source-cpp"><pre data-language="cpp">constexpr int incr(int&amp; n) {
  return ++n;
}
constexpr int g(int k) {
  constexpr int x = incr(k); // error: incr(k) is not a core constant
                             // expression because lifetime of k
                             // began outside the expression incr(k)
  return x;
}
constexpr int h(int k) {
  int x = incr(k); // OK: x is not required to be initialized with a core
                   // constant expression
  return x;
}
constexpr int y = h(1); // OK: initializes y with the value 2
                        // h(1) is a core constant expression because
                        // the lifetime of k begins inside the expression h(1)</pre></div> </div>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">17)</span> a <a href="../typeid/" title="cpp/language/typeid">typeid</a> expression applied to a glvalue of polymorphic type</div> <div class="t-li1">
<span class="t-li">18)</span> a new-expression or a delete-expression</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <div class="t-li1">
<span class="t-li">19)</span> a subtraction operator between two pointers </div>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">20)</span> an equality or relational operator when the result is unspecified</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx14">
<td> <div class="t-li1">
<span class="t-li">21)</span> an assignment or a compount assignment operator </div>
</td> <td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">22)</span> a throw expression</div> <div class="t-li1">
<span class="t-li">23)</span> inside a lambda-expression, a reference to <code>this</code> or to a variable defined outside that lambda, if that reference would be an odr-use <div class="cpp source-cpp"><pre data-language="cpp">void g() {
  const int n=0;
  constexpr int j=*&amp;n; // OK, outside of a lambda-expression
  [=]{ constexpr int i=n;  // OK, 'n' is not odr-used and not captured here.
       constexpr int j=*&amp;n;// Ill-formed, '&amp;n' would be an odr-use of 'n'.
     };
}</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>note that if the ODR-use takes place in a function call to a closure, it does not refer to <code>this</code> or to an enclosing variable, since it accesses a closure's data member instead.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// OK: 'v' &amp; 'm' are odr-used but do not occur in a constant-expression
// within the nested lambda
auto monad = [](auto v){return [=]{return v;};};
auto bind = [](auto m){return [=](auto fvm){return fvm(m());};};
// OK to have captures to automatic objects created during constant expression evaluation.
static_assert(bind(monad(2))(monad)() == monad(2)());</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table>
</div>  <h3 id="Integral_constant_expression"> Integral constant expression</h3> <p><i>Integral constant expression</i> is an expression of integral or unscoped enumeration type implicitly converted to a prvalue, where the converted expression is a core constant expression. If an expression of class type is used where an integral constant expression is expected, the expression is <a href="../implicit_cast/" title="cpp/language/implicit cast" class="mw-redirect">contextually implicitly converted</a> to an integral or unscoped enumeration type.   only integral constant expressions can be used as.</p>
<span class="t-rev-inl t-until-cxx14"><span><a href="../array/" title="cpp/language/array">array bounds</a>, the dimensions in <a href="../new/" title="cpp/language/new">new-expressions</a> other than the first</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>, <a href="../bit_field/" title="cpp/language/bit field">bit-field lengths</a>, enumeration initializers when the underlying type is not fixed, <span class="t-rev-inl t-until-cxx14"><span>null-pointer constants</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>, and alignments.  <h3 id="Converted_constant_expression"> Converted constant expression</h3> <p>A <i>converted constant expression</i> of type <code>T</code> is an expression <a href="../implicit_cast/" title="cpp/language/implicit cast" class="mw-redirect">implicitly converted</a> to type T, where the converted expression is a constant expression, and the implicit conversion sequence contains only:</p>
<ul>
<li> constexpr user-defined conversions (so a class can be used where integral type is expected) </li>
<li> lvalue-to-rvalue conversions </li>
<li> integral promotions </li>
<li> non-narrowing integral conversions </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul>
<li> array-to-pointer conversions </li>
<li> function-to-pointer conversions </li>
<li> function pointer conversions (pointer to noexcept function to pointer to function) </li>
<li> qualification conversions </li>
<li> null pointer conversions from <code><a href="../../types/nullptr_t/" title="cpp/types/nullptr t">std::nullptr_t</a></code> </li>
<li> null member pointer conversions from <code><a href="../../types/nullptr_t/" title="cpp/types/nullptr t">std::nullptr_t</a></code> </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <dl>
<dd>
<ul><li> And if any <a href="../reference_initialization/" title="cpp/language/reference initialization">reference binding</a> takes place, it is direct binding (not one that constructs a temporary object) </li></ul> </dd>
<dd> Only <i>converted constant expressions</i> can be used as <a href="../switch/" title="cpp/language/switch">case expressions</a>, <a href="../enum/" title="cpp/language/enum">enumerator initializers</a> when the underlying type is fixed, <span class="t-rev-inl t-since-cxx14"><span><a href="../array/" title="cpp/language/array">array bounds</a>, the dimensions in <a href="../new/" title="cpp/language/new">new-expressions</a> other than the first</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>, and as <span class="t-rev-inl t-until-cxx17"><span>integral and enumeration </span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span>non-type <a href="../template_parameters/" title="cpp/language/template parameters">template arguments</a>. </dd>
</dl> <p>A <i>contextually converted constant expression of type <code>bool</code></i> is an expression, <a href="../implicit_cast/#Contextual_conversions" title="cpp/language/implicit cast" class="mw-redirect">contextually converted to <code>bool</code></a>, where the converted expression is a constant expression and the conversion sequence contains only the conversions above. Such expressions can be used in <a href="../noexcept_spec/" title="cpp/language/noexcept spec"><code>noexcept</code> specifications</a> and <a href="../static_assert/" title="cpp/language/static assert">static assert declarations</a>.</p>
<h3 id="Literal_constant_expression"> Literal constant expression</h3> <p><i>Literal constant expression</i> is a prvalue <i>core constant expression</i> of non-pointer literal type (after conversions as required by context). A literal constant expression of array or class type requires that each subobject is initialized with a constant expression.</p>
<h3 id="Reference_constant_expression"> Reference constant expression</h3> <p><i>Reference constant expression</i> is an lvalue core constant expression that designates an object with static storage duration or a function.</p>
<h3 id="Address_constant_expression"> Address constant expression</h3> <p><i>Address constant expression</i> is a prvalue core constant expression (after conversions required by context) of type <code><a href="../../types/nullptr_t/"><span class="kw102">std::<span class="me2">nullptr_t</span></span></a></code> or of a pointer type, which points to an object with static storage duration, one past the end of an array with static storage duration, to a function, or is a null pointer.</p>
<h3 id="Notes"> Notes</h3> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td>Implementations are not permitted to declare library functions as <code>constexpr</code> unless the standard says the function is <code>constexpr</code> <p><a href="../copy_elision/" title="cpp/language/copy elision">copy elision</a> is mandatory in constant expressions.</p>
</td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th> DR </th> <th> Applied to </th> <th> Behavior as published </th> <th> Correct behavior </th>
</tr> <tr> <td> <a rel="nofollow" class="external text" href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#2167" target="_blank">CWG 2167</a> </td> <td> C++14 </td> <td> non-member references local to an evaluation were making the evaluation non-constexpr </td> <td> non-member references allowed </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <ul>
<li> <a href="../constexpr/" title="cpp/language/constexpr">constexpr specifier</a> </li>
<li> <code><a href="../../types/is_literal_type/"><span class="kw497">std::<span class="me2">is_literal_type</span></span></a></code> </li>
</ul>           <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/constant_expression" class="_attribution-link" target="_blank">http://en.cppreference.com/w/cpp/language/constant_expression</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
