
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Reference Declaration - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Declares a named variable as a reference, that is, an alias to an already-existing object or function. ">
  <meta name="keywords" content="reference, declaration, -, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/cpp/language/reference/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _c">
				
<h1 id="firstHeading" class="firstHeading">Reference declaration</h1>            <p>Declares a named variable as a reference, that is, an alias to an already-existing object or function.</p>
<h3 id="Syntax"> Syntax</h3> <p>A reference variable declaration is any simple declaration whose <a href="../declarations/" title="cpp/language/declarations">declarator</a> has the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>&amp;</code> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">declarator</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>&amp;&amp;</code> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">declarator</span> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> <b>Lvalue reference declarator</b>: the declaration <code>S&amp; D;</code> declares <code>D</code> as an <i>lvalue reference</i> to the type determined by <span class="t-spar">decl-specifier-seq</span> <code>S</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> <b>Rvalue reference declarator</b>: the declaration <code>S&amp;&amp; D;</code> declares <code>D</code> as an <i>rvalue reference</i> to the type determined by <span class="t-spar">decl-specifier-seq</span> <code>S</code>.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">declarator</span> </td> <td> - </td> <td> any <a href="../declarations/" title="cpp/language/declarations">declarator</a> except another reference declarator (there are no references to references) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> optional list of <a href="../attributes/" title="cpp/language/attributes">attributes</a> </td>
</tr>
</table> <p>A reference is required to be initialized to refer to a valid object or function: see <a href="../reference_initialization/" title="cpp/language/reference initialization">reference initialization</a>.</p>
<p>There are no references to <code>void</code> and no references to references.</p>
<p>Reference types cannot be <a href="../cv/" title="cpp/language/cv">cv-qualified</a> at the top level; there is no syntax for that in declaration, and if a qualification is introduced through a typedef, decltype, or template type argument, it is ignored.</p>
<p>References are not objects; they do not necessarily occupy storage, although the compiler may allocate storage if it is necessary to implement the desired semantics (e.g. a non-static data member of reference type usually increases the size of the class by the amount necessary to store a memory address).</p>
<p>Because references are not objects, there are no arrays of references, no pointers to references, and no references to references:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int&amp; a[3]; // error
int&amp;* p;   // error
int&amp; &amp;r;   // error</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h5 id="Reference_collapsing"> Reference collapsing</h5> <p>It is permitted to form references to references through type manipulations in templates or typedefs, in which case the <i>reference collapsing</i> rules apply: rvalue reference to rvalue reference collapses to rvalue reference, all other combinations form lvalue reference:</p>
<div class="cpp source-cpp"><pre data-language="cpp">typedef int&amp;  lref;
typedef int&amp;&amp; rref;
int n;
lref&amp;  r1 = n; // type of r1 is int&amp;
lref&amp;&amp; r2 = n; // type of r2 is int&amp;
rref&amp;  r3 = n; // type of r3 is int&amp;
rref&amp;&amp; r4 = 1; // type of r4 is int&amp;&amp;</pre></div> <p>(This, along with special rules for <a href="../template_argument_deduction/" title="cpp/language/template argument deduction">template argument deduction</a> when <code>T&amp;&amp;</code> is used in a function template, forms the rules that make <code><a href="../../utility/forward/" title="cpp/utility/forward">std::forward</a></code> possible.).</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h4 id="Lvalue_references"> Lvalue references</h4> <p>Lvalue references can be used to alias an existing object (optionally with different cv-qualification):</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
 
int main()
{
    std::string s = "Ex";
    std::string&amp; r1 = s;
    const std::string&amp; r2 = s;
 
    r1 += "ample";           // modifies s
//  r2 += "!";               // error: cannot modify through reference to const
    std::cout &lt;&lt; r2 &lt;&lt; '\n'; // prints s, which now holds "Example"
}</pre></div> </div> <p>They can also be used to implement pass-by-reference semantics in function calls:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
 
void double_string(std::string&amp; s)
{
    s += s; // 's' is the same object as main()'s 'str'
}
 
int main()
{
    std::string str = "Test";
    double_string(str);
    std::cout &lt;&lt; str &lt;&lt; '\n';
}</pre></div> </div> <p>When a function's return type is lvalue reference, the function call expression becomes an <a href="../value_category/" title="cpp/language/value category">lvalue expression</a>:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
 
char&amp; char_number(std::string&amp; s, std::size_t n)
{
    return s.at(n); // string::at() returns a reference to char
}
 
int main()
{
    std::string str = "Test";
    char_number(str, 1) = 'a'; // the function call is lvalue, can be assigned to
    std::cout &lt;&lt; str &lt;&lt; '\n';
}</pre></div> </div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h4 id="Rvalue_references"> Rvalue references</h4> <p>Rvalue references can be used to <a href="../reference_initialization/" title="cpp/language/reference initialization">extend the lifetimes</a> of temporary objects (note, lvalue references to const can extend the lifetimes of temporary objects too, but they are not modifiable through them):</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
 
int main()
{
    std::string s1 = "Test";
//  std::string&amp;&amp; r1 = s1;           // error: can't bind to lvalue
 
    const std::string&amp; r2 = s1 + s1; // okay: lvalue reference to const extends lifetime
//  r2 += "Test";                    // error: can't modify through reference to const
 
    std::string&amp;&amp; r3 = s1 + s1;      // okay: rvalue reference extends lifetime
    r3 += "Test";                    // okay: can modify through reference to non-const
    std::cout &lt;&lt; r3 &lt;&lt; '\n';
}</pre></div> </div> <p>More importantly, when a function has both rvalue reference and lvalue reference <a href="../overload_resolution/" title="cpp/language/overload resolution">overloads</a>, the rvalue reference overload binds to rvalues (including both prvalues and xvalues), while the lvalue reference overload binds to lvalues:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;
 
void f(int&amp; x)
{
    std::cout &lt;&lt; "lvalue reference overload f(" &lt;&lt; x &lt;&lt; ")\n";
}
 
void f(const int&amp; x)
{
    std::cout &lt;&lt; "lvalue reference to const overload f(" &lt;&lt; x &lt;&lt; ")\n";
}
 
void f(int&amp;&amp; x)
{
    std::cout &lt;&lt; "rvalue reference overload f(" &lt;&lt; x &lt;&lt; ")\n";
}
 
int main()
{
    int i = 1;
    const int ci = 2;
    f(i);  // calls f(int&amp;)
    f(ci); // calls f(const int&amp;)
    f(3);  // calls f(int&amp;&amp;)
           // would call f(const int&amp;) if f(int&amp;&amp;) overload wasn't provided
    f(std::move(i)); // calls f(int&amp;&amp;)
}</pre></div> </div> <p>This allows <a href="../move_constructor/" title="cpp/language/move constructor">move constructors</a>, <a href="../move_operator/" title="cpp/language/move operator" class="mw-redirect">move assignment</a> operators, and other move-aware functions (e.g. <a href="../../container/vector/push_back/" title="cpp/container/vector/push back"><code>vector::push_back()</code></a> to be automatically selected when suitable.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h4 id="Dangling_references"> Dangling references</h4> <p>Although references, once initialized, always refer to valid objects or functions, it is possible to create a program where the <a href="../lifetime/" title="cpp/language/lifetime">lifetime</a> of the referred-to object ends, but the reference remains accessible (<i>dangling</i>). Accessing such a reference is undefined behavior. A common example is a function returning a reference to an automatic variable:</p>
<div class="cpp source-cpp"><pre data-language="cpp">std::string&amp; f()
{
    std::string s = "Example";
    return s; // exits the scope of s:
              // its destructor is called and its storage deallocated
}
 
std::string&amp; r = f(); // dangling reference
std::cout &lt;&lt; r;       // undefined behavior: reads from a dangling reference
std::string s = f();  // undefined behavior: copy-initializes from a dangling reference</pre></div> <p>Note that rvalue references and lvalue references to const extend the lifetimes of temporary objects (see <a href="../reference_initialization/" title="cpp/language/reference initialization">reference initialization</a> for rules and exceptions).</p>
<p>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see <a href="../lifetime/#Access_outside_of_lifetime" title="cpp/language/lifetime">Access outside of lifetime</a> for details).</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/reference" class="_attribution-link" target="_blank">http://en.cppreference.com/w/cpp/language/reference</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
