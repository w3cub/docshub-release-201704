
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Template Parameters and Template Arguments - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Every template is parametrized by one or more template parameters, indicated in the parameter-list of the template declaration syntax&#58; ">
  <meta name="keywords" content="template, parameters, and, arguments, -, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/cpp/language/template_parameters/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _c">
				
<h1 id="firstHeading" class="firstHeading">Template parameters and template arguments</h1>            <p>Every <a href="../templates/" title="cpp/language/templates">template</a> is parametrized by one or more template parameters, indicated in the <span class="t-spar">parameter-list</span> of the template declaration syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <span class="t-spar">declaration</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>Each parameter in <span class="t-spar">parameter-list</span> may be:</p>
<ul>
<li> a non-type template parameter; </li>
<li> a type template parameter; </li>
<li> a template template parameter. </li>
</ul>  <h4 id="Non-type_template_parameter"> Non-type template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>= </code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">type</span> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>auto</code> <span class="t-spar">name</span> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> A non-type template parameter with an optional name.</div> <div class="t-li1">
<span class="t-li">2)</span> A non-type template parameter with an optional name and a default value.</div> <div class="t-li1">
<span class="t-li">3)</span> A non-type template <a href="../parameter_pack/" title="cpp/language/parameter pack">parameter pack</a> with an optional name.</div> <div class="t-li1">
<span class="t-li">4)</span> A non-type template parameter with a deduced type (note, it may also be <code>auto **</code> or any other type that includes the placeholder <code>auto</code> )</div> <p><span class="t-spar">type</span> is one of the following types (optionally cv-qualified, the qualifiers are ignored):</p>
<ul>
<li> <code><a href="../../types/nullptr_t/" title="cpp/types/nullptr t">std::nullptr_t</a></code> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>; </li>
<li> <a href="../type-id/" title="cpp/language/type">integral type</a>; </li>
<li> <a href="../reference/#lvalue_references" title="cpp/language/reference">lvalue reference type</a> (to object or to function); </li>
<li> <a href="../pointer/" title="cpp/language/pointer">pointer type</a> (to object or to function); </li>
<li> <a href="../pointer/#pointers_to_data_members" title="cpp/language/pointer">pointer to member type</a> (to member object or to member function); </li>
<li> <a href="../enum/" title="cpp/language/enum">enumeration type</a>. </li>
</ul> <p>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</p>
<p>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable <a href="../value_category/" title="cpp/language/value category">prvalue</a> unless its type was an lvalue reference type.</p>
<p>A template parameter of the form <code>class Foo</code> is not an unnamed non-type template parameter of type <code>Foo</code>, even if otherwise <code>class Foo</code> is an <a href="../elaborated_type_specifier/" title="cpp/language/elaborated type specifier">elaborated type specifier</a> and <code>class Foo x;</code> declares <code>x</code> to be of type <code>Foo</code>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <p>The type of a non-type template parameter may be deduced if it includes the placeholder keyword <code>auto</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;auto n&gt; struct B { /* ... */ };
B&lt;5&gt; b1;   // OK: non-type template parameter type is int
B&lt;'a'&gt; b2; // OK: non-type template parameter type is char
B&lt;2.5&gt; b3; // error: non-type template parameter type cannot be double</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Type_template_parameter"> Type template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>typename</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>class</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>typename|class</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>= </code> <span class="t-spar">default</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>typename|class</code> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> A type template parameter with an optional name.</div> <div class="t-li1">
<span class="t-li">2)</span> Exactly the same as 1).</div> <div class="t-li1">
<span class="t-li">3)</span> A type template parameter with an optional name and a default.</div> <div class="t-li1">
<span class="t-li">4)</span> A type template <a href="../parameter_pack/" title="cpp/language/parameter pack">parameter pack</a> with an optional name.</div> <p>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</p>
<p>There is no difference between the keywords <code>class</code> and <code>typename</code> in a type template parameter declaration.</p>
<h4 id="Template_template_parameter"> Template template parameter</h4> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <code>typename<span class="t-mark-rev t-since-cxx17">(C++17)</span>|class</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <code>typename<span class="t-mark-rev t-since-cxx17">(C++17)</span>|class</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">default</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>template</code> <code>&lt;</code> <span class="t-spar">parameter-list</span> <code>&gt;</code> <code>typename<span class="t-mark-rev t-since-cxx17">(C++17)</span>|class</code> <code>...</code> <span class="t-spar">name</span><span class="t-mark">(optional)</span> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> A template template parameter with an optional name.</div> <div class="t-li1">
<span class="t-li">2)</span> A template template parameter with an optional name and a default.</div> <div class="t-li1">
<span class="t-li">3)</span> A template template <a href="../parameter_pack/" title="cpp/language/parameter pack">parameter pack</a> with an optional name.</div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Unlike type template parameter declaration, template template parameter declaration can only use the keyword <code>class</code> and not <code>typename</code>.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <p>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; class my_array {};
 
// two type template parameters and one template template parameter:
template&lt;typename K, typename V, template&lt;typename&gt; typename C = my_array&gt;
class Map
{
    C&lt;K&gt; key;
    C&lt;V&gt; value;
};</pre></div> <h3 id="Template_arguments"> Template arguments</h3> <p>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For <a href="../class_template/" title="cpp/language/class template">class templates</a>, the arguments are either explicitly provided<span class="t-rev-inl t-since-cxx17"><span>, <a href="../class_template_deduction/" title="cpp/language/class template deduction">deduced from the initializer</a>, </span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> or defaulted. For <a href="../function_template/" title="cpp/language/function template">function templates</a>, the arguments are explicitly provided, <a href="../template_argument_deduction/" title="cpp/language/template argument deduction">deduced from the context</a>, or defaulted.</p>
<p>If an argument can be interpreted as a both a <a href="../type-id/" title="cpp/language/type-id" class="mw-redirect">type-id</a> and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt; void f(); // #1
template&lt;int I&gt; void f(); // #2
void g() {
    f&lt;int()&gt;(); // "int()" is both a type and an expression,
                // calls #1 because it is interpreted as a type
}</pre></div> <h4 id="Template_non-type_arguments"> Template non-type arguments</h4> <p>The following limitations apply when instantiating templates that have non-type template parameters:</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <ul>
<li> For integral and arithmetic types, the template argument provided during instantiation must be a <a href="../constant_expression/" title="cpp/language/constant expression">converted constant expression</a> of the template parameter's type (so certain implicit conversion applies). </li>
<li> For pointers to objects, the template arguments have to designate the address of an object with static <a href="../storage_duration/" title="cpp/language/storage duration">storage duration</a> and a <a href="../storage_duration/#Linkage" title="cpp/language/storage duration">linkage</a> (either internal or external), or a constant expression that evaluates to the appropriate null pointer or <code><a href="../../types/nullptr_t/" title="cpp/types/nullptr t">std::nullptr_t</a></code> value. </li>
<li> For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values). </li>
<li> For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage). </li>
<li> For pointers to members, the argument has to be a pointer to member expressed as <code>&amp;Class::Member</code> or a constant expression that evaluates to null pointer or <code><a href="../../types/nullptr_t/" title="cpp/types/nullptr t">std::nullptr_t</a></code> value. </li>
</ul> <p>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p>The template argument that can be used with a non-type template parameter can be any <a href="../constant_expression/" title="cpp/language/constant expression">converted constant expression</a> of the type of the template parameter.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;const int* pci&gt; struct X {};
int ai[10];
X&lt;ai&gt; xi;  // ok: array to pointer conversion and cv-qualification conversion
 
struct Y {};
template&lt;const Y&amp; b&gt; struct Z {};
Y y;
Z&lt;y&gt; z;  // ok: no conversion
 
template&lt;int (&amp;pa)[5]&gt; struct W {};
int b[5];
W&lt;b&gt; w; // ok: no conversion
 
void f(char);
void f(int);
template&lt;void (*pf)(int)&gt; struct A {};
A&lt;&amp;f&gt; a; // ok: overload resolution selects f(int)</pre></div> <p>The only exceptions are that non-type template parameters of <i>reference</i> and <i>pointer</i> type cannot refer to/be the address of.</p>
<ul>
<li> a subobject (including non-static class member, base subobject, or array element); </li>
<li> a temporary object (including one created during <a href="../reference_initialization/" title="cpp/language/reference initialization">reference initialization</a>); </li>
<li> a <a href="../string_literal/" title="cpp/language/string literal">string literal</a>; </li>
<li> the result of <a href="../typeid/" title="cpp/language/typeid">typeid</a>; </li>
<li> or the predefined variable <code>__func__</code>. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, const char* p&gt; class X {};
X&lt;int, "Studebaker"&gt; x1; // error: string literal as template-argument
 
template&lt;int* p&gt; class X {};
int a[10];
struct S
{
    int m;
    static int s;
} s;
X&lt;&amp;a[2]&gt; x3;  // error: address of array element
X&lt;&amp;s.m&gt; x4;   // error: address of non-static member
X&lt;&amp;s.s&gt; x5;   // ok: address of static member
X&lt;&amp;S::s&gt; x6;  // ok: address of static member
 
template&lt;const int&amp; CRI&gt; struct B {};
B&lt;1&gt; b2;     // error: temporary would be required for template argument
int c = 1;
B&lt;c&gt; b1;     // ok</pre></div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h4 id="Template_type_arguments"> Template type arguments</h4> <p>A template argument for a type template parameter must be a <a href="../type-id/#Type_naming" title="cpp/language/type">type-id</a>, which may name an incomplete type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; class X {}; // class template
 
struct A; // incomplete type
typedef struct {} B; // type alias to an unnamed type
 
int main()
{
    X&lt;A&gt; x1; // ok: 'A' names a type
    X&lt;A*&gt; x2; // ok: 'A*' names a type
    X&lt;B&gt; x3; // ok: 'B' names a type
}</pre></div> <h4 id="Template_template_arguments"> Template template arguments</h4> <p>A template argument for a template template parameter must be an <a href="../name/#In_expressions" title="cpp/language/identifiers">id-expression</a> which names a class template or a template alias.</p>
<p>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; class A { int x; }; // primary template
template&lt;class T&gt; class A&lt;T*&gt; { long x; }; // partial specialization
 
// class template with a template template parameter V
template&lt;template&lt;typename&gt; class V&gt; class C
{
    V&lt;int&gt; y; // uses the primary template
    V&lt;int*&gt; z; // uses the partial specialization
};
 
C&lt;A&gt; c; // c.y.x has type int, c.z.x has type long</pre></div> <p>To match a template template argument <code>A</code> to a template template parameter <code>P</code>, each of the template parameters of <code>A</code> must match corresponding template parameters of <code>P</code>. If <code>P</code>'s parameter list includes a <a href="../parameter_pack/" title="cpp/language/parameter pack">parameter pack</a>, zero or more template parameters (or parameter packs) from <code>A</code>'s template parameter list are matched by it.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt; struct eval; // primary template 
 
template&lt;template&lt;typename, typename...&gt; class TT, typename T1, typename... Rest&gt;
struct eval&lt;TT&lt;T1, Rest...&gt;&gt; {}; // partial specialization of eval
 
template&lt;typename T1&gt; struct A;
template&lt;typename T1, typename T2&gt; struct B;
template&lt;int N&gt; struct C;
template&lt;typename T1, int N&gt; struct D;
template&lt;typename T1, typename T2, int N = 17&gt; struct E;
 
eval&lt;A&lt;int&gt;&gt; eA; // ok: matches partial specialization of eval
eval&lt;B&lt;int, float&gt;&gt; eB; // ok: matches partial specialization of eval
eval&lt;C&lt;17&gt;&gt; eC; // error: C does not match TT in partial specialization because
                // TT's first parameter is a type template parameter,
                // while 17 does not name a type
eval&lt;D&lt;int, 17&gt;&gt; eD; // error: D does not match TT in partial specialization
                     // because TT's second parameter is a type parameter pack,
                     // while 17 does not name a type
eval&lt;E&lt;int, float&gt;&gt; eE; // error: E does not match TT in partial specialization
                        // because E's third (default) parameter is a non-type</pre></div> <h4 id="Default_template_arguments"> Default template arguments</h4> <p>Default template arguments are specified in the parameter lists after the <code>=</code> sign. Defaults can be specified for any kind of template parameter (type, non-type, or template), but not to parameter packs.</p>
<p>If the default is specified for a template parameter of a primary class template <span class="t-rev-inl t-since-cxx14"><span>, primary variable template, </span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack. In a function template, a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments.</p>
<p>Default parameters are not allowed.</p>
<ul>
<li> in the out-of-class definition of a <a href="../member_template/" title="cpp/language/member template">member template</a> (they have to be provided in the declaration inside the class body) </li>
<li> in <a href="../friend/#Template_friends" title="cpp/language/friend">friend class template</a> declarations </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li> in any <a href="../function_template/" title="cpp/language/function template">function template</a> declaration or definition </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>On a friend function template declaration, default template arguments are allowed only if the declaration is a definition, and no other declarations of this function appear in this translation unit.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <p>Default template arguments that appear in the declarations and the definition are merged similarly to default function arguments:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T1, typename T2 = int&gt; class A;
template&lt;typename T1 = int, typename T2&gt; class A;
// the above is the same as the following:
template&lt;typename T1 = int, typename T2 = int&gt; class A;</pre></div> <p>But the same parameter cannot be given default arguments twice in the same scope.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T = int&gt; class X;
template&lt;typename T = int&gt; class X {}; // error</pre></div> <p>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// class template, with a type template parameter with a default
template&lt;typename T = float&gt; struct B {};
 
// template template parameter T has a parameter list, which 
// consists of one type template parameter with a default
template&lt;template&lt;typename = float&gt; typename T&gt; struct A
{
    void f();
    void g();
};
 
// out-of-body member function template definitions
template&lt;template&lt;typename TT&gt; class T&gt;
void A&lt;T&gt;::f()
{
    T&lt;&gt; t; // error: TT has no default in scope
}
template&lt;template&lt;typename TT = char&gt; class T&gt;
void A&lt;T&gt;::g()
{
    T&lt;&gt; t; // ok: t is T&lt;char&gt;
}</pre></div> <p><a href="../access/" title="cpp/language/access">Member access</a> for the names used in a default template parameter is checked at the declaration, not at the point of use:</p>
<div class="cpp source-cpp"><pre data-language="cpp">class B {};
 
template&lt;typename T&gt; class C
{
    protected:
        typedef T TT;
};
 
template&lt;typename U, typename V = typename U::TT&gt; class D: public U {};
 
D&lt;C&lt;B&gt;&gt;* d; // error: C::TT is protected</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <p>The default template argument is implicitly instantiated when the value of that default argument is needed, except if the template is used to name a function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T, typename U = int&gt; struct S { };
S&lt;bool&gt;* p; // The default argument for U is instantiated at this point
            // the type of p is S&lt;bool, int&gt;*</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Examples"> Examples</h3> <h4 id="Non-type_template_parameters"> Non-type template parameters</h4> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
// simple non-type template parameter
template&lt;int N&gt;
struct S { int a[N]; };
 
template&lt;const char*&gt;
struct S2 {};
 
// complicated non-type example
template
&lt;
    char c, // integral type
    int (&amp;ra)[5], // lvalue reference to object (of array type)
    int (*pf)(int), // pointer to function
    int (S&lt;10&gt;::*a)[10] // pointer to member object (of type int[10])
&gt; struct Complicated
{
    // calls the function selected at compile time
    // and stores the result in the array selected at compile time
    void foo(char base)
    {
        ra[4] = pf(c - base);
    }
};
 
S2&lt;"fail"&gt; s2; // error: string literal cannot be used
char okay[] = "okay"; // static object with linkage
S2&lt; &amp;okay[0] &gt; s2; // error: array element has no linkage
S2&lt;okay&gt; s2; // works
 
int a[5];
int f(int n) { return n; }
 
int main()
{
    S&lt;10&gt; s; // s.a is an array of 10 int
    s.a[9] = 4;
 
    Complicated&lt;'2', a, f, &amp;S&lt;10&gt;::a&gt; c;
    c.foo('0');
 
    std::cout &lt;&lt; s.a[9] &lt;&lt; a[4] &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">42</pre></div> </div>            <div class="_attribution">
  <p class="_attribution-p">
    Â© cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/template_parameters" class="_attribution-link" target="_blank">http://en.cppreference.com/w/cpp/language/template_parameters</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
