
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Sync&#47;atomic - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. ">
  <meta name="keywords" content="package, atomic, sync, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/sync/atomic/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				
<h1>Package atomic</h1>     <ul id="short-nav">
<li><code>import "sync/atomic"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2>Overview </h2> <p> Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. </p> <p> These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don't communicate by sharing memory. </p> <p> The swap operation, implemented by the SwapT functions, is the atomic equivalent of: </p> <pre data-language="go">old = *addr
*addr = new
return old
</pre> <p> The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of: </p> <pre data-language="go">if *addr == old {
	*addr = new
	return true
}
return false
</pre> <p> The add operation, implemented by the AddT functions, is the atomic equivalent of: </p> <pre data-language="go">*addr += delta
return *addr
</pre> <p> The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of "return *addr" and "*addr = val". </p>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#AddInt32">func AddInt32(addr *int32, delta int32) (new int32)</a></li>
<li><a href="#AddInt64">func AddInt64(addr *int64, delta int64) (new int64)</a></li>
<li><a href="#AddUint32">func AddUint32(addr *uint32, delta uint32) (new uint32)</a></li>
<li><a href="#AddUint64">func AddUint64(addr *uint64, delta uint64) (new uint64)</a></li>
<li><a href="#AddUintptr">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</a></li>
<li><a href="#CompareAndSwapInt32">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</a></li>
<li><a href="#CompareAndSwapInt64">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</a></li>
<li><a href="#CompareAndSwapPointer">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUint32">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUint64">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUintptr">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</a></li>
<li><a href="#LoadInt32">func LoadInt32(addr *int32) (val int32)</a></li>
<li><a href="#LoadInt64">func LoadInt64(addr *int64) (val int64)</a></li>
<li><a href="#LoadPointer">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></li>
<li><a href="#LoadUint32">func LoadUint32(addr *uint32) (val uint32)</a></li>
<li><a href="#LoadUint64">func LoadUint64(addr *uint64) (val uint64)</a></li>
<li><a href="#LoadUintptr">func LoadUintptr(addr *uintptr) (val uintptr)</a></li>
<li><a href="#StoreInt32">func StoreInt32(addr *int32, val int32)</a></li>
<li><a href="#StoreInt64">func StoreInt64(addr *int64, val int64)</a></li>
<li><a href="#StorePointer">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></li>
<li><a href="#StoreUint32">func StoreUint32(addr *uint32, val uint32)</a></li>
<li><a href="#StoreUint64">func StoreUint64(addr *uint64, val uint64)</a></li>
<li><a href="#StoreUintptr">func StoreUintptr(addr *uintptr, val uintptr)</a></li>
<li><a href="#SwapInt32">func SwapInt32(addr *int32, new int32) (old int32)</a></li>
<li><a href="#SwapInt64">func SwapInt64(addr *int64, new int64) (old int64)</a></li>
<li><a href="#SwapPointer">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</a></li>
<li><a href="#SwapUint32">func SwapUint32(addr *uint32, new uint32) (old uint32)</a></li>
<li><a href="#SwapUint64">func SwapUint64(addr *uint64, new uint64) (old uint64)</a></li>
<li><a href="#SwapUintptr">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</a></li>
<li><a href="#Value">type Value</a></li>
<li> <a href="#Value.Load">func (v *Value) Load() (x interface{})</a>
</li>
<li> <a href="#Value.Store">func (v *Value) Store(x interface{})</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h4>Examples</h4> <dl> <dd><a class="exampleLink" href="#example_Value_config">Value (Config)</a></dd> <dd><a class="exampleLink" href="#example_Value_readMostly">Value (ReadMostly)</a></dd> </dl> </div> <h4>Package files</h4> <p>  <a href="https://golang.org/src/sync/atomic/doc.go" target="_blank">doc.go</a> <a href="https://golang.org/src/sync/atomic/value.go" target="_blank">value.go</a>  </p>     <h2 id="AddInt32">func AddInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=3559:3610#L82" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func AddInt32(addr *int32, delta int32) (new int32)</pre> <p> AddInt32 atomically adds delta to *addr and returns the new value. </p> <h2 id="AddInt64">func AddInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=3964:4015#L90" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func AddInt64(addr *int64, delta int64) (new int64)</pre> <p> AddInt64 atomically adds delta to *addr and returns the new value. </p> <h2 id="AddUint32">func AddUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=3837:3892#L87" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func AddUint32(addr *uint32, delta uint32) (new uint32)</pre> <p> AddUint32 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)). </p> <h2 id="AddUint64">func AddUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=4242:4297#L95" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func AddUint64(addr *uint64, delta uint64) (new uint64)</pre> <p> AddUint64 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)). </p> <h2 id="AddUintptr">func AddUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=4371:4430#L98" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</pre> <p> AddUintptr atomically adds delta to *addr and returns the new value. </p> <h2 id="CompareAndSwapInt32">func CompareAndSwapInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=2607:2675#L64" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</pre> <p> CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. </p> <h2 id="CompareAndSwapInt64">func CompareAndSwapInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=2760:2828#L67" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</pre> <p> CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value. </p> <h2 id="CompareAndSwapPointer">func CompareAndSwapPointer<a href="https://golang.org/src/sync/atomic/doc.go?s=3399:3487#L79" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</pre> <p> CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value. </p> <h2 id="CompareAndSwapUint32">func CompareAndSwapUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=2914:2985#L70" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</pre> <p> CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value. </p> <h2 id="CompareAndSwapUint64">func CompareAndSwapUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=3071:3142#L73" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</pre> <p> CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value. </p> <h2 id="CompareAndSwapUintptr">func CompareAndSwapUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=3230:3304#L76" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</pre> <p> CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value. </p> <h2 id="LoadInt32">func LoadInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=4469:4508#L101" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LoadInt32(addr *int32) (val int32)</pre> <p> LoadInt32 atomically loads *addr. </p> <h2 id="LoadInt64">func LoadInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=4547:4586#L104" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LoadInt64(addr *int64) (val int64)</pre> <p> LoadInt64 atomically loads *addr. </p> <h2 id="LoadPointer">func LoadPointer<a href="https://golang.org/src/sync/atomic/doc.go?s=4877:4936#L116" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</pre> <p> LoadPointer atomically loads *addr. </p> <h2 id="LoadUint32">func LoadUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=4626:4668#L107" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LoadUint32(addr *uint32) (val uint32)</pre> <p> LoadUint32 atomically loads *addr. </p> <h2 id="LoadUint64">func LoadUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=4708:4750#L110" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LoadUint64(addr *uint64) (val uint64)</pre> <p> LoadUint64 atomically loads *addr. </p> <h2 id="LoadUintptr">func LoadUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=4791:4836#L113" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LoadUintptr(addr *uintptr) (val uintptr)</pre> <p> LoadUintptr atomically loads *addr. </p> <h2 id="StoreInt32">func StoreInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=4986:5025#L119" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func StoreInt32(addr *int32, val int32)</pre> <p> StoreInt32 atomically stores val into *addr. </p> <h2 id="StoreInt64">func StoreInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=5075:5114#L122" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func StoreInt64(addr *int64, val int64)</pre> <p> StoreInt64 atomically stores val into *addr. </p> <h2 id="StorePointer">func StorePointer<a href="https://golang.org/src/sync/atomic/doc.go?s=5449:5508#L134" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</pre> <p> StorePointer atomically stores val into *addr. </p> <h2 id="StoreUint32">func StoreUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=5165:5207#L125" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func StoreUint32(addr *uint32, val uint32)</pre> <p> StoreUint32 atomically stores val into *addr. </p> <h2 id="StoreUint64">func StoreUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=5258:5300#L128" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func StoreUint64(addr *uint64, val uint64)</pre> <p> StoreUint64 atomically stores val into *addr. </p> <h2 id="StoreUintptr">func StoreUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=5352:5397#L131" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func StoreUintptr(addr *uintptr, val uintptr)</pre> <p> StoreUintptr atomically stores val into *addr. </p> <h2 id="SwapInt32">func SwapInt32<a href="https://golang.org/src/sync/atomic/doc.go?s=1741:1791#L46" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SwapInt32(addr *int32, new int32) (old int32)</pre> <p> SwapInt32 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapInt64">func SwapInt64<a href="https://golang.org/src/sync/atomic/doc.go?s=1877:1927#L49" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SwapInt64(addr *int64, new int64) (old int64)</pre> <p> SwapInt64 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapPointer">func SwapPointer<a href="https://golang.org/src/sync/atomic/doc.go?s=2443:2522#L61" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</pre> <p> SwapPointer atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapUint32">func SwapUint32<a href="https://golang.org/src/sync/atomic/doc.go?s=2014:2068#L52" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SwapUint32(addr *uint32, new uint32) (old uint32)</pre> <p> SwapUint32 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapUint64">func SwapUint64<a href="https://golang.org/src/sync/atomic/doc.go?s=2155:2209#L55" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SwapUint64(addr *uint64, new uint64) (old uint64)</pre> <p> SwapUint64 atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="SwapUintptr">func SwapUintptr<a href="https://golang.org/src/sync/atomic/doc.go?s=2297:2355#L58" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</pre> <p> SwapUintptr atomically stores new into *addr and returns the previous *addr value. </p> <h2 id="Value">type Value<a href="https://golang.org/src/sync/atomic/value.go?s=495:547#L7" class="source" target="_blank">Source</a>  </h2> <p> A Value provides an atomic load and store of a consistently typed value. Values can be created as part of other data structures. The zero value for a Value returns nil from Load. Once Store has been called, a Value must not be copied. </p> <p> A Value must not be copied after first use. </p> <pre data-language="go">type Value struct {
        // contains filtered or unexported fields
}</pre>    <h4> <span class="text">Example (Config)</span>
</h4> <p>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines. </p> <p>Code:</p> <pre class="code" data-language="go">
    var config Value // holds current server configuration
    // Create initial config value and store into config.
    config.Store(loadConfig())
    go func() {
            // Reload config every 10 seconds
            // and update config value with the new version.
            for {
                    time.Sleep(10 * time.Second)
                    config.Store(loadConfig())
            }
    }()
    // Create worker goroutines that handle incoming requests
    // using the latest config value.
    for i := 0; i &lt; 10; i++ {
            go func() {
                    for r := range requests() {
                            c := config.Load()
                            // Handle request r using config c.
                            _, _ = r, c
                    }
            }()
    }
</pre>      <h4> <span class="text">Example (ReadMostly)</span>
</h4> <p>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom. </p> <p>Code:</p> <pre class="code" data-language="go">
    type Map map[string]string
    var m Value
    m.Store(make(Map))
    var mu sync.Mutex // used only by writers
    // read function can be used to read the data without further synchronization
    read := func(key string) (val string) {
            m1 := m.Load().(Map)
            return m1[key]
    }
    // insert function can be used to update the data without further synchronization
    insert := func(key, val string) {
            mu.Lock() // synchronize with other potential writers
            defer mu.Unlock()
            m1 := m.Load().(Map) // load current value of the data structure
            m2 := make(Map)      // create a new value
            for k, v := range m1 {
                    m2[k] = v // copy all data from the current object to the new one
            }
            m2[key] = val // do the update that we need
            m.Store(m2)   // atomically replace the current object with the new one
            // At this point all new readers start working with the new version.
            // The old version will be garbage collected once the existing readers
            // (if any) are done with it.
    }
    _, _ = read, insert
</pre>   <h3 id="Value.Load">func (*Value) Load<a href="https://golang.org/src/sync/atomic/value.go?s=798:836#L21" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (v *Value) Load() (x interface{})</pre> <p> Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value. </p> <h3 id="Value.Store">func (*Value) Store<a href="https://golang.org/src/sync/atomic/value.go?s=1308:1344#L38" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (v *Value) Store(x interface{})</pre> <p> Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil). </p> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>
<a href="https://golang.org/src/sync/atomic/doc.go?s=1206:1655#L36" style="float: left;" target="_blank">☞</a> <p> On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX. </p> <p> On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. </p> <p> On both ARM and x86-32, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a global variable or in an allocated struct or slice can be relied upon to be 64-bit aligned. </p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/sync/atomic/" class="_attribution-link" target="_blank">https://golang.org/pkg/sync/atomic/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
