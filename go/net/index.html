
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Net - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package net provides a portable interface for network I&#47;O, including TCP&#47;IP, UDP, domain name resolution, and Unix domain sockets. ">
  <meta name="keywords" content="package, net, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/net/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				
<h1>Package net</h1>     <ul id="short-nav">
<li><code>import "net"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2>Overview </h2> <p> Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets. </p> <p> Although the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions. </p> <p> The Dial function connects to a server: </p> <pre data-language="go">conn, err := net.Dial("tcp", "golang.org:80")
if err != nil {
	// handle error
}
fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
status, err := bufio.NewReader(conn).ReadString('\n')
// ...
</pre> <p> The Listen function creates servers: </p> <pre data-language="go">ln, err := net.Listen("tcp", ":8080")
if err != nil {
	// handle error
}
for {
	conn, err := ln.Accept()
	if err != nil {
		// handle error
	}
	go handleConnection(conn)
}
</pre> <h3 id="hdr-Name_Resolution">Name Resolution</h3> <p> The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system. </p> <p> On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo. </p> <p> By default the pure Go resolver is used, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement, and when the name being looked up ends in .local or is an mDNS name. </p> <p> The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in: </p> <pre data-language="go">export GODEBUG=netdns=go    # force pure Go resolver
export GODEBUG=netdns=cgo   # force cgo resolver
</pre> <p> The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag. </p> <p> A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1. </p> <p> On Plan 9, the resolver always accesses /net/cs and /net/dns. </p> <p> On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery. </p>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#InterfaceAddrs">func InterfaceAddrs() ([]Addr, error)</a></li>
<li><a href="#Interfaces">func Interfaces() ([]Interface, error)</a></li>
<li><a href="#JoinHostPort">func JoinHostPort(host, port string) string</a></li>
<li><a href="#LookupAddr">func LookupAddr(addr string) (names []string, err error)</a></li>
<li><a href="#LookupCNAME">func LookupCNAME(host string) (cname string, err error)</a></li>
<li><a href="#LookupHost">func LookupHost(host string) (addrs []string, err error)</a></li>
<li><a href="#LookupIP">func LookupIP(host string) ([]IP, error)</a></li>
<li><a href="#LookupMX">func LookupMX(name string) ([]*MX, error)</a></li>
<li><a href="#LookupNS">func LookupNS(name string) ([]*NS, error)</a></li>
<li><a href="#LookupPort">func LookupPort(network, service string) (port int, err error)</a></li>
<li><a href="#LookupSRV">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a></li>
<li><a href="#LookupTXT">func LookupTXT(name string) ([]string, error)</a></li>
<li><a href="#SplitHostPort">func SplitHostPort(hostport string) (host, port string, err error)</a></li>
<li><a href="#Addr">type Addr</a></li>
<li><a href="#AddrError">type AddrError</a></li>
<li> <a href="#AddrError.Error">func (e *AddrError) Error() string</a>
</li>
<li> <a href="#AddrError.Temporary">func (e *AddrError) Temporary() bool</a>
</li>
<li> <a href="#AddrError.Timeout">func (e *AddrError) Timeout() bool</a>
</li>
<li><a href="#Buffers">type Buffers</a></li>
<li> <a href="#Buffers.Read">func (v *Buffers) Read(p []byte) (n int, err error)</a>
</li>
<li> <a href="#Buffers.WriteTo">func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
<li><a href="#Conn">type Conn</a></li>
<li> <a href="#Dial">func Dial(network, address string) (Conn, error)</a>
</li>
<li> <a href="#DialTimeout">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</a>
</li>
<li> <a href="#FileConn">func FileConn(f *os.File) (c Conn, err error)</a>
</li>
<li> <a href="#Pipe">func Pipe() (Conn, Conn)</a>
</li>
<li><a href="#DNSConfigError">type DNSConfigError</a></li>
<li> <a href="#DNSConfigError.Error">func (e *DNSConfigError) Error() string</a>
</li>
<li> <a href="#DNSConfigError.Temporary">func (e *DNSConfigError) Temporary() bool</a>
</li>
<li> <a href="#DNSConfigError.Timeout">func (e *DNSConfigError) Timeout() bool</a>
</li>
<li><a href="#DNSError">type DNSError</a></li>
<li> <a href="#DNSError.Error">func (e *DNSError) Error() string</a>
</li>
<li> <a href="#DNSError.Temporary">func (e *DNSError) Temporary() bool</a>
</li>
<li> <a href="#DNSError.Timeout">func (e *DNSError) Timeout() bool</a>
</li>
<li><a href="#Dialer">type Dialer</a></li>
<li> <a href="#Dialer.Dial">func (d *Dialer) Dial(network, address string) (Conn, error)</a>
</li>
<li> <a href="#Dialer.DialContext">func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</a>
</li>
<li><a href="#Error">type Error</a></li>
<li><a href="#Flags">type Flags</a></li>
<li> <a href="#Flags.String">func (f Flags) String() string</a>
</li>
<li><a href="#HardwareAddr">type HardwareAddr</a></li>
<li> <a href="#ParseMAC">func ParseMAC(s string) (hw HardwareAddr, err error)</a>
</li>
<li> <a href="#HardwareAddr.String">func (a HardwareAddr) String() string</a>
</li>
<li><a href="#IP">type IP</a></li>
<li> <a href="#IPv4">func IPv4(a, b, c, d byte) IP</a>
</li>
<li> <a href="#ParseCIDR">func ParseCIDR(s string) (IP, *IPNet, error)</a>
</li>
<li> <a href="#ParseIP">func ParseIP(s string) IP</a>
</li>
<li> <a href="#IP.DefaultMask">func (ip IP) DefaultMask() IPMask</a>
</li>
<li> <a href="#IP.Equal">func (ip IP) Equal(x IP) bool</a>
</li>
<li> <a href="#IP.IsGlobalUnicast">func (ip IP) IsGlobalUnicast() bool</a>
</li>
<li> <a href="#IP.IsInterfaceLocalMulticast">func (ip IP) IsInterfaceLocalMulticast() bool</a>
</li>
<li> <a href="#IP.IsLinkLocalMulticast">func (ip IP) IsLinkLocalMulticast() bool</a>
</li>
<li> <a href="#IP.IsLinkLocalUnicast">func (ip IP) IsLinkLocalUnicast() bool</a>
</li>
<li> <a href="#IP.IsLoopback">func (ip IP) IsLoopback() bool</a>
</li>
<li> <a href="#IP.IsMulticast">func (ip IP) IsMulticast() bool</a>
</li>
<li> <a href="#IP.IsUnspecified">func (ip IP) IsUnspecified() bool</a>
</li>
<li> <a href="#IP.MarshalText">func (ip IP) MarshalText() ([]byte, error)</a>
</li>
<li> <a href="#IP.Mask">func (ip IP) Mask(mask IPMask) IP</a>
</li>
<li> <a href="#IP.String">func (ip IP) String() string</a>
</li>
<li> <a href="#IP.To16">func (ip IP) To16() IP</a>
</li>
<li> <a href="#IP.To4">func (ip IP) To4() IP</a>
</li>
<li> <a href="#IP.UnmarshalText">func (ip *IP) UnmarshalText(text []byte) error</a>
</li>
<li><a href="#IPAddr">type IPAddr</a></li>
<li> <a href="#ResolveIPAddr">func ResolveIPAddr(net, addr string) (*IPAddr, error)</a>
</li>
<li> <a href="#IPAddr.Network">func (a *IPAddr) Network() string</a>
</li>
<li> <a href="#IPAddr.String">func (a *IPAddr) String() string</a>
</li>
<li><a href="#IPConn">type IPConn</a></li>
<li> <a href="#DialIP">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</a>
</li>
<li> <a href="#ListenIP">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</a>
</li>
<li> <a href="#IPConn.Close">func (c *IPConn) Close() error</a>
</li>
<li> <a href="#IPConn.File">func (c *IPConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#IPConn.LocalAddr">func (c *IPConn) LocalAddr() Addr</a>
</li>
<li> <a href="#IPConn.Read">func (c *IPConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#IPConn.ReadFrom">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</a>
</li>
<li> <a href="#IPConn.ReadFromIP">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</a>
</li>
<li> <a href="#IPConn.ReadMsgIP">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</a>
</li>
<li> <a href="#IPConn.RemoteAddr">func (c *IPConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#IPConn.SetDeadline">func (c *IPConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#IPConn.SetReadBuffer">func (c *IPConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#IPConn.SetReadDeadline">func (c *IPConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#IPConn.SetWriteBuffer">func (c *IPConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#IPConn.SetWriteDeadline">func (c *IPConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#IPConn.Write">func (c *IPConn) Write(b []byte) (int, error)</a>
</li>
<li> <a href="#IPConn.WriteMsgIP">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</a>
</li>
<li> <a href="#IPConn.WriteTo">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</a>
</li>
<li> <a href="#IPConn.WriteToIP">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</a>
</li>
<li><a href="#IPMask">type IPMask</a></li>
<li> <a href="#CIDRMask">func CIDRMask(ones, bits int) IPMask</a>
</li>
<li> <a href="#IPv4Mask">func IPv4Mask(a, b, c, d byte) IPMask</a>
</li>
<li> <a href="#IPMask.Size">func (m IPMask) Size() (ones, bits int)</a>
</li>
<li> <a href="#IPMask.String">func (m IPMask) String() string</a>
</li>
<li><a href="#IPNet">type IPNet</a></li>
<li> <a href="#IPNet.Contains">func (n *IPNet) Contains(ip IP) bool</a>
</li>
<li> <a href="#IPNet.Network">func (n *IPNet) Network() string</a>
</li>
<li> <a href="#IPNet.String">func (n *IPNet) String() string</a>
</li>
<li><a href="#Interface">type Interface</a></li>
<li> <a href="#InterfaceByIndex">func InterfaceByIndex(index int) (*Interface, error)</a>
</li>
<li> <a href="#InterfaceByName">func InterfaceByName(name string) (*Interface, error)</a>
</li>
<li> <a href="#Interface.Addrs">func (ifi *Interface) Addrs() ([]Addr, error)</a>
</li>
<li> <a href="#Interface.MulticastAddrs">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</a>
</li>
<li><a href="#InvalidAddrError">type InvalidAddrError</a></li>
<li> <a href="#InvalidAddrError.Error">func (e InvalidAddrError) Error() string</a>
</li>
<li> <a href="#InvalidAddrError.Temporary">func (e InvalidAddrError) Temporary() bool</a>
</li>
<li> <a href="#InvalidAddrError.Timeout">func (e InvalidAddrError) Timeout() bool</a>
</li>
<li><a href="#Listener">type Listener</a></li>
<li> <a href="#FileListener">func FileListener(f *os.File) (ln Listener, err error)</a>
</li>
<li> <a href="#Listen">func Listen(net, laddr string) (Listener, error)</a>
</li>
<li><a href="#MX">type MX</a></li>
<li><a href="#NS">type NS</a></li>
<li><a href="#OpError">type OpError</a></li>
<li> <a href="#OpError.Error">func (e *OpError) Error() string</a>
</li>
<li> <a href="#OpError.Temporary">func (e *OpError) Temporary() bool</a>
</li>
<li> <a href="#OpError.Timeout">func (e *OpError) Timeout() bool</a>
</li>
<li><a href="#PacketConn">type PacketConn</a></li>
<li> <a href="#FilePacketConn">func FilePacketConn(f *os.File) (c PacketConn, err error)</a>
</li>
<li> <a href="#ListenPacket">func ListenPacket(net, laddr string) (PacketConn, error)</a>
</li>
<li><a href="#ParseError">type ParseError</a></li>
<li> <a href="#ParseError.Error">func (e *ParseError) Error() string</a>
</li>
<li><a href="#Resolver">type Resolver</a></li>
<li> <a href="#Resolver.LookupAddr">func (r *Resolver) LookupAddr(ctx context.Context, addr string) (names []string, err error)</a>
</li>
<li> <a href="#Resolver.LookupCNAME">func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string, err error)</a>
</li>
<li> <a href="#Resolver.LookupHost">func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)</a>
</li>
<li> <a href="#Resolver.LookupIPAddr">func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)</a>
</li>
<li> <a href="#Resolver.LookupMX">func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)</a>
</li>
<li> <a href="#Resolver.LookupNS">func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)</a>
</li>
<li> <a href="#Resolver.LookupPort">func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)</a>
</li>
<li> <a href="#Resolver.LookupSRV">func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs []*SRV, err error)</a>
</li>
<li> <a href="#Resolver.LookupTXT">func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)</a>
</li>
<li><a href="#SRV">type SRV</a></li>
<li><a href="#TCPAddr">type TCPAddr</a></li>
<li> <a href="#ResolveTCPAddr">func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</a>
</li>
<li> <a href="#TCPAddr.Network">func (a *TCPAddr) Network() string</a>
</li>
<li> <a href="#TCPAddr.String">func (a *TCPAddr) String() string</a>
</li>
<li><a href="#TCPConn">type TCPConn</a></li>
<li> <a href="#DialTCP">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</a>
</li>
<li> <a href="#TCPConn.Close">func (c *TCPConn) Close() error</a>
</li>
<li> <a href="#TCPConn.CloseRead">func (c *TCPConn) CloseRead() error</a>
</li>
<li> <a href="#TCPConn.CloseWrite">func (c *TCPConn) CloseWrite() error</a>
</li>
<li> <a href="#TCPConn.File">func (c *TCPConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#TCPConn.LocalAddr">func (c *TCPConn) LocalAddr() Addr</a>
</li>
<li> <a href="#TCPConn.Read">func (c *TCPConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#TCPConn.ReadFrom">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</a>
</li>
<li> <a href="#TCPConn.RemoteAddr">func (c *TCPConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#TCPConn.SetDeadline">func (c *TCPConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#TCPConn.SetKeepAlive">func (c *TCPConn) SetKeepAlive(keepalive bool) error</a>
</li>
<li> <a href="#TCPConn.SetKeepAlivePeriod">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</a>
</li>
<li> <a href="#TCPConn.SetLinger">func (c *TCPConn) SetLinger(sec int) error</a>
</li>
<li> <a href="#TCPConn.SetNoDelay">func (c *TCPConn) SetNoDelay(noDelay bool) error</a>
</li>
<li> <a href="#TCPConn.SetReadBuffer">func (c *TCPConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#TCPConn.SetReadDeadline">func (c *TCPConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#TCPConn.SetWriteBuffer">func (c *TCPConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#TCPConn.SetWriteDeadline">func (c *TCPConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#TCPConn.Write">func (c *TCPConn) Write(b []byte) (int, error)</a>
</li>
<li><a href="#TCPListener">type TCPListener</a></li>
<li> <a href="#ListenTCP">func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</a>
</li>
<li> <a href="#TCPListener.Accept">func (l *TCPListener) Accept() (Conn, error)</a>
</li>
<li> <a href="#TCPListener.AcceptTCP">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</a>
</li>
<li> <a href="#TCPListener.Addr">func (l *TCPListener) Addr() Addr</a>
</li>
<li> <a href="#TCPListener.Close">func (l *TCPListener) Close() error</a>
</li>
<li> <a href="#TCPListener.File">func (l *TCPListener) File() (f *os.File, err error)</a>
</li>
<li> <a href="#TCPListener.SetDeadline">func (l *TCPListener) SetDeadline(t time.Time) error</a>
</li>
<li><a href="#UDPAddr">type UDPAddr</a></li>
<li> <a href="#ResolveUDPAddr">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</a>
</li>
<li> <a href="#UDPAddr.Network">func (a *UDPAddr) Network() string</a>
</li>
<li> <a href="#UDPAddr.String">func (a *UDPAddr) String() string</a>
</li>
<li><a href="#UDPConn">type UDPConn</a></li>
<li> <a href="#DialUDP">func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</a>
</li>
<li> <a href="#ListenMulticastUDP">func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</a>
</li>
<li> <a href="#ListenUDP">func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</a>
</li>
<li> <a href="#UDPConn.Close">func (c *UDPConn) Close() error</a>
</li>
<li> <a href="#UDPConn.File">func (c *UDPConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#UDPConn.LocalAddr">func (c *UDPConn) LocalAddr() Addr</a>
</li>
<li> <a href="#UDPConn.Read">func (c *UDPConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#UDPConn.ReadFrom">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</a>
</li>
<li> <a href="#UDPConn.ReadFromUDP">func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)</a>
</li>
<li> <a href="#UDPConn.ReadMsgUDP">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</a>
</li>
<li> <a href="#UDPConn.RemoteAddr">func (c *UDPConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#UDPConn.SetDeadline">func (c *UDPConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#UDPConn.SetReadBuffer">func (c *UDPConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#UDPConn.SetReadDeadline">func (c *UDPConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#UDPConn.SetWriteBuffer">func (c *UDPConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#UDPConn.SetWriteDeadline">func (c *UDPConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#UDPConn.Write">func (c *UDPConn) Write(b []byte) (int, error)</a>
</li>
<li> <a href="#UDPConn.WriteMsgUDP">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</a>
</li>
<li> <a href="#UDPConn.WriteTo">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</a>
</li>
<li> <a href="#UDPConn.WriteToUDP">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</a>
</li>
<li><a href="#UnixAddr">type UnixAddr</a></li>
<li> <a href="#ResolveUnixAddr">func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</a>
</li>
<li> <a href="#UnixAddr.Network">func (a *UnixAddr) Network() string</a>
</li>
<li> <a href="#UnixAddr.String">func (a *UnixAddr) String() string</a>
</li>
<li><a href="#UnixConn">type UnixConn</a></li>
<li> <a href="#DialUnix">func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</a>
</li>
<li> <a href="#ListenUnixgram">func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)</a>
</li>
<li> <a href="#UnixConn.Close">func (c *UnixConn) Close() error</a>
</li>
<li> <a href="#UnixConn.CloseRead">func (c *UnixConn) CloseRead() error</a>
</li>
<li> <a href="#UnixConn.CloseWrite">func (c *UnixConn) CloseWrite() error</a>
</li>
<li> <a href="#UnixConn.File">func (c *UnixConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#UnixConn.LocalAddr">func (c *UnixConn) LocalAddr() Addr</a>
</li>
<li> <a href="#UnixConn.Read">func (c *UnixConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#UnixConn.ReadFrom">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</a>
</li>
<li> <a href="#UnixConn.ReadFromUnix">func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</a>
</li>
<li> <a href="#UnixConn.ReadMsgUnix">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</a>
</li>
<li> <a href="#UnixConn.RemoteAddr">func (c *UnixConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#UnixConn.SetDeadline">func (c *UnixConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixConn.SetReadBuffer">func (c *UnixConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#UnixConn.SetReadDeadline">func (c *UnixConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixConn.SetWriteBuffer">func (c *UnixConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#UnixConn.SetWriteDeadline">func (c *UnixConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixConn.Write">func (c *UnixConn) Write(b []byte) (int, error)</a>
</li>
<li> <a href="#UnixConn.WriteMsgUnix">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</a>
</li>
<li> <a href="#UnixConn.WriteTo">func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</a>
</li>
<li> <a href="#UnixConn.WriteToUnix">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</a>
</li>
<li><a href="#UnixListener">type UnixListener</a></li>
<li> <a href="#ListenUnix">func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</a>
</li>
<li> <a href="#UnixListener.Accept">func (l *UnixListener) Accept() (Conn, error)</a>
</li>
<li> <a href="#UnixListener.AcceptUnix">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</a>
</li>
<li> <a href="#UnixListener.Addr">func (l *UnixListener) Addr() Addr</a>
</li>
<li> <a href="#UnixListener.Close">func (l *UnixListener) Close() error</a>
</li>
<li> <a href="#UnixListener.File">func (l *UnixListener) File() (f *os.File, err error)</a>
</li>
<li> <a href="#UnixListener.SetDeadline">func (l *UnixListener) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixListener.SetUnlinkOnClose">func (l *UnixListener) SetUnlinkOnClose(unlink bool)</a>
</li>
<li><a href="#UnknownNetworkError">type UnknownNetworkError</a></li>
<li> <a href="#UnknownNetworkError.Error">func (e UnknownNetworkError) Error() string</a>
</li>
<li> <a href="#UnknownNetworkError.Temporary">func (e UnknownNetworkError) Temporary() bool</a>
</li>
<li> <a href="#UnknownNetworkError.Timeout">func (e UnknownNetworkError) Timeout() bool</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h4>Examples</h4> <dl> <dd><a class="exampleLink" href="#example_CIDRMask">CIDRMask</a></dd> <dd><a class="exampleLink" href="#example_Listener">Listener</a></dd> </dl> </div> <h4>Package files</h4> <p>  <a href="https://golang.org/src/net/addrselect.go" target="_blank">addrselect.go</a> <a href="https://golang.org/src/net/cgo_linux.go" target="_blank">cgo_linux.go</a> <a href="https://golang.org/src/net/cgo_resnew.go" target="_blank">cgo_resnew.go</a> <a href="https://golang.org/src/net/cgo_socknew.go" target="_blank">cgo_socknew.go</a> <a href="https://golang.org/src/net/cgo_unix.go" target="_blank">cgo_unix.go</a> <a href="https://golang.org/src/net/conf.go" target="_blank">conf.go</a> <a href="https://golang.org/src/net/dial.go" target="_blank">dial.go</a> <a href="https://golang.org/src/net/dnsclient.go" target="_blank">dnsclient.go</a> <a href="https://golang.org/src/net/dnsclient_unix.go" target="_blank">dnsclient_unix.go</a> <a href="https://golang.org/src/net/dnsconfig_unix.go" target="_blank">dnsconfig_unix.go</a> <a href="https://golang.org/src/net/dnsmsg.go" target="_blank">dnsmsg.go</a> <a href="https://golang.org/src/net/fd_mutex.go" target="_blank">fd_mutex.go</a> <a href="https://golang.org/src/net/fd_poll_runtime.go" target="_blank">fd_poll_runtime.go</a> <a href="https://golang.org/src/net/fd_posix.go" target="_blank">fd_posix.go</a> <a href="https://golang.org/src/net/fd_unix.go" target="_blank">fd_unix.go</a> <a href="https://golang.org/src/net/file.go" target="_blank">file.go</a> <a href="https://golang.org/src/net/file_unix.go" target="_blank">file_unix.go</a> <a href="https://golang.org/src/net/hook.go" target="_blank">hook.go</a> <a href="https://golang.org/src/net/hook_cloexec.go" target="_blank">hook_cloexec.go</a> <a href="https://golang.org/src/net/hook_unix.go" target="_blank">hook_unix.go</a> <a href="https://golang.org/src/net/hosts.go" target="_blank">hosts.go</a> <a href="https://golang.org/src/net/interface.go" target="_blank">interface.go</a> <a href="https://golang.org/src/net/interface_linux.go" target="_blank">interface_linux.go</a> <a href="https://golang.org/src/net/ip.go" target="_blank">ip.go</a> <a href="https://golang.org/src/net/iprawsock.go" target="_blank">iprawsock.go</a> <a href="https://golang.org/src/net/iprawsock_posix.go" target="_blank">iprawsock_posix.go</a> <a href="https://golang.org/src/net/ipsock.go" target="_blank">ipsock.go</a> <a href="https://golang.org/src/net/ipsock_posix.go" target="_blank">ipsock_posix.go</a> <a href="https://golang.org/src/net/lookup.go" target="_blank">lookup.go</a> <a href="https://golang.org/src/net/lookup_unix.go" target="_blank">lookup_unix.go</a> <a href="https://golang.org/src/net/mac.go" target="_blank">mac.go</a> <a href="https://golang.org/src/net/net.go" target="_blank">net.go</a> <a href="https://golang.org/src/net/nss.go" target="_blank">nss.go</a> <a href="https://golang.org/src/net/parse.go" target="_blank">parse.go</a> <a href="https://golang.org/src/net/pipe.go" target="_blank">pipe.go</a> <a href="https://golang.org/src/net/port.go" target="_blank">port.go</a> <a href="https://golang.org/src/net/port_unix.go" target="_blank">port_unix.go</a> <a href="https://golang.org/src/net/sendfile_linux.go" target="_blank">sendfile_linux.go</a> <a href="https://golang.org/src/net/sock_cloexec.go" target="_blank">sock_cloexec.go</a> <a href="https://golang.org/src/net/sock_linux.go" target="_blank">sock_linux.go</a> <a href="https://golang.org/src/net/sock_posix.go" target="_blank">sock_posix.go</a> <a href="https://golang.org/src/net/sockopt_linux.go" target="_blank">sockopt_linux.go</a> <a href="https://golang.org/src/net/sockopt_posix.go" target="_blank">sockopt_posix.go</a> <a href="https://golang.org/src/net/sockoptip_linux.go" target="_blank">sockoptip_linux.go</a> <a href="https://golang.org/src/net/sockoptip_posix.go" target="_blank">sockoptip_posix.go</a> <a href="https://golang.org/src/net/tcpsock.go" target="_blank">tcpsock.go</a> <a href="https://golang.org/src/net/tcpsock_posix.go" target="_blank">tcpsock_posix.go</a> <a href="https://golang.org/src/net/tcpsockopt_posix.go" target="_blank">tcpsockopt_posix.go</a> <a href="https://golang.org/src/net/tcpsockopt_unix.go" target="_blank">tcpsockopt_unix.go</a> <a href="https://golang.org/src/net/udpsock.go" target="_blank">udpsock.go</a> <a href="https://golang.org/src/net/udpsock_posix.go" target="_blank">udpsock_posix.go</a> <a href="https://golang.org/src/net/unixsock.go" target="_blank">unixsock.go</a> <a href="https://golang.org/src/net/unixsock_posix.go" target="_blank">unixsock_posix.go</a> <a href="https://golang.org/src/net/writev_unix.go" target="_blank">writev_unix.go</a>  </p>     <h2 id="pkg-constants">Constants</h2> <p> IP address lengths (bytes). </p> <pre data-language="go">const (
        IPv4len = 4
        IPv6len = 16
)</pre> <h2 id="pkg-variables">Variables</h2> <p> Well-known IPv4 addresses </p> <pre data-language="go">var (
        IPv4bcast     = IPv4(255, 255, 255, 255) // limited broadcast
        IPv4allsys    = IPv4(224, 0, 0, 1)       // all systems
        IPv4allrouter = IPv4(224, 0, 0, 2)       // all routers
        IPv4zero      = IPv4(0, 0, 0, 0)         // all zeros
)</pre> <p> Well-known IPv6 addresses </p> <pre data-language="go">var (
        IPv6zero                   = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        IPv6unspecified            = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
        IPv6loopback               = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
        IPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
        IPv6linklocalallnodes      = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
        IPv6linklocalallrouters    = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}
)</pre> <p> DefaultResolver is the resolver used by the package-level Lookup functions and by Dialers without a specified Resolver. </p> <pre data-language="go">var DefaultResolver = &amp;Resolver{}</pre> <p> Various errors contained in OpError. </p> <pre data-language="go">var (
        ErrWriteToConnected = errors.New("use of WriteTo with pre-connected connection")
)</pre> <h2 id="InterfaceAddrs">func InterfaceAddrs<a href="https://golang.org/src/net/interface.go?s=3399:3436#L105" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func InterfaceAddrs() ([]Addr, error)</pre> <p> InterfaceAddrs returns a list of the system's unicast interface addresses. </p> <p> The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail. </p> <h2 id="Interfaces">func Interfaces<a href="https://golang.org/src/net/interface.go?s=2951:2989#L89" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Interfaces() ([]Interface, error)</pre> <p> Interfaces returns a list of the system's network interfaces. </p> <h2 id="JoinHostPort">func JoinHostPort<a href="https://golang.org/src/net/ipsock.go?s=5544:5587#L176" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func JoinHostPort(host, port string) string</pre> <p> JoinHostPort combines host and port into a network address of the form "host:port" or, if host contains a colon or a percent sign, "[host]:port". </p> <h2 id="LookupAddr">func LookupAddr<a href="https://golang.org/src/net/lookup.go?s=10897:10953#L315" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupAddr(addr string) (names []string, err error)</pre> <p> LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. </p> <p> When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver. </p> <h2 id="LookupCNAME">func LookupCNAME<a href="https://golang.org/src/net/lookup.go?s=7494:7549#L236" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupCNAME(host string) (cname string, err error)</pre> <p> LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. </p> <p> A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS "CNAME" records, as long as host resolves to address records. </p> <h2 id="LookupHost">func LookupHost<a href="https://golang.org/src/net/lookup.go?s=2924:2980#L96" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupHost(host string) (addrs []string, err error)</pre> <p> LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. </p> <h2 id="LookupIP">func LookupIP<a href="https://golang.org/src/net/lookup.go?s=3679:3719#L116" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupIP(host string) ([]IP, error)</pre> <p> LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. </p> <h2 id="LookupMX">func LookupMX<a href="https://golang.org/src/net/lookup.go?s=9617:9658#L281" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupMX(name string) ([]*MX, error)</pre> <p> LookupMX returns the DNS MX records for the given domain name sorted by preference. </p> <h2 id="LookupNS">func LookupNS<a href="https://golang.org/src/net/lookup.go?s=9990:10031#L291" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupNS(name string) ([]*NS, error)</pre> <p> LookupNS returns the DNS NS records for the given domain name. </p> <h2 id="LookupPort">func LookupPort<a href="https://golang.org/src/net/lookup.go?s=6461:6523#L207" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupPort(network, service string) (port int, err error)</pre> <p> LookupPort looks up the port for the given network and service. </p> <h2 id="LookupSRV">func LookupSRV<a href="https://golang.org/src/net/lookup.go?s=8699:8782#L263" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</pre> <p> LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is "tcp" or "udp". The returned records are sorted by priority and randomized by weight within a priority. </p> <p> LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. </p> <h2 id="LookupTXT">func LookupTXT<a href="https://golang.org/src/net/lookup.go?s=10344:10389#L301" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func LookupTXT(name string) ([]string, error)</pre> <p> LookupTXT returns the DNS TXT records for the given domain name. </p> <h2 id="SplitHostPort">func SplitHostPort<a href="https://golang.org/src/net/ipsock.go?s=3572:3638#L104" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func SplitHostPort(hostport string) (host, port string, err error)</pre> <p> SplitHostPort splits a network address of the form "host:port", "[host]:port" or "[ipv6-host%zone]:port" into host or ipv6-host%zone and port. A literal address or host name for IPv6 must be enclosed in square brackets, as in "[::1]:80", "[ipv6-host]:http" or "[ipv6-host%zone]:80". </p> <h2 id="Addr">type Addr<a href="https://golang.org/src/net/net.go?s=3775:3961#L99" class="source" target="_blank">Source</a>  </h2> <p> Addr represents a network end point address. </p> <p> The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation. </p> <pre data-language="go">type Addr interface {
        Network() string // name of the network (for example, "tcp", "udp")
        String() string  // string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
}</pre> <h2 id="AddrError">type AddrError<a href="https://golang.org/src/net/net.go?s=16255:16306#L513" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type AddrError struct {
        Err  string
        Addr string
}</pre> <h3 id="AddrError.Error">func (*AddrError) Error<a href="https://golang.org/src/net/net.go?s=16308:16342#L518" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *AddrError) Error() string</pre> <h3 id="AddrError.Temporary">func (*AddrError) Temporary<a href="https://golang.org/src/net/net.go?s=16518:16554#L530" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *AddrError) Temporary() bool</pre> <h3 id="AddrError.Timeout">func (*AddrError) Timeout<a href="https://golang.org/src/net/net.go?s=16464:16498#L529" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *AddrError) Timeout() bool</pre> <h2 id="Buffers">type Buffers<a href="https://golang.org/src/net/net.go?s=19894:19915#L632" class="source" target="_blank">Source</a>  </h2> <p> Buffers contains zero or more runs of bytes to write. </p> <p> On certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as "writev"). </p> <pre data-language="go">type Buffers [][]byte</pre> <h3 id="Buffers.Read">func (*Buffers) Read<a href="https://golang.org/src/net/net.go?s=20278:20329#L655" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (v *Buffers) Read(p []byte) (n int, err error)</pre> <h3 id="Buffers.WriteTo">func (*Buffers) WriteTo<a href="https://golang.org/src/net/net.go?s=19992:20051#L639" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)</pre> <h2 id="Conn">type Conn<a href="https://golang.org/src/net/net.go?s=4091:6064#L107" class="source" target="_blank">Source</a>  </h2> <p> Conn is a generic stream-oriented network connection. </p> <p> Multiple goroutines may invoke methods on a Conn simultaneously. </p> <pre data-language="go">type Conn interface {
        // Read reads data from the connection.
        // Read can be made to time out and return an Error with Timeout() == true
        // after a fixed time limit; see SetDeadline and SetReadDeadline.
        Read(b []byte) (n int, err error)

        // Write writes data to the connection.
        // Write can be made to time out and return an Error with Timeout() == true
        // after a fixed time limit; see SetDeadline and SetWriteDeadline.
        Write(b []byte) (n int, err error)

        // Close closes the connection.
        // Any blocked Read or Write operations will be unblocked and return errors.
        Close() error

        // LocalAddr returns the local network address.
        LocalAddr() Addr

        // RemoteAddr returns the remote network address.
        RemoteAddr() Addr

        // SetDeadline sets the read and write deadlines associated
        // with the connection. It is equivalent to calling both
        // SetReadDeadline and SetWriteDeadline.
        //
        // A deadline is an absolute time after which I/O operations
        // fail with a timeout (see type Error) instead of
        // blocking. The deadline applies to all future and pending
        // I/O, not just the immediately following call to Read or
        // Write. After a deadline has been exceeded, the connection
        // can be refreshed by setting a deadline in the future.
        //
        // An idle timeout can be implemented by repeatedly extending
        // the deadline after successful Read or Write calls.
        //
        // A zero value for t means I/O operations will not time out.
        SetDeadline(t time.Time) error

        // SetReadDeadline sets the deadline for future Read calls
        // and any currently-blocked Read call.
        // A zero value for t means Read will not time out.
        SetReadDeadline(t time.Time) error

        // SetWriteDeadline sets the deadline for future Write calls
        // and any currently-blocked Write call.
        // Even if write times out, it may return n &gt; 0, indicating that
        // some of the data was successfully written.
        // A zero value for t means Write will not time out.
        SetWriteDeadline(t time.Time) error
}</pre> <h3 id="Dial">func Dial<a href="https://golang.org/src/net/dial.go?s=7847:7895#L261" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Dial(network, address string) (Conn, error)</pre> <p> Dial connects to the address on the named network. </p> <p> Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only), "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4" (IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and "unixpacket". </p> <p> For TCP and UDP networks, addresses have the form host:port. If host is a literal IPv6 address it must be enclosed in square brackets as in "[::1]:80" or "[ipv6-host%zone]:80". The functions JoinHostPort and SplitHostPort manipulate addresses in this form. If the host is empty, as in ":80", the local system is assumed. </p> <p> Examples: </p> <pre data-language="go">Dial("tcp", "192.0.2.1:80")
Dial("tcp", "golang.org:http")
Dial("tcp", "[2001:db8::1]:http")
Dial("tcp", "[fe80::1%lo0]:80")
Dial("tcp", ":80")
</pre> <p> For IP networks, the network must be "ip", "ip4" or "ip6" followed by a colon and a protocol number or name and the addr must be a literal IP address. </p> <p> Examples: </p> <pre data-language="go">Dial("ip4:1", "192.0.2.1")
Dial("ip6:ipv6-icmp", "2001:db8::1")
</pre> <p> For Unix networks, the address must be a file system path. </p> <p> If the host is resolved to multiple addresses, Dial will try each address in order until one succeeds. </p> <h3 id="DialTimeout">func DialTimeout<a href="https://golang.org/src/net/dial.go?s=8053:8131#L268" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</pre> <p> DialTimeout acts like Dial but takes a timeout. The timeout includes name resolution, if required. </p> <h3 id="FileConn">func FileConn<a href="https://golang.org/src/net/file.go?s=655:700#L11" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func FileConn(f *os.File) (c Conn, err error)</pre> <p> FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <h3 id="Pipe">func Pipe<a href="https://golang.org/src/net/pipe.go?s=461:485#L8" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Pipe() (Conn, Conn)</pre> <p> Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering. </p> <h2 id="DNSConfigError">type DNSConfigError<a href="https://golang.org/src/net/net.go?s=17160:17201#L546" class="source" target="_blank">Source</a>  </h2> <p> DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.) </p> <pre data-language="go">type DNSConfigError struct {
        Err error
}</pre> <h3 id="DNSConfigError.Error">func (*DNSConfigError) Error<a href="https://golang.org/src/net/net.go?s=17203:17242#L550" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *DNSConfigError) Error() string</pre> <h3 id="DNSConfigError.Temporary">func (*DNSConfigError) Temporary<a href="https://golang.org/src/net/net.go?s=17360:17401#L552" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *DNSConfigError) Temporary() bool</pre> <h3 id="DNSConfigError.Timeout">func (*DNSConfigError) Timeout<a href="https://golang.org/src/net/net.go?s=17301:17340#L551" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *DNSConfigError) Timeout() bool</pre> <h2 id="DNSError">type DNSError<a href="https://golang.org/src/net/net.go?s=17557:17848#L560" class="source" target="_blank">Source</a>  </h2> <p> DNSError represents a DNS lookup error. </p> <pre data-language="go">type DNSError struct {
        Err         string // description of the error
        Name        string // name looked for
        Server      string // server used
        IsTimeout   bool   // if true, timed out; not all timeouts set this
        IsTemporary bool   // if true, error is temporary; not all errors set this
}</pre> <h3 id="DNSError.Error">func (*DNSError) Error<a href="https://golang.org/src/net/net.go?s=17850:17883#L568" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *DNSError) Error() string</pre> <h3 id="DNSError.Temporary">func (*DNSError) Temporary<a href="https://golang.org/src/net/net.go?s=18486:18521#L588" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *DNSError) Temporary() bool</pre> <p> Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false. </p> <h3 id="DNSError.Timeout">func (*DNSError) Timeout<a href="https://golang.org/src/net/net.go?s=18223:18256#L583" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *DNSError) Timeout() bool</pre> <p> Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false. </p> <h2 id="Dialer">type Dialer<a href="https://golang.org/src/net/dial.go?s=469:2399#L8" class="source" target="_blank">Source</a>  </h2> <p> A Dialer contains options for connecting to an address. </p> <p> The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function. </p> <pre data-language="go">type Dialer struct {
        // Timeout is the maximum amount of time a dial will wait for
        // a connect to complete. If Deadline is also set, it may fail
        // earlier.
        //
        // The default is no timeout.
        //
        // When dialing a name with multiple IP addresses, the timeout
        // may be divided between them.
        //
        // With or without a timeout, the operating system may impose
        // its own earlier timeout. For instance, TCP timeouts are
        // often around 3 minutes.
        Timeout time.Duration

        // Deadline is the absolute point in time after which dials
        // will fail. If Timeout is set, it may fail earlier.
        // Zero means no deadline, or dependent on the operating system
        // as with the Timeout option.
        Deadline time.Time

        // LocalAddr is the local address to use when dialing an
        // address. The address must be of a compatible type for the
        // network being dialed.
        // If nil, a local address is automatically chosen.
        LocalAddr Addr

        // DualStack enables RFC 6555-compliant "Happy Eyeballs" dialing
        // when the network is "tcp" and the destination is a host name
        // with both IPv4 and IPv6 addresses. This allows a client to
        // tolerate networks where one address family is silently broken.
        DualStack bool

        // FallbackDelay specifies the length of time to wait before
        // spawning a fallback connection, when DualStack is enabled.
        // If zero, a default delay of 300ms is used.
        FallbackDelay time.Duration

        // KeepAlive specifies the keep-alive period for an active
        // network connection.
        // If zero, keep-alives are not enabled. Network protocols
        // that do not support keep-alives ignore this field.
        KeepAlive time.Duration

        // Resolver optionally specifies an alternate resolver to use.
        Resolver *Resolver

        // Cancel is an optional channel whose closure indicates that
        // the dial should be canceled. Not all types of dials support
        // cancelation.
        //
        // Deprecated: Use DialContext instead.
        Cancel &lt;-chan struct{}
}</pre> <h3 id="Dialer.Dial">func (*Dialer) Dial<a href="https://golang.org/src/net/dial.go?s=8456:8516#L283" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (d *Dialer) Dial(network, address string) (Conn, error)</pre> <p> Dial connects to the address on the named network. </p> <p> See func Dial for a description of the network and address parameters. </p> <h3 id="Dialer.DialContext">func (*Dialer) DialContext<a href="https://golang.org/src/net/dial.go?s=9419:9507#L305" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</pre> <p> DialContext connects to the address on the named network using the provided context. </p> <p> The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. </p> <p> When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one. </p> <p> See func Dial for a description of the network and address parameters. </p> <h2 id="Error">type Error<a href="https://golang.org/src/net/net.go?s=12578:12699#L369" class="source" target="_blank">Source</a>  </h2> <p> An Error represents a network error. </p> <pre data-language="go">type Error interface {
        error
        Timeout() bool   // Is the error a timeout?
        Temporary() bool // Is the error temporary?
}</pre> <h2 id="Flags">type Flags<a href="https://golang.org/src/net/interface.go?s=1330:1345#L28" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type Flags uint</pre> <pre data-language="go">const (
        FlagUp           Flags = 1 &lt;&lt; iota // interface is up
        FlagBroadcast                      // interface supports broadcast access capability
        FlagLoopback                       // interface is a loopback interface
        FlagPointToPoint                   // interface belongs to a point-to-point link
        FlagMulticast                      // interface supports multicast access capability
)</pre> <h3 id="Flags.String">func (Flags) String<a href="https://golang.org/src/net/interface.go?s=1834:1864#L46" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f Flags) String() string</pre> <h2 id="HardwareAddr">type HardwareAddr<a href="https://golang.org/src/net/mac.go?s=268:292#L1" class="source" target="_blank">Source</a>  </h2> <p> A HardwareAddr represents a physical hardware address. </p> <pre data-language="go">type HardwareAddr []byte</pre> <h3 id="ParseMAC">func ParseMAC<a href="https://golang.org/src/net/mac.go?s=1053:1105#L28" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ParseMAC(s string) (hw HardwareAddr, err error)</pre> <p> ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats: </p> <pre data-language="go">01:23:45:67:89:ab
01:23:45:67:89:ab:cd:ef
01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00
01-23-45-67-89-ab
01-23-45-67-89-ab-cd-ef
01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00
0123.4567.89ab
0123.4567.89ab.cdef
0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000
</pre> <h3 id="HardwareAddr.String">func (HardwareAddr) String<a href="https://golang.org/src/net/mac.go?s=294:331#L2" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a HardwareAddr) String() string</pre> <h2 id="IP">type IP<a href="https://golang.org/src/net/ip.go?s=919:933#L20" class="source" target="_blank">Source</a>  </h2> <p> An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input. </p> <p> Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address. </p> <pre data-language="go">type IP []byte</pre> <h3 id="IPv4">func IPv4<a href="https://golang.org/src/net/ip.go?s=1189:1218#L33" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func IPv4(a, b, c, d byte) IP</pre> <p> IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d. </p> <h3 id="ParseCIDR">func ParseCIDR<a href="https://golang.org/src/net/ip.go?s=15511:15555#L661" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ParseCIDR(s string) (IP, *IPNet, error)</pre> <p> ParseCIDR parses s as a CIDR notation IP address and prefix length, like "192.0.2.0/24" or "2001:db8::/32", as defined in RFC 4632 and RFC 4291. </p> <p> It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR("192.0.2.1/24") returns the IP address 198.0.2.1 and the network 198.0.2.0/24. </p> <h3 id="ParseIP">func ParseIP<a href="https://golang.org/src/net/ip.go?s=14972:14997#L640" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ParseIP(s string) IP</pre> <p> ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal ("192.0.2.1") or IPv6 ("2001:db8::68") form. If s is not a valid textual representation of an IP address, ParseIP returns nil. </p> <h3 id="IP.DefaultMask">func (IP) DefaultMask<a href="https://golang.org/src/net/ip.go?s=5873:5906#L208" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) DefaultMask() IPMask</pre> <p> DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address. </p> <h3 id="IP.Equal">func (IP) Equal<a href="https://golang.org/src/net/ip.go?s=9253:9282#L361" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) Equal(x IP) bool</pre> <p> Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal. </p> <h3 id="IP.IsGlobalUnicast">func (IP) IsGlobalUnicast<a href="https://golang.org/src/net/ip.go?s=4596:4631#L152" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) IsGlobalUnicast() bool</pre> <p> IsGlobalUnicast reports whether ip is a global unicast address. </p> <p> The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space. </p> <h3 id="IP.IsInterfaceLocalMulticast">func (IP) IsInterfaceLocalMulticast<a href="https://golang.org/src/net/ip.go?s=3564:3609#L122" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) IsInterfaceLocalMulticast() bool</pre> <p> IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address. </p> <h3 id="IP.IsLinkLocalMulticast">func (IP) IsLinkLocalMulticast<a href="https://golang.org/src/net/ip.go?s=3762:3802#L128" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) IsLinkLocalMulticast() bool</pre> <p> IsLinkLocalMulticast reports whether ip is a link-local multicast address. </p> <h3 id="IP.IsLinkLocalUnicast">func (IP) IsLinkLocalUnicast<a href="https://golang.org/src/net/ip.go?s=4041:4079#L137" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) IsLinkLocalUnicast() bool</pre> <p> IsLinkLocalUnicast reports whether ip is a link-local unicast address. </p> <h3 id="IP.IsLoopback">func (IP) IsLoopback<a href="https://golang.org/src/net/ip.go?s=3140:3170#L105" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) IsLoopback() bool</pre> <p> IsLoopback reports whether ip is a loopback address. </p> <h3 id="IP.IsMulticast">func (IP) IsMulticast<a href="https://golang.org/src/net/ip.go?s=3325:3356#L113" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) IsMulticast() bool</pre> <p> IsMulticast reports whether ip is a multicast address. </p> <h3 id="IP.IsUnspecified">func (IP) IsUnspecified<a href="https://golang.org/src/net/ip.go?s=2989:3022#L100" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) IsUnspecified() bool</pre> <p> IsUnspecified reports whether ip is an unspecified address. </p> <h3 id="IP.MarshalText">func (IP) MarshalText<a href="https://golang.org/src/net/ip.go?s=8503:8545#L332" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) MarshalText() ([]byte, error)</pre> <p> MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String. </p> <h3 id="IP.Mask">func (IP) Mask<a href="https://golang.org/src/net/ip.go?s=6261:6294#L232" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) Mask(mask IPMask) IP</pre> <p> Mask returns the result of masking the IP address ip with mask. </p> <h3 id="IP.String">func (IP) String<a href="https://golang.org/src/net/ip.go?s=6975:7003#L256" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) String() string</pre> <p> String returns the string form of the IP address ip. It returns one of 4 forms: </p> <pre data-language="go">- "&lt;nil&gt;", if ip has length 0
- dotted decimal ("192.0.2.1"), if ip is an IPv4 or IP4-mapped IPv6 address
- IPv6 ("2001:db8::1"), if ip is a valid IPv6 address
- the hexadecimal form of ip, without punctuation, if no other cases apply
</pre> <h3 id="IP.To16">func (IP) To16<a href="https://golang.org/src/net/ip.go?s=5387:5409#L188" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) To16() IP</pre> <p> To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil. </p> <h3 id="IP.To4">func (IP) To4<a href="https://golang.org/src/net/ip.go?s=5060:5081#L173" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip IP) To4() IP</pre> <p> To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil. </p> <h3 id="IP.UnmarshalText">func (*IP) UnmarshalText<a href="https://golang.org/src/net/ip.go?s=8883:8929#L344" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ip *IP) UnmarshalText(text []byte) error</pre> <p> UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP. </p> <h2 id="IPAddr">type IPAddr<a href="https://golang.org/src/net/iprawsock.go?s=1021:1096#L21" class="source" target="_blank">Source</a>  </h2> <p> IPAddr represents the address of an IP end point. </p> <pre data-language="go">type IPAddr struct {
        IP   IP
        Zone string // IPv6 scoped addressing zone
}</pre> <h3 id="ResolveIPAddr">func ResolveIPAddr<a href="https://golang.org/src/net/iprawsock.go?s=1834:1887#L60" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ResolveIPAddr(net, addr string) (*IPAddr, error)</pre> <p> ResolveIPAddr parses addr as an IP address of the form "host" or "ipv6-host%zone" and resolves the domain name on the network net, which must be "ip", "ip4" or "ip6". </p> <p> Resolving a hostname is not recommended because this returns at most one of its IP addresses. </p> <h3 id="IPAddr.Network">func (*IPAddr) Network<a href="https://golang.org/src/net/iprawsock.go?s=1151:1184#L27" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *IPAddr) Network() string</pre> <p> Network returns the address's network name, "ip". </p> <h3 id="IPAddr.String">func (*IPAddr) String<a href="https://golang.org/src/net/iprawsock.go?s=1202:1234#L29" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *IPAddr) String() string</pre> <h2 id="IPConn">type IPConn<a href="https://golang.org/src/net/iprawsock.go?s=2432:2460#L82" class="source" target="_blank">Source</a>  </h2> <p> IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections. </p> <pre data-language="go">type IPConn struct {
        // contains filtered or unexported fields
}</pre> <h3 id="DialIP">func DialIP<a href="https://golang.org/src/net/iprawsock.go?s=5769:5836#L187" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</pre> <p> DialIP connects to the remote address raddr on the network protocol netProto, which must be "ip", "ip4", or "ip6" followed by a colon and a protocol number or name. </p> <h3 id="ListenIP">func ListenIP<a href="https://golang.org/src/net/iprawsock.go?s=6264:6326#L199" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</pre> <p> ListenIP listens for incoming IP packets addressed to the local address laddr. The returned connection's ReadFrom and WriteTo methods can be used to receive and send IP packets with per-packet addressing. </p> <h3 id="IPConn.Close">func (*IPConn) Close<a href="https://golang.org/src/net/net.go?s=6824:6852#L191" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id="IPConn.File">func (*IPConn) File<a href="https://golang.org/src/net/net.go?s=9508:9553#L286" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id="IPConn.LocalAddr">func (*IPConn) LocalAddr<a href="https://golang.org/src/net/net.go?s=7181:7212#L205" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id="IPConn.Read">func (*IPConn) Read<a href="https://golang.org/src/net/net.go?s=6243:6285#L167" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id="IPConn.ReadFrom">func (*IPConn) ReadFrom<a href="https://golang.org/src/net/iprawsock.go?s=3115:3169#L105" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p> ReadFrom implements the PacketConn ReadFrom method. </p> <h3 id="IPConn.ReadFromIP">func (*IPConn) ReadFromIP<a href="https://golang.org/src/net/iprawsock.go?s=2782:2841#L93" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</pre> <p> ReadFromIP reads an IP packet from c, copying the payload into b. It returns the number of bytes copied into b and the return address that was on the packet. </p> <p> ReadFromIP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id="IPConn.ReadMsgIP">func (*IPConn) ReadMsgIP<a href="https://golang.org/src/net/iprawsock.go?s=3707:3794#L123" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</pre> <p> ReadMsgIP reads a packet from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet and the source address of the packet. </p> <h3 id="IPConn.RemoteAddr">func (*IPConn) RemoteAddr<a href="https://golang.org/src/net/net.go?s=7406:7438#L215" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id="IPConn.SetDeadline">func (*IPConn) SetDeadline<a href="https://golang.org/src/net/net.go?s=7548:7593#L223" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id="IPConn.SetReadBuffer">func (*IPConn) SetReadBuffer<a href="https://golang.org/src/net/net.go?s=8512:8557#L257" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id="IPConn.SetReadDeadline">func (*IPConn) SetReadDeadline<a href="https://golang.org/src/net/net.go?s=7848:7897#L234" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id="IPConn.SetWriteBuffer">func (*IPConn) SetWriteBuffer<a href="https://golang.org/src/net/net.go?s=8865:8911#L269" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id="IPConn.SetWriteDeadline">func (*IPConn) SetWriteDeadline<a href="https://golang.org/src/net/net.go?s=8158:8208#L245" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id="IPConn.Write">func (*IPConn) Write<a href="https://golang.org/src/net/net.go?s=6546:6589#L179" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h3 id="IPConn.WriteMsgIP">func (*IPConn) WriteMsgIP<a href="https://golang.org/src/net/iprawsock.go?s=5232:5313#L171" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</pre> <p> WriteMsgIP writes a packet to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. </p> <h3 id="IPConn.WriteTo">func (*IPConn) WriteTo<a href="https://golang.org/src/net/iprawsock.go?s=4641:4699#L153" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p> WriteTo implements the PacketConn WriteTo method. </p> <h3 id="IPConn.WriteToIP">func (*IPConn) WriteToIP<a href="https://golang.org/src/net/iprawsock.go?s=4314:4377#L141" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</pre> <p> WriteToIP writes an IP packet to addr via c, copying the payload from b. </p> <p> WriteToIP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. On packet-oriented connections, write timeouts are rare. </p> <h2 id="IPMask">type IPMask<a href="https://golang.org/src/net/ip.go?s=967:985#L23" class="source" target="_blank">Source</a>  </h2> <p> An IP mask is an IP address. </p> <pre data-language="go">type IPMask []byte</pre> <h3 id="CIDRMask">func CIDRMask<a href="https://golang.org/src/net/ip.go?s=1774:1810#L59" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func CIDRMask(ones, bits int) IPMask</pre> <p> CIDRMask returns an IPMask consisting of `ones' 1 bits followed by 0s up to a total length of `bits' bits. For a mask of this form, CIDRMask is the inverse of IPMask.Size. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"net"
)

func main() {
	// This mask corresponds to a /31 subnet for IPv4.
	fmt.Println(net.CIDRMask(31, 32))

	// This mask corresponds to a /64 subnet for IPv6.
	fmt.Println(net.CIDRMask(64, 128))

}
</pre>   <h3 id="IPv4Mask">func IPv4Mask<a href="https://golang.org/src/net/ip.go?s=1472:1509#L47" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func IPv4Mask(a, b, c, d byte) IPMask</pre> <p> IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d. </p> <h3 id="IPMask.Size">func (IPMask) Size<a href="https://golang.org/src/net/ip.go?s=10526:10565#L422" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (m IPMask) Size() (ones, bits int)</pre> <p> Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0. </p> <h3 id="IPMask.String">func (IPMask) String<a href="https://golang.org/src/net/ip.go?s=10723:10754#L431" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (m IPMask) String() string</pre> <p> String returns the hexadecimal form of m, with no punctuation. </p> <h2 id="IPNet">type IPNet<a href="https://golang.org/src/net/ip.go?s=1025:1106#L26" class="source" target="_blank">Source</a>  </h2> <p> An IPNet represents an IP network. </p> <pre data-language="go">type IPNet struct {
        IP   IP     // network number
        Mask IPMask // network mask
}</pre> <h3 id="IPNet.Contains">func (*IPNet) Contains<a href="https://golang.org/src/net/ip.go?s=11219:11255#L462" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n *IPNet) Contains(ip IP) bool</pre> <p> Contains reports whether the network includes ip. </p> <h3 id="IPNet.Network">func (*IPNet) Network<a href="https://golang.org/src/net/ip.go?s=11539:11571#L480" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n *IPNet) Network() string</pre> <p> Network returns the address's network name, "ip+net". </p> <h3 id="IPNet.String">func (*IPNet) String<a href="https://golang.org/src/net/ip.go?s=11943:11974#L488" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (n *IPNet) String() string</pre> <p> String returns the CIDR notation of n like "192.0.2.1/24" or "2001:db8::/48" as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like "198.51.100.1/c000ff00". </p> <h2 id="Interface">type Interface<a href="https://golang.org/src/net/interface.go?s=962:1328#L20" class="source" target="_blank">Source</a>  </h2> <p> Interface represents a mapping between network interface name and index. It also represents network interface facility information. </p> <pre data-language="go">type Interface struct {
        Index        int          // positive integer that starts at one, zero is never used
        MTU          int          // maximum transmission unit
        Name         string       // e.g., "en0", "lo0", "eth0.100"
        HardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form
        Flags        Flags        // e.g., FlagUp, FlagLoopback, FlagMulticast
}</pre> <h3 id="InterfaceByIndex">func InterfaceByIndex<a href="https://golang.org/src/net/interface.go?s=3803:3855#L118" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func InterfaceByIndex(index int) (*Interface, error)</pre> <p> InterfaceByIndex returns the interface specified by index. </p> <p> On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use InterfaceByName. </p> <h3 id="InterfaceByName">func InterfaceByName<a href="https://golang.org/src/net/interface.go?s=4532:4585#L143" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func InterfaceByName(name string) (*Interface, error)</pre> <p> InterfaceByName returns the interface specified by name. </p> <h3 id="Interface.Addrs">func (*Interface) Addrs<a href="https://golang.org/src/net/interface.go?s=2115:2160#L64" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ifi *Interface) Addrs() ([]Addr, error)</pre> <p> Addrs returns a list of unicast interface addresses for a specific interface. </p> <h3 id="Interface.MulticastAddrs">func (*Interface) MulticastAddrs<a href="https://golang.org/src/net/interface.go?s=2541:2595#L77" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</pre> <p> MulticastAddrs returns a list of multicast, joined group addresses for a specific interface. </p> <h2 id="InvalidAddrError">type InvalidAddrError<a href="https://golang.org/src/net/net.go?s=16821:16849#L538" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type InvalidAddrError string</pre> <h3 id="InvalidAddrError.Error">func (InvalidAddrError) Error<a href="https://golang.org/src/net/net.go?s=16851:16891#L540" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e InvalidAddrError) Error() string</pre> <h3 id="InvalidAddrError.Temporary">func (InvalidAddrError) Temporary<a href="https://golang.org/src/net/net.go?s=16975:17017#L542" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e InvalidAddrError) Temporary() bool</pre> <h3 id="InvalidAddrError.Timeout">func (InvalidAddrError) Timeout<a href="https://golang.org/src/net/net.go?s=16915:16955#L541" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e InvalidAddrError) Timeout() bool</pre> <h2 id="Listener">type Listener<a href="https://golang.org/src/net/net.go?s=12234:12536#L356" class="source" target="_blank">Source</a>  </h2> <p> A Listener is a generic network listener for stream-oriented protocols. </p> <p> Multiple goroutines may invoke methods on a Listener simultaneously. </p> <pre data-language="go">type Listener interface {
        // Accept waits for and returns the next connection to the listener.
        Accept() (Conn, error)

        // Close closes the listener.
        // Any blocked Accept operations will be unblocked and return errors.
        Close() error

        // Addr returns the listener's network address.
        Addr() Addr
}</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"io"
	"log"
	"net"
)

func main() {
	// Listen on TCP port 2000 on all interfaces.
	l, err := net.Listen("tcp", ":2000")
	if err != nil {
		log.Fatal(err)
	}
	defer l.Close()
	for {
		// Wait for a connection.
		conn, err := l.Accept()
		if err != nil {
			log.Fatal(err)
		}
		// Handle the connection in a new goroutine.
		// The loop then returns to accepting, so that
		// multiple connections may be served concurrently.
		go func(c net.Conn) {
			// Echo all incoming data.
			io.Copy(c, c)
			// Shut down the connection.
			c.Close()
		}(conn)
	}
}
</pre>   <h3 id="FileListener">func FileListener<a href="https://golang.org/src/net/file.go?s=1074:1128#L23" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func FileListener(f *os.File) (ln Listener, err error)</pre> <p> FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln. </p> <h3 id="Listen">func Listen<a href="https://golang.org/src/net/dial.go?s=15947:15995#L540" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Listen(net, laddr string) (Listener, error)</pre> <p> Listen announces on the local network address laddr. The network net must be a stream-oriented network: "tcp", "tcp4", "tcp6", "unix" or "unixpacket". For TCP and UDP, the syntax of laddr is "host:port", like "127.0.0.1:8080". If host is omitted, as in ":8080", Listen listens on all available interfaces instead of just the interface with the given host address. See Dial for more details about address syntax. </p> <p> Listening on a hostname is not recommended because this creates a socket for at most one of its IP addresses. </p> <h2 id="MX">type MX<a href="https://golang.org/src/net/dnsclient.go?s=6666:6710#L239" class="source" target="_blank">Source</a>  </h2> <p> An MX represents a single DNS MX record. </p> <pre data-language="go">type MX struct {
        Host string
        Pref uint16
}</pre> <h2 id="NS">type NS<a href="https://golang.org/src/net/dnsclient.go?s=7201:7232#L261" class="source" target="_blank">Source</a>  </h2> <p> An NS represents a single DNS NS record. </p> <pre data-language="go">type NS struct {
        Host string
}</pre> <h2 id="OpError">type OpError<a href="https://golang.org/src/net/net.go?s=13796:14570#L409" class="source" target="_blank">Source</a>  </h2> <p> OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error. </p> <pre data-language="go">type OpError struct {
        // Op is the operation which caused the error, such as
        // "read" or "write".
        Op string

        // Net is the network type on which this error occurred,
        // such as "tcp" or "udp6".
        Net string

        // For operations involving a remote network connection, like
        // Dial, Read, or Write, Source is the corresponding local
        // network address.
        Source Addr

        // Addr is the network address for which this error occurred.
        // For local operations, like Listen or SetDeadline, Addr is
        // the address of the local endpoint being manipulated.
        // For operations involving a remote network connection, like
        // Dial, Read, or Write, Addr is the remote address of that
        // connection.
        Addr Addr

        // Err is the error that occurred during the operation.
        Err error
}</pre> <h3 id="OpError.Error">func (*OpError) Error<a href="https://golang.org/src/net/net.go?s=14572:14604#L435" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *OpError) Error() string</pre> <h3 id="OpError.Temporary">func (*OpError) Temporary<a href="https://golang.org/src/net/net.go?s=15506:15540#L486" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *OpError) Temporary() bool</pre> <h3 id="OpError.Timeout">func (*OpError) Timeout<a href="https://golang.org/src/net/net.go?s=15265:15297#L473" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *OpError) Timeout() bool</pre> <h2 id="PacketConn">type PacketConn<a href="https://golang.org/src/net/net.go?s=9840:12038#L297" class="source" target="_blank">Source</a>  </h2> <p> PacketConn is a generic packet-oriented network connection. </p> <p> Multiple goroutines may invoke methods on a PacketConn simultaneously. </p> <pre data-language="go">type PacketConn interface {
        // ReadFrom reads a packet from the connection,
        // copying the payload into b. It returns the number of
        // bytes copied into b and the return address that
        // was on the packet.
        // ReadFrom can be made to time out and return
        // an Error with Timeout() == true after a fixed time limit;
        // see SetDeadline and SetReadDeadline.
        ReadFrom(b []byte) (n int, addr Addr, err error)

        // WriteTo writes a packet with payload b to addr.
        // WriteTo can be made to time out and return
        // an Error with Timeout() == true after a fixed time limit;
        // see SetDeadline and SetWriteDeadline.
        // On packet-oriented connections, write timeouts are rare.
        WriteTo(b []byte, addr Addr) (n int, err error)

        // Close closes the connection.
        // Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.
        Close() error

        // LocalAddr returns the local network address.
        LocalAddr() Addr

        // SetDeadline sets the read and write deadlines associated
        // with the connection. It is equivalent to calling both
        // SetReadDeadline and SetWriteDeadline.
        //
        // A deadline is an absolute time after which I/O operations
        // fail with a timeout (see type Error) instead of
        // blocking. The deadline applies to all future and pending
        // I/O, not just the immediately following call to ReadFrom or
        // WriteTo. After a deadline has been exceeded, the connection
        // can be refreshed by setting a deadline in the future.
        //
        // An idle timeout can be implemented by repeatedly extending
        // the deadline after successful ReadFrom or WriteTo calls.
        //
        // A zero value for t means I/O operations will not time out.
        SetDeadline(t time.Time) error

        // SetReadDeadline sets the deadline for future ReadFrom calls
        // and any currently-blocked ReadFrom call.
        // A zero value for t means ReadFrom will not time out.
        SetReadDeadline(t time.Time) error

        // SetWriteDeadline sets the deadline for future WriteTo calls
        // and any currently-blocked WriteTo call.
        // Even if write times out, it may return n &gt; 0, indicating that
        // some of the data was successfully written.
        // A zero value for t means WriteTo will not time out.
        SetWriteDeadline(t time.Time) error
}</pre> <h3 id="FilePacketConn">func FilePacketConn<a href="https://golang.org/src/net/file.go?s=1515:1572#L35" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func FilePacketConn(f *os.File) (c PacketConn, err error)</pre> <p> FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <h3 id="ListenPacket">func ListenPacket<a href="https://golang.org/src/net/dial.go?s=17158:17214#L570" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ListenPacket(net, laddr string) (PacketConn, error)</pre> <p> ListenPacket announces on the local network address laddr. The network net must be a packet-oriented network: "udp", "udp4", "udp6", "ip", "ip4", "ip6" or "unixgram". For TCP and UDP, the syntax of laddr is "host:port", like "127.0.0.1:8080". If host is omitted, as in ":8080", ListenPacket listens on all available interfaces instead of just the interface with the given host address. See Dial for the syntax of laddr. </p> <p> Listening on a hostname is not recommended because this creates a socket for at most one of its IP addresses. </p> <h2 id="ParseError">type ParseError<a href="https://golang.org/src/net/net.go?s=15985:16169#L502" class="source" target="_blank">Source</a>  </h2> <p> A ParseError is the error type of literal network address parsers. </p> <pre data-language="go">type ParseError struct {
        // Type is the type of string that was expected, such as
        // "IP address", "CIDR address".
        Type string

        // Text is the malformed text string.
        Text string
}</pre> <h3 id="ParseError.Error">func (*ParseError) Error<a href="https://golang.org/src/net/net.go?s=16171:16206#L511" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e *ParseError) Error() string</pre> <h2 id="Resolver">type Resolver<a href="https://golang.org/src/net/lookup.go?s=2475:2810#L84" class="source" target="_blank">Source</a>  </h2> <p> A Resolver looks up names and numbers. </p> <p> A nil *Resolver is equivalent to a zero Resolver. </p> <pre data-language="go">type Resolver struct {
        // PreferGo controls whether Go's built-in DNS resolver is preferred
        // on platforms where it's available. It is equivalent to setting
        // GODEBUG=netdns=go, but scoped to just this resolver.
        PreferGo bool
}</pre> <h3 id="Resolver.LookupAddr">func (*Resolver) LookupAddr<a href="https://golang.org/src/net/lookup.go?s=11139:11230#L321" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupAddr(ctx context.Context, addr string) (names []string, err error)</pre> <p> LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. </p> <h3 id="Resolver.LookupCNAME">func (*Resolver) LookupCNAME<a href="https://golang.org/src/net/lookup.go?s=8077:8167#L250" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string, err error)</pre> <p> LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. </p> <p> A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS "CNAME" records, as long as host resolves to address records. </p> <h3 id="Resolver.LookupHost">func (*Resolver) LookupHost<a href="https://golang.org/src/net/lookup.go?s=3161:3252#L102" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)</pre> <p> LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. </p> <h3 id="Resolver.LookupIPAddr">func (*Resolver) LookupIPAddr<a href="https://golang.org/src/net/lookup.go?s=4049:4132#L130" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)</pre> <p> LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. </p> <h3 id="Resolver.LookupMX">func (*Resolver) LookupMX<a href="https://golang.org/src/net/lookup.go?s=9812:9888#L286" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)</pre> <p> LookupMX returns the DNS MX records for the given domain name sorted by preference. </p> <h3 id="Resolver.LookupNS">func (*Resolver) LookupNS<a href="https://golang.org/src/net/lookup.go?s=10164:10240#L296" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)</pre> <p> LookupNS returns the DNS NS records for the given domain name. </p> <h3 id="Resolver.LookupPort">func (*Resolver) LookupPort<a href="https://golang.org/src/net/lookup.go?s=6671:6768#L212" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)</pre> <p> LookupPort looks up the port for the given network and service. </p> <h3 id="Resolver.LookupSRV">func (*Resolver) LookupSRV<a href="https://golang.org/src/net/lookup.go?s=9359:9477#L276" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs []*SRV, err error)</pre> <p> LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is "tcp" or "udp". The returned records are sorted by priority and randomized by weight within a priority. </p> <p> LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. </p> <h3 id="Resolver.LookupTXT">func (*Resolver) LookupTXT<a href="https://golang.org/src/net/lookup.go?s=10525:10605#L306" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)</pre> <p> LookupTXT returns the DNS TXT records for the given domain name. </p> <h2 id="SRV">type SRV<a href="https://golang.org/src/net/dnsclient.go?s=5385:5472#L185" class="source" target="_blank">Source</a>  </h2> <p> An SRV represents a single DNS SRV record. </p> <pre data-language="go">type SRV struct {
        Target   string
        Port     uint16
        Priority uint16
        Weight   uint16
}</pre> <h2 id="TCPAddr">type TCPAddr<a href="https://golang.org/src/net/tcpsock.go?s=363:449#L9" class="source" target="_blank">Source</a>  </h2> <p> TCPAddr represents the address of a TCP end point. </p> <pre data-language="go">type TCPAddr struct {
        IP   IP
        Port int
        Zone string // IPv6 scoped addressing zone
}</pre> <h3 id="ResolveTCPAddr">func ResolveTCPAddr<a href="https://golang.org/src/net/tcpsock.go?s=1431:1486#L52" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</pre> <p> ResolveTCPAddr parses addr as a TCP address of the form "host:port" or "[ipv6-host%zone]:port" and resolves a pair of domain name and port name on the network net, which must be "tcp", "tcp4" or "tcp6". A literal address or host name for IPv6 must be enclosed in square brackets, as in "[::1]:80", "[ipv6-host]:http" or "[ipv6-host%zone]:80". </p> <p> Resolving a hostname is not recommended because this returns at most one of its IP addresses. </p> <h3 id="TCPAddr.Network">func (*TCPAddr) Network<a href="https://golang.org/src/net/tcpsock.go?s=505:539#L16" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *TCPAddr) Network() string</pre> <p> Network returns the address's network name, "tcp". </p> <h3 id="TCPAddr.String">func (*TCPAddr) String<a href="https://golang.org/src/net/tcpsock.go?s=558:591#L18" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *TCPAddr) String() string</pre> <h2 id="TCPConn">type TCPConn<a href="https://golang.org/src/net/tcpsock.go?s=1912:1941#L69" class="source" target="_blank">Source</a>  </h2> <p> TCPConn is an implementation of the Conn interface for TCP network connections. </p> <pre data-language="go">type TCPConn struct {
        // contains filtered or unexported fields
}</pre> <h3 id="DialTCP">func DialTCP<a href="https://golang.org/src/net/tcpsock.go?s=5151:5216#L177" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</pre> <p> DialTCP connects to the remote address raddr on the network net, which must be "tcp", "tcp4", or "tcp6". If laddr is not nil, it is used as the local address for the connection. </p> <h3 id="TCPConn.Close">func (*TCPConn) Close<a href="https://golang.org/src/net/net.go?s=6824:6852#L191" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id="TCPConn.CloseRead">func (*TCPConn) CloseRead<a href="https://golang.org/src/net/tcpsock.go?s=2381:2416#L87" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) CloseRead() error</pre> <p> CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close. </p> <h3 id="TCPConn.CloseWrite">func (*TCPConn) CloseWrite<a href="https://golang.org/src/net/tcpsock.go?s=2718:2754#L99" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) CloseWrite() error</pre> <p> CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close. </p> <h3 id="TCPConn.File">func (*TCPConn) File<a href="https://golang.org/src/net/net.go?s=9508:9553#L286" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id="TCPConn.LocalAddr">func (*TCPConn) LocalAddr<a href="https://golang.org/src/net/net.go?s=7181:7212#L205" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id="TCPConn.Read">func (*TCPConn) Read<a href="https://golang.org/src/net/net.go?s=6243:6285#L167" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id="TCPConn.ReadFrom">func (*TCPConn) ReadFrom<a href="https://golang.org/src/net/tcpsock.go?s=2001:2055#L74" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</pre> <p> ReadFrom implements the io.ReaderFrom ReadFrom method. </p> <h3 id="TCPConn.RemoteAddr">func (*TCPConn) RemoteAddr<a href="https://golang.org/src/net/net.go?s=7406:7438#L215" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id="TCPConn.SetDeadline">func (*TCPConn) SetDeadline<a href="https://golang.org/src/net/net.go?s=7548:7593#L223" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id="TCPConn.SetKeepAlive">func (*TCPConn) SetKeepAlive<a href="https://golang.org/src/net/tcpsock.go?s=3785:3837#L133" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetKeepAlive(keepalive bool) error</pre> <p> SetKeepAlive sets whether the operating system should send keepalive messages on the connection. </p> <h3 id="TCPConn.SetKeepAlivePeriod">func (*TCPConn) SetKeepAlivePeriod<a href="https://golang.org/src/net/tcpsock.go?s=4101:4160#L144" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</pre> <p> SetKeepAlivePeriod sets period between keep alives. </p> <h3 id="TCPConn.SetLinger">func (*TCPConn) SetLinger<a href="https://golang.org/src/net/tcpsock.go?s=3440:3482#L121" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetLinger(sec int) error</pre> <p> SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged. </p> <p> If sec &lt; 0 (the default), the operating system finishes sending the data in the background. </p> <p> If sec == 0, the operating system discards any unsent or unacknowledged data. </p> <p> If sec &gt; 0, the data is sent in the background as with sec &lt; 0. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded. </p> <h3 id="TCPConn.SetNoDelay">func (*TCPConn) SetNoDelay<a href="https://golang.org/src/net/tcpsock.go?s=4610:4658#L158" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetNoDelay(noDelay bool) error</pre> <p> SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write. </p> <h3 id="TCPConn.SetReadBuffer">func (*TCPConn) SetReadBuffer<a href="https://golang.org/src/net/net.go?s=8512:8557#L257" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id="TCPConn.SetReadDeadline">func (*TCPConn) SetReadDeadline<a href="https://golang.org/src/net/net.go?s=7848:7897#L234" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id="TCPConn.SetWriteBuffer">func (*TCPConn) SetWriteBuffer<a href="https://golang.org/src/net/net.go?s=8865:8911#L269" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id="TCPConn.SetWriteDeadline">func (*TCPConn) SetWriteDeadline<a href="https://golang.org/src/net/net.go?s=8158:8208#L245" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id="TCPConn.Write">func (*TCPConn) Write<a href="https://golang.org/src/net/net.go?s=6546:6589#L179" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *TCPConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h2 id="TCPListener">type TCPListener<a href="https://golang.org/src/net/tcpsock.go?s=5848:5886#L195" class="source" target="_blank">Source</a>  </h2> <p> TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP. </p> <pre data-language="go">type TCPListener struct {
        // contains filtered or unexported fields
}</pre> <h3 id="ListenTCP">func ListenTCP<a href="https://golang.org/src/net/tcpsock.go?s=8364:8428#L276" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</pre> <p> ListenTCP announces on the TCP address laddr and returns a TCP listener. Net must be "tcp", "tcp4", or "tcp6". If laddr has a port of 0, ListenTCP will choose an available port. The caller can use the Addr method of TCPListener to retrieve the chosen address. </p> <h3 id="TCPListener.Accept">func (*TCPListener) Accept<a href="https://golang.org/src/net/tcpsock.go?s=6344:6388#L214" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *TCPListener) Accept() (Conn, error)</pre> <p> Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn. </p> <h3 id="TCPListener.AcceptTCP">func (*TCPListener) AcceptTCP<a href="https://golang.org/src/net/tcpsock.go?s=5967:6018#L201" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</pre> <p> AcceptTCP accepts the next incoming call and returns the new connection. </p> <h3 id="TCPListener.Addr">func (*TCPListener) Addr<a href="https://golang.org/src/net/tcpsock.go?s=7045:7078#L240" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *TCPListener) Addr() Addr</pre> <p> Addr returns the listener's network address, a *TCPAddr. The Addr returned is shared by all invocations of Addr, so do not modify it. </p> <h3 id="TCPListener.Close">func (*TCPListener) Close<a href="https://golang.org/src/net/tcpsock.go?s=6683:6718#L227" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *TCPListener) Close() error</pre> <p> Close stops listening on the TCP address. Already Accepted connections are not closed. </p> <h3 id="TCPListener.File">func (*TCPListener) File<a href="https://golang.org/src/net/tcpsock.go?s=7849:7901#L261" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *TCPListener) File() (f *os.File, err error)</pre> <p> File returns a copy of the underlying os.File, set to blocking mode. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id="TCPListener.SetDeadline">func (*TCPListener) SetDeadline<a href="https://golang.org/src/net/tcpsock.go?s=7209:7261#L244" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *TCPListener) SetDeadline(t time.Time) error</pre> <p> SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. </p> <h2 id="UDPAddr">type UDPAddr<a href="https://golang.org/src/net/udpsock.go?s=538:624#L12" class="source" target="_blank">Source</a>  </h2> <p> UDPAddr represents the address of a UDP end point. </p> <pre data-language="go">type UDPAddr struct {
        IP   IP
        Port int
        Zone string // IPv6 scoped addressing zone
}</pre> <h3 id="ResolveUDPAddr">func ResolveUDPAddr<a href="https://golang.org/src/net/udpsock.go?s=1606:1661#L55" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</pre> <p> ResolveUDPAddr parses addr as a UDP address of the form "host:port" or "[ipv6-host%zone]:port" and resolves a pair of domain name and port name on the network net, which must be "udp", "udp4" or "udp6". A literal address or host name for IPv6 must be enclosed in square brackets, as in "[::1]:80", "[ipv6-host]:http" or "[ipv6-host%zone]:80". </p> <p> Resolving a hostname is not recommended because this returns at most one of its IP addresses. </p> <h3 id="UDPAddr.Network">func (*UDPAddr) Network<a href="https://golang.org/src/net/udpsock.go?s=680:714#L19" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *UDPAddr) Network() string</pre> <p> Network returns the address's network name, "udp". </p> <h3 id="UDPAddr.String">func (*UDPAddr) String<a href="https://golang.org/src/net/udpsock.go?s=733:766#L21" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *UDPAddr) String() string</pre> <h2 id="UDPConn">type UDPConn<a href="https://golang.org/src/net/udpsock.go?s=2104:2133#L72" class="source" target="_blank">Source</a>  </h2> <p> UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections. </p> <pre data-language="go">type UDPConn struct {
        // contains filtered or unexported fields
}</pre> <h3 id="DialUDP">func DialUDP<a href="https://golang.org/src/net/udpsock.go?s=5612:5677#L180" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</pre> <p> DialUDP connects to the remote address raddr on the network net, which must be "udp", "udp4", or "udp6". If laddr is not nil, it is used as the local address for the connection. </p> <h3 id="ListenMulticastUDP">func ListenMulticastUDP<a href="https://golang.org/src/net/udpsock.go?s=7631:7720#L230" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</pre> <p> ListenMulticastUDP listens for incoming multicast UDP packets addressed to the group address gaddr on the interface ifi. Network must be "udp", "udp4" or "udp6". ListenMulticastUDP uses the system-assigned multicast interface when ifi is nil, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. </p> <p> ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses. </p> <h3 id="ListenUDP">func ListenUDP<a href="https://golang.org/src/net/udpsock.go?s=6597:6657#L203" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</pre> <p> ListenUDP listens for incoming UDP packets addressed to the local address laddr. Net must be "udp", "udp4", or "udp6". If laddr has a port of 0, ListenUDP will choose an available port. The LocalAddr method of the returned UDPConn can be used to discover the port. The returned connection's ReadFrom and WriteTo methods can be used to receive and send UDP packets with per-packet addressing. </p> <h3 id="UDPConn.Close">func (*UDPConn) Close<a href="https://golang.org/src/net/net.go?s=6824:6852#L191" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id="UDPConn.File">func (*UDPConn) File<a href="https://golang.org/src/net/net.go?s=9508:9553#L286" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id="UDPConn.LocalAddr">func (*UDPConn) LocalAddr<a href="https://golang.org/src/net/net.go?s=7181:7212#L205" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id="UDPConn.Read">func (*UDPConn) Read<a href="https://golang.org/src/net/net.go?s=6243:6285#L167" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id="UDPConn.ReadFrom">func (*UDPConn) ReadFrom<a href="https://golang.org/src/net/udpsock.go?s=2793:2848#L95" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p> ReadFrom implements the PacketConn ReadFrom method. </p> <h3 id="UDPConn.ReadFromUDP">func (*UDPConn) ReadFromUDP<a href="https://golang.org/src/net/udpsock.go?s=2457:2519#L83" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)</pre> <p> ReadFromUDP reads a UDP packet from c, copying the payload into b. It returns the number of bytes copied into b and the return address that was on the packet. </p> <p> ReadFromUDP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id="UDPConn.ReadMsgUDP">func (*UDPConn) ReadMsgUDP<a href="https://golang.org/src/net/udpsock.go?s=3390:3480#L114" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</pre> <p> ReadMsgUDP reads a packet from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet and the source address of the packet. </p> <h3 id="UDPConn.RemoteAddr">func (*UDPConn) RemoteAddr<a href="https://golang.org/src/net/net.go?s=7406:7438#L215" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id="UDPConn.SetDeadline">func (*UDPConn) SetDeadline<a href="https://golang.org/src/net/net.go?s=7548:7593#L223" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id="UDPConn.SetReadBuffer">func (*UDPConn) SetReadBuffer<a href="https://golang.org/src/net/net.go?s=8512:8557#L257" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id="UDPConn.SetReadDeadline">func (*UDPConn) SetReadDeadline<a href="https://golang.org/src/net/net.go?s=7848:7897#L234" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id="UDPConn.SetWriteBuffer">func (*UDPConn) SetWriteBuffer<a href="https://golang.org/src/net/net.go?s=8865:8911#L269" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id="UDPConn.SetWriteDeadline">func (*UDPConn) SetWriteDeadline<a href="https://golang.org/src/net/net.go?s=8158:8208#L245" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id="UDPConn.Write">func (*UDPConn) Write<a href="https://golang.org/src/net/net.go?s=6546:6589#L179" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h3 id="UDPConn.WriteMsgUDP">func (*UDPConn) WriteMsgUDP<a href="https://golang.org/src/net/udpsock.go?s=5055:5139#L164" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</pre> <p> WriteMsgUDP writes a packet to addr via c if c isn't connected, or to c's remote destination address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written. </p> <h3 id="UDPConn.WriteTo">func (*UDPConn) WriteTo<a href="https://golang.org/src/net/udpsock.go?s=4332:4391#L144" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p> WriteTo implements the PacketConn WriteTo method. </p> <h3 id="UDPConn.WriteToUDP">func (*UDPConn) WriteToUDP<a href="https://golang.org/src/net/udpsock.go?s=4002:4068#L132" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</pre> <p> WriteToUDP writes a UDP packet to addr via c, copying the payload from b. </p> <p> WriteToUDP can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. On packet-oriented connections, write timeouts are rare. </p> <h2 id="UnixAddr">type UnixAddr<a href="https://golang.org/src/net/unixsock.go?s=299:349#L6" class="source" target="_blank">Source</a>  </h2> <p> UnixAddr represents the address of a Unix domain socket end point. </p> <pre data-language="go">type UnixAddr struct {
        Name string
        Net  string
}</pre> <h3 id="ResolveUnixAddr">func ResolveUnixAddr<a href="https://golang.org/src/net/unixsock.go?s=881:938#L38" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</pre> <p> ResolveUnixAddr parses addr as a Unix domain socket address. The string net gives the network name, "unix", "unixgram" or "unixpacket". </p> <h3 id="UnixAddr.Network">func (*UnixAddr) Network<a href="https://golang.org/src/net/unixsock.go?s=437:472#L13" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *UnixAddr) Network() string</pre> <p> Network returns the address's network name, "unix", "unixgram" or "unixpacket". </p> <h3 id="UnixAddr.String">func (*UnixAddr) String<a href="https://golang.org/src/net/unixsock.go?s=492:526#L17" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (a *UnixAddr) String() string</pre> <h2 id="UnixConn">type UnixConn<a href="https://golang.org/src/net/unixsock.go?s=1194:1224#L49" class="source" target="_blank">Source</a>  </h2> <p> UnixConn is an implementation of the Conn interface for connections to Unix domain sockets. </p> <pre data-language="go">type UnixConn struct {
        // contains filtered or unexported fields
}</pre> <h3 id="DialUnix">func DialUnix<a href="https://golang.org/src/net/unixsock.go?s=5513:5581#L183" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</pre> <p> DialUnix connects to the remote address raddr on the network net, which must be "unix", "unixgram" or "unixpacket". If laddr is not nil, it is used as the local address for the connection. </p> <h3 id="ListenUnixgram">func ListenUnixgram<a href="https://golang.org/src/net/unixsock.go?s=9450:9517#L303" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ListenUnixgram(net string, laddr *UnixAddr) (*UnixConn, error)</pre> <p> ListenUnixgram listens for incoming Unix datagram packets addressed to the local address laddr. The network net must be "unixgram". The returned connection's ReadFrom and WriteTo methods can be used to receive and send packets with per-packet addressing. </p> <h3 id="UnixConn.Close">func (*UnixConn) Close<a href="https://golang.org/src/net/net.go?s=6824:6852#L191" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) Close() error</pre> <p> Close closes the connection. </p> <h3 id="UnixConn.CloseRead">func (*UnixConn) CloseRead<a href="https://golang.org/src/net/unixsock.go?s=1337:1373#L55" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) CloseRead() error</pre> <p> CloseRead shuts down the reading side of the Unix domain connection. Most callers should just use Close. </p> <h3 id="UnixConn.CloseWrite">func (*UnixConn) CloseWrite<a href="https://golang.org/src/net/unixsock.go?s=1683:1720#L67" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) CloseWrite() error</pre> <p> CloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use Close. </p> <h3 id="UnixConn.File">func (*UnixConn) File<a href="https://golang.org/src/net/net.go?s=9508:9553#L286" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) File() (f *os.File, err error)</pre> <p> File sets the underlying os.File to blocking mode and returns a copy. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id="UnixConn.LocalAddr">func (*UnixConn) LocalAddr<a href="https://golang.org/src/net/net.go?s=7181:7212#L205" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) LocalAddr() Addr</pre> <p> LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p> <h3 id="UnixConn.Read">func (*UnixConn) Read<a href="https://golang.org/src/net/net.go?s=6243:6285#L167" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) Read(b []byte) (int, error)</pre> <p> Read implements the Conn Read method. </p> <h3 id="UnixConn.ReadFrom">func (*UnixConn) ReadFrom<a href="https://golang.org/src/net/unixsock.go?s=2569:2625#L96" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p> ReadFrom implements the PacketConn ReadFrom method. </p> <h3 id="UnixConn.ReadFromUnix">func (*UnixConn) ReadFromUnix<a href="https://golang.org/src/net/unixsock.go?s=2230:2295#L84" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</pre> <p> ReadFromUnix reads a packet from c, copying the payload into b. It returns the number of bytes copied into b and the source address of the packet. </p> <p> ReadFromUnix can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id="UnixConn.ReadMsgUnix">func (*UnixConn) ReadMsgUnix<a href="https://golang.org/src/net/unixsock.go?s=3290:3383#L117" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</pre> <p> ReadMsgUnix reads a packet from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the packet, and the source address of the packet. </p> <p> Note that if len(b) == 0 and len(oob) &gt; 0, this function will still read (and discard) 1 byte from the connection. </p> <h3 id="UnixConn.RemoteAddr">func (*UnixConn) RemoteAddr<a href="https://golang.org/src/net/net.go?s=7406:7438#L215" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) RemoteAddr() Addr</pre> <p> RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p> <h3 id="UnixConn.SetDeadline">func (*UnixConn) SetDeadline<a href="https://golang.org/src/net/net.go?s=7548:7593#L223" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) SetDeadline(t time.Time) error</pre> <p> SetDeadline implements the Conn SetDeadline method. </p> <h3 id="UnixConn.SetReadBuffer">func (*UnixConn) SetReadBuffer<a href="https://golang.org/src/net/net.go?s=8512:8557#L257" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) SetReadBuffer(bytes int) error</pre> <p> SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p> <h3 id="UnixConn.SetReadDeadline">func (*UnixConn) SetReadDeadline<a href="https://golang.org/src/net/net.go?s=7848:7897#L234" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline implements the Conn SetReadDeadline method. </p> <h3 id="UnixConn.SetWriteBuffer">func (*UnixConn) SetWriteBuffer<a href="https://golang.org/src/net/net.go?s=8865:8911#L269" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) SetWriteBuffer(bytes int) error</pre> <p> SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p> <h3 id="UnixConn.SetWriteDeadline">func (*UnixConn) SetWriteDeadline<a href="https://golang.org/src/net/net.go?s=8158:8208#L245" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline implements the Conn SetWriteDeadline method. </p> <h3 id="UnixConn.Write">func (*UnixConn) Write<a href="https://golang.org/src/net/net.go?s=6546:6589#L179" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) Write(b []byte) (int, error)</pre> <p> Write implements the Conn Write method. </p> <h3 id="UnixConn.WriteMsgUnix">func (*UnixConn) WriteMsgUnix<a href="https://golang.org/src/net/unixsock.go?s=4939:5026#L167" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</pre> <p> WriteMsgUnix writes a packet to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. </p> <p> Note that if len(b) == 0 and len(oob) &gt; 0, this function will still write 1 byte to the connection. </p> <h3 id="UnixConn.WriteTo">func (*UnixConn) WriteTo<a href="https://golang.org/src/net/unixsock.go?s=4233:4293#L146" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p> WriteTo implements the PacketConn WriteTo method. </p> <h3 id="UnixConn.WriteToUnix">func (*UnixConn) WriteToUnix<a href="https://golang.org/src/net/unixsock.go?s=3900:3969#L134" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</pre> <p> WriteToUnix writes a packet to addr via c, copying the payload from b. </p> <p> WriteToUnix can be made to time out and return an error with Timeout() == true after a fixed time limit; see SetDeadline and SetWriteDeadline. On packet-oriented connections, write timeouts are rare. </p> <h2 id="UnixListener">type UnixListener<a href="https://golang.org/src/net/unixsock.go?s=6126:6231#L199" class="source" target="_blank">Source</a>  </h2> <p> UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets. </p> <pre data-language="go">type UnixListener struct {
        // contains filtered or unexported fields
}</pre> <h3 id="ListenUnix">func ListenUnix<a href="https://golang.org/src/net/unixsock.go?s=8629:8696#L283" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</pre> <p> ListenUnix announces on the Unix domain socket laddr and returns a Unix listener. The network net must be "unix" or "unixpacket". </p> <h3 id="UnixListener.Accept">func (*UnixListener) Accept<a href="https://golang.org/src/net/unixsock.go?s=6758:6803#L223" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *UnixListener) Accept() (Conn, error)</pre> <p> Accept implements the Accept method in the Listener interface. Returned connections will be of type *UnixConn. </p> <h3 id="UnixListener.AcceptUnix">func (*UnixListener) AcceptUnix<a href="https://golang.org/src/net/unixsock.go?s=6385:6439#L210" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</pre> <p> AcceptUnix accepts the next incoming call and returns the new connection. </p> <h3 id="UnixListener.Addr">func (*UnixListener) Addr<a href="https://golang.org/src/net/unixsock.go?s=7450:7484#L249" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *UnixListener) Addr() Addr</pre> <p> Addr returns the listener's network address. The Addr returned is shared by all invocations of Addr, so do not modify it. </p> <h3 id="UnixListener.Close">func (*UnixListener) Close<a href="https://golang.org/src/net/unixsock.go?s=7099:7135#L236" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *UnixListener) Close() error</pre> <p> Close stops listening on the Unix address. Already accepted connections are not closed. </p> <h3 id="UnixListener.File">func (*UnixListener) File<a href="https://golang.org/src/net/unixsock.go?s=8256:8309#L270" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *UnixListener) File() (f *os.File, err error)</pre> <p> File returns a copy of the underlying os.File, set to blocking mode. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. </p> <p> The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p> <h3 id="UnixListener.SetDeadline">func (*UnixListener) SetDeadline<a href="https://golang.org/src/net/unixsock.go?s=7615:7668#L253" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *UnixListener) SetDeadline(t time.Time) error</pre> <p> SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. </p> <h3 id="UnixListener.SetUnlinkOnClose">func (*UnixListener) SetUnlinkOnClose<a href="https://golang.org/src/net/unixsock_posix.go?s=5223:5275#L195" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (l *UnixListener) SetUnlinkOnClose(unlink bool)</pre> <p> SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed. </p> <p> The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file. </p> <h2 id="UnknownNetworkError">type UnknownNetworkError<a href="https://golang.org/src/net/net.go?s=16573:16604#L532" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type UnknownNetworkError string</pre> <h3 id="UnknownNetworkError.Error">func (UnknownNetworkError) Error<a href="https://golang.org/src/net/net.go?s=16606:16649#L534" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e UnknownNetworkError) Error() string</pre> <h3 id="UnknownNetworkError.Temporary">func (UnknownNetworkError) Temporary<a href="https://golang.org/src/net/net.go?s=16757:16802#L536" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e UnknownNetworkError) Temporary() bool</pre> <h3 id="UnknownNetworkError.Timeout">func (UnknownNetworkError) Timeout<a href="https://golang.org/src/net/net.go?s=16694:16737#L535" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e UnknownNetworkError) Timeout() bool</pre> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>
<a href="https://golang.org/src/net/file.go?s=186:301#L1" style="float: left;" target="_blank"></a> <p> On NaCl and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/interface.go?s=211:301#L3" style="float: left;" target="_blank"></a> <p> On NaCl, methods and functions related to Interface are not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/interface.go?s=303:434#L6" style="float: left;" target="_blank"></a> <p> On DragonFly BSD, NetBSD, OpenBSD, Plan 9 and Solaris, the MulticastAddrs method of Interface is not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/iprawsock.go?s=207:773#L2" style="float: left;" target="_blank"></a> <p> On every POSIX platform, reads from the "ip4" network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. This can occur even in cases where Read or ReadMsgIP could return a complete packet. For this reason, it is recommended that you do not use these methods if it is important to receive a full packet. </p> <p> The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead. </p> </li> <li>
<a href="https://golang.org/src/net/iprawsock.go?s=775:889#L14" style="float: left;" target="_blank"></a> <p> On NaCl, Plan 9 and Windows, the ReadMsgIP and WriteMsgIP methods of IPConn are not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/iprawsock.go?s=891:966#L17" style="float: left;" target="_blank"></a> <p> On Windows, the File method of IPConn is not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/ipsock.go?s=233:577#L3" style="float: left;" target="_blank"></a> <p> On DragonFly BSD and OpenBSD, listening on the "tcp" and "udp" networks does not listen for both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket - two separate sockets are required if both address families are to be supported. See inet6(4) for details. </p> </li> <li>
<a href="https://golang.org/src/net/tcpsock.go?s=227:307#L5" style="float: left;" target="_blank"></a> <p> On Windows, the File method of TCPListener is not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/udpsock.go?s=207:324#L2" style="float: left;" target="_blank"></a> <p> On NaCl, Plan 9 and Windows, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/udpsock.go?s=326:402#L5" style="float: left;" target="_blank"></a> <p> On Windows, the File method of UDPConn is not implemented. </p> </li> <li>
<a href="https://golang.org/src/net/udpsock.go?s=404:482#L8" style="float: left;" target="_blank"></a> <p> On NaCl, the ListenMulticastUDP function is not implemented. </p> </li> </ul> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="http/index" target="_blank">http</a> </td> <td class="pkg-synopsis"> Package http provides HTTP client and server implementations. </td> </tr> <tr> <td class="pkg-name"> <a href="http/cgi/index" target="_blank">cgi</a> </td> <td class="pkg-synopsis"> Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875. </td> </tr> <tr> <td class="pkg-name"> <a href="http/cookiejar/index" target="_blank">cookiejar</a> </td> <td class="pkg-synopsis"> Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar. </td> </tr> <tr> <td class="pkg-name"> <a href="http/fcgi/index" target="_blank">fcgi</a> </td> <td class="pkg-synopsis"> Package fcgi implements the FastCGI protocol. </td> </tr> <tr> <td class="pkg-name"> <a href="http/httptest/index" target="_blank">httptest</a> </td> <td class="pkg-synopsis"> Package httptest provides utilities for HTTP testing. </td> </tr> <tr> <td class="pkg-name"> <a href="http/httptrace/index" target="_blank">httptrace</a> </td> <td class="pkg-synopsis"> Package httptrace provides mechanisms to trace the events within HTTP client requests. </td> </tr> <tr> <td class="pkg-name"> <a href="http/httputil/index" target="_blank">httputil</a> </td> <td class="pkg-synopsis"> Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package. </td> </tr> <tr> <td class="pkg-name"> <a href="http/pprof/index" target="_blank">pprof</a> </td> <td class="pkg-synopsis"> Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool. </td> </tr> <tr> <td class="pkg-name"> <a href="mail/">mail</a> </td> <td class="pkg-synopsis"> Package mail implements parsing of mail messages. </td> </tr> <tr> <td class="pkg-name"> <a href="rpc/">rpc</a> </td> <td class="pkg-synopsis"> Package rpc provides access to the exported methods of an object across a network or other I/O connection. </td> </tr> <tr> <td class="pkg-name"> <a href="rpc/jsonrpc/">jsonrpc</a> </td> <td class="pkg-synopsis"> Package jsonrpc implements a JSON-RPC ClientCodec and ServerCodec for the rpc package. </td> </tr> <tr> <td class="pkg-name"> <a href="smtp/">smtp</a> </td> <td class="pkg-synopsis"> Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. </td> </tr> <tr> <td class="pkg-name"> <a href="textproto/">textproto</a> </td> <td class="pkg-synopsis"> Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP. </td> </tr> <tr> <td class="pkg-name"> <a href="url/">url</a> </td> <td class="pkg-synopsis"> Package url parses URLs and implements query escaping. </td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
     Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/net/" class="_attribution-link" target="_blank">https://golang.org/pkg/net/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
