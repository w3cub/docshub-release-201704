
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Archive&#47;zip - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package zip provides support for reading and writing ZIP archives. ">
  <meta name="keywords" content="package, zip, archive, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/archive/zip/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				
<h1>Package zip</h1>     <ul id="short-nav">
<li><code>import "archive/zip"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2>Overview </h2> <p> Package zip provides support for reading and writing ZIP archives. </p> <p> See: <a href="https://www.pkware.com/documents/casestudies/APPNOTE.TXT" target="_blank">https://www.pkware.com/documents/casestudies/APPNOTE.TXT</a> </p> <p> This package does not support disk spanning. </p> <p> A note about ZIP64: </p> <p> To be backwards compatible the FileHeader has both 32 and 64 bit Size fields. The 64 bit fields will always contain the correct value and for normal archives both fields will be the same. For files requiring the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit fields must be used instead. </p>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#RegisterCompressor">func RegisterCompressor(method uint16, comp Compressor)</a></li>
<li><a href="#RegisterDecompressor">func RegisterDecompressor(method uint16, dcomp Decompressor)</a></li>
<li><a href="#Compressor">type Compressor</a></li>
<li><a href="#Decompressor">type Decompressor</a></li>
<li><a href="#File">type File</a></li>
<li> <a href="#File.DataOffset">func (f *File) DataOffset() (offset int64, err error)</a>
</li>
<li> <a href="#File.Open">func (f *File) Open() (io.ReadCloser, error)</a>
</li>
<li><a href="#FileHeader">type FileHeader</a></li>
<li> <a href="#FileInfoHeader">func FileInfoHeader(fi os.FileInfo) (*FileHeader, error)</a>
</li>
<li> <a href="#FileHeader.FileInfo">func (h *FileHeader) FileInfo() os.FileInfo</a>
</li>
<li> <a href="#FileHeader.ModTime">func (h *FileHeader) ModTime() time.Time</a>
</li>
<li> <a href="#FileHeader.Mode">func (h *FileHeader) Mode() (mode os.FileMode)</a>
</li>
<li> <a href="#FileHeader.SetModTime">func (h *FileHeader) SetModTime(t time.Time)</a>
</li>
<li> <a href="#FileHeader.SetMode">func (h *FileHeader) SetMode(mode os.FileMode)</a>
</li>
<li><a href="#ReadCloser">type ReadCloser</a></li>
<li> <a href="#OpenReader">func OpenReader(name string) (*ReadCloser, error)</a>
</li>
<li> <a href="#ReadCloser.Close">func (rc *ReadCloser) Close() error</a>
</li>
<li><a href="#Reader">type Reader</a></li>
<li> <a href="#NewReader">func NewReader(r io.ReaderAt, size int64) (*Reader, error)</a>
</li>
<li> <a href="#Reader.RegisterDecompressor">func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</a>
</li>
<li><a href="#Writer">type Writer</a></li>
<li> <a href="#NewWriter">func NewWriter(w io.Writer) *Writer</a>
</li>
<li> <a href="#Writer.Close">func (w *Writer) Close() error</a>
</li>
<li> <a href="#Writer.Create">func (w *Writer) Create(name string) (io.Writer, error)</a>
</li>
<li> <a href="#Writer.CreateHeader">func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</a>
</li>
<li> <a href="#Writer.Flush">func (w *Writer) Flush() error</a>
</li>
<li> <a href="#Writer.RegisterCompressor">func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</a>
</li>
<li> <a href="#Writer.SetOffset">func (w *Writer) SetOffset(n int64)</a>
</li>
</ul> <div id="pkg-examples"> <h4>Examples</h4> <dl> <dd><a class="exampleLink" href="#example_Reader">Reader</a></dd> <dd><a class="exampleLink" href="#example_Writer">Writer</a></dd> <dd><a class="exampleLink" href="#example_Writer_RegisterCompressor">Writer.RegisterCompressor</a></dd> </dl> </div> <h4>Package files</h4> <p>  <a href="https://golang.org/src/archive/zip/reader.go" target="_blank">reader.go</a> <a href="https://golang.org/src/archive/zip/register.go" target="_blank">register.go</a> <a href="https://golang.org/src/archive/zip/struct.go" target="_blank">struct.go</a> <a href="https://golang.org/src/archive/zip/writer.go" target="_blank">writer.go</a>  </p>     <h2 id="pkg-constants">Constants</h2> <p> Compression methods. </p> <pre data-language="go">const (
        Store   uint16 = 0
        Deflate uint16 = 8
)</pre> <h2 id="pkg-variables">Variables</h2> <pre data-language="go">var (
        ErrFormat    = errors.New("zip: not a valid zip file")
        ErrAlgorithm = errors.New("zip: unsupported compression algorithm")
        ErrChecksum  = errors.New("zip: checksum error")
)</pre> <h2 id="RegisterCompressor">func RegisterCompressor<a href="https://golang.org/src/archive/zip/register.go?s=3268:3323#L123" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func RegisterCompressor(method uint16, comp Compressor)</pre> <p> RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in. </p> <h2 id="RegisterDecompressor">func RegisterDecompressor<a href="https://golang.org/src/archive/zip/register.go?s=2921:2981#L111" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func RegisterDecompressor(method uint16, dcomp Decompressor)</pre> <p> RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in. </p> <h2 id="Compressor">type Compressor<a href="https://golang.org/src/archive/zip/register.go?s=545:602#L10" class="source" target="_blank">Source</a>  </h2> <p> A Compressor returns a new compressing writer, writing to w. The WriteCloser's Close method must be used to flush pending data to w. The Compressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned writer will be used only by one goroutine at a time. </p> <pre data-language="go">type Compressor func(w io.Writer) (io.WriteCloser, error)</pre> <h2 id="Decompressor">type Decompressor<a href="https://golang.org/src/archive/zip/register.go?s=921:970#L17" class="source" target="_blank">Source</a>  </h2> <p> A Decompressor returns a new decompressing reader, reading from r. The ReadCloser's Close method must be used to release associated resources. The Decompressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned reader will be used only by one goroutine at a time. </p> <pre data-language="go">type Decompressor func(r io.Reader) io.ReadCloser</pre> <h2 id="File">type File<a href="https://golang.org/src/archive/zip/reader.go?s=631:751#L26" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type File struct {
        FileHeader
        // contains filtered or unexported fields
}</pre> <h3 id="File.DataOffset">func (*File) DataOffset<a href="https://golang.org/src/archive/zip/reader.go?s=3638:3691#L136" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) DataOffset() (offset int64, err error)</pre> <p> DataOffset returns the offset of the file's possibly-compressed data, relative to the beginning of the zip file. </p> <p> Most callers should instead use Open, which transparently decompresses data and verifies checksums. </p> <h3 id="File.Open">func (*File) Open<a href="https://golang.org/src/archive/zip/reader.go?s=3924:3968#L146" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (f *File) Open() (io.ReadCloser, error)</pre> <p> Open returns a ReadCloser that provides access to the File's contents. Multiple files may be read concurrently. </p> <h2 id="FileHeader">type FileHeader<a href="https://golang.org/src/archive/zip/struct.go?s=2050:2805#L60" class="source" target="_blank">Source</a>  </h2> <p> FileHeader describes a file within a zip file. See the zip spec for details. </p> <pre data-language="go">type FileHeader struct {
        // Name is the name of the file.
        // It must be a relative path: it must not start with a drive
        // letter (e.g. C:) or leading slash, and only forward slashes
        // are allowed.
        Name string

        CreatorVersion     uint16
        ReaderVersion      uint16
        Flags              uint16
        Method             uint16
        ModifiedTime       uint16 // MS-DOS time
        ModifiedDate       uint16 // MS-DOS date
        CRC32              uint32
        CompressedSize     uint32 // Deprecated: Use CompressedSize64 instead.
        UncompressedSize   uint32 // Deprecated: Use UncompressedSize64 instead.
        CompressedSize64   uint64
        UncompressedSize64 uint64
        Extra              []byte
        ExternalAttrs      uint32 // Meaning depends on CreatorVersion
        Comment            string
}</pre> <h3 id="FileInfoHeader">func FileInfoHeader<a href="https://golang.org/src/archive/zip/struct.go?s=3826:3882#L110" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func FileInfoHeader(fi os.FileInfo) (*FileHeader, error)</pre> <p> FileInfoHeader creates a partially-populated FileHeader from an os.FileInfo. Because os.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. </p> <h3 id="FileHeader.FileInfo">func (*FileHeader) FileInfo<a href="https://golang.org/src/archive/zip/struct.go?s=2862:2905#L84" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (h *FileHeader) FileInfo() os.FileInfo</pre> <p> FileInfo returns an os.FileInfo for the FileHeader. </p> <h3 id="FileHeader.ModTime">func (*FileHeader) ModTime<a href="https://golang.org/src/archive/zip/struct.go?s=5515:5555#L169" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (h *FileHeader) ModTime() time.Time</pre> <p> ModTime returns the modification time in UTC. The resolution is 2s. </p> <h3 id="FileHeader.Mode">func (*FileHeader) Mode<a href="https://golang.org/src/archive/zip/struct.go?s=6274:6320#L199" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (h *FileHeader) Mode() (mode os.FileMode)</pre> <p> Mode returns the permission and mode bits for the FileHeader. </p> <h3 id="FileHeader.SetModTime">func (*FileHeader) SetModTime<a href="https://golang.org/src/archive/zip/struct.go?s=5728:5772#L175" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (h *FileHeader) SetModTime(t time.Time)</pre> <p> SetModTime sets the ModifiedTime and ModifiedDate fields to the given time in UTC. The resolution is 2s. </p> <h3 id="FileHeader.SetMode">func (*FileHeader) SetMode<a href="https://golang.org/src/archive/zip/struct.go?s=6695:6741#L213" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (h *FileHeader) SetMode(mode os.FileMode)</pre> <p> SetMode changes the permission and mode bits for the FileHeader. </p> <h2 id="ReadCloser">type ReadCloser<a href="https://golang.org/src/archive/zip/reader.go?s=583:629#L21" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type ReadCloser struct {
        Reader
        // contains filtered or unexported fields
}</pre> <h3 id="OpenReader">func OpenReader<a href="https://golang.org/src/archive/zip/reader.go?s=903:952#L39" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func OpenReader(name string) (*ReadCloser, error)</pre> <p> OpenReader will open the Zip file specified by name and return a ReadCloser. </p> <h3 id="ReadCloser.Close">func (*ReadCloser) Close<a href="https://golang.org/src/archive/zip/reader.go?s=3348:3383#L127" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (rc *ReadCloser) Close() error</pre> <p> Close closes the Zip file, rendering it unusable for I/O. </p> <h2 id="Reader">type Reader<a href="https://golang.org/src/archive/zip/reader.go?s=448:581#L14" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type Reader struct {
        File    []*File
        Comment string
        // contains filtered or unexported fields
}</pre>    <h4> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// Open a zip archive for reading.
    r, err := zip.OpenReader("testdata/readme.zip")
    if err != nil {
            log.Fatal(err)
    }
    defer r.Close()

    // Iterate through the files in the archive,
    // printing some of their contents.
    for _, f := range r.File {
            fmt.Printf("Contents of %s:\n", f.Name)
            rc, err := f.Open()
            if err != nil {
                    log.Fatal(err)
            }
            _, err = io.CopyN(os.Stdout, rc, 68)
            if err != nil {
                    log.Fatal(err)
            }
            rc.Close()
            fmt.Println()
    }
    </pre> <p>Output:</p> <pre class="output" data-language="go">Contents of README:
This is the source code repository for the Go programming language.
</pre>   <h3 id="NewReader">func NewReader<a href="https://golang.org/src/archive/zip/reader.go?s=1320:1378#L60" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewReader(r io.ReaderAt, size int64) (*Reader, error)</pre> <p> NewReader returns a new Reader reading from r, which is assumed to have the given size in bytes. </p> <h3 id="Reader.RegisterDecompressor">func (*Reader) RegisterDecompressor<a href="https://golang.org/src/archive/zip/reader.go?s=2930:3002#L111" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</pre> <p> RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level. </p> <h2 id="Writer">type Writer<a href="https://golang.org/src/archive/zip/writer.go?s=332:645#L9" class="source" target="_blank">Source</a>  </h2> <p> Writer implements a zip file writer. </p> <pre data-language="go">type Writer struct {
        // contains filtered or unexported fields
}</pre>    <h4> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
    // Create a buffer to write our archive to.
    buf := new(bytes.Buffer)

    // Create a new zip archive.
    w := zip.NewWriter(buf)

    // Add some files to the archive.
    var files = []struct {
            Name, Body string
    }{
            {"readme.txt", "This archive contains some text files."},
            {"gopher.txt", "Gopher names:\nGeorge\nGeoffrey\nGonzo"},
            {"todo.txt", "Get animal handling licence.\nWrite more examples."},
    }
    for _, file := range files {
            f, err := w.Create(file.Name)
            if err != nil {
                    log.Fatal(err)
            }
            _, err = f.Write([]byte(file.Body))
            if err != nil {
                    log.Fatal(err)
            }
    }

    // Make sure to check the error on Close.
    err := w.Close()
    if err != nil {
            log.Fatal(err)
    }
</pre>   <h3 id="NewWriter">func NewWriter<a href="https://golang.org/src/archive/zip/writer.go?s=758:793#L27" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new Writer writing a zip file to w. </p> <h3 id="Writer.Close">func (*Writer) Close<a href="https://golang.org/src/archive/zip/writer.go?s=1578:1608#L50" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (w *Writer) Close() error</pre> <p> Close finishes writing the zip file by writing the central directory. It does not (and cannot) close the underlying writer. </p> <h3 id="Writer.Create">func (*Writer) Create<a href="https://golang.org/src/archive/zip/writer.go?s=6091:6146#L186" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (w *Writer) Create(name string) (io.Writer, error)</pre> <p> Create adds a file to the zip file using the provided name. It returns a Writer to which the file contents should be written. The name must be a relative path: it must not start with a drive letter (e.g. C:) or leading slash, and only forward slashes are allowed. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close. </p> <h3 id="Writer.CreateHeader">func (*Writer) CreateHeader<a href="https://golang.org/src/archive/zip/writer.go?s=6613:6677#L201" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</pre> <p> CreateHeader adds a file to the zip file using the provided FileHeader for the file metadata. It returns a Writer to which the file contents should be written. </p> <p> The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close. The provided FileHeader fh must not be modified after a call to CreateHeader. </p> <h3 id="Writer.Flush">func (*Writer) Flush<a href="https://golang.org/src/archive/zip/writer.go?s=1373:1403#L44" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (w *Writer) Flush() error</pre> <p> Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient. </p> <h3 id="Writer.RegisterCompressor">func (*Writer) RegisterCompressor<a href="https://golang.org/src/archive/zip/writer.go?s=8544:8611#L275" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</pre> <p> RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"archive/zip"
	"bytes"
	"compress/flate"
	"io"
)

func main() {
	// Override the default Deflate compressor with a higher compression level.

	// Create a buffer to write our archive to.
	buf := new(bytes.Buffer)

	// Create a new zip archive.
	w := zip.NewWriter(buf)

	// Register a custom Deflate compressor.
	w.RegisterCompressor(zip.Deflate, func(out io.Writer) (io.WriteCloser, error) {
		return flate.NewWriter(out, flate.BestCompression)
	})

	// Proceed to add files to w.
}
</pre>   <h3 id="Writer.SetOffset">func (*Writer) SetOffset<a href="https://golang.org/src/archive/zip/writer.go?s=1101:1136#L35" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (w *Writer) SetOffset(n int64)</pre> <p> SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written. </p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/archive/zip/" class="_attribution-link" target="_blank">https://golang.org/pkg/archive/zip/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
