
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Regexp - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package regexp implements regular expression search. ">
  <meta name="keywords" content="package, regexp, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/regexp/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				
<h1>Package regexp</h1>     <ul id="short-nav">
<li><code>import "regexp"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2>Overview </h2> <p> Package regexp implements regular expression search. </p> <p> The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at <a href="https://golang.org/s/re2syntax" target="_blank">https://golang.org/s/re2syntax</a>, except for \C. For an overview of the syntax, run </p> <pre data-language="go">go doc regexp/syntax
</pre> <p> The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see </p> <pre data-language="go">http://swtch.com/~rsc/regexp/regexp1.html
</pre> <p> or any book about automata theory. </p> <p> All characters are UTF-8-encoded code points. </p> <p> There are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression: </p> <pre data-language="go">Find(All)?(String)?(Submatch)?(Index)?
</pre> <p> If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n; if n &gt;= 0, the function returns at most n matches/submatches. </p> <p> If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate. </p> <p> If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on. </p> <p> If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative, it means that subexpression did not match any string in the input. </p> <p> There is also a subset of the methods that can be applied to text read from a RuneReader: </p> <pre data-language="go">MatchReader, FindReaderIndex, FindReaderSubmatchIndex
</pre> <p> This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning. </p> <p> (There are a few other methods that do not match this pattern.) </p>      <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	// Compile the expression once, usually at init time.
	// Use raw strings to avoid having to quote the backslashes.
	var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)

	fmt.Println(validID.MatchString("adam[23]"))
	fmt.Println(validID.MatchString("eve[7]"))
	fmt.Println(validID.MatchString("Job[48]"))
	fmt.Println(validID.MatchString("snakey"))
}
</pre>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#Match">func Match(pattern string, b []byte) (matched bool, err error)</a></li>
<li><a href="#MatchReader">func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)</a></li>
<li><a href="#MatchString">func MatchString(pattern string, s string) (matched bool, err error)</a></li>
<li><a href="#QuoteMeta">func QuoteMeta(s string) string</a></li>
<li><a href="#Regexp">type Regexp</a></li>
<li> <a href="#Compile">func Compile(expr string) (*Regexp, error)</a>
</li>
<li> <a href="#CompilePOSIX">func CompilePOSIX(expr string) (*Regexp, error)</a>
</li>
<li> <a href="#MustCompile">func MustCompile(str string) *Regexp</a>
</li>
<li> <a href="#MustCompilePOSIX">func MustCompilePOSIX(str string) *Regexp</a>
</li>
<li> <a href="#Regexp.Copy">func (re *Regexp) Copy() *Regexp</a>
</li>
<li> <a href="#Regexp.Expand">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte</a>
</li>
<li> <a href="#Regexp.ExpandString">func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte</a>
</li>
<li> <a href="#Regexp.Find">func (re *Regexp) Find(b []byte) []byte</a>
</li>
<li> <a href="#Regexp.FindAll">func (re *Regexp) FindAll(b []byte, n int) [][]byte</a>
</li>
<li> <a href="#Regexp.FindAllIndex">func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</a>
</li>
<li> <a href="#Regexp.FindAllString">func (re *Regexp) FindAllString(s string, n int) []string</a>
</li>
<li> <a href="#Regexp.FindAllStringIndex">func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</a>
</li>
<li> <a href="#Regexp.FindAllStringSubmatch">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</a>
</li>
<li> <a href="#Regexp.FindAllStringSubmatchIndex">func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int</a>
</li>
<li> <a href="#Regexp.FindAllSubmatch">func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</a>
</li>
<li> <a href="#Regexp.FindAllSubmatchIndex">func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int</a>
</li>
<li> <a href="#Regexp.FindIndex">func (re *Regexp) FindIndex(b []byte) (loc []int)</a>
</li>
<li> <a href="#Regexp.FindReaderIndex">func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)</a>
</li>
<li> <a href="#Regexp.FindReaderSubmatchIndex">func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int</a>
</li>
<li> <a href="#Regexp.FindString">func (re *Regexp) FindString(s string) string</a>
</li>
<li> <a href="#Regexp.FindStringIndex">func (re *Regexp) FindStringIndex(s string) (loc []int)</a>
</li>
<li> <a href="#Regexp.FindStringSubmatch">func (re *Regexp) FindStringSubmatch(s string) []string</a>
</li>
<li> <a href="#Regexp.FindStringSubmatchIndex">func (re *Regexp) FindStringSubmatchIndex(s string) []int</a>
</li>
<li> <a href="#Regexp.FindSubmatch">func (re *Regexp) FindSubmatch(b []byte) [][]byte</a>
</li>
<li> <a href="#Regexp.FindSubmatchIndex">func (re *Regexp) FindSubmatchIndex(b []byte) []int</a>
</li>
<li> <a href="#Regexp.LiteralPrefix">func (re *Regexp) LiteralPrefix() (prefix string, complete bool)</a>
</li>
<li> <a href="#Regexp.Longest">func (re *Regexp) Longest()</a>
</li>
<li> <a href="#Regexp.Match">func (re *Regexp) Match(b []byte) bool</a>
</li>
<li> <a href="#Regexp.MatchReader">func (re *Regexp) MatchReader(r io.RuneReader) bool</a>
</li>
<li> <a href="#Regexp.MatchString">func (re *Regexp) MatchString(s string) bool</a>
</li>
<li> <a href="#Regexp.NumSubexp">func (re *Regexp) NumSubexp() int</a>
</li>
<li> <a href="#Regexp.ReplaceAll">func (re *Regexp) ReplaceAll(src, repl []byte) []byte</a>
</li>
<li> <a href="#Regexp.ReplaceAllFunc">func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</a>
</li>
<li> <a href="#Regexp.ReplaceAllLiteral">func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte</a>
</li>
<li> <a href="#Regexp.ReplaceAllLiteralString">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</a>
</li>
<li> <a href="#Regexp.ReplaceAllString">func (re *Regexp) ReplaceAllString(src, repl string) string</a>
</li>
<li> <a href="#Regexp.ReplaceAllStringFunc">func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</a>
</li>
<li> <a href="#Regexp.Split">func (re *Regexp) Split(s string, n int) []string</a>
</li>
<li> <a href="#Regexp.String">func (re *Regexp) String() string</a>
</li>
<li> <a href="#Regexp.SubexpNames">func (re *Regexp) SubexpNames() []string</a>
</li>
</ul> <div id="pkg-examples"> <h4>Examples</h4> <dl> <dd><a class="exampleLink" href="#example_">Package</a></dd> <dd><a class="exampleLink" href="#example_MatchString">MatchString</a></dd> <dd><a class="exampleLink" href="#example_Regexp_FindAllString">Regexp.FindAllString</a></dd> <dd><a class="exampleLink" href="#example_Regexp_FindAllStringSubmatch">Regexp.FindAllStringSubmatch</a></dd> <dd><a class="exampleLink" href="#example_Regexp_FindAllStringSubmatchIndex">Regexp.FindAllStringSubmatchIndex</a></dd> <dd><a class="exampleLink" href="#example_Regexp_FindString">Regexp.FindString</a></dd> <dd><a class="exampleLink" href="#example_Regexp_FindStringIndex">Regexp.FindStringIndex</a></dd> <dd><a class="exampleLink" href="#example_Regexp_FindStringSubmatch">Regexp.FindStringSubmatch</a></dd> <dd><a class="exampleLink" href="#example_Regexp_ReplaceAllLiteralString">Regexp.ReplaceAllLiteralString</a></dd> <dd><a class="exampleLink" href="#example_Regexp_ReplaceAllString">Regexp.ReplaceAllString</a></dd> <dd><a class="exampleLink" href="#example_Regexp_Split">Regexp.Split</a></dd> <dd><a class="exampleLink" href="#example_Regexp_SubexpNames">Regexp.SubexpNames</a></dd> </dl> </div> <h4>Package files</h4> <p>  <a href="https://golang.org/src/regexp/backtrack.go" target="_blank">backtrack.go</a> <a href="https://golang.org/src/regexp/exec.go" target="_blank">exec.go</a> <a href="https://golang.org/src/regexp/onepass.go" target="_blank">onepass.go</a> <a href="https://golang.org/src/regexp/regexp.go" target="_blank">regexp.go</a>  </p>     <h2 id="Match">func Match<a href="https://golang.org/src/regexp/regexp.go?s=13990:14052#L439" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Match(pattern string, b []byte) (matched bool, err error)</pre> <p> Match checks whether a textual regular expression matches a byte slice. More complicated queries need to use Compile and the full Regexp interface. </p> <h2 id="MatchReader">func MatchReader<a href="https://golang.org/src/regexp/regexp.go?s=13319:13394#L417" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)</pre> <p> MatchReader checks whether a textual regular expression matches the text read by the RuneReader. More complicated queries need to use Compile and the full Regexp interface. </p> <h2 id="MatchString">func MatchString<a href="https://golang.org/src/regexp/regexp.go?s=13659:13727#L428" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func MatchString(pattern string, s string) (matched bool, err error)</pre> <p> MatchString checks whether a textual regular expression matches a string. More complicated queries need to use Compile and the full Regexp interface. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	matched, err := regexp.MatchString("foo.*", "seafood")
	fmt.Println(matched, err)
	matched, err = regexp.MatchString("bar.*", "seafood")
	fmt.Println(matched, err)
	matched, err = regexp.MatchString("a(b", "seafood")
	fmt.Println(matched, err)
}
</pre>   <h2 id="QuoteMeta">func QuoteMeta<a href="https://golang.org/src/regexp/regexp.go?s=19023:19054#L592" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func QuoteMeta(s string) string</pre> <p> QuoteMeta returns a string that quotes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text. For example, QuoteMeta(`[foo]`) returns `\[foo\]`. </p> <h2 id="Regexp">type Regexp<a href="https://golang.org/src/regexp/regexp.go?s=3252:3394#L70" class="source" target="_blank">Source</a>  </h2> <p> Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines. </p> <pre data-language="go">type Regexp struct {
        // contains filtered or unexported fields
}</pre> <h3 id="Compile">func Compile<a href="https://golang.org/src/regexp/regexp.go?s=5090:5132#L121" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Compile(expr string) (*Regexp, error)</pre> <p> Compile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text. </p> <p> When matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX. </p> <h3 id="CompilePOSIX">func CompilePOSIX<a href="https://golang.org/src/regexp/regexp.go?s=6251:6298#L144" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func CompilePOSIX(expr string) (*Regexp, error)</pre> <p> CompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest. </p> <p> That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies. </p> <p> However, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See <a href="http://swtch.com/~rsc/regexp/regexp2.html#posix" target="_blank">http://swtch.com/~rsc/regexp/regexp2.html#posix</a> for details. </p> <h3 id="MustCompile">func MustCompile<a href="https://golang.org/src/regexp/regexp.go?s=8527:8563#L224" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func MustCompile(str string) *Regexp</pre> <p> MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. </p> <h3 id="MustCompilePOSIX">func MustCompilePOSIX<a href="https://golang.org/src/regexp/regexp.go?s=8888:8929#L235" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func MustCompilePOSIX(str string) *Regexp</pre> <p> MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. </p> <h3 id="Regexp.Copy">func (*Regexp) Copy<a href="https://golang.org/src/regexp/regexp.go?s=4340:4372#L103" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) Copy() *Regexp</pre> <p> Copy returns a new Regexp object copied from re. </p> <p> When using a Regexp in multiple goroutines, giving each goroutine its own copy helps to avoid lock contention. </p> <h3 id="Regexp.Expand">func (*Regexp) Expand<a href="https://golang.org/src/regexp/regexp.go?s=24478:24563#L782" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte</pre> <p> Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex. </p> <p> In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P&lt;name&gt;...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice. </p> <p> In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0. </p> <p> To insert a literal $ in the output, use $$ in the template. </p> <h3 id="Regexp.ExpandString">func (*Regexp) ExpandString<a href="https://golang.org/src/regexp/regexp.go?s=24802:24893#L789" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte</pre> <p> ExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation. </p> <h3 id="Regexp.Find">func (*Regexp) Find<a href="https://golang.org/src/regexp/regexp.go?s=21062:21101#L685" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) Find(b []byte) []byte</pre> <p> Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match. </p> <h3 id="Regexp.FindAll">func (*Regexp) FindAll<a href="https://golang.org/src/regexp/regexp.go?s=29352:29403#L946" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAll(b []byte, n int) [][]byte</pre> <p> FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindAllIndex">func (*Regexp) FindAllIndex<a href="https://golang.org/src/regexp/regexp.go?s=29858:29913#L964" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</pre> <p> FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindAllString">func (*Regexp) FindAllString<a href="https://golang.org/src/regexp/regexp.go?s=30359:30416#L982" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAllString(s string, n int) []string</pre> <p> FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("a.")
	fmt.Println(re.FindAllString("paranormal", -1))
	fmt.Println(re.FindAllString("paranormal", 2))
	fmt.Println(re.FindAllString("graal", -1))
	fmt.Println(re.FindAllString("none", -1))
}
</pre>   <h3 id="Regexp.FindAllStringIndex">func (*Regexp) FindAllStringIndex<a href="https://golang.org/src/regexp/regexp.go?s=30884:30945#L1000" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</pre> <p> FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindAllStringSubmatch">func (*Regexp) FindAllStringSubmatch<a href="https://golang.org/src/regexp/regexp.go?s=32575:32642#L1060" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</pre> <p> FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("a(x*)b")
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-", -1))
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-", -1))
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-axb-", -1))
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-ab-", -1))
}
</pre>   <h3 id="Regexp.FindAllStringSubmatchIndex">func (*Regexp) FindAllStringSubmatchIndex<a href="https://golang.org/src/regexp/regexp.go?s=33256:33325#L1085" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int</pre> <p> FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("a(x*)b")
	// Indices:
	//    01234567   012345678
	//    -ab-axb-   -axxb-ab-
	fmt.Println(re.FindAllStringSubmatchIndex("-ab-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-axxb-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-ab-axb-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-axxb-ab-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-foo-", -1))
}
</pre>   <h3 id="Regexp.FindAllSubmatch">func (*Regexp) FindAllSubmatch<a href="https://golang.org/src/regexp/regexp.go?s=31396:31457#L1018" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</pre> <p> FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindAllSubmatchIndex">func (*Regexp) FindAllSubmatchIndex<a href="https://golang.org/src/regexp/regexp.go?s=32055:32118#L1042" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int</pre> <p> FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindIndex">func (*Regexp) FindIndex<a href="https://golang.org/src/regexp/regexp.go?s=21448:21497#L698" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindIndex(b []byte) (loc []int)</pre> <p> FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match. </p> <h3 id="Regexp.FindReaderIndex">func (*Regexp) FindReaderIndex<a href="https://golang.org/src/regexp/regexp.go?s=22793:22855#L737" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)</pre> <p> FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match. </p> <h3 id="Regexp.FindReaderSubmatchIndex">func (*Regexp) FindReaderSubmatchIndex<a href="https://golang.org/src/regexp/regexp.go?s=28918:28982#L936" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int</pre> <p> FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindString">func (*Regexp) FindString<a href="https://golang.org/src/regexp/regexp.go?s=21943:21988#L711" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindString(s string) string</pre> <p> FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("fo.?")
	fmt.Printf("%q\n", re.FindString("seafood"))
	fmt.Printf("%q\n", re.FindString("meat"))
}
</pre>   <h3 id="Regexp.FindStringIndex">func (*Regexp) FindStringIndex<a href="https://golang.org/src/regexp/regexp.go?s=22341:22396#L724" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindStringIndex(s string) (loc []int)</pre> <p> FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("ab?")
	fmt.Println(re.FindStringIndex("tablett"))
	fmt.Println(re.FindStringIndex("foo") == nil)
}
</pre>   <h3 id="Regexp.FindStringSubmatch">func (*Regexp) FindStringSubmatch<a href="https://golang.org/src/regexp/regexp.go?s=27824:27879#L907" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindStringSubmatch(s string) []string</pre> <p> FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("a(x*)b(y|z)c")
	fmt.Printf("%q\n", re.FindStringSubmatch("-axxxbyc-"))
	fmt.Printf("%q\n", re.FindStringSubmatch("-abzc-"))
}
</pre>   <h3 id="Regexp.FindStringSubmatchIndex">func (*Regexp) FindStringSubmatchIndex<a href="https://golang.org/src/regexp/regexp.go?s=28453:28510#L927" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindStringSubmatchIndex(s string) []int</pre> <p> FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindSubmatch">func (*Regexp) FindSubmatch<a href="https://golang.org/src/regexp/regexp.go?s=23229:23278#L750" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindSubmatch(b []byte) [][]byte</pre> <p> FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.FindSubmatchIndex">func (*Regexp) FindSubmatchIndex<a href="https://golang.org/src/regexp/regexp.go?s=27416:27467#L898" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) FindSubmatchIndex(b []byte) []int</pre> <p> FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. </p> <h3 id="Regexp.LiteralPrefix">func (*Regexp) LiteralPrefix<a href="https://golang.org/src/regexp/regexp.go?s=12573:12637#L394" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) LiteralPrefix() (prefix string, complete bool)</pre> <p> LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression. </p> <h3 id="Regexp.Longest">func (*Regexp) Longest<a href="https://golang.org/src/regexp/regexp.go?s=6609:6636#L152" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) Longest()</pre> <p> Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. </p> <h3 id="Regexp.Match">func (*Regexp) Match<a href="https://golang.org/src/regexp/regexp.go?s=13062:13100#L410" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) Match(b []byte) bool</pre> <p> Match reports whether the Regexp matches the byte slice b. </p> <h3 id="Regexp.MatchReader">func (*Regexp) MatchReader<a href="https://golang.org/src/regexp/regexp.go?s=12766:12817#L400" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) MatchReader(r io.RuneReader) bool</pre> <p> MatchReader reports whether the Regexp matches the text read by the RuneReader. </p> <h3 id="Regexp.MatchString">func (*Regexp) MatchString<a href="https://golang.org/src/regexp/regexp.go?s=12918:12962#L405" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) MatchString(s string) bool</pre> <p> MatchString reports whether the Regexp matches the string s. </p> <h3 id="Regexp.NumSubexp">func (*Regexp) NumSubexp<a href="https://golang.org/src/regexp/regexp.go?s=9272:9305#L251" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) NumSubexp() int</pre> <p> NumSubexp returns the number of parenthesized subexpressions in this Regexp. </p> <h3 id="Regexp.ReplaceAll">func (*Regexp) ReplaceAll<a href="https://golang.org/src/regexp/regexp.go?s=17501:17554#L549" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) ReplaceAll(src, repl []byte) []byte</pre> <p> ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. </p> <h3 id="Regexp.ReplaceAllFunc">func (*Regexp) ReplaceAllFunc<a href="https://golang.org/src/regexp/regexp.go?s=18453:18530#L577" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</pre> <p> ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand. </p> <h3 id="Regexp.ReplaceAllLiteral">func (*Regexp) ReplaceAllLiteral<a href="https://golang.org/src/regexp/regexp.go?s=18025:18085#L567" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte</pre> <p> ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand. </p> <h3 id="Regexp.ReplaceAllLiteralString">func (*Regexp) ReplaceAllLiteralString<a href="https://golang.org/src/regexp/regexp.go?s=14850:14916#L464" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</pre> <p> ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("a(x*)b")
	fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "T"))
	fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "$1"))
	fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "${1}"))
}
</pre>   <h3 id="Regexp.ReplaceAllString">func (*Regexp) ReplaceAllString<a href="https://golang.org/src/regexp/regexp.go?s=14380:14439#L450" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) ReplaceAllString(src, repl string) string</pre> <p> ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("a(x*)b")
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "T"))
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1"))
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1W"))
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "${1}W"))
}
</pre>   <h3 id="Regexp.ReplaceAllStringFunc">func (*Regexp) ReplaceAllStringFunc<a href="https://golang.org/src/regexp/regexp.go?s=15298:15381#L474" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</pre> <p> ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand. </p> <h3 id="Regexp.Split">func (*Regexp) Split<a href="https://golang.org/src/regexp/regexp.go?s=34252:34301#L1114" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) Split(s string, n int) []string</pre> <p> Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches. </p> <p> The slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN. </p> <p> Example: </p> <pre data-language="go">s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)
// s: ["", "b", "b", "c", "cadaaae"]
</pre> <p> The count determines the number of substrings to return: </p> <pre data-language="go">n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
n == 0: the result is nil (zero substrings)
n &lt; 0: all substrings
</pre>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	a := regexp.MustCompile("a")
	fmt.Println(a.Split("banana", -1))
	fmt.Println(a.Split("banana", 0))
	fmt.Println(a.Split("banana", 1))
	fmt.Println(a.Split("banana", 2))
	zp := regexp.MustCompile("z+")
	fmt.Println(zp.Split("pizza", -1))
	fmt.Println(zp.Split("pizza", 0))
	fmt.Println(zp.Split("pizza", 1))
	fmt.Println(zp.Split("pizza", 2))
}
</pre>   <h3 id="Regexp.String">func (*Regexp) String<a href="https://golang.org/src/regexp/regexp.go?s=4113:4146#L95" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) String() string</pre> <p> String returns the source text used to compile the regular expression. </p> <h3 id="Regexp.SubexpNames">func (*Regexp) SubexpNames<a href="https://golang.org/src/regexp/regexp.go?s=9666:9706#L260" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (re *Regexp) SubexpNames() []string</pre> <p> SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)")
	fmt.Println(re.MatchString("Alan Turing"))
	fmt.Printf("%q\n", re.SubexpNames())
	reversed := fmt.Sprintf("${%s} ${%s}", re.SubexpNames()[2], re.SubexpNames()[1])
	fmt.Println(reversed)
	fmt.Println(re.ReplaceAllString("Alan Turing", reversed))
}
</pre>   <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="syntax/">syntax</a> </td> <td class="pkg-synopsis"> Package syntax parses regular expressions into parse trees and compiles parse trees into programs. </td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    Â© Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/regexp/" class="_attribution-link" target="_blank">https://golang.org/pkg/regexp/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
