
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>CollectionView - Marionette.js 2 - W3cubDocs</title>
  
  <meta name="description" content="The CollectionView will loop through all of the models in the specified collection, render each of them using a specified childView, then append the &hellip;">
  <meta name="keywords" content="marionette, collectionview, -, js, marionette~2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/marionette~2/marionette.collectionview/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/marionette~2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/marionette~2/" class="_nav-link" title="" style="margin-left:0;">Marionette.js 2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _marionette">
				
<h1>
Marionette.CollectionView</h1>
<p>The <code>CollectionView</code> will loop through all of the models in the specified collection, render each of them using a specified <code>childView</code>, then append the results of the child view's <code>el</code> to the collection view's <code>el</code>. By default the <code>CollectionView</code> will maintain a sorted collection's order in the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize.</p> <p>CollectionView extends directly from Marionette.View. Please see <a href="../marionette.view/">the Marionette.View documentation</a> for more information on available features and functionality.</p> <p>Additionally, interactions with Marionette.Region will provide features such as <code>onShow</code> callbacks, etc. Please see <a href="../marionette.region/">the Region documentation</a> for more information.</p> <h2 id="documentation-index">
Documentation Index</h2>
<ul> <li>
<a href="#collectionviews-childview">CollectionView's <code>childView</code></a><ul> <li><a href="#collectionviews-getchildview">CollectionView's <code>getChildView</code></a></li> <li><a href="#collectionviews-childviewoptions">CollectionView's <code>childViewOptions</code></a></li> <li><a href="#collectionviews-childvieweventprefix">CollectionView's <code>childViewEventPrefix</code></a></li> <li><a href="#collectionviews-childevents">CollectionView's <code>childEvents</code></a></li> <li><a href="#collectionviews-buildchildview">CollectionView's <code>buildChildView</code></a></li> <li><a href="#collectionviews-removechildview">CollectionView's <code>removeChildView</code></a></li> <li><a href="#collectionviews-addchild">CollectionView's <code>addChild</code></a></li> <li><a href="#collectionviews-reorderonsort">CollectionView's <code>reorderOnSort</code></a></li> </ul> </li> <li>
<a href="#collectionviews-emptyview">CollectionView's <code>emptyView</code></a><ul> <li><a href="#collectionviews-getemptyview">CollectionView's <code>getEmptyView</code></a></li> <li><a href="#collectionviews-isempty">CollectionView's <code>isEmpty</code></a></li> <li><a href="#collectionviews-emptyviewoptions">CollectionView's <code>emptyViewOptions</code></a></li> <li><a href="#collectionviews-destroychildren">CollectionView's <code>destroyChildren</code></a></li> </ul> </li> <li>
<a href="#callback-methods">Callback Methods</a><ul> <li><a href="#onbeforerender-callback">onBeforeRender callback</a></li> <li><a href="#onrender-callback">onRender callback</a></li> <li><a href="#onbeforereorder-callback">onBeforeReorder callback</a></li> <li><a href="#onreorder-callback">onReorder callback</a></li> <li><a href="#beforedestroy-callback">onBeforeDestroy callback</a></li> <li><a href="#ondestroy-callback">onDestroy callback</a></li> <li><a href="#onbeforeaddchild-callback">onBeforeAddChild callback</a></li> <li><a href="#onaddchild-callback">onAddChild callback</a></li> <li><a href="#onbeforeremovechild-callback">onBeforeRemoveChild callback</a></li> <li><a href="#onremovechild-callback">onRemoveChild callback</a></li> </ul> </li> <li>
<a href="#collectionview-events">CollectionView Events</a><ul> <li><a href="#beforerender-event">"before:render" event</a></li> <li><a href="#render-event">"render" event</a></li> <li><a href="#beforereorder--reorder-event">"before:reorder" / "reorder" event</a></li> <li><a href="#beforedestroy-event">"before:destroy" event</a></li> <li><a href="#destroy--destroycollection-event">"destroy" / "destroy:collection" event</a></li> <li><a href="#beforeaddchild--addchild-event">"before:add:child" / "add:child" event</a></li> <li><a href="#beforeremovechild-event">"before:remove:child event</a></li> <li><a href="#removechild-event">"remove:child" event</a></li> <li><a href="#childview-event-bubbling-from-child-views">"childview:*" event bubbling from child views</a></li> <li><a href="#beforerendercollection-event">"before:render:collection" event</a></li> <li><a href="#rendercollection-event">"render:collection" event</a></li> </ul> </li> <li><a href="#collectionview-child-view-events">CollectionView Child View Events</a></li> <li><a href="#collectionview-render">CollectionView render</a></li> <li><a href="#collectionview-automatic-rendering">CollectionView: Automatic Rendering</a></li> <li><a href="#collectionview-re-render-collection">CollectionView: Re-render Collection</a></li> <li><a href="#collectionviews-attachhtml">CollectionView's attachHtml</a></li> <li><a href="#collectionviews-resortview">CollectionView's resortView</a></li> <li><a href="#collectionviews-viewcomparator">CollectionView's viewComparator</a></li> <li><a href="#collectionviews-filter">CollectionView's <code>filter</code></a></li> <li><a href="#collectionviews-children">CollectionView's children</a></li> <li><a href="#collectionview-destroy">CollectionView destroy</a></li> </ul> <h2 id="collectionviews-childview">
CollectionView's <code>childView</code>
</h2>
<p>Specify a <code>childView</code> in your collection view definition. This must be a Backbone view object definition, not an instance. It can be any <code>Backbone.View</code> or be derived from <code>Marionette.ItemView</code>.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyChildView = Marionette.ItemView.extend({});

Marionette.CollectionView.extend({
  childView: MyChildView
});
</pre> <p>Child views must be defined before they are referenced by the <code>childView</code> attribute in a collection view definition. Use <code>getChildView</code> to lookup the definition as child views are instantiated.</p> <p>Alternatively, you can specify a <code>childView</code> in the options for the constructor:</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({...});

<span class="hljs-keyword">new</span> MyCollectionView({
  childView: MyChildView
});
</pre> <p>If you do not specify a <code>childView</code>, an exception will be thrown stating that you must specify a <code>childView</code>.</p> <h3 id="collectionviews-getchildview">
CollectionView's <code>getChildView</code>
</h3>
<p>The value returned by this method is the <code>ChildView</code> class that will be instantiated when a <code>Model</code> needs to be initially rendered. This method also gives you the ability to customize per <code>Model</code> <code>ChildViews</code>.</p> <pre data-language="js"><span class="hljs-keyword">var</span> FooBar = Backbone.Model.extend({
  defaults: {
    isFoo: <span class="hljs-literal">false</span>
  }
});

<span class="hljs-keyword">var</span> FooView = Marionette.ItemView.extend({
  template: <span class="hljs-string">'#foo-template'</span>
});
<span class="hljs-keyword">var</span> BarView = Marionette.ItemView.extend({
  template: <span class="hljs-string">'#bar-template'</span>
});

<span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({
  getChildView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{
    <span class="hljs-comment">// Choose which view class to render,</span>
    <span class="hljs-comment">// depending on the properties of the item model</span>
    <span class="hljs-keyword">if</span>  (item.get(<span class="hljs-string">'isFoo'</span>)) {
      <span class="hljs-keyword">return</span> FooView;
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> BarView;
    }
  }
});

<span class="hljs-keyword">var</span> collectionView = <span class="hljs-keyword">new</span> MyCollectionView({
  collection: <span class="hljs-keyword">new</span> Backbone.Collection()
});
<span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> FooBar({
  isFoo: <span class="hljs-literal">true</span>
});
<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> FooBar({
  isFoo: <span class="hljs-literal">false</span>
});

<span class="hljs-comment">// Renders a FooView</span>
collectionView.collection.add(foo);

<span class="hljs-comment">// Renders a BarView</span>
collectionView.collection.add(bar);
</pre> <h3 id="collectionviews-childviewoptions">
CollectionView's <code>childViewOptions</code>
</h3>
<p>There may be scenarios where you need to pass data from your parent collection view in to each of the childView instances. To do this, provide a <code>childViewOptions</code> definition on your collection view as an object literal. This will be passed to the constructor of your childView as part of the <code>options</code>.</p> <pre data-language="js"><span class="hljs-keyword">var</span> ChildView = Marionette.ItemView.extend({
  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{
    <span class="hljs-built_in">console</span>.log(options.foo); <span class="hljs-comment">// =&gt; "bar"</span>
  }
});

<span class="hljs-keyword">var</span> CollectionView = Marionette.CollectionView.extend({
  childView: ChildView,

  childViewOptions: {
    foo: <span class="hljs-string">"bar"</span>
  }
});
</pre> <p>You can also specify the <code>childViewOptions</code> as a function, if you need to calculate the values to return at runtime. The model will be passed into the function should you need access to it when calculating <code>childViewOptions</code>. The function must return an object, and the attributes of the object will be copied to the <code>childView</code> instance's options.</p> <pre data-language="js"><span class="hljs-keyword">var</span> CollectionView = Marionette.CollectionView.extend({
  childViewOptions: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, index)</span> </span>{
    <span class="hljs-comment">// do some calculations based on the model</span>
    <span class="hljs-keyword">return</span> {
      foo: <span class="hljs-string">"bar"</span>,
      childIndex: index
    }
  }
});
</pre> <h3 id="collectionviews-childvieweventprefix">
CollectionView's <code>childViewEventPrefix</code>
</h3>
<p>You can customize the event prefix for events that are forwarded through the collection view. To do this, set the <code>childViewEventPrefix</code> on the collection view. For more information on the <code>childViewEventPrefix</code> see <a href="#childview-event-bubbling-from-child-views">"childview:*" event bubbling from child views</a></p> <pre data-language="js"><span class="hljs-keyword">var</span> CV = Marionette.CollectionView.extend({
  childViewEventPrefix: <span class="hljs-string">"some:prefix"</span>
});

<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> CV({
  collection: myCol
});

c.on(<span class="hljs-string">"some:prefix:render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">// child view was rendered</span>
});

c.render();
</pre> <p>The <code>childViewEventPrefix</code> can be provided in the view definition or in the constructor function call, to get a view instance.</p> <h3 id="collectionviews-childevents">
CollectionView's <code>childEvents</code>
</h3>
<p>A <code>childEvents</code> hash or method permits handling of child view events without manually setting bindings. The values of the hash can either be a function or a string method name on the collection view.</p> <pre data-language="js"><span class="hljs-comment">// childEvents can be specified as a hash...</span>
<span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({

  childEvents: {
    <span class="hljs-comment">// This callback will be called whenever a child is rendered or emits a `render` event</span>
    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A child view has been rendered.'</span>);
    }
  }
});

<span class="hljs-comment">// ...or as a function that returns a hash.</span>
<span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({

  childEvents: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> {
      render: <span class="hljs-keyword">this</span>.onChildRendered
    }
  },

  onChildRendered: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A child view has been rendered.'</span>);
  }
});
</pre> <p><code>childEvents</code> also catches custom events fired by a child view. Take note that the first argument to a <code>childEvents</code> handler is the child view itself.</p> <pre data-language="js"><span class="hljs-comment">// The child view fires a custom event, `show:message`</span>
<span class="hljs-keyword">var</span> ChildView = Marionette.ItemView.extend({

  <span class="hljs-comment">// Events hash defines local event handlers that in turn may call `triggerMethod`.</span>
  events: {
    <span class="hljs-string">'click .button'</span>: <span class="hljs-string">'onClickButton'</span>
  },

  <span class="hljs-comment">// Triggers hash converts DOM events directly to view events catchable on the parent.</span>
  triggers: {
    <span class="hljs-string">'submit form'</span>: <span class="hljs-string">'submit:form'</span>
  },

  onClickButton: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Both `trigger` and `triggerMethod` events will be caught by parent.</span>
    <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'show:message'</span>, <span class="hljs-string">'foo'</span>);
    <span class="hljs-keyword">this</span>.triggerMethod(<span class="hljs-string">'show:message'</span>, <span class="hljs-string">'bar'</span>);
  }
});

<span class="hljs-comment">// The parent uses childEvents to catch the child view's custom event</span>
<span class="hljs-keyword">var</span> ParentView = Marionette.CollectionView.extend({

  childView: ChildView,

  childEvents: {
    <span class="hljs-string">'show:message'</span>: <span class="hljs-string">'onChildShowMessage'</span>,
    <span class="hljs-string">'submit:form'</span>: <span class="hljs-string">'onChildSubmitForm'</span>
  },

  onChildShowMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(childView, message)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A child view fired show:message with '</span> + message);
  },

  onChildSubmitForm: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(childView)</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A child view fired submit:form'</span>);
  }
});
</pre> <h3 id="collectionviews-buildchildview">
CollectionView's <code>buildChildView</code>
</h3>
<p>When a custom view instance needs to be created for the <code>childView</code> that represents a child, override the <code>buildChildView</code> method. This method takes three parameters and returns a view instance to be used as the child view.</p> <pre data-language="js">buildChildView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, ChildViewClass, childViewOptions)</span></span>{
  <span class="hljs-comment">// build the final list of options for the childView class</span>
  <span class="hljs-keyword">var</span> options = _.extend({model: child}, childViewOptions);
  <span class="hljs-comment">// create the child view instance</span>
  <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">new</span> ChildViewClass(options);
  <span class="hljs-comment">// return it</span>
  <span class="hljs-keyword">return</span> view;
},
</pre> <h3 id="collectionviews-removechildview">
CollectionView's <code>removeChildView</code>
</h3>
<p>Remove a specific view instance and destroy it. This function also updates the indices of later views in the collection in order to keep the children in sync with the collection.</p> <pre data-language="js"><span class="hljs-comment">// add some views to a CollectionView</span>
<span class="hljs-keyword">var</span> myCollectionView = <span class="hljs-keyword">new</span> MyCollectionView({
  collection: <span class="hljs-keyword">new</span> Backbone.Collection([fooModel, barModel]);
});

myCollectionView.render();

<span class="hljs-keyword">var</span> myView = myCollectionView.children.findByModel(foo);

<span class="hljs-comment">// remove a child view myView</span>
myCollectionView.removeChildView(myView);

<span class="hljs-comment">// check if the removed view still exist</span>
<span class="hljs-built_in">console</span>.log(myCollectionView.children.findByModel(fooModel)); <span class="hljs-comment">// return undefined</span>
<span class="hljs-built_in">console</span>.log(myCollectionView.children.findByModel(barModel)); <span class="hljs-comment">// return a childView bar</span>
</pre> <h3 id="collectionviews-addchild">
CollectionView's <code>addChild</code>
</h3>
<p>The <code>addChild</code> method is responsible for rendering the <code>childViews</code> and adding them to the HTML for the <code>collectionView</code> instance. It is also responsible for triggering the events per <code>ChildView</code>. In most cases you should not override this method. However if you do want to short circuit this method, it can be accomplished via the following.</p> <pre data-language="js">Marionette.CollectionView.extend({
  addChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, ChildView, index)</span></span>{
    <span class="hljs-keyword">if</span> (child.shouldBeShown()) {
      Marionette.CollectionView.prototype.addChild.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
  }
});
</pre> <h3 id="collectionviews-reorderonsort">
CollectionView's <code>reorderOnSort</code>
</h3>
<p>This option is useful when you have performance issues when you resort your <code>CollectionView</code>. Without this option, your <code>CollectionView</code> will be completely re-rendered, which can be costly if you have a large number of elements or if your <code>ChildView</code>s are complex. If this option is activated, when you sort your <code>Collection</code>, there will be no re-rendering, only the DOM nodes will be reordered. This can be a problem if your <code>ChildView</code>s use their collection's index in their rendering. In this case, you cannot use this option as you need to re-render each <code>ChildView</code>.</p> <p>If you combine this option with a <a href="#collectionviews-filter">filter</a> that changes the views that are to be displayed, <code>reorderOnSort</code> will be bypassed to render new children and remove those that are rejected by the filter.</p> <h2 id="collectionviews-emptyview">
CollectionView's <code>emptyView</code>
</h2>
<p>When a collection has no children, and you need to render a view other than the list of childViews, you can specify an <code>emptyView</code> attribute on your collection view.</p> <pre data-language="js"><span class="hljs-keyword">var</span> NoChildrenView = Marionette.ItemView.extend({
  template: <span class="hljs-string">"#show-no-children-message-template"</span>
});

Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  emptyView: NoChildrenView
});
</pre> <h3 id="collectionviews-getemptyview">
CollectionView's <code>getEmptyView</code>
</h3>
<p>If you need the <code>emptyView</code>'s class chosen dynamically, specify <code>getEmptyView</code>:</p> <pre data-language="js">Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  getEmptyView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// custom logic</span>
    <span class="hljs-keyword">return</span> NoChildrenView;
  }
});
</pre> <h3 id="collectionviews-isempty">
CollectionView's <code>isEmpty</code>
</h3>
<p>If you want to control when the empty view is rendered, you can override <code>isEmpty</code>:</p> <pre data-language="js">Marionette.CollectionView.extend({
  isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collection)</span> </span>{
    <span class="hljs-comment">// some logic to calculate if the view should be rendered as empty</span>
    <span class="hljs-keyword">return</span> someBoolean;
  }
});
</pre> <h3 id="collectionviews-emptyviewoptions">
CollectionView's <code>emptyViewOptions</code>
</h3>
<p>Similar to <code>childView</code> and <code>childViewOptions</code>, there is an <code>emptyViewOptions</code> property that will be passed to the <code>emptyView</code> constructor. It can be provided as an object literal or as a function.</p> <p>If <code>emptyViewOptions</code> aren't provided the CollectionView will default to passing the <code>childViewOptions</code> to the <code>emptyView</code>.</p> <pre data-language="js"><span class="hljs-keyword">var</span> EmptyView = Marionette.ItemView({
  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span></span>{
    <span class="hljs-built_in">console</span>.log(options.foo); <span class="hljs-comment">// =&gt; "bar"</span>
  }
});

<span class="hljs-keyword">var</span> CollectionView = Marionette.CollectionView({
  emptyView: EmptyView,

  emptyViewOptions: {
    foo: <span class="hljs-string">"bar"</span>
  }
});
</pre> <h3 id="collectionviews-destroychildren">
CollectionView's <code>destroyChildren</code>
</h3>
<p><code>CollectionView</code> provides a <code>destroyChildren</code> method that will only destroy it's childViews. This can be useful when you would like to empty your view but keep the data in the <code>collection</code>. This method takes an optional <code>checkEmpty</code> parameter, by default it is set to <code>true</code>, if <code>false</code> it will disable the call to <code>checkEmpty</code> and <code>destroyChildren</code> will not show the <code>emptyView</code>.</p> <pre data-language="js">myView.destroyChildren(); <span class="hljs-comment">// will show emptyView</span>
myView.destroyChildren({checkEmpty: <span class="hljs-literal">false</span>}); <span class="hljs-comment">// will not show emptyView</span>
</pre> <h2 id="callback-methods">
Callback Methods</h2>
<p>There are several callback methods that can be provided on a <code>CollectionView</code>. If they are found, they will be called by the view's base methods. These callback methods are intended to be handled within the view definition directly.</p> <h3 id="onbeforerender-callback">
onBeforeRender callback</h3>
<p>A <code>onBeforeRender</code> callback will be called just prior to rendering the collection view.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onBeforeRender: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</pre> <h3 id="onrender-callback">
onRender callback</h3>
<p>After the view has been rendered, a <code>onRender</code> method will be called. You can implement this in your view to provide custom code for dealing with the view's <code>el</code> after it has been rendered:</p> <pre data-language="js">Marionette.CollectionView.extend({
  onRender: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</pre> <h3 id="onbeforereorder-callback">
onBeforeReorder callback</h3>
<p>If <code>reorderOnSort</code> is set to <code>true</code>, <code>onBeforeReorder</code> will be called just prior to reordering the collection view.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onBeforeReorder: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</pre> <h3 id="onreorder-callback">
onReorder callback</h3>
<p>If <code>reorderOnSort</code> is set to <code>true</code>, after the view has been reordered, a <code>onReorder</code> method will be called.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onReorder: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</pre> <h3 id="onbeforedestroy-callback">
onBeforeDestroy callback</h3>
<p>This method is called just before destroying the view.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onBeforeDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</pre> <h3 id="ondestroy-callback">
onDestroy callback</h3>
<p>This method is called just after destroying the view.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</pre> <h3 id="onbeforeaddchild-callback">
onBeforeAddChild callback</h3>
<p>This callback function allows you to know when a child / child view instance is about to be added to the collection view. It provides access to the view instance for the child that was added.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onBeforeAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</pre> <h3 id="onaddchild-callback">
onAddChild callback</h3>
<p>This callback function allows you to know when a child / child view instance has been added to the collection view. It provides access to the view instance for the child that was added.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</pre> <h3 id="onbeforeremovechild-callback">
onBeforeRemoveChild callback</h3>
<p>This callback function allows you to know when a <code>childView</code> instance is about to be removed from the <code>collectionView</code>. It provides access to the view instance for the child that was removed.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onBeforeRemoveChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</pre> <h3 id="onremovechild-callback">
onRemoveChild callback</h3>
<p>This callback function allows you to know when a child / childView instance has been deleted or removed from the collection.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onRemoveChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</pre> <h2 id="collectionview-events">
CollectionView Events</h2>
<p>There are several events that will be triggered during the life of a collection view. Each of these events is called with the <a href="../marionette.functions/#marionettetriggermethod">Marionette.triggerMethod</a> function, which calls a corresponding "on{EventName}" method on the view instance (see <a href="#callback-methods">above</a>).</p> <h3 id="beforerender-event">
"before:render" event</h3>
<p>Triggers just prior to the view being rendered. Also triggered as "before:render:collection" / <code>onBeforeRenderCollection</code>.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyView = Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"before:render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is about to be rendered"</span>);
});

myView.render();
</pre> <h3 id="render-event">
"render" event</h3>
<p>A "render:collection" / <code>onRenderCollection</code> event will also be fired. This allows you to add more than one callback to execute after the view is rendered, and allows parent views and other parts of the application to know that the view was rendered.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyView = Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view was rendered!"</span>);
});

myView.on(<span class="hljs-string">"render:collection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view was rendered!"</span>);
});

myView.render();
</pre> <h3 id="beforereorder--reorder-events">
"before:reorder" / "reorder" events</h3>
<p>When <code>reorderOnSort</code> is set to <code>true</code>, these events are fired respectfully just prior/just after the reordering of the collection.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyView = Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myCol = <span class="hljs-keyword">new</span> Backbone.Collection({ comparator: ... })
<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView({ reorderOnSort: <span class="hljs-literal">true</span> });
myView.render();
myCol.comparator = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'foo'</span>); };

myView.on(<span class="hljs-string">"before:reorder"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is about to be reordered"</span>);
});

myView.on(<span class="hljs-string">"reorder"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view has been reordered following its collection"</span>);
});

myCol.sort()
</pre> <h3 id="beforedestroy-event">
"before:destroy" event</h3>
<p>Triggered just before destroying the view. A "before:destroy:collection" / <code>onBeforeDestroyCollection</code> event will also be fired</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyView = Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"before:destroy:collection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is about to be destroyed"</span>);
});

myView.destroy();
</pre> <h3 id="destroy--destroycollection-event">
"destroy" / "destroy:collection" event</h3>
<p>Triggered just after destroying the view, both with corresponding method calls.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyView = Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"destroy:collection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is now destroyed"</span>);
});

myView.destroy();
</pre> <h3 id="beforeaddchild--addchild-event">
"before:add:child" / "add:child" event</h3>
<p>The "before:add:child" event and corresponding <code>onBeforeAddChild</code> method are triggered just after creating a new <code>childView</code> instance for a child that was added to the collection, but before the view is rendered and added to the DOM.</p> <p>The "add:child" event and corresponding <code>onAddChild</code> method are triggered after rendering the view and adding it to the view's DOM element.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyCV = Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  onBeforeAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// ...</span>
  },

  onAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// ...</span>
  }
});

<span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> MyCV({...});

cv.on(<span class="hljs-string">"before:add:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});

cv.on(<span class="hljs-string">"add:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</pre> <h3 id="beforeremovechild">
"before:remove:child"</h3>
<p>This is triggered after the childView instance has been removed from the collection, but before it has been destroyed.</p> <pre data-language="js">cv.on(<span class="hljs-string">"before:remove:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</pre> <h3 id="removechild-event">
"remove:child" event</h3>
<p>Triggered after a childView instance has been destroyed and removed, when its child was deleted or removed from the collection.</p> <pre data-language="js">cv.on(<span class="hljs-string">"remove:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</pre> <h3 id="childview-event-bubbling-from-child-views">
"childview:*" event bubbling from child views</h3>
<p>When a child view within a collection view triggers an event, that event will bubble up through the parent collection view with "childview:" prepended to the event name.</p> <p>That is, if a child view triggers "do:something", the parent collection view will then trigger "childview:do:something".</p> <pre data-language="js"><span class="hljs-comment">// set up basic collection</span>
<span class="hljs-keyword">var</span> myModel = <span class="hljs-keyword">new</span> MyModel();
<span class="hljs-keyword">var</span> myCollection = <span class="hljs-keyword">new</span> MyCollection();
myCollection.add(myModel);

<span class="hljs-keyword">var</span> MyItemView = Marionette.ItemView.extend({
  triggers: {
    <span class="hljs-string">'click button'</span>: <span class="hljs-string">'do:something'</span>
  }
});

<span class="hljs-comment">// get the collection view in place</span>
<span class="hljs-keyword">var</span> colView = <span class="hljs-keyword">new</span> CollectionView({
  collection: myCollection,
  childView: MyItemView,

  onChildviewDoSomething: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    alert(<span class="hljs-string">"I said, 'do something!'"</span>);
  }
});
colView.render();
</pre> <p>Now, whenever the button inside the attached childView is clicked, an alert box will appear that says: I said, 'do something!'</p> <p>It's also possible to attach the event manually using the usual <code>view.on('childview:do:something')</code>.</p> <h3 id="beforerendercollection-event">
before:render:collection event</h3>
<p>The <code>before:render:collection</code> event is triggered before the <code>collectionView</code>'s children have been rendered and buffered. It differs from the <code>collectionsView</code>'s <code>before:render</code> in that it is <strong>only</strong> emitted if the <code>collection</code> is not empty.</p> <h3 id="rendercollection-event">
render:collection event</h3>
<p>The <code>render:collection</code> event is triggered after a <code>collectionView</code>'s children have been rendered and buffered. It differs from the <code>collectionViews</code>'s <code>render</code> event in that it happens <strong>only</strong> if the <code>collection</code> is not empty.</p> <h2 id="collectionview-child-view-events">
CollectionView Child View Events</h2>
<p>The following events are raised on child views during rendering and destruction of child views, which is consistent with the view lifecycle experienced during <code>Region#show</code>.</p> <ul> <li>
<code>before:render</code> / <code>onBeforeRender</code> - Called before the view is rendered.</li> <li>
<code>render</code> / <code>onRender</code> - Called after the view is rendered, but before it is attached to the DOM.</li> <li>
<code>before:show</code> / <code>onBeforeShow</code> - Called after the view has been rendered, but before it has been bound to the CollectionView.</li> <li>
<code>before:attach</code> / <code>onBeforeAttach</code> - Called before the view is attached to the DOM. This will not fire if the CollectionView itself is not attached.</li> <li>
<code>attach</code> / <code>onAttach</code> - Called after the view is attached to the DOM. This will not fire if the CollectionView itself is not attached.</li> <li>
<code>show</code> / <code>onShow</code> - Called when the view has been rendered and bound to the CollectionView.</li> <li>
<code>dom:refresh</code> / <code>onDomRefresh</code> - Called when the view is both rendered and shown, but only if it is attached to the DOM. This will not fire if the CollectionView itself is not attached.</li> <li>
<code>before:destroy</code> / <code>onBeforeDestroy</code> - Called before destroying a view.</li> <li>
<code>destroy</code> / <code>onDestroy</code> - Called after destroying a view.</li> </ul> <p>Note: <code>render</code>, <code>destroy</code>, and <code>dom:refresh</code> are triggered on pure Backbone Views during child view rendering, but for a complete implementation of these events the Backbone View should fire <code>render</code> within <code>render()</code> and <code>destroy</code> within <code>remove()</code> as well as set the following flags:</p> <pre data-language="js">view.supportsRenderLifecycle = <span class="hljs-literal">true</span>;
view.supportsDestroyLifecycle = <span class="hljs-literal">true</span>;
</pre> <h2 id="collectionview-render">
CollectionView render</h2>
<p>The <code>render</code> method of the collection view is responsible for rendering the entire collection. It loops through each of the children in the collection and renders them individually as an <code>childView</code>.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({...});

<span class="hljs-comment">// all of the children views will now be rendered.</span>
<span class="hljs-keyword">new</span> MyCollectionView().render();
</pre> <h2 id="collectionview-automatic-rendering">
CollectionView: Automatic Rendering</h2>
<p>After the initial render the collection view binds to the "add", "remove" and "reset" events of the collection that is specified.</p> <p>When the collection for the view is "reset", the view will call <code>render</code> on itself and re-render the entire collection.</p> <p>When a model is added to the collection, the collection view will render that one model in to the collection of child views.</p> <p>When a model is removed from a collection (or destroyed / deleted), the collection view will destroy and remove that model's child view.</p> <p>When the collection for the view is sorted, the view will automatically re-sort its child views. if the <code>reorderOnSort</code> option is set it will attempt to reorder the DOM and do this without a full re-render, otherwise it will re-render if the order has changed. Please Note that if you apply a filter to the collection view and the filtered views change during a sort then it will always re-render.</p> <pre data-language="js"><span class="hljs-keyword">var</span> collection = <span class="hljs-keyword">new</span> Backbone.Collection();

<span class="hljs-keyword">var</span> myChildView = Marionette.View.extend({
  template: <span class="hljs-literal">false</span>
});

<span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({
  childView: myChildView,
  collection: collection,
});

<span class="hljs-keyword">var</span> myCollectionView = <span class="hljs-keyword">new</span> MyCollectionView();

<span class="hljs-comment">// Collection view will not re-render as it has not been rendered</span>
collection.reset([{foo: <span class="hljs-string">'foo'</span>}]);

myCollectionView.render();

<span class="hljs-comment">// Collection view will re-render displaying the new model</span>
collection.reset([{foo: <span class="hljs-string">'bar'</span>}]);
</pre> <h2 id="collectionview-re-render-collection">
CollectionView: Re-render Collection</h2>
<p>If you need to re-render the entire collection, you can call the <code>view.render</code> method. This method takes care of destroying all of the child views that may have previously been opened.</p> <h2 id="collectionviews-attachhtml">
CollectionView's attachHtml</h2>
<p>By default the collection view will append the HTML of each ChildView into the element buffer, and then call jQuery's <code>.append</code> once at the end to move the HTML into the collection view's <code>el</code>.</p> <p>You can override this by specifying an <code>attachHtml</code> method in your view definition. This method takes three parameters and has no return value.</p> <pre data-language="js">Marionette.CollectionView.extend({

    <span class="hljs-comment">// The default implementation:</span>
  attachHtml: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collectionView, childView, index)</span></span>{
    <span class="hljs-keyword">if</span> (collectionView.isBuffering) {
      <span class="hljs-comment">// buffering happens on reset events and initial renders</span>
      <span class="hljs-comment">// in order to reduce the number of inserts into the</span>
      <span class="hljs-comment">// document, which are expensive.</span>
      collectionView._bufferedChildren.splice(index, <span class="hljs-number">0</span>, childView);
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// If we've already rendered the main collection, append</span>
      <span class="hljs-comment">// the new child into the correct order if we need to. Otherwise</span>
      <span class="hljs-comment">// append to the end.</span>
      <span class="hljs-keyword">if</span> (!collectionView._insertBefore(childView, index)){
        collectionView._insertAfter(childView);
      }
    }
  },

  <span class="hljs-comment">// Called after all children have been appended into the elBuffer</span>
  attachBuffer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collectionView, buffer)</span> </span>{
    collectionView.$el.append(buffer);
  },

  <span class="hljs-comment">// called on initialize and after attachBuffer is called</span>
  initRenderBuffer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.elBuffer = <span class="hljs-built_in">document</span>.createDocumentFragment();
  }

});
</pre> <p>The first parameter is the instance of the collection view that will receive the HTML from the second parameter, the current child view instance.</p> <p>The third parameter, <code>index</code>, is the index of the model that this <code>childView</code> instance represents, in the collection that the model came from. This is useful for sorting a collection and displaying the sorted list in the correct order on the screen.</p> <p>Overrides of <code>attachHtml</code> that don't take into account the element buffer will work fine, but won't take advantage of the 60x performance increase the buffer provides.</p> <h2 id="collectionviews-resortview">
CollectionView's resortView</h2>
<p>By default the <code>CollectionView</code> will maintain the order of its <code>collection</code> in the DOM. However on occasions the view may need to re-render to make this possible, for example if you were to change the comparator on the collection. By default <code>CollectionView</code> will call <code>render</code> when this happens, but there are cases where this may not be suitable. For instance when sorting the <code>children</code> in a <code>CompositeView</code>, you want to only render the internal collection.</p> <pre data-language="js"><span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> Marionette.CollectionView({
  collection: someCollection,
  resortView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// provide custom logic for rendering after sorting the collection</span>
  }
});
</pre> <h2 id="collectionviews-viewcomparator">
CollectionView's viewComparator</h2>
<p>CollectionView allows for a custom <code>viewComparator</code> option if you want your CollectionView's children to be rendered with a different sort order than the underlying Backbone collection uses.</p> <pre data-language="js">  <span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> Marionette.CollectionView({
    collection: someCollection,
    viewComparator: <span class="hljs-string">'otherFieldToSortOn'</span>
  });
</pre> <p>The <code>viewComparator</code> can take any of the acceptable <code>Backbone.Collection</code> <a href="http://backbonejs.org/#Collection-comparator" target="_blank">comparator formats</a> -- a sortBy (pass a function that takes a single argument), as a sort (pass a comparator function that expects two arguments), or as a string indicating the attribute to sort by.</p> <h2 id="collectionviews-filter">
CollectionView's <code>filter</code>
</h2>
<p>CollectionView allows for a custom <code>filter</code> option if you want to prevent some of the underlying <code>collection</code>'s models from being rendered as child views. The filter function takes a model from the collection and returns a truthy value if the child should be rendered, and a falsey value if it should not.</p> <pre data-language="js">  <span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> Marionette.CollectionView({
    childView: SomeChildView,
    emptyView: SomeEmptyView,
    collection: <span class="hljs-keyword">new</span> Backbone.Collection([
      { value: <span class="hljs-number">1</span> },
      { value: <span class="hljs-number">2</span> },
      { value: <span class="hljs-number">3</span> },
      { value: <span class="hljs-number">4</span> }
    ]),

    <span class="hljs-comment">// Only show views with even values</span>
    filter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(child, index, collection)</span> </span>{
      <span class="hljs-keyword">return</span> child.get(<span class="hljs-string">'value'</span>) % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;
    }
  });

  <span class="hljs-comment">// renders the views with values '2' and '4'</span>
  cv.render();

  <span class="hljs-comment">// change the filter</span>
  cv.filter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(child, index, collection)</span> </span>{
    <span class="hljs-keyword">return</span> child.get(<span class="hljs-string">'value'</span>) % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>;
  };

  <span class="hljs-comment">// renders the views with values '1' and '3'</span>
  cv.render();

  <span class="hljs-comment">// remove the filter</span>
  <span class="hljs-comment">// note that using `delete cv.filter` will cause the prototype's filter to be used</span>
  <span class="hljs-comment">// which may be undesirable</span>
  cv.filter = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// renders all views</span>
  cv.render();
</pre> <h2 id="collectionviews-children">
CollectionView's children</h2>
<p>The CollectionView uses <a href="https://github.com/marionettejs/backbone.babysitter" target="_blank">Backbone.BabySitter</a> to store and manage its child views. This allows you to easily access the views within the collection view, iterate them, find them by a given indexer such as the view's model or collection, and more.</p> <pre data-language="js"><span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> Marionette.CollectionView({
  collection: someCollection
});

cv.render();


<span class="hljs-comment">// retrieve a view by model</span>
<span class="hljs-keyword">var</span> v = cv.children.findByModel(someModel);

<span class="hljs-comment">// iterate over all of the views and process them</span>
cv.children.each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span></span>{

  <span class="hljs-comment">// process the `view` here</span>

});
</pre> <p>For more information on the available features and functionality of the <code>.children</code>, see the <a href="https://github.com/marionettejs/backbone.babysitter" target="_blank">Backbone.BabySitter documentation</a>.</p> <h2 id="collectionview-destroy">
CollectionView destroy</h2>
<p>CollectionView implements a <code>destroy</code> method, which is called by the region managers automatically. As part of the implementation, the following are performed:</p> <ul> <li>unbind all <code>listenTo</code> events</li> <li>unbind all custom view events</li> <li>unbind all DOM events</li> <li>unbind all child views that were rendered</li> <li>remove <code>this.el</code> from the DOM</li> <li>call an <code>onDestroy</code> event on the view, if one is provided</li> <li>the <code>CollectionView</code> is returned</li> </ul> <p>By providing an <code>onDestroy</code> event in your view definition, you can run custom code for your view that is fired after your view has been destroyed and cleaned up. This lets you handle any additional clean up code without having to override the <code>destroy</code> method.</p> <pre data-language="js">Marionette.CollectionView.extend({
  onDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// custom cleanup or destroying code, here</span>
  }
});
</pre>
<div class="_attribution">
  <p class="_attribution-p">
     2016 Muted Solutions, LLC<br>Licensed under the MIT License.<br>
    <a href="https://marionettejs.com/docs/v2.4.7/marionette.collectionview.html" class="_attribution-link" target="_blank">https://marionettejs.com/docs/v2.4.7/marionette.collectionview.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
