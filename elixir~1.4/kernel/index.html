
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Kernel - Elixir 1.4 - W3cubDocs</title>
  
  <meta name="description" content=" Provides the default macros and functions Elixir imports into your environment. ">
  <meta name="keywords" content="kernel, summary, functions, macros, -, elixir, elixir~1.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.4/kernel/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.4/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Kernel  </h1>  <p>Provides the default macros and functions Elixir imports into your environment.</p> <p>These macros and functions can be skipped or cherry-picked via the <code class="inline">import/2</code> macro. For instance, if you want to tell Elixir not to import the <a href="#if/2"><code class="inline">if/2</code></a> macro, you can do:</p> <pre data-language="elixir"><code class="elixir">import Kernel, except: [if: 2]</code></pre> <p>Elixir also has special forms that are always imported and cannot be skipped. These are described in <a href="../kernel.specialforms/"><code class="inline">Kernel.SpecialForms</code></a>.</p> <p>Some of the functions described in this module are inlined by the Elixir compiler into their Erlang counterparts in the <code class="inline">:erlang</code> module. Those functions are called BIFs (built-in internal functions) in Erlang-land and they exhibit interesting properties, as some of them are allowed in guards and others are used for compiler optimizations.</p> <p>Most of the inlined functions can be seen in effect when capturing the function:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; &amp;Kernel.is_atom/1
&amp;:erlang.is_atom/1</code></pre> <p>Those functions will be explicitly marked in their docs as “inlined by the compiler”.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#!=/2">left != right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if the two items are not equal</p> </dd>   <dt class="summary-signature"> <a href="#!==/2">left !== right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if the two items are not exactly equal</p> </dd>   <dt class="summary-signature"> <a href="#*/2">left * right</a> </dt> <dd class="summary-synopsis">
<p>Arithmetic multiplication</p> </dd>   <dt class="summary-signature"> <a href="#+/1">+value</a> </dt> <dd class="summary-synopsis">
<p>Arithmetic unary plus</p> </dd>   <dt class="summary-signature"> <a href="#+/2">left + right</a> </dt> <dd class="summary-synopsis">
<p>Arithmetic addition</p> </dd>   <dt class="summary-signature"> <a href="#++/2">left ++ right</a> </dt> <dd class="summary-synopsis">
<p>Concatenates a proper list and a term, returning a list</p> </dd>   <dt class="summary-signature"> <a href="#-/1">-value</a> </dt> <dd class="summary-synopsis">
<p>Arithmetic unary minus</p> </dd>   <dt class="summary-signature"> <a href="#-/2">left - right</a> </dt> <dd class="summary-synopsis">
<p>Arithmetic subtraction</p> </dd>   <dt class="summary-signature"> <a href="#--/2">left -- right</a> </dt> <dd class="summary-synopsis">
<p>Removes the first occurrence of an item on the left list for each item on the right</p> </dd>   <dt class="summary-signature"> <a href="#//2">left / right</a> </dt> <dd class="summary-synopsis">
<p>Arithmetic division</p> </dd>   <dt class="summary-signature"> <a href="#%3C/2">left &lt; right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if left is less than right</p> </dd>   <dt class="summary-signature"> <a href="#%3C=/2">left &lt;= right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if left is less than or equal to right</p> </dd>   <dt class="summary-signature"> <a href="#==/2">left == right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if the two items are equal</p> </dd>   <dt class="summary-signature"> <a href="#===/2">left === right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if the two items are exactly equal</p> </dd>   <dt class="summary-signature"> <a href="#=~/2">left =~ right</a> </dt> <dd class="summary-synopsis">
<p>Matches the term on the left against the regular expression or string on the right</p> </dd>   <dt class="summary-signature"> <a href="#%3E/2">left &gt; right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if left is more than right</p> </dd>   <dt class="summary-signature"> <a href="#%3E=/2">left &gt;= right</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if left is more than or equal to right</p> </dd>   <dt class="summary-signature"> <a href="#abs/1">abs(number)</a> </dt> <dd class="summary-synopsis">
<p>Returns an integer or float which is the arithmetical absolute value of <code class="inline">number</code></p> </dd>   <dt class="summary-signature"> <a href="#apply/2">apply(fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Invokes the given <code class="inline">fun</code> with the list of arguments <code class="inline">args</code></p> </dd>   <dt class="summary-signature"> <a href="#apply/3">apply(module, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Invokes the given <code class="inline">fun</code> from <code class="inline">module</code> with the list of arguments <code class="inline">args</code></p> </dd>   <dt class="summary-signature"> <a href="#binary_part/3">binary_part(binary, start, length)</a> </dt> <dd class="summary-synopsis">
<p>Extracts the part of the binary starting at <code class="inline">start</code> with length <code class="inline">length</code>. Binaries are zero-indexed</p> </dd>   <dt class="summary-signature"> <a href="#bit_size/1">bit_size(bitstring)</a> </dt> <dd class="summary-synopsis">
<p>Returns an integer which is the size in bits of <code class="inline">bitstring</code></p> </dd>   <dt class="summary-signature"> <a href="#byte_size/1">byte_size(bitstring)</a> </dt> <dd class="summary-synopsis">
<p>Returns the number of bytes needed to contain <code class="inline">bitstring</code></p> </dd>   <dt class="summary-signature"> <a href="#div/2">div(dividend, divisor)</a> </dt> <dd class="summary-synopsis">
<p>Performs an integer division</p> </dd>   <dt class="summary-signature"> <a href="#elem/2">elem(tuple, index)</a> </dt> <dd class="summary-synopsis">
<p>Gets the element at the zero-based <code class="inline">index</code> in <code class="inline">tuple</code></p> </dd>   <dt class="summary-signature"> <a href="#exit/1">exit(reason)</a> </dt> <dd class="summary-synopsis">
<p>Stops the execution of the calling process with the given reason</p> </dd>   <dt class="summary-signature"> <a href="#function_exported?/3">function_exported?(module, function, arity)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">function</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#get_and_update_in/3">get_and_update_in(data, keys, fun)</a> </dt> <dd class="summary-synopsis">
<p>Gets a value and updates a nested structure</p> </dd>   <dt class="summary-signature"> <a href="#get_in/2">get_in(data, keys)</a> </dt> <dd class="summary-synopsis">
<p>Gets a value from a nested structure</p> </dd>   <dt class="summary-signature"> <a href="#hd/1">hd(list)</a> </dt> <dd class="summary-synopsis">
<p>Returns the head of a list. Raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the list is empty</p> </dd>   <dt class="summary-signature"> <a href="#inspect/2">inspect(arg, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Inspects the given argument according to the <a href="../inspect/"><code class="inline">Inspect</code></a> protocol. The second argument is a keyword list with options to control inspection</p> </dd>   <dt class="summary-signature"> <a href="#is_atom/1">is_atom(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an atom; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_binary/1">is_binary(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a binary; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_bitstring/1">is_bitstring(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a bitstring (including a binary); otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_boolean/1">is_boolean(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either the atom <code class="inline">true</code> or the atom <code class="inline">false</code> (i.e., a boolean); otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_float/1">is_float(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a floating point number; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_function/1">is_function(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_function/2">is_function(term, arity)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function that can be applied with <code class="inline">arity</code> number of arguments; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_integer/1">is_integer(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an integer; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_list/1">is_list(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a list with zero or more elements; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_map/1">is_map(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a map; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_number/1">is_number(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either an integer or a floating point number; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_pid/1">is_pid(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a PID (process identifier); otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_port/1">is_port(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a port identifier; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_reference/1">is_reference(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a reference; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#is_tuple/1">is_tuple(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a tuple; otherwise returns <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#length/1">length(list)</a> </dt> <dd class="summary-synopsis">
<p>Returns the length of <code class="inline">list</code></p> </dd>   <dt class="summary-signature"> <a href="#macro_exported?/3">macro_exported?(module, macro, arity)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">macro</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code></p> </dd>   <dt class="summary-signature"> <a href="#make_ref/0">make_ref()</a> </dt> <dd class="summary-synopsis">
<p>Returns an almost unique reference</p> </dd>   <dt class="summary-signature"> <a href="#map_size/1">map_size(map)</a> </dt> <dd class="summary-synopsis">
<p>Returns the size of a map</p> </dd>   <dt class="summary-signature"> <a href="#max/2">max(first, second)</a> </dt> <dd class="summary-synopsis">
<p>Returns the biggest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned</p> </dd>   <dt class="summary-signature"> <a href="#min/2">min(first, second)</a> </dt> <dd class="summary-synopsis">
<p>Returns the smallest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned</p> </dd>   <dt class="summary-signature"> <a href="#node/0">node()</a> </dt> <dd class="summary-synopsis">
<p>Returns an atom representing the name of the local node. If the node is not alive, <code class="inline">:nonode@nohost</code> is returned instead</p> </dd>   <dt class="summary-signature"> <a href="#node/1">node(arg)</a> </dt> <dd class="summary-synopsis">
<p>Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, <code class="inline">:nonode@nohost</code> is returned</p> </dd>   <dt class="summary-signature"> <a href="#not/1">not arg</a> </dt> <dd class="summary-synopsis">
<p>Boolean not</p> </dd>   <dt class="summary-signature"> <a href="#pop_in/2">pop_in(data, keys)</a> </dt> <dd class="summary-synopsis">
<p>Pops a key from the given nested structure</p> </dd>   <dt class="summary-signature"> <a href="#put_elem/3">put_elem(tuple, index, value)</a> </dt> <dd class="summary-synopsis">
<p>Inserts <code class="inline">value</code> at the given zero-based <code class="inline">index</code> in <code class="inline">tuple</code></p> </dd>   <dt class="summary-signature"> <a href="#put_in/3">put_in(data, keys, value)</a> </dt> <dd class="summary-synopsis">
<p>Puts a value in a nested structure</p> </dd>   <dt class="summary-signature"> <a href="#rem/2">rem(dividend, divisor)</a> </dt> <dd class="summary-synopsis">
<p>Computes the remainder of an integer division</p> </dd>   <dt class="summary-signature"> <a href="#round/1">round(number)</a> </dt> <dd class="summary-synopsis">
<p>Rounds a number to the nearest integer</p> </dd>   <dt class="summary-signature"> <a href="#self/0">self()</a> </dt> <dd class="summary-synopsis">
<p>Returns the PID (process identifier) of the calling process</p> </dd>   <dt class="summary-signature"> <a href="#send/2">send(dest, msg)</a> </dt> <dd class="summary-synopsis">
<p>Sends a message to the given <code class="inline">dest</code> and returns the message</p> </dd>   <dt class="summary-signature"> <a href="#spawn/1">spawn(fun)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given function and returns its PID</p> </dd>   <dt class="summary-signature"> <a href="#spawn/3">spawn(module, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given module and function passing the given args and returns its PID</p> </dd>   <dt class="summary-signature"> <a href="#spawn_link/1">spawn_link(fun)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given function, links it to the current process and returns its PID</p> </dd>   <dt class="summary-signature"> <a href="#spawn_link/3">spawn_link(module, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given module and function passing the given args, links it to the current process and returns its PID</p> </dd>   <dt class="summary-signature"> <a href="#spawn_monitor/1">spawn_monitor(fun)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given function, monitors it and returns its PID and monitoring reference</p> </dd>   <dt class="summary-signature"> <a href="#spawn_monitor/3">spawn_monitor(module, fun, args)</a> </dt> <dd class="summary-synopsis">
<p>Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference</p> </dd>   <dt class="summary-signature"> <a href="#struct/2">struct(struct, kv \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Creates and updates structs</p> </dd>   <dt class="summary-signature"> <a href="#struct!/2">struct!(struct, kv \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Similar to <a href="#struct/2"><code class="inline">struct/2</code></a> but checks for key validity</p> </dd>   <dt class="summary-signature"> <a href="#throw/1">throw(term)</a> </dt> <dd class="summary-synopsis">
<p>A non-local return from a function</p> </dd>   <dt class="summary-signature"> <a href="#tl/1">tl(list)</a> </dt> <dd class="summary-synopsis">
<p>Returns the tail of a list. Raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the list is empty</p> </dd>   <dt class="summary-signature"> <a href="#trunc/1">trunc(number)</a> </dt> <dd class="summary-synopsis">
<p>Returns the integer part of <code class="inline">number</code></p> </dd>   <dt class="summary-signature"> <a href="#tuple_size/1">tuple_size(tuple)</a> </dt> <dd class="summary-synopsis">
<p>Returns the size of a tuple</p> </dd>   <dt class="summary-signature"> <a href="#update_in/3">update_in(data, keys, fun)</a> </dt> <dd class="summary-synopsis">
<p>Updates a key in a nested structure</p> </dd>  </dl> <h2> Macros </h2>
<dl class="summary-macros summary">   <dt class="summary-signature"> <a href="#!/1">!arg</a> </dt> <dd class="summary-synopsis">
<p>Boolean not</p> </dd>   <dt class="summary-signature"> <a href="#&amp;&amp;/2">left &amp;&amp; right</a> </dt> <dd class="summary-synopsis">
<p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to <code class="inline">true</code> (i.e., it is neither <code class="inline">nil</code> nor <code class="inline">false</code>). Returns the first expression otherwise</p> </dd>   <dt class="summary-signature"> <a href="#../2">first..last</a> </dt> <dd class="summary-synopsis">
<p>Returns a range with the specified start and end</p> </dd>   <dt class="summary-signature"> <a href="#%3C%3E/2">left &lt;&gt; right</a> </dt> <dd class="summary-synopsis">
<p>Concatenates two binaries</p> </dd>   <dt class="summary-signature"> <a href="#@/1">@expr</a> </dt> <dd class="summary-synopsis">
<p>Reads and writes attributes of the current module</p> </dd>   <dt class="summary-signature"> <a href="#alias!/1">alias!(alias)</a> </dt> <dd class="summary-synopsis">
<p>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded</p> </dd>   <dt class="summary-signature"> <a href="#and/2">left and right</a> </dt> <dd class="summary-synopsis">
<p>Boolean and</p> </dd>   <dt class="summary-signature"> <a href="#binding/1">binding(context \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Returns the binding for the given context as a keyword list</p> </dd>   <dt class="summary-signature"> <a href="#def/2">def(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Defines a function with the given name and body</p> </dd>   <dt class="summary-signature"> <a href="#defdelegate/2">defdelegate(funs, opts)</a> </dt> <dd class="summary-synopsis">
<p>Defines a function that delegates to another module</p> </dd>   <dt class="summary-signature"> <a href="#defexception/1">defexception(fields)</a> </dt> <dd class="summary-synopsis">
<p>Defines an exception</p> </dd>   <dt class="summary-signature"> <a href="#defimpl/3">defimpl(name, opts, do_block \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Defines an implementation for the given protocol</p> </dd>   <dt class="summary-signature"> <a href="#defmacro/2">defmacro(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Defines a macro with the given name and body</p> </dd>   <dt class="summary-signature"> <a href="#defmacrop/2">defmacrop(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Defines a private macro with the given name and body</p> </dd>   <dt class="summary-signature"> <a href="#defmodule/2">defmodule(alias, do_block)</a> </dt> <dd class="summary-synopsis">
<p>Defines a module given by name with the given contents</p> </dd>   <dt class="summary-signature"> <a href="#defoverridable/1">defoverridable(keywords)</a> </dt> <dd class="summary-synopsis">
<p>Makes the given functions in the current module overridable</p> </dd>   <dt class="summary-signature"> <a href="#defp/2">defp(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Defines a private function with the given name and body</p> </dd>   <dt class="summary-signature"> <a href="#defprotocol/2">defprotocol(name, do_block)</a> </dt> <dd class="summary-synopsis">
<p>Defines a protocol</p> </dd>   <dt class="summary-signature"> <a href="#defstruct/1">defstruct(fields)</a> </dt> <dd class="summary-synopsis">
<p>Defines a struct</p> </dd>   <dt class="summary-signature"> <a href="#destructure/2">destructure(left, right)</a> </dt> <dd class="summary-synopsis">
<p>Destructures two lists, assigning each term in the right one to the matching term in the left one</p> </dd>   <dt class="summary-signature"> <a href="#get_and_update_in/2">get_and_update_in(path, fun)</a> </dt> <dd class="summary-synopsis">
<p>Gets a value and updates a nested data structure via the given <code class="inline">path</code></p> </dd>   <dt class="summary-signature"> <a href="#if/2">if(condition, clauses)</a> </dt> <dd class="summary-synopsis">
<p>Provides an <a href="#if/2"><code class="inline">if/2</code></a> macro</p> </dd>   <dt class="summary-signature"> <a href="#in/2">left in right</a> </dt> <dd class="summary-synopsis">
<p>Checks if the element on the left-hand side is a member of the collection on the right-hand side</p> </dd>   <dt class="summary-signature"> <a href="#is_nil/1">is_nil(term)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">term</code> is <code class="inline">nil</code>, <code class="inline">false</code> otherwise</p> </dd>   <dt class="summary-signature"> <a href="#match?/2">match?(pattern, expr)</a> </dt> <dd class="summary-synopsis">
<p>A convenience macro that checks if the right side (an expression) matches the left side (a pattern)</p> </dd>   <dt class="summary-signature"> <a href="#or/2">left or right</a> </dt> <dd class="summary-synopsis">
<p>Boolean or</p> </dd>   <dt class="summary-signature"> <a href="#pop_in/1">pop_in(path)</a> </dt> <dd class="summary-synopsis">
<p>Pops a key from the nested structure via the given <code class="inline">path</code></p> </dd>   <dt class="summary-signature"> <a href="#put_in/2">put_in(path, value)</a> </dt> <dd class="summary-synopsis">
<p>Puts a value in a nested structure via the given <code class="inline">path</code></p> </dd>   <dt class="summary-signature"> <a href="#raise/1">raise(msg)</a> </dt> <dd class="summary-synopsis">
<p>Raises an exception</p> </dd>   <dt class="summary-signature"> <a href="#raise/2">raise(exception, attrs)</a> </dt> <dd class="summary-synopsis">
<p>Raises an exception</p> </dd>   <dt class="summary-signature"> <a href="#reraise/2">reraise(msg, stacktrace)</a> </dt> <dd class="summary-synopsis">
<p>Raises an exception preserving a previous stacktrace</p> </dd>   <dt class="summary-signature"> <a href="#reraise/3">reraise(exception, attrs, stacktrace)</a> </dt> <dd class="summary-synopsis">
<p>Raises an exception preserving a previous stacktrace</p> </dd>   <dt class="summary-signature"> <a href="#sigil_C/2">sigil_C(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~C</code></p> </dd>   <dt class="summary-signature"> <a href="#sigil_D/2">sigil_D(date, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~D</code> for dates</p> </dd>   <dt class="summary-signature"> <a href="#sigil_N/2">sigil_N(date, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~N</code> for naive date times</p> </dd>   <dt class="summary-signature"> <a href="#sigil_R/2">sigil_R(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~R</code></p> </dd>   <dt class="summary-signature"> <a href="#sigil_S/2">sigil_S(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~S</code></p> </dd>   <dt class="summary-signature"> <a href="#sigil_T/2">sigil_T(date, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~T</code> for times</p> </dd>   <dt class="summary-signature"> <a href="#sigil_W/2">sigil_W(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~W</code></p> </dd>   <dt class="summary-signature"> <a href="#sigil_c/2">sigil_c(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~c</code></p> </dd>   <dt class="summary-signature"> <a href="#sigil_r/2">sigil_r(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~r</code></p> </dd>   <dt class="summary-signature"> <a href="#sigil_s/2">sigil_s(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~s</code></p> </dd>   <dt class="summary-signature"> <a href="#sigil_w/2">sigil_w(term, modifiers)</a> </dt> <dd class="summary-synopsis">
<p>Handles the sigil <code class="inline">~w</code></p> </dd>   <dt class="summary-signature"> <a href="#to_charlist/1">to_charlist(arg)</a> </dt> <dd class="summary-synopsis">
<p>Converts the argument to a charlist according to the <a href="../list.chars/"><code class="inline">List.Chars</code></a> protocol</p> </dd>   <dt class="summary-signature"> <a href="#to_string/1">to_string(arg)</a> </dt> <dd class="summary-synopsis">
<p>Converts the argument to a string according to the <a href="../string.chars/"><code class="inline">String.Chars</code></a> protocol</p> </dd>   <dt class="summary-signature"> <a href="#unless/2">unless(condition, clauses)</a> </dt> <dd class="summary-synopsis">
<p>Provides an <code class="inline">unless</code> macro</p> </dd>   <dt class="summary-signature"> <a href="#update_in/2">update_in(path, fun)</a> </dt> <dd class="summary-synopsis">
<p>Updates a nested structure via the given <code class="inline">path</code></p> </dd>   <dt class="summary-signature"> <a href="#use/2">use(module, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Uses the given module in the current context</p> </dd>   <dt class="summary-signature"> <a href="#var!/2">var!(var, context \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>When used inside quoting, marks that the given variable should not be hygienized</p> </dd>   <dt class="summary-signature"> <a href="#%7C%3E/2">left |&gt; right</a> </dt> <dd class="summary-synopsis">
<p>Pipe operator</p> </dd>   <dt class="summary-signature"> <a href="#%7C%7C/2">left || right</a> </dt> <dd class="summary-synopsis">
<p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to <code class="inline">true</code> (i.e., it is either <code class="inline">nil</code> or <code class="inline">false</code>). Returns the first expression otherwise</p> </dd>  </dl>   <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="!=/2">  <span class="signature">left != right</span>     </h3>
<pre data-language="elixir">term != term :: boolean</pre>  <p>Returns <code class="inline">true</code> if the two items are not equal.</p> <p>This operator considers 1 and 1.0 to be equal. For match comparison, use <code class="inline">!==</code> instead.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="!=/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 != 2
true

iex&gt; 1 != 1.0
false</code></pre>    <h3 class="detail-header function" id="!==/2">  <span class="signature">left !== right</span>     </h3>
<pre data-language="elixir">term !== term :: boolean</pre>  <p>Returns <code class="inline">true</code> if the two items are not exactly equal.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="!==/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 !== 2
true

iex&gt; 1 !== 1.0
true</code></pre>    <h3 class="detail-header function" id="*/2">  <span class="signature">left * right</span>        </h3>
<pre data-language="elixir">float * integer :: float</pre>
<pre data-language="elixir">integer * float :: float</pre>
<pre data-language="elixir">float * float :: float</pre>
<pre data-language="elixir">integer * integer :: integer</pre>  <p>Arithmetic multiplication.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="*/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 * 2
2</code></pre>    <h3 class="detail-header function" id="+/1">  <span class="signature">+value</span>     </h3>
<pre data-language="elixir">+value :: value when value: number</pre>  <p>Arithmetic unary plus.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="+/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; +1
1</code></pre>    <h3 class="detail-header function" id="+/2">  <span class="signature">left + right</span>        </h3>
<pre data-language="elixir">float + integer :: float</pre>
<pre data-language="elixir">integer + float :: float</pre>
<pre data-language="elixir">float + float :: float</pre>
<pre data-language="elixir">integer + integer :: integer</pre>  <p>Arithmetic addition.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="+/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 + 2
3</code></pre>    <h3 class="detail-header function" id="++/2">  <span class="signature">left ++ right</span>     </h3>
<pre data-language="elixir">list ++ term :: maybe_improper_list</pre>  <p>Concatenates a proper list and a term, returning a list.</p> <p>The complexity of <code class="inline">a ++ b</code> is proportional to <code class="inline">length(a)</code>, so avoid repeatedly appending to lists of arbitrary length, e.g. <code class="inline">list ++ [item]</code>. Instead, consider prepending via <code class="inline">[item | rest]</code> and then reversing.</p> <p>If the <code class="inline">right</code> operand is not a proper list, it returns an improper list. If the <code class="inline">left</code> operand is not a proper list, it raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a>.</p> <p>Inlined by the compiler.</p> <h4 id="++/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; [1] ++ [2, 3]
[1, 2, 3]

iex&gt; 'foo' ++ 'bar'
'foobar'

# returns an improper list
iex&gt; [1] ++ 2
[1 | 2]

# returns a proper list
iex&gt; [1] ++ [2]
[1, 2]

# improper list on the right will return an improper list
iex&gt; [1] ++ [2 | 3]
[1, 2 | 3]</code></pre>    <h3 class="detail-header function" id="-/1">  <span class="signature">-value</span>        </h3>
<pre data-language="elixir">-float :: float</pre>
<pre data-language="elixir">-neg_integer :: pos_integer</pre>
<pre data-language="elixir">-pos_integer :: neg_integer</pre>
<pre data-language="elixir">-0 :: 0</pre>  <p>Arithmetic unary minus.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="-/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; -2
-2</code></pre>    <h3 class="detail-header function" id="-/2">  <span class="signature">left - right</span>        </h3>
<pre data-language="elixir">float - integer :: float</pre>
<pre data-language="elixir">integer - float :: float</pre>
<pre data-language="elixir">float - float :: float</pre>
<pre data-language="elixir">integer - integer :: integer</pre>  <p>Arithmetic subtraction.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="-/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 - 2
-1</code></pre>    <h3 class="detail-header function" id="--/2">  <span class="signature">left -- right</span>     </h3>
<pre data-language="elixir">list -- list :: list</pre>  <p>Removes the first occurrence of an item on the left list for each item on the right.</p> <p>The complexity of <code class="inline">a -- b</code> is proportional to <code class="inline">length(a) * length(b)</code>, meaning that it will be very slow if both <code class="inline">a</code> and <code class="inline">b</code> are long lists. In such cases, consider converting each list to a <a href="../mapset/"><code class="inline">MapSet</code></a> and using <a href="../mapset/#difference/2"><code class="inline">MapSet.difference/2</code></a>.</p> <p>Inlined by the compiler.</p> <h4 id="--/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; [1, 2, 3] -- [1, 2]
[3]

iex&gt; [1, 2, 3, 2, 1] -- [1, 2, 2]
[3, 1]</code></pre>    <h3 class="detail-header function" id="//2">  <span class="signature">left / right</span>     </h3>
<pre data-language="elixir">number / number :: float</pre>  <p>Arithmetic division.</p> <p>The result is always a float. Use <a href="#div/2"><code class="inline">div/2</code></a> and <a href="#rem/2"><code class="inline">rem/2</code></a> if you want an integer division or the remainder.</p> <p>Raises <a href="../arithmeticerror/"><code class="inline">ArithmeticError</code></a> if <code class="inline">right</code> is 0 or 0.0.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="//2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">1 / 2
#=&gt; 0.5

-3.0 / 2.0
#=&gt; -1.5

5 / 1
#=&gt; 5.0

7 / 0
#=&gt; ** (ArithmeticError) bad argument in arithmetic expression</code></pre>    <h3 class="detail-header function" id="%3C/2">  <span class="signature">left &lt; right</span>     </h3>
<pre data-language="elixir">term &lt; term :: boolean</pre>  <p>Returns <code class="inline">true</code> if left is less than right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="%3C/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 &lt; 2
true</code></pre>    <h3 class="detail-header function" id="%3C=/2">  <span class="signature">left &lt;= right</span>     </h3>
<pre data-language="elixir">term &lt;= term :: boolean</pre>  <p>Returns <code class="inline">true</code> if left is less than or equal to right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="%3C=/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 &lt;= 2
true</code></pre>    <h3 class="detail-header function" id="==/2">  <span class="signature">left == right</span>     </h3>
<pre data-language="elixir">term == term :: boolean</pre>  <p>Returns <code class="inline">true</code> if the two items are equal.</p> <p>This operator considers 1 and 1.0 to be equal. For stricter semantics, use <code class="inline">===</code> instead.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="==/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 == 2
false

iex&gt; 1 == 1.0
true</code></pre>    <h3 class="detail-header function" id="===/2">  <span class="signature">left === right</span>     </h3>
<pre data-language="elixir">term === term :: boolean</pre>  <p>Returns <code class="inline">true</code> if the two items are exactly equal.</p> <p>The items are only considered to be exactly equal if they have the same value and are of the same type. For example, <code class="inline">1 == 1.0</code> returns true, but since they are of different types, <code class="inline">1 === 1.0</code> returns false.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="===/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 === 2
false

iex&gt; 1 === 1.0
false</code></pre>    <h3 class="detail-header function" id="=~/2">  <span class="signature">left =~ right</span>     </h3>
<pre data-language="elixir"><a href="../string/#t:t/0">String.t</a> =~ <a href="../string/#t:t/0">String.t</a> | <a href="../regex/#t:t/0">Regex.t</a> :: boolean</pre>  <p>Matches the term on the left against the regular expression or string on the right.</p> <p>Returns <code class="inline">true</code> if <code class="inline">left</code> matches <code class="inline">right</code> (if it’s a regular expression) or contains <code class="inline">right</code> (if it’s a string).</p> <h4 id="=~/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; "abcd" =~ ~r/c(d)/
true

iex&gt; "abcd" =~ ~r/e/
false

iex&gt; "abcd" =~ "bc"
true

iex&gt; "abcd" =~ "ad"
false

iex&gt; "abcd" =~ ""
true</code></pre>    <h3 class="detail-header function" id="%3E/2">  <span class="signature">left &gt; right</span>     </h3>
<pre data-language="elixir">term &gt; term :: boolean</pre>  <p>Returns <code class="inline">true</code> if left is more than right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="%3E/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 &gt; 2
false</code></pre>    <h3 class="detail-header function" id="%3E=/2">  <span class="signature">left &gt;= right</span>     </h3>
<pre data-language="elixir">term &gt;= term :: boolean</pre>  <p>Returns <code class="inline">true</code> if left is more than or equal to right.</p> <p>All terms in Elixir can be compared with each other.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="%3E=/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 1 &gt;= 2
false</code></pre>    <h3 class="detail-header function" id="abs/1">  <span class="signature">abs(number)</span>     </h3>
<pre data-language="elixir">abs(number) :: number</pre>  <p>Returns an integer or float which is the arithmetical absolute value of <code class="inline">number</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="abs/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; abs(-3.33)
3.33

iex&gt; abs(-3)
3</code></pre>    <h3 class="detail-header function" id="apply/2">  <span class="signature">apply(fun, args)</span>     </h3>
<pre data-language="elixir">apply((... -&gt; any), [any]) :: any</pre>  <p>Invokes the given <code class="inline">fun</code> with the list of arguments <code class="inline">args</code>.</p> <p>Inlined by the compiler.</p> <h4 id="apply/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; apply(fn x -&gt; x * 2 end, [2])
4</code></pre>    <h3 class="detail-header function" id="apply/3">  <span class="signature">apply(module, fun, args)</span>     </h3>
<pre data-language="elixir">apply(module, atom, [any]) :: any</pre>  <p>Invokes the given <code class="inline">fun</code> from <code class="inline">module</code> with the list of arguments <code class="inline">args</code>.</p> <p>Inlined by the compiler.</p> <h4 id="apply/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; apply(Enum, :reverse, [[1, 2, 3]])
[3, 2, 1]</code></pre>    <h3 class="detail-header function" id="binary_part/3">  <span class="signature">binary_part(binary, start, length)</span>     </h3>
<pre data-language="elixir">binary_part(binary, pos_integer, integer) :: binary</pre>  <p>Extracts the part of the binary starting at <code class="inline">start</code> with length <code class="inline">length</code>. Binaries are zero-indexed.</p> <p>If <code class="inline">start</code> or <code class="inline">length</code> reference in any way outside the binary, an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="binary_part/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; binary_part("foo", 1, 2)
"oo"</code></pre> <p>A negative <code class="inline">length</code> can be used to extract bytes that come <em>before</em> the byte at <code class="inline">start</code>:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; binary_part("Hello", 5, -3)
"llo"</code></pre>    <h3 class="detail-header function" id="bit_size/1">  <span class="signature">bit_size(bitstring)</span>     </h3>
<pre data-language="elixir">bit_size(bitstring) :: non_neg_integer</pre>  <p>Returns an integer which is the size in bits of <code class="inline">bitstring</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="bit_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; bit_size(&lt;&lt;433::16, 3::3&gt;&gt;)
19

iex&gt; bit_size(&lt;&lt;1, 2, 3&gt;&gt;)
24</code></pre>    <h3 class="detail-header function" id="byte_size/1">  <span class="signature">byte_size(bitstring)</span>     </h3>
<pre data-language="elixir">byte_size(bitstring) :: non_neg_integer</pre>  <p>Returns the number of bytes needed to contain <code class="inline">bitstring</code>.</p> <p>That is, if the number of bits in <code class="inline">bitstring</code> is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="byte_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; byte_size(&lt;&lt;433::16, 3::3&gt;&gt;)
3

iex&gt; byte_size(&lt;&lt;1, 2, 3&gt;&gt;)
3</code></pre>    <h3 class="detail-header function" id="div/2">  <span class="signature">div(dividend, divisor)</span>     </h3>
<pre data-language="elixir">div(integer, neg_integer | pos_integer) :: integer</pre>  <p>Performs an integer division.</p> <p>Raises an <a href="../arithmeticerror/"><code class="inline">ArithmeticError</code></a> exception if one of the arguments is not an integer, or when the <code class="inline">divisor</code> is <code class="inline">0</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <p><a href="#div/2"><code class="inline">div/2</code></a> performs <em>truncated</em> integer division. This means that the result is always rounded towards zero.</p> <p>If you want to perform floored integer division (rounding towards negative infinity), use <a href="../integer/#floor_div/2"><code class="inline">Integer.floor_div/2</code></a> instead.</p> <h4 id="div/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">div(5, 2)
#=&gt; 2

div(6, -4)
#=&gt; -1

div(-99, 2)
#=&gt; -49

div(100, 0)
#=&gt; ** (ArithmeticError) bad argument in arithmetic expression</code></pre>    <h3 class="detail-header function" id="elem/2">  <span class="signature">elem(tuple, index)</span>     </h3>
<pre data-language="elixir">elem(tuple, non_neg_integer) :: term</pre>  <p>Gets the element at the zero-based <code class="inline">index</code> in <code class="inline">tuple</code>.</p> <p>It raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> when index is negative or it is out of range of the tuple elements.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="elem/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">tuple = {:foo, :bar, 3}
elem(tuple, 1)
#=&gt; :bar

elem({}, 0)
#=&gt; ** (ArgumentError) argument error

elem({:foo, :bar}, 2)
#=&gt; ** (ArgumentError) argument error</code></pre>    <h3 class="detail-header function" id="exit/1">  <span class="signature">exit(reason)</span>     </h3>
<pre data-language="elixir">exit(term) :: no_return</pre>  <p>Stops the execution of the calling process with the given reason.</p> <p>Since evaluating this function causes the process to terminate, it has no return value.</p> <p>Inlined by the compiler.</p> <h4 id="exit/1-examples" class="section-heading">  Examples </h4> <p>When a process reaches its end, by default it exits with reason <code class="inline">:normal</code>. You can also call <a href="#exit/1"><code class="inline">exit/1</code></a> explicitly if you want to terminate a process but not signal any failure:</p> <pre data-language="elixir"><code class="elixir">exit(:normal)</code></pre> <p>In case something goes wrong, you can also use <a href="#exit/1"><code class="inline">exit/1</code></a> with a different reason:</p> <pre data-language="elixir"><code class="elixir">exit(:seems_bad)</code></pre> <p>If the exit reason is not <code class="inline">:normal</code>, all the processes linked to the process that exited will crash (unless they are trapping exits).</p> <h4 id="exit/1-otp-exits" class="section-heading">  OTP exits </h4> <p>Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered “normal”:</p> <ul> <li>
<code class="inline">exit(:normal)</code> </li> <li>
<code class="inline">exit(:shutdown)</code> </li> <li>
<code class="inline">exit({:shutdown, term})</code> </li> </ul> <p>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, etc.</p> <p>This behaviour is relied on in many different places. For example, <code class="inline">ExUnit</code> uses <code class="inline">exit(:shutdown)</code> when exiting the test process to signal linked processes, supervision trees and so on to politely shutdown too.</p> <h4 id="exit/1-cli-exits" class="section-heading">  CLI exits </h4> <p>Building on top of the exit signals mentioned above, if the process started by the command line exits with any of the three reasons above, its exit is considered normal and the Operating System process will exit with status 0.</p> <p>It is, however, possible to customize the Operating System exit signal by invoking:</p> <pre data-language="elixir"><code class="elixir">exit({:shutdown, integer})</code></pre> <p>This will cause the OS process to exit with the status given by <code class="inline">integer</code> while signaling all linked OTP processes to politely shutdown.</p> <p>Any other exit reason will cause the OS process to exit with status <code class="inline">1</code> and linked OTP processes to crash.</p>    <h3 class="detail-header function" id="function_exported?/3">  <span class="signature">function_exported?(module, function, arity)</span>     </h3>
<pre data-language="elixir">function_exported?(module, atom, arity) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">function</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code>.</p> <p>Note that this function does not load the module in case it is not loaded. Check <a href="../code/#ensure_loaded/1"><code class="inline">Code.ensure_loaded/1</code></a> for more information.</p> <h4 id="function_exported?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; function_exported?(Enum, :member?, 2)
true</code></pre>    <h3 class="detail-header function" id="get_and_update_in/3">  <span class="signature">get_and_update_in(data, keys, fun)</span>     </h3>
<pre data-language="elixir">get_and_update_in(structure :: <a href="../access/#t:t/0">Access.t</a>, keys, (term -&gt; {get_value, update_value} | :pop)) :: {get_value, structure :: <a href="../access/#t:t/0">Access.t</a>} when keys: [any, ...], update_value: term, get_value: var</pre>  <p>Gets a value and updates a nested structure.</p> <p><code class="inline">data</code> is a nested structure (ie. a map, keyword list, or struct that implements the <a href="../access/"><code class="inline">Access</code></a> behaviour).</p> <p>The <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present) and must return a two-element tuple: the “get” value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>. The <code class="inline">fun</code> may also return <code class="inline">:pop</code>, implying the current value shall be removed from the structure and returned.</p> <p>It uses the <a href="../access/"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function.</p> <p>If a key is a function, the function will be invoked passing three arguments, the operation (<code class="inline">:get_and_update</code>), the data to be accessed, and a function to be invoked next.</p> <p>This means <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a> can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</p> <h4 id="get_and_update_in/3-examples" class="section-heading">  Examples </h4> <p>This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to increase the age of a user by one and return the previous age in one pass:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_and_update_in(users, ["john", :age], &amp;{&amp;1, &amp;1 + 1})
{27, %{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}}</code></pre> <p>When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = [%{name: "john", age: 27}, %{name: "meg", age: 23}]
iex&gt; all = fn :get_and_update, data, next -&gt;
...&gt;   Enum.map(data, next) |&gt; :lists.unzip
...&gt; end
iex&gt; get_and_update_in(users, [all, :age], &amp;{&amp;1, &amp;1 + 1})
{[27, 23], [%{name: "john", age: 28}, %{name: "meg", age: 24}]}</code></pre> <p>If the previous value before invoking the function is <code class="inline">nil</code>, the function <em>will</em> receive <code class="inline">nil</code> as a value and must handle it accordingly (be it by failing or providing a sane default).</p> <p>The <a href="../access/"><code class="inline">Access</code></a> module ships with many convenience accessor functions, like the <code class="inline">all</code> anonymous function defined above. See <a href="../access/#all/0"><code class="inline">Access.all/0</code></a>, <a href="../access/#key/2"><code class="inline">Access.key/2</code></a> and others as examples.</p>    <h3 class="detail-header function" id="get_in/2">  <span class="signature">get_in(data, keys)</span>     </h3>
<pre data-language="elixir">get_in(<a href="../access/#t:t/0">Access.t</a>, [term, ...]) :: term</pre>  <p>Gets a value from a nested structure.</p> <p>Uses the <a href="../access/"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function.</p> <p>If a key is a function, the function will be invoked passing three arguments, the operation (<code class="inline">:get</code>), the data to be accessed, and a function to be invoked next.</p> <p>This means <a href="#get_in/2"><code class="inline">get_in/2</code></a> can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</p> <h4 id="get_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_in(users, ["john", :age])
27</code></pre> <p>In case any of entries in the middle returns <code class="inline">nil</code>, <code class="inline">nil</code> will be returned as per the Access module:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_in(users, ["unknown", :age])
nil</code></pre> <p>When one of the keys is a function, the function is invoked. In the example below, we use a function to get all the maps inside a list:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = [%{name: "john", age: 27}, %{name: "meg", age: 23}]
iex&gt; all = fn :get, data, next -&gt; Enum.map(data, next) end
iex&gt; get_in(users, [all, :age])
[27, 23]</code></pre> <p>If the previous value before invoking the function is <code class="inline">nil</code>, the function <em>will</em> receive nil as a value and must handle it accordingly.</p>    <h3 class="detail-header function" id="hd/1">  <span class="signature">hd(list)</span>     </h3>
<pre data-language="elixir">hd(nonempty_maybe_improper_list(elem, any)) :: elem when elem: term</pre>  <p>Returns the head of a list. Raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the list is empty.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="hd/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">hd([1, 2, 3, 4])
#=&gt; 1

hd([])
#=&gt; ** (ArgumentError) argument error</code></pre>     <h3 class="detail-header function" id="inspect/2">  <span class="signature">inspect(arg, opts \\ [])</span>     </h3>
<pre data-language="elixir">inspect(<a href="../inspect/#t:t/0">Inspect.t</a>, <a href="../keyword/#t:t/0">Keyword.t</a>) :: <a href="../string/#t:t/0">String.t</a></pre>  <p>Inspects the given argument according to the <a href="../inspect/"><code class="inline">Inspect</code></a> protocol. The second argument is a keyword list with options to control inspection.</p> <h4 id="inspect/2-options" class="section-heading">  Options </h4> <p><a href="#inspect/2"><code class="inline">inspect/2</code></a> accepts a list of options that are internally translated to an <a href="../inspect.opts/"><code class="inline">Inspect.Opts</code></a> struct. Check the docs for <a href="../inspect.opts/"><code class="inline">Inspect.Opts</code></a> to see the supported options.</p> <h4 id="inspect/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; inspect(:foo)
":foo"

iex&gt; inspect [1, 2, 3, 4, 5], limit: 3
"[1, 2, 3, ...]"

iex&gt; inspect [1, 2, 3], pretty: true, width: 0
"[1,\n 2,\n 3]"

iex&gt; inspect("olá" &lt;&gt; &lt;&lt;0&gt;&gt;)
"&lt;&lt;111, 108, 195, 161, 0&gt;&gt;"

iex&gt; inspect("olá" &lt;&gt; &lt;&lt;0&gt;&gt;, binaries: :as_strings)
"\"olá\\0\""

iex&gt; inspect("olá", binaries: :as_binaries)
"&lt;&lt;111, 108, 195, 161&gt;&gt;"

iex&gt; inspect('bar')
"'bar'"

iex&gt; inspect([0 | 'bar'])
"[0, 98, 97, 114]"

iex&gt; inspect(100, base: :octal)
"0o144"

iex&gt; inspect(100, base: :hex)
"0x64"</code></pre> <p>Note that the <a href="../inspect/"><code class="inline">Inspect</code></a> protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with <code class="inline">#</code>. For example, inspecting a function will return:</p> <pre data-language="elixir"><code class="elixir">inspect fn a, b -&gt; a + b end
#=&gt; #Function&lt;...&gt;</code></pre>    <h3 class="detail-header function" id="is_atom/1">  <span class="signature">is_atom(term)</span>     </h3>
<pre data-language="elixir">is_atom(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an atom; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_binary/1">  <span class="signature">is_binary(term)</span>     </h3>
<pre data-language="elixir">is_binary(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a binary; otherwise returns <code class="inline">false</code>.</p> <p>A binary always contains a complete number of bytes.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="is_binary/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; is_binary "foo"
true
iex&gt; is_binary &lt;&lt;1::3&gt;&gt;
false</code></pre>    <h3 class="detail-header function" id="is_bitstring/1">  <span class="signature">is_bitstring(term)</span>     </h3>
<pre data-language="elixir">is_bitstring(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a bitstring (including a binary); otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="is_bitstring/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; is_bitstring "foo"
true
iex&gt; is_bitstring &lt;&lt;1::3&gt;&gt;
true</code></pre>    <h3 class="detail-header function" id="is_boolean/1">  <span class="signature">is_boolean(term)</span>     </h3>
<pre data-language="elixir">is_boolean(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either the atom <code class="inline">true</code> or the atom <code class="inline">false</code> (i.e., a boolean); otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_float/1">  <span class="signature">is_float(term)</span>     </h3>
<pre data-language="elixir">is_float(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a floating point number; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_function/1">  <span class="signature">is_function(term)</span>     </h3>
<pre data-language="elixir">is_function(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_function/2">  <span class="signature">is_function(term, arity)</span>     </h3>
<pre data-language="elixir">is_function(term, non_neg_integer) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function that can be applied with <code class="inline">arity</code> number of arguments; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="is_function/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; is_function(fn(x) -&gt; x * 2 end, 1)
true
iex&gt; is_function(fn(x) -&gt; x * 2 end, 2)
false</code></pre>    <h3 class="detail-header function" id="is_integer/1">  <span class="signature">is_integer(term)</span>     </h3>
<pre data-language="elixir">is_integer(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an integer; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_list/1">  <span class="signature">is_list(term)</span>     </h3>
<pre data-language="elixir">is_list(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a list with zero or more elements; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_map/1">  <span class="signature">is_map(term)</span>     </h3>
<pre data-language="elixir">is_map(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a map; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_number/1">  <span class="signature">is_number(term)</span>     </h3>
<pre data-language="elixir">is_number(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either an integer or a floating point number; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_pid/1">  <span class="signature">is_pid(term)</span>     </h3>
<pre data-language="elixir">is_pid(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a PID (process identifier); otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_port/1">  <span class="signature">is_port(term)</span>     </h3>
<pre data-language="elixir">is_port(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a port identifier; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_reference/1">  <span class="signature">is_reference(term)</span>     </h3>
<pre data-language="elixir">is_reference(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a reference; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="is_tuple/1">  <span class="signature">is_tuple(term)</span>     </h3>
<pre data-language="elixir">is_tuple(term) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a tuple; otherwise returns <code class="inline">false</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="length/1">  <span class="signature">length(list)</span>     </h3>
<pre data-language="elixir">length(list) :: non_neg_integer</pre>  <p>Returns the length of <code class="inline">list</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="length/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; length([1, 2, 3, 4, 5, 6, 7, 8, 9])
9</code></pre>    <h3 class="detail-header function" id="macro_exported?/3">  <span class="signature">macro_exported?(module, macro, arity)</span>     </h3>
<pre data-language="elixir">macro_exported?(module, atom, arity) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">macro</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code>.</p> <p>Note that this function does not load the module in case it is not loaded. Check <a href="../code/#ensure_loaded/1"><code class="inline">Code.ensure_loaded/1</code></a> for more information.</p> <p>If <code class="inline">module</code> is an Erlang module (as opposed to an Elixir module), this function always returns <code class="inline">false</code>.</p> <h4 id="macro_exported?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; macro_exported?(Kernel, :use, 2)
true

iex&gt; macro_exported?(:erlang, :abs, 1)
false</code></pre>    <h3 class="detail-header function" id="make_ref/0">  <span class="signature">make_ref()</span>     </h3>
<pre data-language="elixir">make_ref() :: reference</pre>  <p>Returns an almost unique reference.</p> <p>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</p> <p>Inlined by the compiler.</p> <h4 id="make_ref/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">make_ref() #=&gt; #Reference&lt;0.0.0.135&gt;</code></pre>    <h3 class="detail-header function" id="map_size/1">  <span class="signature">map_size(map)</span>     </h3>
<pre data-language="elixir">map_size(map) :: non_neg_integer</pre>  <p>Returns the size of a map.</p> <p>The size of a map is the number of key-value pairs that the map contains.</p> <p>This operation happens in constant time.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="map_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; map_size(%{a: "foo", b: "bar"})
2</code></pre>    <h3 class="detail-header function" id="max/2">  <span class="signature">max(first, second)</span>     </h3>
<pre data-language="elixir">max(first, second) ::
  first |
  second when first: term, second: term</pre>  <p>Returns the biggest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned.</p> <p>Inlined by the compiler.</p> <h4 id="max/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; max(1, 2)
2
iex&gt; max(:a, :b)
:b</code></pre>    <h3 class="detail-header function" id="min/2">  <span class="signature">min(first, second)</span>     </h3>
<pre data-language="elixir">min(first, second) ::
  first |
  second when first: term, second: term</pre>  <p>Returns the smallest of the two given terms according to Erlang’s term ordering. If the terms compare equal, the first one is returned.</p> <p>Inlined by the compiler.</p> <h4 id="min/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; min(1, 2)
1
iex&gt; min("foo", "bar")
"bar"</code></pre>    <h3 class="detail-header function" id="node/0">  <span class="signature">node()</span>     </h3>
<pre data-language="elixir">node() :: node</pre>  <p>Returns an atom representing the name of the local node. If the node is not alive, <code class="inline">:nonode@nohost</code> is returned instead.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="node/1">  <span class="signature">node(arg)</span>     </h3>
<pre data-language="elixir">node(pid | reference | port) :: node</pre>  <p>Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, <code class="inline">:nonode@nohost</code> is returned.</p> <p>Allowed in guard tests. Inlined by the compiler.</p>    <h3 class="detail-header function" id="not/1">  <span class="signature">not arg</span>      </h3>
<pre data-language="elixir">not false :: true</pre>
<pre data-language="elixir">not true :: false</pre>  <p>Boolean not.</p> <p><code class="inline">arg</code> must be a boolean; if it’s not, an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="not/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; not false
true</code></pre>    <h3 class="detail-header function" id="pop_in/2">  <span class="signature">pop_in(data, keys)</span>     </h3>
<pre data-language="elixir">pop_in(<a href="../access/#t:t/0">Access.t</a>, [term, ...]) :: {term, <a href="../access/#t:t/0">Access.t</a>}</pre>  <p>Pops a key from the given nested structure.</p> <p>Uses the <a href="../access/"><code class="inline">Access</code></a> protocol to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function. If the key is a function, it will be invoked as specified in <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>.</p> <h4 id="pop_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; pop_in(users, ["john", :age])
{27, %{"john" =&gt; %{}, "meg" =&gt; %{age: 23}}}</code></pre> <p>In case any entry returns <code class="inline">nil</code>, its key will be removed and the deletion will be considered a success.</p>    <h3 class="detail-header function" id="put_elem/3">  <span class="signature">put_elem(tuple, index, value)</span>     </h3>
<pre data-language="elixir">put_elem(tuple, non_neg_integer, term) :: tuple</pre>  <p>Inserts <code class="inline">value</code> at the given zero-based <code class="inline">index</code> in <code class="inline">tuple</code>.</p> <p>Inlined by the compiler.</p> <h4 id="put_elem/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; tuple = {:foo, :bar, 3}
iex&gt; put_elem(tuple, 0, :baz)
{:baz, :bar, 3}</code></pre>    <h3 class="detail-header function" id="put_in/3">  <span class="signature">put_in(data, keys, value)</span>     </h3>
<pre data-language="elixir">put_in(<a href="../access/#t:t/0">Access.t</a>, [term, ...], term) :: <a href="../access/#t:t/0">Access.t</a></pre>  <p>Puts a value in a nested structure.</p> <p>Uses the <a href="../access/"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function. If the key is a function, it will be invoked as specified in <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>.</p> <h4 id="put_in/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; put_in(users, ["john", :age], 28)
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</code></pre> <p>In case any of entries in the middle returns <code class="inline">nil</code>, an error will be raised when trying to access it next.</p>    <h3 class="detail-header function" id="rem/2">  <span class="signature">rem(dividend, divisor)</span>     </h3>
<pre data-language="elixir">rem(integer, neg_integer | pos_integer) :: integer</pre>  <p>Computes the remainder of an integer division.</p> <p><a href="#rem/2"><code class="inline">rem/2</code></a> uses truncated division, which means that the result will always have the sign of the <code class="inline">dividend</code>.</p> <p>Raises an <a href="../arithmeticerror/"><code class="inline">ArithmeticError</code></a> exception if one of the arguments is not an integer, or when the <code class="inline">divisor</code> is <code class="inline">0</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="rem/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; rem(5, 2)
1
iex&gt; rem(6, -4)
2</code></pre>    <h3 class="detail-header function" id="round/1">  <span class="signature">round(number)</span>      </h3>
<pre data-language="elixir">round(value) :: value when value: integer</pre>
<pre data-language="elixir">round(float) :: integer</pre>  <p>Rounds a number to the nearest integer.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="round/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; round(5.6)
6

iex&gt; round(5.2)
5

iex&gt; round(-9.9)
-10

iex&gt; round(-9)
-9</code></pre>    <h3 class="detail-header function" id="self/0">  <span class="signature">self()</span>     </h3>
<pre data-language="elixir">self() :: pid</pre>  <p>Returns the PID (process identifier) of the calling process.</p> <p>Allowed in guard clauses. Inlined by the compiler.</p>    <h3 class="detail-header function" id="send/2">  <span class="signature">send(dest, msg)</span>     </h3>
<pre data-language="elixir">send(dest :: pid | port | atom | {atom, node}, msg) :: msg when msg: any</pre>  <p>Sends a message to the given <code class="inline">dest</code> and returns the message.</p> <p><code class="inline">dest</code> may be a remote or local PID, a (local) port, a locally registered name, or a tuple <code class="inline">{registered_name, node}</code> for a registered name at another node.</p> <p>Inlined by the compiler.</p> <h4 id="send/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; send self(), :hello
:hello</code></pre>    <h3 class="detail-header function" id="spawn/1">  <span class="signature">spawn(fun)</span>     </h3>
<pre data-language="elixir">spawn((() -&gt; any)) :: pid</pre>  <p>Spawns the given function and returns its PID.</p> <p>Check the <a href="../process/"><code class="inline">Process</code></a> and <a href="../node/"><code class="inline">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>The anonymous function receives 0 arguments, and may return any value.</p> <p>Inlined by the compiler.</p> <h4 id="spawn/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">current = self()
child   = spawn(fn -&gt; send current, {self(), 1 + 2} end)

receive do
  {^child, 3} -&gt; IO.puts "Received 3 back"
end</code></pre>    <h3 class="detail-header function" id="spawn/3">  <span class="signature">spawn(module, fun, args)</span>     </h3>
<pre data-language="elixir">spawn(module, atom, list) :: pid</pre>  <p>Spawns the given module and function passing the given args and returns its PID.</p> <p>Check the <a href="../process/"><code class="inline">Process</code></a> and <a href="../node/"><code class="inline">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4 id="spawn/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">spawn(SomeModule, :function, [1, 2, 3])</code></pre>    <h3 class="detail-header function" id="spawn_link/1">  <span class="signature">spawn_link(fun)</span>     </h3>
<pre data-language="elixir">spawn_link((() -&gt; any)) :: pid</pre>  <p>Spawns the given function, links it to the current process and returns its PID.</p> <p>Check the <a href="../process/"><code class="inline">Process</code></a> and <a href="../node/"><code class="inline">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>The anonymous function receives 0 arguments, and may return any value.</p> <p>Inlined by the compiler.</p> <h4 id="spawn_link/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">current = self()
child   = spawn_link(fn -&gt; send current, {self(), 1 + 2} end)

receive do
  {^child, 3} -&gt; IO.puts "Received 3 back"
end</code></pre>    <h3 class="detail-header function" id="spawn_link/3">  <span class="signature">spawn_link(module, fun, args)</span>     </h3>
<pre data-language="elixir">spawn_link(module, atom, list) :: pid</pre>  <p>Spawns the given module and function passing the given args, links it to the current process and returns its PID.</p> <p>Check the <a href="../process/"><code class="inline">Process</code></a> and <a href="../node/"><code class="inline">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4 id="spawn_link/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">spawn_link(SomeModule, :function, [1, 2, 3])</code></pre>    <h3 class="detail-header function" id="spawn_monitor/1">  <span class="signature">spawn_monitor(fun)</span>     </h3>
<pre data-language="elixir">spawn_monitor((() -&gt; any)) :: {pid, reference}</pre>  <p>Spawns the given function, monitors it and returns its PID and monitoring reference.</p> <p>Check the <a href="../process/"><code class="inline">Process</code></a> and <a href="../node/"><code class="inline">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>The anonymous function receives 0 arguments, and may return any value.</p> <p>Inlined by the compiler.</p> <h4 id="spawn_monitor/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">current = self()
spawn_monitor(fn -&gt; send current, {self(), 1 + 2} end)</code></pre>    <h3 class="detail-header function" id="spawn_monitor/3">  <span class="signature">spawn_monitor(module, fun, args)</span>     </h3>
<pre data-language="elixir">spawn_monitor(module, atom, list) :: {pid, reference}</pre>  <p>Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference.</p> <p>Check the <a href="../process/"><code class="inline">Process</code></a> and <a href="../node/"><code class="inline">Node</code></a> modules for other functions to handle processes, including spawning functions in nodes.</p> <p>Inlined by the compiler.</p> <h4 id="spawn_monitor/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">spawn_monitor(SomeModule, :function, [1, 2, 3])</code></pre>     <h3 class="detail-header function" id="struct/2">  <span class="signature">struct(struct, kv \\ [])</span>     </h3>
<pre data-language="elixir">struct(module | struct, <a href="../enum/#t:t/0">Enum.t</a>) :: struct</pre>  <p>Creates and updates structs.</p> <p>The <code class="inline">struct</code> argument may be an atom (which defines <code class="inline">defstruct</code>) or a <code class="inline">struct</code> itself. The second argument is any <a href="../enumerable/"><code class="inline">Enumerable</code></a> that emits two-element tuples (key-value pairs) during enumeration.</p> <p>Keys in the <a href="../enumerable/"><code class="inline">Enumerable</code></a> that don’t exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</p> <p>This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate <code class="inline">:__struct__</code> field into the map may not be enough and <a href="#struct/2"><code class="inline">struct/2</code></a> should be used instead.</p> <h4 id="struct/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">defmodule User do
  defstruct name: "john"
end

struct(User)
#=&gt; %User{name: "john"}

opts = [name: "meg"]
user = struct(User, opts)
#=&gt; %User{name: "meg"}

struct(user, unknown: "value")
#=&gt; %User{name: "meg"}

struct(User, %{name: "meg"})
#=&gt; %User{name: "meg"}

# String keys are ignored
struct(User, %{"name" =&gt; "meg"})
#=&gt; %User{name: "john"}</code></pre>     <h3 class="detail-header function" id="struct!/2">  <span class="signature">struct!(struct, kv \\ [])</span>     </h3>
<pre data-language="elixir">struct!(module | struct, <a href="../enum/#t:t/0">Enum.t</a>) :: struct | no_return</pre>  <p>Similar to <a href="#struct/2"><code class="inline">struct/2</code></a> but checks for key validity.</p> <p>The function <a href="#struct!/2"><code class="inline">struct!/2</code></a> emulates the compile time behaviour of structs. This means that:</p> <ul> <li>
<p>when building a struct, as in <code class="inline">struct!(SomeStruct, key: :value)</code>, it is equivalent to <code class="inline">%SomeStruct{key: :value}</code> and therefore this function will check if every given key-value belongs to the struct. If the struct is enforcing any key via <code class="inline">@enforce_keys</code>, those will be enforced as well;</p> </li> <li>when updating a struct, as in <code class="inline">struct!(%SomeStruct{}, key: :value)</code>, it is equivalent to <code class="inline">%SomeStruct{struct | key: :value}</code> and therefore this function will check if every given key-value belongs to the struct. However, updating structs does not enforce keys, as keys are enforced only when building; </li> </ul>    <h3 class="detail-header function" id="throw/1">  <span class="signature">throw(term)</span>     </h3>
<pre data-language="elixir">throw(term) :: no_return</pre>  <p>A non-local return from a function.</p> <p>Check <a href="../kernel.specialforms/#try/1"><code class="inline">Kernel.SpecialForms.try/1</code></a> for more information.</p> <p>Inlined by the compiler.</p>    <h3 class="detail-header function" id="tl/1">  <span class="signature">tl(list)</span>     </h3>
<pre data-language="elixir">tl(nonempty_maybe_improper_list(elem, tail)) ::
  maybe_improper_list(elem, tail) |
  tail when elem: term, tail: term</pre>  <p>Returns the tail of a list. Raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the list is empty.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="tl/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">tl([1, 2, 3, :go])
#=&gt; [2, 3, :go]

tl([])
#=&gt; ** (ArgumentError) argument error</code></pre>    <h3 class="detail-header function" id="trunc/1">  <span class="signature">trunc(number)</span>      </h3>
<pre data-language="elixir">trunc(float) :: integer</pre>
<pre data-language="elixir">trunc(value) :: value when value: integer</pre>  <p>Returns the integer part of <code class="inline">number</code>.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="trunc/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; trunc(5.4)
5

iex&gt; trunc(-5.99)
-5

iex&gt; trunc(-5)
-5</code></pre>    <h3 class="detail-header function" id="tuple_size/1">  <span class="signature">tuple_size(tuple)</span>     </h3>
<pre data-language="elixir">tuple_size(tuple) :: non_neg_integer</pre>  <p>Returns the size of a tuple.</p> <p>This operation happens in constant time.</p> <p>Allowed in guard tests. Inlined by the compiler.</p> <h4 id="tuple_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; tuple_size {:a, :b, :c}
3</code></pre>    <h3 class="detail-header function" id="update_in/3">  <span class="signature">update_in(data, keys, fun)</span>     </h3>
<pre data-language="elixir">update_in(<a href="../access/#t:t/0">Access.t</a>, [term, ...], (term -&gt; term)) :: <a href="../access/#t:t/0">Access.t</a></pre>  <p>Updates a key in a nested structure.</p> <p>Uses the <a href="../access/"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function. If the key is a function, it will be invoked as specified in <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>.</p> <h4 id="update_in/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; update_in(users, ["john", :age], &amp;(&amp;1 + 1))
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</code></pre> <p>In case any of entries in the middle returns <code class="inline">nil</code>, an error will be raised when trying to access it next.</p>     <h1 class="section-heading" id="macros">  Macros </h1>  <h3 class="detail-header macro" id="!/1">  <span class="signature">!arg</span>  </h3>  <p>Boolean not.</p> <p>Receives any argument (not just booleans) and returns <code class="inline">true</code> if the argument is <code class="inline">false</code> or <code class="inline">nil</code>; returns <code class="inline">false</code> otherwise.</p> <p>Not allowed in guard clauses.</p> <h4 id="!/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; !Enum.empty?([])
false

iex&gt; !List.first([])
true</code></pre>    <h3 class="detail-header macro" id="&amp;&amp;/2">  <span class="signature">left &amp;&amp; right</span>  </h3>  <p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to <code class="inline">true</code> (i.e., it is neither <code class="inline">nil</code> nor <code class="inline">false</code>). Returns the first expression otherwise.</p> <p>Not allowed in guard clauses.</p> <h4 id="&amp;&amp;/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.empty?([]) &amp;&amp; Enum.empty?([])
true

iex&gt; List.first([]) &amp;&amp; true
nil

iex&gt; Enum.empty?([]) &amp;&amp; List.first([1])
1

iex&gt; false &amp;&amp; throw(:bad)
false</code></pre> <p>Note that, unlike <a href="#and/2"><code class="inline">and/2</code></a>, this operator accepts any expression as the first argument, not only booleans.</p>    <h3 class="detail-header macro" id="../2">  <span class="signature">first..last</span>  </h3>  <p>Returns a range with the specified start and end.</p> <p>Both ends are included.</p> <h4 id="../2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; 0 in 1..3
false

iex&gt; 1 in 1..3
true

iex&gt; 2 in 1..3
true

iex&gt; 3 in 1..3
true</code></pre>    <h3 class="detail-header macro" id="%3C%3E/2">  <span class="signature">left &lt;&gt; right</span>  </h3>  <p>Concatenates two binaries.</p> <h4 id="%3C%3E/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; "foo" &lt;&gt; "bar"
"foobar"</code></pre> <p>The <code class="inline">&lt;&gt;</code> operator can also be used in pattern matching (and guard clauses) as long as the first part is a literal binary:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; "foo" &lt;&gt; x = "foobar"
iex&gt; x
"bar"</code></pre> <p><code class="inline">x &lt;&gt; "bar" = "foobar"</code> would have resulted in a <a href="../compileerror/"><code class="inline">CompileError</code></a> exception.</p>    <h3 class="detail-header macro" id="@/1">  <span class="signature">@expr</span>  </h3>  <p>Reads and writes attributes of the current module.</p> <p>The canonical example for attributes is annotating that a module implements the OTP behaviour called <code class="inline">gen_server</code>:</p> <pre data-language="elixir"><code class="elixir">defmodule MyServer do
  @behaviour :gen_server
  # ... callbacks ...
end</code></pre> <p>By default Elixir supports all the module attributes supported by Erlang, but custom attributes can be used as well:</p> <pre data-language="elixir"><code class="elixir">defmodule MyServer do
  @my_data 13
  IO.inspect @my_data #=&gt; 13
end</code></pre> <p>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using <a href="../module/#register_attribute/3"><code class="inline">Module.register_attribute/3</code></a>.</p> <p>Finally, notice that attributes can also be read inside functions:</p> <pre data-language="elixir"><code class="elixir">defmodule MyServer do
  @my_data 11
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=&gt; 11
MyServer.second_data #=&gt; 13</code></pre> <p>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the <a href="../module/"><code class="inline">Module</code></a> module for other functions to manipulate module attributes.</p>    <h3 class="detail-header macro" id="alias!/1">  <span class="signature">alias!(alias)</span>  </h3>  <p>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded.</p> <p>Check <a href="../kernel.specialforms/#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a> for more information.</p>    <h3 class="detail-header macro" id="and/2">  <span class="signature">left and right</span>  </h3>  <p>Boolean and.</p> <p>If the first argument is <code class="inline">false</code>, <code class="inline">false</code> is returned; otherwise, the second argument is returned.</p> <p>Requires only the first argument to be a boolean since it short-circuits. If the first argument is not a boolean, an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests.</p> <h4 id="and/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; true and false
false
iex&gt; true and "yay!"
"yay!"</code></pre>     <h3 class="detail-header macro" id="binding/1">  <span class="signature">binding(context \\ nil)</span>  </h3>  <p>Returns the binding for the given context as a keyword list.</p> <p>In the returned result, keys are variable names and values are the corresponding variable values.</p> <p>If the given <code class="inline">context</code> is <code class="inline">nil</code> (by default it is), the binding for the current context is returned.</p> <h4 id="binding/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; x = 1
iex&gt; binding()
[x: 1]
iex&gt; x = 2
iex&gt; binding()
[x: 2]

iex&gt; binding(:foo)
[]
iex&gt; var!(x, :foo) = 1
1
iex&gt; binding(:foo)
[x: 1]</code></pre>     <h3 class="detail-header macro" id="def/2">  <span class="signature">def(call, expr \\ nil)</span>  </h3>  <p>Defines a function with the given name and body.</p> <h4 id="def/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">defmodule Foo do
  def bar, do: :baz
end

Foo.bar #=&gt; :baz</code></pre> <p>A function that expects arguments can be defined as follows:</p> <pre data-language="elixir"><code class="elixir">defmodule Foo do
  def sum(a, b) do
    a + b
  end
end</code></pre> <p>In the example above, a <code class="inline">sum/2</code> function is defined; this function receives two arguments and returns their sum.</p> <h4 id="def/2-function-and-variable-names" class="section-heading">  Function and variable names </h4> <p>Function and variable names have the following syntax: A <em>lowercase ASCII letter</em> or an <em>underscore</em>, followed by any number of <em>lowercase or uppercase ASCII letters</em>, <em>numbers</em>, or <em>underscores</em>. Optionally they can end in either an <em>exclamation mark</em> or a <em>question mark</em>.</p> <p>For variables, any identifier starting with an underscore should indicate an unused variable. For example:</p> <pre data-language="elixir"><code class="elixir">def foo(bar) do
  []
end
#=&gt; warning: variable bar is unused

def foo(_bar) do
  []
end
#=&gt; no warning

def foo(_bar) do
  _bar
end
#=&gt; warning: the underscored variable "_bar" is used after being set</code></pre> <h4 id="def/2-rescue-catch-after" class="section-heading">  rescue/catch/after </h4> <p>Function bodies support <code class="inline">rescue</code>, <code class="inline">catch</code> and <code class="inline">after</code> as <code class="inline">SpecialForms.try/1</code> does. The following two functions are equivalent:</p> <pre data-language="elixir"><code class="elixir">def format(value) do
  try do
    format!(value)
  catch
    :exit, reason -&gt; {:error, reason}
  end
end

def format(value) do
  format!(value)
catch
  :exit, reason -&gt; {:error, reason}
end</code></pre>    <h3 class="detail-header macro" id="defdelegate/2">  <span class="signature">defdelegate(funs, opts)</span>  </h3>  <p>Defines a function that delegates to another module.</p> <p>Functions defined with <a href="#defdelegate/2"><code class="inline">defdelegate/2</code></a> are public and can be invoked from outside the module they’re defined in (like if they were defined using <a href="#def/2)"><code class="inline">def/2</code></a>. When the desire is to delegate as private functions, <code class="inline">import/2</code> should be used.</p> <p>Delegation only works with functions; delegating macros is not supported.</p> <h4 id="defdelegate/2-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:to</code> - the module to dispatch to.</p> </li> <li>
<code class="inline">:as</code> - the function to call on the target given in <code class="inline">:to</code>. This parameter is optional and defaults to the name being delegated (<code class="inline">funs</code>). </li> </ul> <h4 id="defdelegate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">defmodule MyList do
  defdelegate reverse(list), to: :lists
  defdelegate other_reverse(list), to: :lists, as: :reverse
end

MyList.reverse([1, 2, 3])
#=&gt; [3, 2, 1]

MyList.other_reverse([1, 2, 3])
#=&gt; [3, 2, 1]</code></pre>    <h3 class="detail-header macro" id="defexception/1">  <span class="signature">defexception(fields)</span>  </h3>  <p>Defines an exception.</p> <p>Exceptions are structs backed by a module that implements the <a href="../exception/"><code class="inline">Exception</code></a> behaviour. The <a href="../exception/"><code class="inline">Exception</code></a> behaviour requires two functions to be implemented:</p> <ul> <li>
<p><code class="inline">exception/1</code> - receives the arguments given to <a href="#raise/2"><code class="inline">raise/2</code></a> and returns the exception struct. The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception’s message.</p> </li> <li>
<code class="inline">message/1</code> - receives the exception struct and must return its message. Most commonly exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented. </li> </ul> <p>Since exceptions are structs, the API supported by <a href="#defstruct/1"><code class="inline">defstruct/1</code></a> is also available in <a href="#defexception/1"><code class="inline">defexception/1</code></a>.</p> <h4 id="defexception/1-raising-exceptions" class="section-heading">  Raising exceptions </h4> <p>The most common way to raise an exception is via <a href="#raise/2"><code class="inline">raise/2</code></a>:</p> <pre data-language="elixir"><code class="elixir">defmodule MyAppError do
  defexception [:message]
end

value = [:hello]

raise MyAppError,
  message: "did not get what was expected, got: #{inspect value}"</code></pre> <p>In many cases it is more convenient to pass the expected value to <a href="#raise/2"><code class="inline">raise/2</code></a> and generate the message in the <a href="../exception/#c:exception/1"><code class="inline">Exception.exception/1</code></a> callback:</p> <pre data-language="elixir"><code class="elixir">defmodule MyAppError do
  defexception [:message]

  def exception(value) do
    msg = "did not get what was expected, got: #{inspect value}"
    %MyAppError{message: msg}
  end
end

raise MyAppError, value</code></pre> <p>The example above shows the preferred strategy for customizing exception messages.</p>     <h3 class="detail-header macro" id="defimpl/3">  <span class="signature">defimpl(name, opts, do_block \\ [])</span>  </h3>  <p>Defines an implementation for the given protocol.</p> <p>See <a href="#defprotocol/2"><code class="inline">defprotocol/2</code></a> for more information and examples on protocols.</p> <p>Inside an implementation, the name of the protocol can be accessed via <code class="inline">@protocol</code> and the current target as <code class="inline">@for</code>.</p>     <h3 class="detail-header macro" id="defmacro/2">  <span class="signature">defmacro(call, expr \\ nil)</span>  </h3>  <p>Defines a macro with the given name and body.</p> <h4 id="defmacro/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">defmodule MyLogic do
  defmacro unless(expr, opts) do
    quote do
      if !unquote(expr), unquote(opts)
    end
  end
end

require MyLogic
MyLogic.unless false do
  IO.puts "It works"
end</code></pre>     <h3 class="detail-header macro" id="defmacrop/2">  <span class="signature">defmacrop(call, expr \\ nil)</span>  </h3>  <p>Defines a private macro with the given name and body.</p> <p>Private macros are only accessible from the same module in which they are defined.</p> <p>Check <a href="#defmacro/2"><code class="inline">defmacro/2</code></a> for more information.</p>    <h3 class="detail-header macro" id="defmodule/2">  <span class="signature">defmodule(alias, do_block)</span>  </h3>  <p>Defines a module given by name with the given contents.</p> <p>This macro defines a module with the given <code class="inline">alias</code> as its name and with the given contents. It returns a tuple with four elements:</p> <ul> <li>
<code class="inline">:module</code> </li> <li>the module name </li> <li>the binary contents of the module </li> <li>the result of evaluating the contents block </li> </ul> <h4 id="defmodule/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; defmodule Foo do
...&gt;   def bar, do: :baz
...&gt; end
iex&gt; Foo.bar
:baz</code></pre> <h4 id="defmodule/2-nesting" class="section-heading">  Nesting </h4> <p>Nesting a module inside another module affects the name of the nested module:</p> <pre data-language="elixir"><code class="elixir">defmodule Foo do
  defmodule Bar do
  end
end</code></pre> <p>In the example above, two modules - <code class="inline">Foo</code> and <code class="inline">Foo.Bar</code> - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module <code class="inline">Foo.Bar</code> to be accessed as <code class="inline">Bar</code> in the same lexical scope where it’s defined (the <code class="inline">Foo</code> module).</p> <p>If the <code class="inline">Foo.Bar</code> module is moved somewhere else, the references to <code class="inline">Bar</code> in the <code class="inline">Foo</code> module need to be updated to the fully-qualified name (<code class="inline">Foo.Bar</code>) or an alias has to be explicitly set in the <code class="inline">Foo</code> module with the help of <a href="../kernel.specialforms/#alias/2"><code class="inline">Kernel.SpecialForms.alias/2</code></a>.</p> <pre data-language="elixir"><code class="elixir">defmodule Foo.Bar do
  # code
end

defmodule Foo do
  alias Foo.Bar
  # code here can refer to "Foo.Bar" as just "Bar"
end</code></pre> <h4 id="defmodule/2-module-names" class="section-heading">  Module names </h4> <p>A module name can be any atom, but Elixir provides a special syntax which is usually used for module names. What is called a module name is an <em>uppercase ASCII letter</em> followed by any number of <em>lowercase or uppercase ASCII letters</em>, <em>numbers</em>, or <em>underscores</em>. This identifier is equivalent to an atom prefixed by <code class="inline">Elixir.</code>. So in the <code class="inline">defmodule Foo</code> example <code class="inline">Foo</code> is equivalent to <code class="inline">:"Elixir.Foo"</code></p> <h4 id="defmodule/2-dynamic-names" class="section-heading">  Dynamic names </h4> <p>Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:</p> <pre data-language="elixir"><code class="elixir">defmodule String.to_atom("Foo#{1}") do
  # contents ...
end</code></pre> <p>Elixir will accept any module name as long as the expression passed as the first argument to <a href="#defmodule/2"><code class="inline">defmodule/2</code></a> evaluates to an atom. Note that, when a dynamic name is used, Elixir won’t nest the name under the current module nor automatically set up an alias.</p>    <h3 class="detail-header macro" id="defoverridable/1">  <span class="signature">defoverridable(keywords)</span>  </h3>  <p>Makes the given functions in the current module overridable.</p> <p>An overridable function is lazily defined, allowing a developer to override it.</p> <h4 id="defoverridable/1-example" class="section-heading">  Example </h4> <pre data-language="elixir"><code class="elixir">defmodule DefaultMod do
  defmacro __using__(_opts) do
    quote do
      def test(x, y) do
        x + y
      end

      defoverridable [test: 2]
    end
  end
end

defmodule InheritMod do
  use DefaultMod

  def test(x, y) do
    x * y + super(x, y)
  end
end</code></pre> <p>As seen as in the example above, <code class="inline">super</code> can be used to call the default implementation.</p>     <h3 class="detail-header macro" id="defp/2">  <span class="signature">defp(call, expr \\ nil)</span>  </h3>  <p>Defines a private function with the given name and body.</p> <p>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it’s defined in results in an <a href="../undefinedfunctionerror/"><code class="inline">UndefinedFunctionError</code></a> exception.</p> <p>Check <a href="#def/2"><code class="inline">def/2</code></a> for more information.</p> <h4 id="defp/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">defmodule Foo do
  def bar do
    sum(1, 2)
  end

  defp sum(a, b), do: a + b
end

Foo.bar #=&gt; 3
Foo.sum(1, 2) #=&gt; ** (UndefinedFunctionError) undefined function Foo.sum/2</code></pre>    <h3 class="detail-header macro" id="defprotocol/2">  <span class="signature">defprotocol(name, do_block)</span>  </h3>  <p>Defines a protocol.</p> <p>A protocol specifies an API that should be defined by its implementations.</p> <h4 id="defprotocol/2-examples" class="section-heading">  Examples </h4> <p>In Elixir, we have two verbs for checking how many items there are in a data structure: <code class="inline">length</code> and <code class="inline">size</code>. <code class="inline">length</code> means the information must be computed. For example, <code class="inline">length(list)</code> needs to traverse the whole list to calculate its length. On the other hand, <code class="inline">tuple_size(tuple)</code> and <code class="inline">byte_size(binary)</code> do not depend on the tuple and binary size as the size information is precomputed in the data structure.</p> <p>Although Elixir includes specific functions such as <code class="inline">tuple_size</code>, <code class="inline">binary_size</code> and <code class="inline">map_size</code>, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:</p> <pre data-language="elixir"><code class="elixir">defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end</code></pre> <p>Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:</p> <pre data-language="elixir"><code class="elixir">defimpl Size, for: Binary do
  def size(binary), do: byte_size(binary)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end</code></pre> <p>Notice we didn’t implement it for lists as we don’t have the <code class="inline">size</code> information on lists, rather its value needs to be computed with <code class="inline">length</code>.</p> <p>It is possible to implement protocols for all Elixir types:</p> <ul> <li>Structs (see below) </li> <li>
<a href="../tuple/"><code class="inline">Tuple</code></a> </li> <li>
<a href="../atom/"><code class="inline">Atom</code></a> </li> <li>
<a href="../list/"><code class="inline">List</code></a> </li> <li>
<code class="inline">BitString</code> </li> <li>
<a href="../integer/"><code class="inline">Integer</code></a> </li> <li>
<a href="../float/"><code class="inline">Float</code></a> </li> <li>
<code class="inline">Function</code> </li> <li>
<code class="inline">PID</code> </li> <li>
<a href="../map/"><code class="inline">Map</code></a> </li> <li>
<a href="../port/"><code class="inline">Port</code></a> </li> <li>
<code class="inline">Reference</code> </li> <li>
<code class="inline">Any</code> (see below) </li> </ul> <h4 id="defprotocol/2-protocols-and-structs" class="section-heading">  Protocols and Structs </h4> <p>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like <a href="../mapset/"><code class="inline">MapSet</code></a>. We can implement the <code class="inline">Size</code> protocol for those types as well:</p> <pre data-language="elixir"><code class="elixir">defimpl Size, for: MapSet do
  def size(map_set), do: MapSet.size(map_set)
end</code></pre> <p>When implementing a protocol for a struct, the <code class="inline">:for</code> option can be omitted if the <code class="inline">defimpl</code> call is inside the module that defines the struct:</p> <pre data-language="elixir"><code class="elixir">defmodule User do
  defstruct [:email, :name]

  defimpl Size do
    def size(%User{}), do: 2 # two fields
  end
end</code></pre> <p>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fallback to <code class="inline">Any</code>. Conveniences for building implementations on top of existing ones are also available, look at <a href="#defstruct/1"><code class="inline">defstruct/1</code></a> for more information about deriving protocols.</p> <h4 id="defprotocol/2-fallback-to-any" class="section-heading">  Fallback to any </h4> <p>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the <code class="inline">@fallback_to_any</code> attribute to <code class="inline">true</code> in the protocol definition:</p> <pre data-language="elixir"><code class="elixir">defprotocol Size do
  @fallback_to_any true
  def size(data)
end</code></pre> <p>The <code class="inline">Size</code> protocol can now be implemented for <code class="inline">Any</code>:</p> <pre data-language="elixir"><code class="elixir">defimpl Size, for: Any do
  def size(_), do: 0
end</code></pre> <p>Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an Integer have a size of 0. That’s one of the reasons why <code class="inline">@fallback_to_any</code> is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour.</p> <h4 id="defprotocol/2-types" class="section-heading">  Types </h4> <p>Defining a protocol automatically defines a type named <code class="inline">t</code>, which can be used as follows:</p> <pre data-language="elixir"><code class="elixir">@spec print_size(Size.t) :: :ok
def print_size(data) do
  IO.puts(case Size.size(data) do
    0 -&gt; "data has no items"
    1 -&gt; "data has one item"
    n -&gt; "data has #{n} items"
  end)
end</code></pre> <p>The <code class="inline">@spec</code> above expresses that all types allowed to implement the given protocol are valid argument types for the given function.</p> <h4 id="defprotocol/2-reflection" class="section-heading">  Reflection </h4> <p>Any protocol module contains three extra functions:</p> <ul> <li>
<p><code class="inline">__protocol__/1</code> - returns the protocol name when <code class="inline">:name</code> is given, and a keyword list with the protocol functions and their arities when <code class="inline">:functions</code> is given</p> </li> <li>
<p><code class="inline">impl_for/1</code> - receives a structure and returns the module that implements the protocol for the structure, <code class="inline">nil</code> otherwise</p> </li> <li>
<p><code class="inline">impl_for!/1</code> - same as above but raises an error if an implementation is not found</p> <pre data-language="elixir"><code class="elixir">Enumerable.__protocol__(:functions)
#=&gt; [count: 1, member?: 2, reduce: 3]

Enumerable.impl_for([])
#=&gt; Enumerable.List

Enumerable.impl_for(42)
#=&gt; nil</code></pre> </li> </ul> <h4 id="defprotocol/2-consolidation" class="section-heading">  Consolidation </h4> <p>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</p> <p>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. For this reason, all protocols are compiled with <code class="inline">debug_info</code> set to <code class="inline">true</code>, regardless of the option set by <code class="inline">elixirc</code> compiler. The debug info though may be removed after consolidation.</p> <p>Protocol consolidation is applied by default to all Mix projects. For applying consolidation manually, please check the functions in the <a href="../protocol/"><code class="inline">Protocol</code></a> module or the <code class="inline">mix compile.protocols</code> task.</p>    <h3 class="detail-header macro" id="defstruct/1">  <span class="signature">defstruct(fields)</span>  </h3>  <p>Defines a struct.</p> <p>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</p> <p>To define a struct, a developer must define both <code class="inline">__struct__/0</code> and <code class="inline">__struct__/1</code> functions. <a href="#defstruct/1"><code class="inline">defstruct/1</code></a> is a convenience macro which defines such functions with some conveniences.</p> <p>For more information about structs, please check <a href="../kernel.specialforms/#%2525/2"><code class="inline">Kernel.SpecialForms.%/2</code></a>.</p> <h4 id="defstruct/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">defmodule User do
  defstruct name: nil, age: nil
end</code></pre> <p>Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, <code class="inline">10 + 11</code> is evaluated at compile-time and the age field is stored with value <code class="inline">21</code>:</p> <pre data-language="elixir"><code class="elixir">defmodule User do
  defstruct name: nil, age: 10 + 11
end</code></pre> <p>The <code class="inline">fields</code> argument is usually a keyword list with field names as atom keys and default values as corresponding values. <a href="#defstruct/1"><code class="inline">defstruct/1</code></a> also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct’s field names and they will all default to <code class="inline">nil</code>.</p> <pre data-language="elixir"><code class="elixir">defmodule Post do
  defstruct [:title, :content, :author]
end</code></pre> <h4 id="defstruct/1-deriving" class="section-heading">  Deriving </h4> <p>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the <code class="inline">User</code> struct leads to an error:</p> <pre data-language="elixir"><code class="elixir">john = %User{name: "John"}
MyProtocol.call(john)
** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}</code></pre> <p><a href="#defstruct/1"><code class="inline">defstruct/1</code></a>, however, allows protocol implementations to be <em>derived</em>. This can be done by defining a <code class="inline">@derive</code> attribute as a list before invoking <a href="#defstruct/1"><code class="inline">defstruct/1</code></a>:</p> <pre data-language="elixir"><code class="elixir">defmodule User do
  @derive [MyProtocol]
  defstruct name: nil, age: 10 + 11
end

MyProtocol.call(john) #=&gt; works</code></pre> <p>For each protocol in the <code class="inline">@derive</code> list, Elixir will assert there is an implementation of that protocol for any (regardless if fallback to any is <code class="inline">true</code>) and check if the any implementation defines a <code class="inline">__deriving__/3</code> callback. If so, the callback is invoked, otherwise an implementation that simply points to the any implementation is automatically derived.</p> <h4 id="defstruct/1-enforcing-keys" class="section-heading">  Enforcing keys </h4> <p>When building a struct, Elixir will automatically guarantee all keys belongs to the struct:</p> <pre data-language="elixir"><code class="elixir">%User{name: "john", unknown: :key}
** (KeyError) key :unknown not found in: %User{age: 21, name: nil}</code></pre> <p>Elixir also allows developers to enforce certain keys must always be given when building the struct:</p> <pre data-language="elixir"><code class="elixir">defmodule User do
  @enforce_keys [:name]
  defstruct name: nil, age: 10 + 11
end</code></pre> <p>Now trying to build a struct without the name key will fail:</p> <pre data-language="elixir"><code class="elixir">%User{age: 21}
** (ArgumentError) the following keys must also be given when building struct User: [:name]</code></pre> <p>Keep in mind <code class="inline">@enforce_keys</code> is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</p> <h4 id="defstruct/1-types" class="section-heading">  Types </h4> <p>It is recommended to define types for structs. By convention such type is called <code class="inline">t</code>. To define a struct inside a type, the struct literal syntax is used:</p> <pre data-language="elixir"><code class="elixir">defmodule User do
  defstruct name: "John", age: 25
  @type t :: %User{name: String.t, age: non_neg_integer}
end</code></pre> <p>It is recommended to only use the struct syntax when defining the struct’s type. When referring to another struct it’s better to use <code class="inline">User.t</code> instead of <code class="inline">%User{}</code>.</p> <p>The types of the struct fields that are not included in <code class="inline">%User{}</code> default to <code class="inline">term</code>.</p> <p>Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the <code class="inline">@opaque</code> attribute. Structs whose internal structure is public should use <code class="inline">@type</code>.</p>    <h3 class="detail-header macro" id="destructure/2">  <span class="signature">destructure(left, right)</span>  </h3>  <p>Destructures two lists, assigning each term in the right one to the matching term in the left one.</p> <p>Unlike pattern matching via <code class="inline">=</code>, if the sizes of the left and right lists don’t match, destructuring simply stops instead of raising an error.</p> <h4 id="destructure/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; destructure([x, y, z], [1, 2, 3, 4, 5])
iex&gt; {x, y, z}
{1, 2, 3}</code></pre> <p>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining items are simply set to <code class="inline">nil</code>:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; destructure([x, y, z], [1])
iex&gt; {x, y, z}
{1, nil, nil}</code></pre> <p>The left-hand side supports any expression you would use on the left-hand side of a match:</p> <pre data-language="elixir"><code class="elixir">x = 1
destructure([^x, y, z], [1, 2, 3])</code></pre> <p>The example above will only work if <code class="inline">x</code> matches the first value in the right list. Otherwise, it will raise a <a href="../matcherror/"><code class="inline">MatchError</code></a> (like the <code class="inline">=</code> operator would do).</p>    <h3 class="detail-header macro" id="get_and_update_in/2">  <span class="signature">get_and_update_in(path, fun)</span>  </h3>  <p>Gets a value and updates a nested data structure via the given <code class="inline">path</code>.</p> <p>This is similar to <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language="elixir"><code class="elixir">get_and_update_in(opts[:foo][:bar], &amp;{&amp;1, &amp;1 + 1})</code></pre> <p>Is equivalent to:</p> <pre data-language="elixir"><code class="elixir">get_and_update_in(opts, [:foo, :bar], &amp;{&amp;1, &amp;1 + 1})</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. See the Paths section below.</p> <h4 id="get_and_update_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_and_update_in(users["john"].age, &amp;{&amp;1, &amp;1 + 1})
{27, %{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}}</code></pre> <h4 id="get_and_update_in/2-paths" class="section-heading">  Paths </h4> <p>A path may start with a variable, local or remote call, and must be followed by one or more:</p> <ul> <li>
<p><code class="inline">foo[bar]</code> - accesses the key <code class="inline">bar</code> in <code class="inline">foo</code>; in case <code class="inline">foo</code> is nil, <code class="inline">nil</code> is returned</p> </li> <li>
<code class="inline">foo.bar</code> - accesses a map/struct field; in case the field is not present, an error is raised </li> </ul> <p>Here are some valid paths:</p> <pre data-language="elixir"><code class="elixir">users["john"][:age]
users["john"].age
User.all["john"].age
all_users()["john"].age</code></pre> <p>Here are some invalid ones:</p> <pre data-language="elixir"><code class="elixir"># Does a remote call after the initial value
users["john"].do_something(arg1, arg2)

# Does not access any key or field
users</code></pre>    <h3 class="detail-header macro" id="if/2">  <span class="signature">if(condition, clauses)</span>  </h3>  <p>Provides an <a href="#if/2"><code class="inline">if/2</code></a> macro.</p> <p>This macro expects the first argument to be a condition and the second argument to be a keyword list.</p> <h4 id="if/2-one-liner-examples" class="section-heading">  One-liner examples </h4> <pre data-language="elixir"><code class="elixir">if(foo, do: bar)</code></pre> <p>In the example above, <code class="inline">bar</code> will be returned if <code class="inline">foo</code> evaluates to <code class="inline">true</code> (i.e., it is neither <code class="inline">false</code> nor <code class="inline">nil</code>). Otherwise, <code class="inline">nil</code> will be returned.</p> <p>An <code class="inline">else</code> option can be given to specify the opposite:</p> <pre data-language="elixir"><code class="elixir">if(foo, do: bar, else: baz)</code></pre> <h4 id="if/2-blocks-examples" class="section-heading">  Blocks examples </h4> <p>It’s also possible to pass a block to the <a href="#if/2"><code class="inline">if/2</code></a> macro. The first example above would be translated to:</p> <pre data-language="elixir"><code class="elixir">if foo do
  bar
end</code></pre> <p>Note that <code class="inline">do/end</code> become delimiters. The second example would translate to:</p> <pre data-language="elixir"><code class="elixir">if foo do
  bar
else
  baz
end</code></pre> <p>In order to compare more than two clauses, the <code class="inline">cond/1</code> macro has to be used.</p>    <h3 class="detail-header macro" id="in/2">  <span class="signature">left in right</span>  </h3>  <p>Checks if the element on the left-hand side is a member of the collection on the right-hand side.</p> <h4 id="in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; x = 1
iex&gt; x in [1, 2, 3]
true</code></pre> <p>This operator (which is a macro) simply translates to a call to <a href="../enum/#member?/2"><code class="inline">Enum.member?/2</code></a>. The example above would translate to:</p> <pre data-language="elixir"><code class="elixir">Enum.member?([1, 2, 3], x)</code></pre> <h4 id="in/2-guards" class="section-heading">  Guards </h4> <p>The <a href="#in/2"><code class="inline">in/2</code></a> operator can be used in guard clauses as long as the right-hand side is a range or a list. In such cases, Elixir will expand the operator to a valid guard expression. For example:</p> <pre data-language="elixir"><code class="elixir">when x in [1, 2, 3]</code></pre> <p>translates to:</p> <pre data-language="elixir"><code class="elixir">when x === 1 or x === 2 or x === 3</code></pre> <p>When using ranges:</p> <pre data-language="elixir"><code class="elixir">when x in 1..3</code></pre> <p>translates to:</p> <pre data-language="elixir"><code class="elixir">when x &gt;= 1 and x &lt;= 3</code></pre>    <h3 class="detail-header macro" id="is_nil/1">  <span class="signature">is_nil(term)</span>  </h3>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is <code class="inline">nil</code>, <code class="inline">false</code> otherwise.</p> <p>Allowed in guard clauses.</p> <h4 id="is_nil/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; is_nil(1)
false

iex&gt; is_nil(nil)
true</code></pre>    <h3 class="detail-header macro" id="match?/2">  <span class="signature">match?(pattern, expr)</span>  </h3>  <p>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</p> <h4 id="match?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; match?(1, 1)
true

iex&gt; match?(1, 2)
false

iex&gt; match?({1, _}, {1, 2})
true

iex&gt; map = %{a: 1, b: 2}
iex&gt; match?(%{a: _}, map)
true

iex&gt; a = 1
iex&gt; match?(^a, 1)
true</code></pre> <p><a href="#match?/2"><code class="inline">match?/2</code></a> is very useful when filtering of finding a value in an enumerable:</p> <pre data-language="elixir"><code class="elixir">list = [{:a, 1}, {:b, 2}, {:a, 3}]
Enum.filter list, &amp;match?({:a, _}, &amp;1)
#=&gt; [{:a, 1}, {:a, 3}]</code></pre> <p>Guard clauses can also be given to the match:</p> <pre data-language="elixir"><code class="elixir">list = [{:a, 1}, {:b, 2}, {:a, 3}]
Enum.filter list, &amp;match?({:a, x} when x &lt; 2, &amp;1)
#=&gt; [{:a, 1}]</code></pre> <p>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the <code class="inline">=</code> operator):</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; match?(_x, 1)
true
iex&gt; binding()
[]</code></pre>    <h3 class="detail-header macro" id="or/2">  <span class="signature">left or right</span>  </h3>  <p>Boolean or.</p> <p>If the first argument is <code class="inline">true</code>, <code class="inline">true</code> is returned; otherwise, the second argument is returned.</p> <p>Requires only the first argument to be a boolean since it short-circuits. If the first argument is not a boolean, an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> exception is raised.</p> <p>Allowed in guard tests.</p> <h4 id="or/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; true or false
true
iex&gt; false or 42
42</code></pre>    <h3 class="detail-header macro" id="pop_in/1">  <span class="signature">pop_in(path)</span>  </h3>  <p>Pops a key from the nested structure via the given <code class="inline">path</code>.</p> <p>This is similar to <a href="#pop_in/2"><code class="inline">pop_in/2</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language="elixir"><code class="elixir">pop_in(opts[:foo][:bar])</code></pre> <p>Is equivalent to:</p> <pre data-language="elixir"><code class="elixir">pop_in(opts, [:foo, :bar])</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href="#get_and_update_in/2"><code class="inline">get_and_update_in/2</code></a> docs.</p> <h4 id="pop_in/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; pop_in(users["john"][:age])
{27, %{"john" =&gt; %{}, "meg" =&gt; %{age: 23}}}

iex&gt; users = %{john: %{age: 27}, meg: %{age: 23}}
iex&gt; pop_in(users.john[:age])
{27, %{john: %{}, meg: %{age: 23}}}</code></pre> <p>In case any entry returns <code class="inline">nil</code>, its key will be removed and the deletion will be considered a success.</p>    <h3 class="detail-header macro" id="put_in/2">  <span class="signature">put_in(path, value)</span>  </h3>  <p>Puts a value in a nested structure via the given <code class="inline">path</code>.</p> <p>This is similar to <a href="#put_in/3"><code class="inline">put_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language="elixir"><code class="elixir">put_in(opts[:foo][:bar], :baz)</code></pre> <p>Is equivalent to:</p> <pre data-language="elixir"><code class="elixir">put_in(opts, [:foo, :bar], :baz)</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href="#get_and_update_in/2"><code class="inline">get_and_update_in/2</code></a> docs.</p> <h4 id="put_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; put_in(users["john"][:age], 28)
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}

iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; put_in(users["john"].age, 28)
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</code></pre>    <h3 class="detail-header macro" id="raise/1">  <span class="signature">raise(msg)</span>  </h3>  <p>Raises an exception.</p> <p>If the argument <code class="inline">msg</code> is a binary, it raises a <a href="../runtimeerror/"><code class="inline">RuntimeError</code></a> exception using the given argument as message.</p> <p>If <code class="inline">msg</code> is an atom, it just calls <a href="#raise/2"><code class="inline">raise/2</code></a> with the atom as the first argument and <code class="inline">[]</code> as the second argument.</p> <p>If <code class="inline">msg</code> is anything else, raises an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> exception.</p> <h4 id="raise/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; raise "oops"
** (RuntimeError) oops

try do
  1 + :foo
rescue
  x in [ArithmeticError] -&gt;
    IO.puts "that was expected"
    raise x
end</code></pre>    <h3 class="detail-header macro" id="raise/2">  <span class="signature">raise(exception, attrs)</span>  </h3>  <p>Raises an exception.</p> <p>Calls the <code class="inline">exception/1</code> function on the given argument (which has to be a module name like <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> or <a href="../runtimeerror.html)/"><code class="inline">RuntimeError</code></a> passing <code class="inline">attrs</code> as the attributes in order to retrieve the exception struct.</p> <p>Any module that contains a call to the <a href="#defexception/1"><code class="inline">defexception/1</code></a> macro automatically implements the <a href="../exception/#c:exception/1"><code class="inline">Exception.exception/1</code></a> callback expected by <a href="#raise/2"><code class="inline">raise/2</code></a>. For more information, see <a href="#defexception/1"><code class="inline">defexception/1</code></a>.</p> <h4 id="raise/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; raise(ArgumentError, message: "Sample")
** (ArgumentError) Sample</code></pre>    <h3 class="detail-header macro" id="reraise/2">  <span class="signature">reraise(msg, stacktrace)</span>  </h3>  <p>Raises an exception preserving a previous stacktrace.</p> <p>Works like <a href="#raise/1"><code class="inline">raise/1</code></a> but does not generate a new stacktrace.</p> <p>Notice that <a href="../system/#stacktrace/0"><code class="inline">System.stacktrace/0</code></a> returns the stacktrace of the last exception. That said, it is common to assign the stacktrace as the first expression inside a <code class="inline">rescue</code> clause as any other exception potentially raised (and rescued) between the rescue clause and the raise call may change the <a href="../system/#stacktrace/0"><code class="inline">System.stacktrace/0</code></a> value.</p> <h4 id="reraise/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">try do
  raise "oops"
rescue
  exception -&gt;
    stacktrace = System.stacktrace
    if Exception.message(exception) == "oops" do
      reraise exception, stacktrace
    end
end</code></pre>    <h3 class="detail-header macro" id="reraise/3">  <span class="signature">reraise(exception, attrs, stacktrace)</span>  </h3>  <p>Raises an exception preserving a previous stacktrace.</p> <p><a href="#reraise/3"><code class="inline">reraise/3</code></a> works like <a href="#reraise/2"><code class="inline">reraise/2</code></a>, except it passes arguments to the <code class="inline">exception/1</code> function as explained in <a href="#raise/2"><code class="inline">raise/2</code></a>.</p> <h4 id="reraise/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">try do
  raise "oops"
rescue
  exception -&gt;
    stacktrace = System.stacktrace
    reraise WrapperError, [exception: exception], stacktrace
end</code></pre>    <h3 class="detail-header macro" id="sigil_C/2">  <span class="signature">sigil_C(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~C</code>.</p> <p>It simply returns a charlist without escaping characters and without interpolations.</p> <h4 id="sigil_C/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~C(foo)
'foo'

iex&gt; ~C(f#{o}o)
'f\#{o}o'</code></pre>    <h3 class="detail-header macro" id="sigil_D/2">  <span class="signature">sigil_D(date, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~D</code> for dates.</p> <p>The lower case <code class="inline">~d</code> variant does not exist as interpolation and escape characters are not useful for date sigils.</p> <h4 id="sigil_D/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~D[2015-01-13]
~D[2015-01-13]</code></pre>    <h3 class="detail-header macro" id="sigil_N/2">  <span class="signature">sigil_N(date, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~N</code> for naive date times.</p> <p>The lower case <code class="inline">~n</code> variant does not exist as interpolation and escape characters are not useful for datetime sigils.</p> <h4 id="sigil_N/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~N[2015-01-13 13:00:07]
~N[2015-01-13 13:00:07]
iex&gt; ~N[2015-01-13T13:00:07.001]
~N[2015-01-13 13:00:07.001]</code></pre>    <h3 class="detail-header macro" id="sigil_R/2">  <span class="signature">sigil_R(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~R</code>.</p> <p>It returns a regular expression pattern without escaping nor interpreting interpolations.</p> <p>More information on regexes can be found in the <a href="../regex/"><code class="inline">Regex</code></a> module.</p> <h4 id="sigil_R/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Regex.match?(~R(f#{1,3}o), "f#o")
true</code></pre>    <h3 class="detail-header macro" id="sigil_S/2">  <span class="signature">sigil_S(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~S</code>.</p> <p>It simply returns a string without escaping characters and without interpolations.</p> <h4 id="sigil_S/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~S(foo)
"foo"

iex&gt; ~S(f#{o}o)
"f\#{o}o"</code></pre>    <h3 class="detail-header macro" id="sigil_T/2">  <span class="signature">sigil_T(date, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~T</code> for times.</p> <p>The lower case <code class="inline">~t</code> variant does not exist as interpolation and escape characters are not useful for time sigils.</p> <h4 id="sigil_T/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~T[13:00:07]
~T[13:00:07]
iex&gt; ~T[13:00:07.001]
~T[13:00:07.001]</code></pre>    <h3 class="detail-header macro" id="sigil_W/2">  <span class="signature">sigil_W(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~W</code>.</p> <p>It returns a list of “words” split by whitespace without escaping nor interpreting interpolations.</p> <h4 id="sigil_W/2-modifiers" class="section-heading">  Modifiers </h4> <ul> <li>
<code class="inline">s</code>: words in the list are strings (default) </li> <li>
<code class="inline">a</code>: words in the list are atoms </li> <li>
<code class="inline">c</code>: words in the list are charlists </li> </ul> <h4 id="sigil_W/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~W(foo #{bar} baz)
["foo", "\#{bar}", "baz"]</code></pre>    <h3 class="detail-header macro" id="sigil_c/2">  <span class="signature">sigil_c(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~c</code>.</p> <p>It returns a charlist as if it were a single quoted string, unescaping characters and replacing interpolations.</p> <h4 id="sigil_c/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~c(foo)
'foo'

iex&gt; ~c(f#{:o}o)
'foo'

iex&gt; ~c(f\#{:o}o)
'f\#{:o}o'</code></pre>    <h3 class="detail-header macro" id="sigil_r/2">  <span class="signature">sigil_r(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~r</code>.</p> <p>It returns a regular expression pattern, unescaping characters and replacing interpolations.</p> <p>More information on regexes can be found in the <a href="../regex/"><code class="inline">Regex</code></a> module.</p> <h4 id="sigil_r/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Regex.match?(~r(foo), "foo")
true

iex&gt; Regex.match?(~r/abc/, "abc")
true</code></pre>    <h3 class="detail-header macro" id="sigil_s/2">  <span class="signature">sigil_s(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~s</code>.</p> <p>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</p> <h4 id="sigil_s/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~s(foo)
"foo"

iex&gt; ~s(f#{:o}o)
"foo"

iex&gt; ~s(f\#{:o}o)
"f\#{:o}o"</code></pre>    <h3 class="detail-header macro" id="sigil_w/2">  <span class="signature">sigil_w(term, modifiers)</span>  </h3>  <p>Handles the sigil <code class="inline">~w</code>.</p> <p>It returns a list of “words” split by whitespace. Character unescaping and interpolation happens for each word.</p> <h4 id="sigil_w/2-modifiers" class="section-heading">  Modifiers </h4> <ul> <li>
<code class="inline">s</code>: words in the list are strings (default) </li> <li>
<code class="inline">a</code>: words in the list are atoms </li> <li>
<code class="inline">c</code>: words in the list are charlists </li> </ul> <h4 id="sigil_w/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~w(foo #{:bar} baz)
["foo", "bar", "baz"]

iex&gt; ~w(foo #{" bar baz "})
["foo", "bar", "baz"]

iex&gt; ~w(--source test/enum_test.exs)
["--source", "test/enum_test.exs"]

iex&gt; ~w(foo bar baz)a
[:foo, :bar, :baz]</code></pre>    <h3 class="detail-header macro" id="to_charlist/1">  <span class="signature">to_charlist(arg)</span>  </h3>  <p>Converts the argument to a charlist according to the <a href="../list.chars/"><code class="inline">List.Chars</code></a> protocol.</p> <h4 id="to_charlist/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; to_charlist(:foo)
'foo'</code></pre>    <h3 class="detail-header macro" id="to_string/1">  <span class="signature">to_string(arg)</span>  </h3>  <p>Converts the argument to a string according to the <a href="../string.chars/"><code class="inline">String.Chars</code></a> protocol.</p> <p>This is the function invoked when there is string interpolation.</p> <h4 id="to_string/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; to_string(:foo)
"foo"</code></pre>    <h3 class="detail-header macro" id="unless/2">  <span class="signature">unless(condition, clauses)</span>  </h3>  <p>Provides an <code class="inline">unless</code> macro.</p> <p>This macro evaluates and returns the <code class="inline">do</code> block passed in as the second argument unless <code class="inline">clause</code> evaluates to <code class="inline">true</code>. Otherwise, it returns the value of the <code class="inline">else</code> block if present or <code class="inline">nil</code> if not.</p> <p>See also <a href="#if/2"><code class="inline">if/2</code></a>.</p> <h4 id="unless/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; unless(Enum.empty?([]), do: "Hello")
nil

iex&gt; unless(Enum.empty?([1, 2, 3]), do: "Hello")
"Hello"

iex&gt; unless Enum.sum([2, 2]) == 5 do
...&gt;   "Math still works"
...&gt; else
...&gt;   "Math is broken"
...&gt; end
"Math still works"</code></pre>    <h3 class="detail-header macro" id="update_in/2">  <span class="signature">update_in(path, fun)</span>  </h3>  <p>Updates a nested structure via the given <code class="inline">path</code>.</p> <p>This is similar to <a href="#update_in/3"><code class="inline">update_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p> <pre data-language="elixir"><code class="elixir">update_in(opts[:foo][:bar], &amp;(&amp;1 + 1))</code></pre> <p>Is equivalent to:</p> <pre data-language="elixir"><code class="elixir">update_in(opts, [:foo, :bar], &amp;(&amp;1 + 1))</code></pre> <p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href="#get_and_update_in/2"><code class="inline">get_and_update_in/2</code></a> docs.</p> <h4 id="update_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; update_in(users["john"][:age], &amp;(&amp;1 + 1))
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}

iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; update_in(users["john"].age, &amp;(&amp;1 + 1))
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</code></pre>     <h3 class="detail-header macro" id="use/2">  <span class="signature">use(module, opts \\ [])</span>  </h3>  <p>Uses the given module in the current context.</p> <p>When calling:</p> <pre data-language="elixir"><code class="elixir">use MyModule, some: :options</code></pre> <p>the <code class="inline">__using__/1</code> macro from the <code class="inline">MyModule</code> module is invoked with the second argument passed to <code class="inline">use</code> as its argument. Since <code class="inline">__using__/1</code> is a macro, all the usual macro rules apply, and its return value should be quoted code that is then inserted where <a href="#use/2"><code class="inline">use/2</code></a> is called.</p> <h4 id="use/2-examples" class="section-heading">  Examples </h4> <p>For example, in order to write test cases using the <code class="inline">ExUnit</code> framework provided with Elixir, a developer should <code class="inline">use</code> the <code class="inline">ExUnit.Case</code> module:</p> <pre data-language="elixir"><code class="elixir">defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end</code></pre> <p>In this example, <code class="inline">ExUnit.Case.__using__/1</code> is called with the keyword list <code class="inline">[async: true]</code> as its argument; <a href="#use/2"><code class="inline">use/2</code></a> translates to:</p> <pre data-language="elixir"><code class="elixir">defmodule AssertionTest do
  require ExUnit.Case
  ExUnit.Case.__using__([async: true])

  test "always pass" do
    assert true
  end
end</code></pre> <p><code class="inline">ExUnit.Case</code> will then define the <code class="inline">__using__/1</code> macro:</p> <pre data-language="elixir"><code class="elixir">defmodule ExUnit.Case do
  defmacro __using__(opts) do
    # do something with opts
    quote do
      # return some code to inject in the caller
    end
  end
end</code></pre> <h4 id="use/2-best-practices" class="section-heading">  Best practices </h4> <p><code class="inline">__using__/1</code> is typically used when there is a need to set some state (via module attributes) or callbacks (like <code class="inline">@before_compile</code>, see the documentation for <a href="../module/"><code class="inline">Module</code></a> for more information) into the caller.</p> <p><code class="inline">__using__/1</code> may also be used to alias, require, or import functionality from different modules:</p> <pre data-language="elixir"><code class="elixir">defmodule MyModule do
  defmacro __using__(opts) do
    quote do
      import MyModule.Foo
      import MyModule.Bar
      import MyModule.Baz

      alias MyModule.Repo
    end
  end
end</code></pre> <p>However, do not provide <code class="inline">__using__/1</code> if all it does is to import, alias or require the module itself. For example, avoid this:</p> <pre data-language="elixir"><code class="elixir">defmodule MyModule do
  defmacro __using__(_opts) do
    quote do
      import MyModule
    end
  end
end</code></pre> <p>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind <a href="#use/2"><code class="inline">use/2</code></a>.</p> <p>Finally, developers should also avoid defining functions inside the <code class="inline">__using__/1</code> callback, unless those functions are the default implementation of a previously defined <code class="inline">@callback</code> or are functions meant to be overridden (see <a href="#defoverridable/1)"><code class="inline">defoverridable/1</code></a>. Even in these cases, defining functions should be seen as a “last resource”.</p> <p>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, <code class="inline">ExUnit.Case</code> doesn’t define the <code class="inline">test/3</code> macro in the module that calls <code class="inline">use ExUnit.Case</code>, but it defines <code class="inline">ExUnit.Case.test/3</code> and just imports that into the caller when used.</p>     <h3 class="detail-header macro" id="var!/2">  <span class="signature">var!(var, context \\ nil)</span>  </h3>  <p>When used inside quoting, marks that the given variable should not be hygienized.</p> <p>The argument can be either a variable unquoted or in standard tuple form <code class="inline">{name, meta, context}</code>.</p> <p>Check <a href="../kernel.specialforms/#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a> for more information.</p>    <h3 class="detail-header macro" id="%7C%3E/2">  <span class="signature">left |&gt; right</span>  </h3>  <p>Pipe operator.</p> <p>This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.</p> <h4 id="%7C%3E/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; [1, [2], 3] |&gt; List.flatten()
[1, 2, 3]</code></pre> <p>The example above is the same as calling <code class="inline">List.flatten([1, [2], 3])</code>.</p> <p>The <code class="inline">|&gt;</code> operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; [1, [2], 3] |&gt; List.flatten |&gt; Enum.map(fn x -&gt; x * 2 end)
[2, 4, 6]</code></pre> <p>In the example above, the list <code class="inline">[1, [2], 3]</code> is passed as the first argument to the <a href="../list/#flatten/1"><code class="inline">List.flatten/1</code></a> function, then the flattened list is passed as the first argument to the <a href="../enum/#map/2"><code class="inline">Enum.map/2</code></a> function which doubles each element of the list.</p> <p>In other words, the expression above simply translates to:</p> <pre data-language="elixir"><code class="elixir">Enum.map(List.flatten([1, [2], 3]), fn x -&gt; x * 2 end)</code></pre> <h4 id="%7C%3E/2-pitfalls" class="section-heading">  Pitfalls </h4> <p>There are two common pitfalls when using the pipe operator.</p> <p>The first one is related to operator precedence. For example, the following expression:</p> <pre data-language="elixir"><code class="elixir">String.graphemes "Hello" |&gt; Enum.reverse</code></pre> <p>Translates to:</p> <pre data-language="elixir"><code class="elixir">String.graphemes("Hello" |&gt; Enum.reverse)</code></pre> <p>which results in an error as the <a href="../enumerable/"><code class="inline">Enumerable</code></a> protocol is not defined for binaries. Adding explicit parentheses resolves the ambiguity:</p> <pre data-language="elixir"><code class="elixir">String.graphemes("Hello") |&gt; Enum.reverse</code></pre> <p>Or, even better:</p> <pre data-language="elixir"><code class="elixir">"Hello" |&gt; String.graphemes |&gt; Enum.reverse</code></pre> <p>The second pitfall is that the <code class="inline">|&gt;</code> operator works on calls. For example, when you write:</p> <pre data-language="elixir"><code class="elixir">"Hello" |&gt; some_function()</code></pre> <p>Elixir sees the right-hand side is a function call and pipes to it. This means that, if you want to pipe to an anonymous or captured function, it must also be explicitly called.</p> <p>Given the anonymous function:</p> <pre data-language="elixir"><code class="elixir">fun = fn x -&gt; IO.puts(x) end
fun.("Hello")</code></pre> <p>This won’t work as it will rather try to invoke the local function <code class="inline">fun</code>:</p> <pre data-language="elixir"><code class="elixir">"Hello" |&gt; fun()</code></pre> <p>This works:</p> <pre data-language="elixir"><code class="elixir">"Hello" |&gt; fun.()</code></pre> <p>As you can see, the <code class="inline">|&gt;</code> operator retains the same semantics as when the pipe is not used since both require the <code class="inline">fun.(...)</code> notation.</p>    <h3 class="detail-header macro" id="%7C%7C/2">  <span class="signature">left || right</span>  </h3>  <p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to <code class="inline">true</code> (i.e., it is either <code class="inline">nil</code> or <code class="inline">false</code>). Returns the first expression otherwise.</p> <p>Not allowed in guard clauses.</p> <h4 id="%7C%7C/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Enum.empty?([1]) || Enum.empty?([1])
false

iex&gt; List.first([]) || true
true

iex&gt; Enum.empty?([1]) || 1
1

iex&gt; Enum.empty?([]) || throw(:bad)
true</code></pre> <p>Note that, unlike <a href="#or/2"><code class="inline">or/2</code></a>, this operator accepts any expression as the first argument, not only booleans.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.4.1/Kernel.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.4.1/Kernel.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
