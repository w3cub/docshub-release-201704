
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Path - Elixir 1.4 - W3cubDocs</title>
  
  <meta name="description" content=" This module provides conveniences for manipulating or retrieving file system paths. ">
  <meta name="keywords" content="path, summary, types, functions, -, elixir, elixir~1.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.4/path/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.4/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Path  </h1>  <p>This module provides conveniences for manipulating or retrieving file system paths.</p> <p>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</p> <p>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like <a href="#wildcard/2"><code class="inline">wildcard/2</code></a> and <a href="#expand/1)"><code class="inline">expand/1</code></a>.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#absname/1">absname(path)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given path to an absolute one. Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code></p> </dd>   <dt class="summary-signature"> <a href="#absname/2">absname(path, relative_to)</a> </dt> <dd class="summary-synopsis">
<p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>. If <code class="inline">path</code> is already an absolute path, <code class="inline">relative_to</code> is ignored. See also <a href="#relative_to/2"><code class="inline">relative_to/2</code></a></p> </dd>   <dt class="summary-signature"> <a href="#basename/1">basename(path)</a> </dt> <dd class="summary-synopsis">
<p>Returns the last component of the path or the path itself if it does not contain any directory separators</p> </dd>   <dt class="summary-signature"> <a href="#basename/2">basename(path, extension)</a> </dt> <dd class="summary-synopsis">
<p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped. This function should be used to remove a specific extension which may, or may not, be there</p> </dd>   <dt class="summary-signature"> <a href="#dirname/1">dirname(path)</a> </dt> <dd class="summary-synopsis">
<p>Returns the directory component of <code class="inline">path</code></p> </dd>   <dt class="summary-signature"> <a href="#expand/1">expand(path)</a> </dt> <dd class="summary-synopsis">
<p>Converts the path to an absolute one and expands any <code class="inline">.</code> and <code class="inline">..</code> characters and a leading <code class="inline">~</code></p> </dd>   <dt class="summary-signature"> <a href="#expand/2">expand(path, relative_to)</a> </dt> <dd class="summary-synopsis">
<p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters. If the path is already an absolute path, <code class="inline">relative_to</code> is ignored</p> </dd>   <dt class="summary-signature"> <a href="#extname/1">extname(path)</a> </dt> <dd class="summary-synopsis">
<p>Returns the extension of the last component of <code class="inline">path</code></p> </dd>   <dt class="summary-signature"> <a href="#join/1">join(list)</a> </dt> <dd class="summary-synopsis">
<p>Joins a list of paths</p> </dd>   <dt class="summary-signature"> <a href="#join/2">join(left, right)</a> </dt> <dd class="summary-synopsis">
<p>Joins two paths</p> </dd>   <dt class="summary-signature"> <a href="#relative/1">relative(name)</a> </dt> <dd class="summary-synopsis">
<p>Forces the path to be a relative path</p> </dd>   <dt class="summary-signature"> <a href="#relative_to/2">relative_to(path, from)</a> </dt> <dd class="summary-synopsis">
<p>Returns the given <code class="inline">path</code> relative to the given <code class="inline">from</code> path. In other words, it tries to strip the <code class="inline">from</code> prefix from <code class="inline">path</code></p> </dd>   <dt class="summary-signature"> <a href="#relative_to_cwd/1">relative_to_cwd(path)</a> </dt> <dd class="summary-synopsis">
<p>Convenience to get the path relative to the current working directory. If, for some reason, the current working directory cannot be retrieved, returns the full path</p> </dd>   <dt class="summary-signature"> <a href="#rootname/1">rootname(path)</a> </dt> <dd class="summary-synopsis">
<p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped</p> </dd>   <dt class="summary-signature"> <a href="#rootname/2">rootname(path, extension)</a> </dt> <dd class="summary-synopsis">
<p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped. This function should be used to remove a specific extension which might, or might not, be there</p> </dd>   <dt class="summary-signature"> <a href="#split/1">split(path)</a> </dt> <dd class="summary-synopsis">
<p>Splits the path into a list at the path separator</p> </dd>   <dt class="summary-signature"> <a href="#type/1">type(name)</a> </dt> <dd class="summary-synopsis">
<p>Returns the path type</p> </dd>   <dt class="summary-signature"> <a href="#wildcard/2">wildcard(glob, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Traverses paths according to the given <code class="inline">glob</code> expression, and returns a list of matches</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: :unicode.chardata</pre>       <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="absname/1">  <span class="signature">absname(path)</span>     </h3>
<pre data-language="elixir">absname(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Converts the given path to an absolute one. Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p> <h4 id="absname/1-unix-examples" class="section-heading">  Unix examples </h4> <pre data-language="elixir"><code class="elixir">Path.absname("foo")
#=&gt; "/usr/local/foo"

Path.absname("../x")
#=&gt; "/usr/local/../x"</code></pre> <h4 id="absname/1-windows" class="section-heading">  Windows </h4> <pre data-language="elixir"><code class="elixir">Path.absname("foo").
"D:/usr/local/foo"
Path.absname("../x").
"D:/usr/local/../x"</code></pre>    <h3 class="detail-header function" id="absname/2">  <span class="signature">absname(path, relative_to)</span>     </h3>
<pre data-language="elixir">absname(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: binary</pre>  <p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>. If <code class="inline">path</code> is already an absolute path, <code class="inline">relative_to</code> is ignored. See also <a href="#relative_to/2"><code class="inline">relative_to/2</code></a>.</p> <p>Unlike <a href="#expand/2"><code class="inline">expand/2</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p> <h4 id="absname/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.absname("foo", "bar")
"bar/foo"

iex&gt; Path.absname("../x", "bar")
"bar/../x"</code></pre>    <h3 class="detail-header function" id="basename/1">  <span class="signature">basename(path)</span>     </h3>
<pre data-language="elixir">basename(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p> <h4 id="basename/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.basename("foo")
"foo"

iex&gt; Path.basename("foo/bar")
"bar"

iex&gt; Path.basename("/")
""</code></pre>    <h3 class="detail-header function" id="basename/2">  <span class="signature">basename(path, extension)</span>     </h3>
<pre data-language="elixir">basename(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped. This function should be used to remove a specific extension which may, or may not, be there.</p> <h4 id="basename/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.basename("~/foo/bar.ex", ".ex")
"bar"

iex&gt; Path.basename("~/foo/bar.exs", ".ex")
"bar.exs"

iex&gt; Path.basename("~/foo/bar.old.ex", ".ex")
"bar.old"</code></pre>    <h3 class="detail-header function" id="dirname/1">  <span class="signature">dirname(path)</span>     </h3>
<pre data-language="elixir">dirname(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the directory component of <code class="inline">path</code>.</p> <h4 id="dirname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.dirname("/foo/bar.ex")
"/foo"

iex&gt; Path.dirname("/foo/bar/baz.ex")
"/foo/bar"</code></pre>    <h3 class="detail-header function" id="expand/1">  <span class="signature">expand(path)</span>     </h3>
<pre data-language="elixir">expand(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Converts the path to an absolute one and expands any <code class="inline">.</code> and <code class="inline">..</code> characters and a leading <code class="inline">~</code>.</p> <h4 id="expand/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Path.expand("/foo/bar/../bar")
#=&gt; "/foo/bar"</code></pre>    <h3 class="detail-header function" id="expand/2">  <span class="signature">expand(path, relative_to)</span>     </h3>
<pre data-language="elixir">expand(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: binary</pre>  <p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters. If the path is already an absolute path, <code class="inline">relative_to</code> is ignored.</p> <p>Note, that this function treats <code class="inline">path</code> with a leading <code class="inline">~</code> as an absolute one.</p> <p>The second argument is first expanded to an absolute path.</p> <h4 id="expand/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Assuming that the absolute path to baz is /quux/baz
Path.expand("foo/bar/../bar", "baz")
#=&gt; "/quux/baz/foo/bar"

Path.expand("foo/bar/../bar", "/baz")
"/baz/foo/bar"
Path.expand("/foo/bar/../bar", "/baz")
"/foo/bar"</code></pre>    <h3 class="detail-header function" id="extname/1">  <span class="signature">extname(path)</span>     </h3>
<pre data-language="elixir">extname(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the extension of the last component of <code class="inline">path</code>.</p> <h4 id="extname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.extname("foo.erl")
".erl"

iex&gt; Path.extname("~/foo/bar")
""</code></pre>    <h3 class="detail-header function" id="join/1">  <span class="signature">join(list)</span>     </h3>
<pre data-language="elixir">join([<a href="#t:t/0">t</a>, ...]) :: binary</pre>  <p>Joins a list of paths.</p> <p>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</p> <h4 id="join/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.join(["~", "foo"])
"~/foo"

iex&gt; Path.join(["foo"])
"foo"

iex&gt; Path.join(["/", "foo", "bar/"])
"/foo/bar"</code></pre>    <h3 class="detail-header function" id="join/2">  <span class="signature">join(left, right)</span>     </h3>
<pre data-language="elixir">join(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: binary</pre>  <p>Joins two paths.</p> <p>The right path will always be expanded to its relative format and any trailing slash is removed on join.</p> <h4 id="join/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.join("foo", "bar")
"foo/bar"</code></pre>    <h3 class="detail-header function" id="relative/1">  <span class="signature">relative(name)</span>     </h3>
<pre data-language="elixir">relative(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Forces the path to be a relative path.</p> <h4 id="relative/1-unix-examples" class="section-heading">  Unix examples </h4> <pre data-language="elixir"><code class="elixir">Path.relative("/usr/local/bin")   #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("../usr/local/bin") #=&gt; "../usr/local/bin"</code></pre> <h4 id="relative/1-windows-examples" class="section-heading">  Windows examples </h4> <pre data-language="elixir"><code class="elixir">Path.relative("D:/usr/local/bin") #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("D:bar.ex")         #=&gt; "bar.ex"
Path.relative("/bar/foo.ex")      #=&gt; "bar/foo.ex"</code></pre>    <h3 class="detail-header function" id="relative_to/2">  <span class="signature">relative_to(path, from)</span>     </h3>
<pre data-language="elixir">relative_to(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the given <code class="inline">path</code> relative to the given <code class="inline">from</code> path. In other words, it tries to strip the <code class="inline">from</code> prefix from <code class="inline">path</code>.</p> <p>This function does not query the file system, so it assumes no symlinks between the paths.</p> <p>In case a direct relative path cannot be found, it returns the original path.</p> <h4 id="relative_to/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.relative_to("/usr/local/foo", "/usr/local")
"foo"

iex&gt; Path.relative_to("/usr/local/foo", "/")
"usr/local/foo"

iex&gt; Path.relative_to("/usr/local/foo", "/etc")
"/usr/local/foo"</code></pre>    <h3 class="detail-header function" id="relative_to_cwd/1">  <span class="signature">relative_to_cwd(path)</span>     </h3>
<pre data-language="elixir">relative_to_cwd(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Convenience to get the path relative to the current working directory. If, for some reason, the current working directory cannot be retrieved, returns the full path.</p>    <h3 class="detail-header function" id="rootname/1">  <span class="signature">rootname(path)</span>     </h3>
<pre data-language="elixir">rootname(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p> <h4 id="rootname/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.rootname("/foo/bar")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.ex")
"/foo/bar"</code></pre>    <h3 class="detail-header function" id="rootname/2">  <span class="signature">rootname(path, extension)</span>     </h3>
<pre data-language="elixir">rootname(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped. This function should be used to remove a specific extension which might, or might not, be there.</p> <h4 id="rootname/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.rootname("/foo/bar.erl", ".erl")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.erl", ".ex")
"/foo/bar.erl"</code></pre>    <h3 class="detail-header function" id="split/1">  <span class="signature">split(path)</span>     </h3>
<pre data-language="elixir">split(<a href="#t:t/0">t</a>) :: [binary]</pre>  <p>Splits the path into a list at the path separator.</p> <p>If an empty string is given, returns an empty list.</p> <p>On Windows, path is split on both “\” and “/“ separators and the driver letter, if there is one, is always returned in lowercase.</p> <h4 id="split/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Path.split("")
[]

iex&gt; Path.split("foo")
["foo"]

iex&gt; Path.split("/foo/bar")
["/", "foo", "bar"]</code></pre>    <h3 class="detail-header function" id="type/1">  <span class="signature">type(name)</span>     </h3>
<pre data-language="elixir">type(<a href="#t:t/0">t</a>) :: :absolute | :relative | :volumerelative</pre>  <p>Returns the path type.</p> <h4 id="type/1-unix-examples" class="section-heading">  Unix examples </h4> <pre data-language="elixir"><code class="elixir">Path.type("/")                #=&gt; :absolute
Path.type("/usr/local/bin")   #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("../usr/local/bin") #=&gt; :relative
Path.type("~/file")           #=&gt; :relative</code></pre> <h4 id="type/1-windows-examples" class="section-heading">  Windows examples </h4> <pre data-language="elixir"><code class="elixir">Path.type("D:/usr/local/bin") #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("D:bar.ex")         #=&gt; :volumerelative
Path.type("/bar/foo.ex")      #=&gt; :volumerelative</code></pre>     <h3 class="detail-header function" id="wildcard/2">  <span class="signature">wildcard(glob, opts \\ [])</span>     </h3>
<pre data-language="elixir">wildcard(<a href="#t:t/0">t</a>, <a href="../keyword/#t:t/0">Keyword.t</a>) :: [binary]</pre>  <p>Traverses paths according to the given <code class="inline">glob</code> expression, and returns a list of matches.</p> <p>The wildcard looks like an ordinary path, except that certain “wildcard characters” are interpreted in a special way. The following characters are special:</p> <ul> <li>
<p><code class="inline">?</code> - matches one character</p> </li> <li>
<p><code class="inline">*</code> - matches any number of characters up to the end of the filename, the next dot, or the next slash</p> </li> <li>
<p><code class="inline">**</code> - two adjacent <code class="inline">*</code>’s used as a single pattern will match all files and zero or more directories and subdirectories</p> </li> <li>
<p><code class="inline">[char1,char2,...]</code> - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p> </li> <li>
<code class="inline">{item1,item2,...}</code> - matches one of the alternatives Do not add spaces before and after the comma as it would then match paths containing the space character itself. </li> </ul> <p>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive; i.e. “a” will not match “A”.</p> <p>By default, the patterns <code class="inline">*</code> and <code class="inline">?</code> do not match files starting with a dot <code class="inline">.</code> unless <code class="inline">match_dot: true</code> is given in <code class="inline">opts</code>.</p> <h4 id="wildcard/2-examples" class="section-heading">  Examples </h4> <p>Imagine you have a directory called <code class="inline">projects</code> with three Elixir projects inside of it: <code class="inline">elixir</code>, <code class="inline">ex_doc</code> and <code class="inline">dynamo</code>. You can find all <code class="inline">.beam</code> files inside the <code class="inline">ebin</code> directory of each project as follows:</p> <pre data-language="elixir"><code class="elixir">Path.wildcard("projects/*/ebin/**/*.beam")</code></pre> <p>If you want to search for both <code class="inline">.beam</code> and <code class="inline">.app</code> files, you could do:</p> <pre data-language="elixir"><code class="elixir">Path.wildcard("projects/*/ebin/**/*.{beam,app}")</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.4.1/Path.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.4.1/Path.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
