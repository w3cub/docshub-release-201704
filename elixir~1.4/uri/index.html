
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>URI - Elixir 1.4 - W3cubDocs</title>
  
  <meta name="description" content=" Utilities for working with URIs. ">
  <meta name="keywords" content="uri, summary, types, functions, -, elixir, elixir~1.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.4/uri/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.4.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.4/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.4</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  URI  </h1>  <p>Utilities for working with URIs.</p> <p>This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). For reference, most of the functions in this module refer to <a href="https://tools.ietf.org/html/rfc3986" target="_blank">RFC 3986</a>.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#char_reserved?/1">char_reserved?(char)</a> </dt> <dd class="summary-synopsis">
<p>Checks if the character is a “reserved” character in a URI</p> </dd>   <dt class="summary-signature"> <a href="#char_unescaped?/1">char_unescaped?(char)</a> </dt> <dd class="summary-synopsis">
<p>Checks if the character is allowed unescaped in a URI</p> </dd>   <dt class="summary-signature"> <a href="#char_unreserved?/1">char_unreserved?(char)</a> </dt> <dd class="summary-synopsis">
<p>Checks if the character is a “unreserved” character in a URI</p> </dd>   <dt class="summary-signature"> <a href="#decode/1">decode(uri)</a> </dt> <dd class="summary-synopsis">
<p>Percent-unescapes a URI</p> </dd>   <dt class="summary-signature"> <a href="#decode_query/2">decode_query(query, map \\ %{})</a> </dt> <dd class="summary-synopsis">
<p>Decodes a query string into a map</p> </dd>   <dt class="summary-signature"> <a href="#decode_www_form/1">decode_www_form(string)</a> </dt> <dd class="summary-synopsis">
<p>Decodes a string as “x-www-form-urlencoded”</p> </dd>   <dt class="summary-signature"> <a href="#default_port/1">default_port(scheme)</a> </dt> <dd class="summary-synopsis">
<p>Returns the default port for a given scheme</p> </dd>   <dt class="summary-signature"> <a href="#default_port/2">default_port(scheme, port)</a> </dt> <dd class="summary-synopsis">
<p>Registers the default port <code class="inline">port</code> for the given <code class="inline">scheme</code></p> </dd>   <dt class="summary-signature"> <a href="#encode/2">encode(string, predicate \\ &amp;char_unescaped?/1)</a> </dt> <dd class="summary-synopsis">
<p>Percent-escapes the given string</p> </dd>   <dt class="summary-signature"> <a href="#encode_query/1">encode_query(enumerable)</a> </dt> <dd class="summary-synopsis">
<p>Encodes an enumerable into a query string</p> </dd>   <dt class="summary-signature"> <a href="#encode_www_form/1">encode_www_form(string)</a> </dt> <dd class="summary-synopsis">
<p>Encodes a string as “x-www-form-urlencoded”</p> </dd>   <dt class="summary-signature"> <a href="#merge/2">merge(uri, rel)</a> </dt> <dd class="summary-synopsis">
<p>Merges two URIs</p> </dd>   <dt class="summary-signature"> <a href="#parse/1">parse(uri)</a> </dt> <dd class="summary-synopsis">
<p>Parses a well-formed URI reference into its components</p> </dd>   <dt class="summary-signature"> <a href="#path_to_segments/1">path_to_segments(path)</a> </dt>   <dt class="summary-signature"> <a href="#query_decoder/1">query_decoder(query)</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream of two-element tuples representing key-value pairs in the given <code class="inline">query</code></p> </dd>   <dt class="summary-signature"> <a href="#to_string/1">to_string(uri)</a> </dt> <dd class="summary-synopsis">
<p>Returns the string representation of the given <a href="../uri/#content"><code class="inline">URI</code></a> struct</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: %URI{authority: nil | binary, fragment: nil | binary, host: nil | binary, path: nil | binary, port: nil | :inet.port_number, query: nil | binary, scheme: nil | binary, userinfo: nil | binary}</pre>       <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="char_reserved?/1">  <span class="signature">char_reserved?(char)</span>     </h3>
<pre data-language="elixir">char_reserved?(char) :: boolean</pre>  <p>Checks if the character is a “reserved” character in a URI.</p> <p>Reserved characters are specified in <a href="http://tools.ietf.org/html/rfc3986#section-2.2" target="_blank">RFC 3986, section 2.2</a>.</p> <h4 id="char_reserved?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.char_reserved?(?+)
true</code></pre>    <h3 class="detail-header function" id="char_unescaped?/1">  <span class="signature">char_unescaped?(char)</span>     </h3>
<pre data-language="elixir">char_unescaped?(char) :: boolean</pre>  <p>Checks if the character is allowed unescaped in a URI.</p> <p>This is the default used by <a href="../uri/#encode/2"><code class="inline">URI.encode/2</code></a> where both reserved and unreserved characters are kept unescaped.</p> <h4 id="char_unescaped?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.char_unescaped?(?{)
false</code></pre>    <h3 class="detail-header function" id="char_unreserved?/1">  <span class="signature">char_unreserved?(char)</span>     </h3>
<pre data-language="elixir">char_unreserved?(char) :: boolean</pre>  <p>Checks if the character is a “unreserved” character in a URI.</p> <p>Unreserved characters are specified in <a href="http://tools.ietf.org/html/rfc3986#section-2.3" target="_blank">RFC 3986, section 2.3</a>.</p> <h4 id="char_unreserved?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.char_unreserved?(?_)
true</code></pre>    <h3 class="detail-header function" id="decode/1">  <span class="signature">decode(uri)</span>     </h3>
<pre data-language="elixir">decode(binary) :: binary</pre>  <p>Percent-unescapes a URI.</p> <h4 id="decode/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.decode("http%3A%2F%2Felixir-lang.org")
"http://elixir-lang.org"</code></pre>     <h3 class="detail-header function" id="decode_query/2">  <span class="signature">decode_query(query, map \\ %{})</span>     </h3>
<pre data-language="elixir">decode_query(binary, map) :: map</pre>  <p>Decodes a query string into a map.</p> <p>Given a query string of the form of <code class="inline">key1=value1&amp;key2=value2...</code>, this function inserts each key-value pair in the query string as one entry in the given <code class="inline">map</code>. Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped.</p> <p>Use <a href="#query_decoder/1"><code class="inline">query_decoder/1</code></a> if you want to iterate over each value manually.</p> <h4 id="decode_query/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.decode_query("foo=1&amp;bar=2")
%{"bar" =&gt; "2", "foo" =&gt; "1"}

iex&gt; URI.decode_query("percent=oh+yes%21", %{"starting" =&gt; "map"})
%{"percent" =&gt; "oh yes!", "starting" =&gt; "map"}</code></pre>    <h3 class="detail-header function" id="decode_www_form/1">  <span class="signature">decode_www_form(string)</span>     </h3>
<pre data-language="elixir">decode_www_form(binary) :: binary</pre>  <p>Decodes a string as “x-www-form-urlencoded”.</p> <h4 id="decode_www_form/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.decode_www_form("%3Call+in%2F")
"&lt;all in/"</code></pre>    <h3 class="detail-header function" id="default_port/1">  <span class="signature">default_port(scheme)</span>     </h3>
<pre data-language="elixir">default_port(binary) :: nil | non_neg_integer</pre>  <p>Returns the default port for a given scheme.</p> <p>If the scheme is unknown to the <a href="../uri/#content"><code class="inline">URI</code></a> module, this function returns <code class="inline">nil</code>. The default port for any scheme can be configured globally via <a href="#default_port/2"><code class="inline">default_port/2</code></a>.</p> <h4 id="default_port/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.default_port("ftp")
21

iex&gt; URI.default_port("ponzi")
nil</code></pre>    <h3 class="detail-header function" id="default_port/2">  <span class="signature">default_port(scheme, port)</span>     </h3>
<pre data-language="elixir">default_port(binary, non_neg_integer) :: :ok</pre>  <p>Registers the default port <code class="inline">port</code> for the given <code class="inline">scheme</code>.</p> <p>After this function is called, <code class="inline">port</code> will be returned by <a href="#default_port/1"><code class="inline">default_port/1</code></a> for the given scheme <code class="inline">scheme</code>. Note that this function changes the default port for the given <code class="inline">scheme</code> <em>globally</em>, meaning for every application.</p> <p>It is recommended for this function to be invoked in your application’s start callback in case you want to register new URIs.</p>     <h3 class="detail-header function" id="encode/2">  <span class="signature">encode(string, predicate \\ &amp;char_unescaped?/1)</span>     </h3>
<pre data-language="elixir">encode(binary, (byte -&gt; boolean)) :: binary</pre>  <p>Percent-escapes the given string.</p> <p>This function accepts a <code class="inline">predicate</code> function as an optional argument; if passed, this function will be called with each character (byte) in <code class="inline">string</code> as its argument and should return <code class="inline">true</code> if that character should not be escaped and left as is.</p> <h4 id="encode/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.encode("ftp://s-ite.tld/?value=put it+й")
"ftp://s-ite.tld/?value=put%20it+%D0%B9"

iex&gt; URI.encode("a string", &amp;(&amp;1 != ?i))
"a str%69ng"</code></pre>    <h3 class="detail-header function" id="encode_query/1">  <span class="signature">encode_query(enumerable)</span>     </h3>
<pre data-language="elixir">encode_query(term) :: binary</pre>  <p>Encodes an enumerable into a query string.</p> <p>Takes an enumerable that enumerates as a list of two-element tuples (e.g., a map or a keyword list) and returns a string in the form of <code class="inline">key1=value1&amp;key2=value2...</code> where keys and values are URL encoded as per <a href="#encode_www_form/1"><code class="inline">encode_www_form/1</code></a>.</p> <p>Keys and values can be any term that implements the <a href="../string.chars/"><code class="inline">String.Chars</code></a> protocol, except lists which are explicitly forbidden.</p> <h4 id="encode_query/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; hd = %{"foo" =&gt; 1, "bar" =&gt; 2}
iex&gt; URI.encode_query(hd)
"bar=2&amp;foo=1"

iex&gt; query = %{"key" =&gt; "value with spaces"}
iex&gt; URI.encode_query(query)
"key=value+with+spaces"

iex&gt; URI.encode_query %{key: [:a, :list]}
** (ArgumentError) encode_query/1 values cannot be lists, got: [:a, :list]</code></pre>    <h3 class="detail-header function" id="encode_www_form/1">  <span class="signature">encode_www_form(string)</span>     </h3>
<pre data-language="elixir">encode_www_form(binary) :: binary</pre>  <p>Encodes a string as “x-www-form-urlencoded”.</p> <h4 id="encode_www_form/1-example" class="section-heading">  Example </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.encode_www_form("put: it+й")
"put%3A+it%2B%D0%B9"</code></pre>    <h3 class="detail-header function" id="merge/2">  <span class="signature">merge(uri, rel)</span>     </h3>
<pre data-language="elixir">merge(<a href="#t:t/0">t</a> | binary, <a href="#t:t/0">t</a> | binary) :: <a href="#t:t/0">t</a></pre>  <p>Merges two URIs.</p> <p>This function merges two URIs as per <a href="http://tools.ietf.org/html/rfc3986#section-5.2" target="_blank">RFC 3986, section 5.2</a>.</p> <h4 id="merge/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.merge(URI.parse("http://google.com"), "/query") |&gt; to_string
"http://google.com/query"

iex&gt; URI.merge("http://example.com", "http://google.com") |&gt; to_string
"http://google.com"</code></pre>    <h3 class="detail-header function" id="parse/1">  <span class="signature">parse(uri)</span>     </h3>
<pre data-language="elixir">parse(<a href="#t:t/0">t</a> | binary) :: <a href="#t:t/0">t</a></pre>  <p>Parses a well-formed URI reference into its components.</p> <p>Note this function expects a well-formed URI and does not perform any validation. See the “Examples” section below for examples of how <a href="../uri/#parse/1"><code class="inline">URI.parse/1</code></a> can be used to parse a wide range of URIs.</p> <p>This function uses the parsing regular expression as defined in <a href="http://tools.ietf.org/html/rfc3986#appendix-B" target="_blank">RFC 3986, Appendix B</a>.</p> <p>When a URI is given without a port, the value returned by <a href="../uri/#default_port/1"><code class="inline">URI.default_port/1</code></a> for the URI’s scheme is used for the <code class="inline">:port</code> field.</p> <p>If a <code class="inline">%URI{}</code> struct is given to this function, this function returns it unmodified.</p> <h4 id="parse/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.parse("http://elixir-lang.org/")
%URI{scheme: "http", path: "/", query: nil, fragment: nil,
     authority: "elixir-lang.org", userinfo: nil,
     host: "elixir-lang.org", port: 80}

iex&gt; URI.parse("//elixir-lang.org/")
%URI{authority: "elixir-lang.org", fragment: nil, host: "elixir-lang.org",
     path: "/", port: nil, query: nil, scheme: nil, userinfo: nil}

iex&gt; URI.parse("/foo/bar")
%URI{authority: nil, fragment: nil, host: nil, path: "/foo/bar",
     port: nil, query: nil, scheme: nil, userinfo: nil}

iex&gt; URI.parse("foo/bar")
%URI{authority: nil, fragment: nil, host: nil, path: "foo/bar",
     port: nil, query: nil, scheme: nil, userinfo: nil}</code></pre>    <h3 class="detail-header function" id="path_to_segments/1">  <span class="signature">path_to_segments(path)</span>  </h3>     <h3 class="detail-header function" id="query_decoder/1">  <span class="signature">query_decoder(query)</span>     </h3>
<pre data-language="elixir">query_decoder(binary) :: <a href="../enumerable/#t:t/0">Enumerable.t</a></pre>  <p>Returns a stream of two-element tuples representing key-value pairs in the given <code class="inline">query</code>.</p> <p>Key and value in each tuple will be binaries and will be percent-unescaped.</p> <h4 id="query_decoder/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.query_decoder("foo=1&amp;bar=2") |&gt; Enum.to_list()
[{"foo", "1"}, {"bar", "2"}]</code></pre>    <h3 class="detail-header function" id="to_string/1">  <span class="signature">to_string(uri)</span>     </h3>
<pre data-language="elixir">to_string(<a href="#t:t/0">t</a>) :: binary</pre>  <p>Returns the string representation of the given <a href="../uri/#content"><code class="inline">URI</code></a> struct.</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; URI.to_string(URI.parse("http://google.com"))
"http://google.com"

iex&gt; URI.to_string(%URI{scheme: "foo", host: "bar.baz"})
"foo://bar.baz"</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.4.1/URI.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.4.1/URI.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
