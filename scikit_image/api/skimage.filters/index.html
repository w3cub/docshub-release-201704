
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Filters - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Deprecated function. Use skimage.feature.canny instead. ">
  <meta name="keywords" content="module, filters, -, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_image/api/skimage.filters/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="module-filters">Module: filters</h1> <table class="longtable docutils" id="module-skimage.filters">   <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.canny" title="skimage.filters.canny"><code>skimage.filters.canny</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.feature.canny</code> instead.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.copy_func" title="skimage.filters.copy_func"><code>skimage.filters.copy_func</code></a>(f[, name])</td> <td>Create a copy of a function.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.gabor" title="skimage.filters.gabor"><code>skimage.filters.gabor</code></a>(image, frequency[, ...])</td> <td>Return real and imaginary responses to Gabor filter.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.gabor_filter" title="skimage.filters.gabor_filter"><code>skimage.filters.gabor_filter</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.gabor</code> instead.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.gabor_kernel" title="skimage.filters.gabor_kernel"><code>skimage.filters.gabor_kernel</code></a>(frequency[, ...])</td> <td>Return complex 2D Gabor filter kernel.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.gaussian" title="skimage.filters.gaussian"><code>skimage.filters.gaussian</code></a>(image, sigma[, ...])</td> <td>Multi-dimensional Gaussian filter</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.gaussian_filter" title="skimage.filters.gaussian_filter"><code>skimage.filters.gaussian_filter</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.gaussian</code> instead.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.hprewitt" title="skimage.filters.hprewitt"><code>skimage.filters.hprewitt</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.prewitt_h</code> instead.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.hscharr" title="skimage.filters.hscharr"><code>skimage.filters.hscharr</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.scharr_h</code> instead.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.hsobel" title="skimage.filters.hsobel"><code>skimage.filters.hsobel</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.sobel_h</code> instead.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.inverse" title="skimage.filters.inverse"><code>skimage.filters.inverse</code></a>(data[, ...])</td> <td>Apply the filter in reverse to the given data.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.laplace" title="skimage.filters.laplace"><code>skimage.filters.laplace</code></a>(image[, ksize, mask])</td> <td>Find the edges of an image using the Laplace operator.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.median" title="skimage.filters.median"><code>skimage.filters.median</code></a>(image, selem[, out, ...])</td> <td>Return local median of an image.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>skimage.filters.prewitt</code></a>(image[, mask])</td> <td>Find the edge magnitude using the Prewitt transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.prewitt_h" title="skimage.filters.prewitt_h"><code>skimage.filters.prewitt_h</code></a>(image[, mask])</td> <td>Find the horizontal edges of an image using the Prewitt transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.prewitt_v" title="skimage.filters.prewitt_v"><code>skimage.filters.prewitt_v</code></a>(image[, mask])</td> <td>Find the vertical edges of an image using the Prewitt transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.rank_order" title="skimage.filters.rank_order"><code>skimage.filters.rank_order</code></a>(image)</td> <td>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <code>image</code>, aka the rank-order value.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.roberts" title="skimage.filters.roberts"><code>skimage.filters.roberts</code></a>(image[, mask])</td> <td>Find the edge magnitude using Roberts’ cross operator.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.roberts_neg_diag" title="skimage.filters.roberts_neg_diag"><code>skimage.filters.roberts_neg_diag</code></a>(image[, mask])</td> <td>Find the cross edges of an image using the Roberts’ Cross operator.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.roberts_negative_diagonal" title="skimage.filters.roberts_negative_diagonal"><code>skimage.filters.roberts_negative_diagonal</code></a>(...)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.roberts_neg_diag</code> instead.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.roberts_pos_diag" title="skimage.filters.roberts_pos_diag"><code>skimage.filters.roberts_pos_diag</code></a>(image[, mask])</td> <td>Find the cross edges of an image using Roberts’ cross operator.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.roberts_positive_diagonal" title="skimage.filters.roberts_positive_diagonal"><code>skimage.filters.roberts_positive_diagonal</code></a>(...)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.roberts_pos_diag</code> instead.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>skimage.filters.scharr</code></a>(image[, mask])</td> <td>Find the edge magnitude using the Scharr transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.scharr_h" title="skimage.filters.scharr_h"><code>skimage.filters.scharr_h</code></a>(image[, mask])</td> <td>Find the horizontal edges of an image using the Scharr transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.scharr_v" title="skimage.filters.scharr_v"><code>skimage.filters.scharr_v</code></a>(image[, mask])</td> <td>Find the vertical edges of an image using the Scharr transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>skimage.filters.sobel</code></a>(image[, mask])</td> <td>Find the edge magnitude using the Sobel transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.sobel_h" title="skimage.filters.sobel_h"><code>skimage.filters.sobel_h</code></a>(image[, mask])</td> <td>Find the horizontal edges of an image using the Sobel transform.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.sobel_v" title="skimage.filters.sobel_v"><code>skimage.filters.sobel_v</code></a>(image[, mask])</td> <td>Find the vertical edges of an image using the Sobel transform.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.threshold_adaptive" title="skimage.filters.threshold_adaptive"><code>skimage.filters.threshold_adaptive</code></a>(image, ...)</td> <td>Applies an adaptive threshold to an array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.threshold_isodata" title="skimage.filters.threshold_isodata"><code>skimage.filters.threshold_isodata</code></a>(image[, ...])</td> <td>Return threshold value(s) based on ISODATA method.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.threshold_li" title="skimage.filters.threshold_li"><code>skimage.filters.threshold_li</code></a>(image)</td> <td>Return threshold value based on adaptation of Li’s Minimum Cross Entropy method.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.threshold_otsu" title="skimage.filters.threshold_otsu"><code>skimage.filters.threshold_otsu</code></a>(image[, nbins])</td> <td>Return threshold value based on Otsu’s method.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.threshold_yen" title="skimage.filters.threshold_yen"><code>skimage.filters.threshold_yen</code></a>(image[, nbins])</td> <td>Return threshold value based on Yen’s method.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.vprewitt" title="skimage.filters.vprewitt"><code>skimage.filters.vprewitt</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.prewitt_v</code> instead.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.vscharr" title="skimage.filters.vscharr"><code>skimage.filters.vscharr</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.scharr_v</code> instead.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.vsobel" title="skimage.filters.vsobel"><code>skimage.filters.vsobel</code></a>(*args, **kwargs)</td> <td>
<strong>Deprecated function</strong>. Use <code>skimage.filters.sobel_v</code> instead.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.wiener" title="skimage.filters.wiener"><code>skimage.filters.wiener</code></a>(data[, ...])</td> <td>Minimum Mean Square Error (Wiener) inverse filter.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="#skimage.filters.LPIFilter2D" title="skimage.filters.LPIFilter2D"><code>skimage.filters.LPIFilter2D</code></a>(...)</td> <td>Linear Position-Invariant Filter (2-dimensional)</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="#skimage.filters.deprecated" title="skimage.filters.deprecated"><code>skimage.filters.deprecated</code></a>([alt_func, behavior])</td> <td>Decorator to mark deprecated functions with warning.</td> </tr>  </table>  <h2 id="canny">canny</h2> <dl class="function"> <dt id="skimage.filters.canny">
<code>skimage.filters.canny(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.feature.canny</code> instead.</p> </dd>
</dl>   <h2 id="copy-func">copy_func</h2> <dl class="function"> <dt id="skimage.filters.copy_func">
<code>skimage.filters.copy_func(f, name=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L180" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a copy of a function.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>f</strong> : function</p>  <p>Function to copy.</p>  <p><strong>name</strong> : str, optional</p>  <p>Name of new function.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="gabor">gabor</h2> <dl class="function"> <dt id="skimage.filters.gabor">
<code>skimage.filters.gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/_gabor.py#L97" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return real and imaginary responses to Gabor filter.</p> <p>The real and imaginary parts of the Gabor filter kernel are applied to the image and the response is returned as a pair of arrays.</p> <p>Gabor filter is a linear filter with a Gaussian kernel which is modulated by a sinusoidal plane wave. Frequency and orientation representations of the Gabor filter are similar to those of the human visual system. Gabor filter banks are commonly used in computer vision and image processing. They are especially suitable for edge detection and texture classification.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Input image.</p>  <p><strong>frequency</strong> : float</p>  <p>Spatial frequency of the harmonic function. Specified in pixels.</p>  <p><strong>theta</strong> : float, optional</p>  <p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>  <p><strong>bandwidth</strong> : float, optional</p>  <p>The bandwidth captured by the filter. For fixed bandwidth, <code>sigma_x</code> and <code>sigma_y</code> will decrease with increasing frequency. This value is ignored if <code>sigma_x</code> and <code>sigma_y</code> are set by the user.</p>  <p><strong>sigma_x, sigma_y</strong> : float, optional</p>  <p>Standard deviation in x- and y-directions. These directions apply to the kernel <em>before</em> rotation. If <code>theta = pi/2</code>, then the kernel is rotated 90 degrees so that <code>sigma_x</code> controls the <em>vertical</em> direction.</p>  <p><strong>n_stds</strong> : scalar, optional</p>  <p>The linear size of the kernel is n_stds (3 by default) standard deviations.</p>  <p><strong>offset</strong> : float, optional</p>  <p>Phase offset of harmonic function in radians.</p>  <p><strong>mode</strong> : {‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</p>  <p>Mode used to convolve image with a kernel, passed to <code>ndi.convolve</code></p>  <p><strong>cval</strong> : scalar, optional</p>  <p>Value to fill past edges of input if <code>mode</code> of convolution is ‘constant’. The parameter is passed to <code>ndi.convolve</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>real, imag</strong> : arrays</p>  <p>Filtered images using the real and imaginary parts of the Gabor filter kernel. Images are of the same dimensions as the input one.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r186" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[R186]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Gabor_filter" target="_blank">http://en.wikipedia.org/wiki/Gabor_filter</a></td>
</tr>  </table> <table class="docutils citation" frame="void" id="r187" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[R187]</a></td>
<td><a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf" target="_blank">http://mplab.ucsd.edu/tutorials/gabor.pdf</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import gabor
&gt;&gt;&gt; from skimage import data, io
&gt;&gt;&gt; from matplotlib import pyplot as plt  
</pre> <pre data-language="python">&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; # detecting edges in a coin image
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.6)
&gt;&gt;&gt; plt.figure()            
&gt;&gt;&gt; io.imshow(filt_real)    
&gt;&gt;&gt; io.show()               
</pre> <pre data-language="python">&gt;&gt;&gt; # less sensitivity to finer details with the lower frequency kernel
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.1)
&gt;&gt;&gt; plt.figure()            
&gt;&gt;&gt; io.imshow(filt_real)    
&gt;&gt;&gt; io.show()               
</pre> </dd>
</dl>   <h2 id="gabor-filter">gabor_filter</h2> <dl class="function"> <dt id="skimage.filters.gabor_filter">
<code>skimage.filters.gabor_filter(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.gabor</code> instead.</p> <p>Return real and imaginary responses to Gabor filter.</p> <p>The real and imaginary parts of the Gabor filter kernel are applied to the image and the response is returned as a pair of arrays.</p> <p>Gabor filter is a linear filter with a Gaussian kernel which is modulated by a sinusoidal plane wave. Frequency and orientation representations of the Gabor filter are similar to those of the human visual system. Gabor filter banks are commonly used in computer vision and image processing. They are especially suitable for edge detection and texture classification.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Input image.</p>  <p><strong>frequency</strong> : float</p>  <p>Spatial frequency of the harmonic function. Specified in pixels.</p>  <p><strong>theta</strong> : float, optional</p>  <p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>  <p><strong>bandwidth</strong> : float, optional</p>  <p>The bandwidth captured by the filter. For fixed bandwidth, <code>sigma_x</code> and <code>sigma_y</code> will decrease with increasing frequency. This value is ignored if <code>sigma_x</code> and <code>sigma_y</code> are set by the user.</p>  <p><strong>sigma_x, sigma_y</strong> : float, optional</p>  <p>Standard deviation in x- and y-directions. These directions apply to the kernel <em>before</em> rotation. If <code>theta = pi/2</code>, then the kernel is rotated 90 degrees so that <code>sigma_x</code> controls the <em>vertical</em> direction.</p>  <p><strong>n_stds</strong> : scalar, optional</p>  <p>The linear size of the kernel is n_stds (3 by default) standard deviations.</p>  <p><strong>offset</strong> : float, optional</p>  <p>Phase offset of harmonic function in radians.</p>  <p><strong>mode</strong> : {‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</p>  <p>Mode used to convolve image with a kernel, passed to <code>ndi.convolve</code></p>  <p><strong>cval</strong> : scalar, optional</p>  <p>Value to fill past edges of input if <code>mode</code> of convolution is ‘constant’. The parameter is passed to <code>ndi.convolve</code>.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>real, imag</strong> : arrays</p>  <p>Filtered images using the real and imaginary parts of the Gabor filter kernel. Images are of the same dimensions as the input one.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r188" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[R188]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Gabor_filter" target="_blank">http://en.wikipedia.org/wiki/Gabor_filter</a></td>
</tr>  </table> <table class="docutils citation" frame="void" id="r189" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[R189]</a></td>
<td><a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf" target="_blank">http://mplab.ucsd.edu/tutorials/gabor.pdf</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import gabor
&gt;&gt;&gt; from skimage import data, io
&gt;&gt;&gt; from matplotlib import pyplot as plt  
</pre> <pre data-language="python">&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; # detecting edges in a coin image
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.6)
&gt;&gt;&gt; plt.figure()            
&gt;&gt;&gt; io.imshow(filt_real)    
&gt;&gt;&gt; io.show()               
</pre> <pre data-language="python">&gt;&gt;&gt; # less sensitivity to finer details with the lower frequency kernel
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.1)
&gt;&gt;&gt; plt.figure()            
&gt;&gt;&gt; io.imshow(filt_real)    
&gt;&gt;&gt; io.show()               
</pre> </dd>
</dl>   <h2 id="gabor-kernel">gabor_kernel</h2> <dl class="function"> <dt id="skimage.filters.gabor_kernel">
<code>skimage.filters.gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/_gabor.py#L16" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return complex 2D Gabor filter kernel.</p> <p>Gabor kernel is a Gaussian kernel modulated by a complex harmonic function. Harmonic function consists of an imaginary sine function and a real cosine function. Spatial frequency is inversely proportional to the wavelength of the harmonic and to the standard deviation of a Gaussian kernel. The bandwidth is also inversely proportional to the standard deviation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>frequency</strong> : float</p>  <p>Spatial frequency of the harmonic function. Specified in pixels.</p>  <p><strong>theta</strong> : float, optional</p>  <p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>  <p><strong>bandwidth</strong> : float, optional</p>  <p>The bandwidth captured by the filter. For fixed bandwidth, <code>sigma_x</code> and <code>sigma_y</code> will decrease with increasing frequency. This value is ignored if <code>sigma_x</code> and <code>sigma_y</code> are set by the user.</p>  <p><strong>sigma_x, sigma_y</strong> : float, optional</p>  <p>Standard deviation in x- and y-directions. These directions apply to the kernel <em>before</em> rotation. If <code>theta = pi/2</code>, then the kernel is rotated 90 degrees so that <code>sigma_x</code> controls the <em>vertical</em> direction.</p>  <p><strong>n_stds</strong> : scalar, optional</p>  <p>The linear size of the kernel is n_stds (3 by default) standard deviations</p>  <p><strong>offset</strong> : float, optional</p>  <p>Phase offset of harmonic function in radians.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>g</strong> : complex array</p>  <p>Complex filter kernel.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r190" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id5">[R190]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Gabor_filter" target="_blank">http://en.wikipedia.org/wiki/Gabor_filter</a></td>
</tr>  </table> <table class="docutils citation" frame="void" id="r191" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id6">[R191]</a></td>
<td><a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf" target="_blank">http://mplab.ucsd.edu/tutorials/gabor.pdf</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import gabor_kernel
&gt;&gt;&gt; from skimage import io
&gt;&gt;&gt; from matplotlib import pyplot as plt  
</pre> <pre data-language="python">&gt;&gt;&gt; gk = gabor_kernel(frequency=0.2)
&gt;&gt;&gt; plt.figure()        
&gt;&gt;&gt; io.imshow(gk.real)  
&gt;&gt;&gt; io.show()           
</pre> <pre data-language="python">&gt;&gt;&gt; # more ripples (equivalent to increasing the size of the
&gt;&gt;&gt; # Gaussian spread)
&gt;&gt;&gt; gk = gabor_kernel(frequency=0.2, bandwidth=0.1)
&gt;&gt;&gt; plt.figure()        
&gt;&gt;&gt; io.imshow(gk.real)  
&gt;&gt;&gt; io.show()           
</pre> </dd>
</dl>   <h2 id="gaussian">gaussian</h2> <dl class="function"> <dt id="skimage.filters.gaussian">
<code>skimage.filters.gaussian(image, sigma, output=None, mode='nearest', cval=0, multichannel=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/_gaussian.py#L12" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Multi-dimensional Gaussian filter</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array-like</p>  <p>input image (grayscale or color) to filter.</p>  <p><strong>sigma</strong> : scalar or sequence of scalars</p>  <p>standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes.</p>  <p><strong>output</strong> : array, optional</p>  <p>The <code>output</code> parameter passes an array in which to store the filter output.</p>  <p><strong>mode</strong> : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</p>  <p>The <code>mode</code> parameter determines how the array borders are handled, where <code>cval</code> is the value when mode is equal to ‘constant’. Default is ‘nearest’.</p>  <p><strong>cval</strong> : scalar, optional</p>  <p>Value to fill past edges of input if <code>mode</code> is ‘constant’. Default is 0.0</p>  <p><strong>multichannel</strong> : bool, optional (default: None)</p>  <p>Whether the last axis of the image is to be interpreted as multiple channels. If True, each channel is filtered separately (channels are not mixed together). Only 3 channels are supported. If <code>None</code>, the function will attempt to guess this, and raise a warning if ambiguous, when the array has shape (M, N, 3).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>filtered_image</strong> : ndarray</p>  <p>the filtered array</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This function is a wrapper around <code>scipy.ndi.gaussian_filter()</code>.</p> <p>Integer arrays are converted to float.</p> <p>The multi-dimensional filter is implemented as a sequence of one-dimensional convolution filters. The intermediate arrays are stored in the same data type as the output. Therefore, for output types with a limited precision, the results may be imprecise because intermediate results may be stored with insufficient precision.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; a[1, 1] = 1
&gt;&gt;&gt; a
array([[ 0.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  0.]])
&gt;&gt;&gt; gaussian(a, sigma=0.4)  # mild smoothing
array([[ 0.00163116,  0.03712502,  0.00163116],
       [ 0.03712502,  0.84496158,  0.03712502],
       [ 0.00163116,  0.03712502,  0.00163116]])
&gt;&gt;&gt; gaussian(a, sigma=1)  # more smooting
array([[ 0.05855018,  0.09653293,  0.05855018],
       [ 0.09653293,  0.15915589,  0.09653293],
       [ 0.05855018,  0.09653293,  0.05855018]])
&gt;&gt;&gt; # Several modes are possible for handling boundaries
&gt;&gt;&gt; gaussian(a, sigma=1, mode='reflect')
array([[ 0.08767308,  0.12075024,  0.08767308],
       [ 0.12075024,  0.16630671,  0.12075024],
       [ 0.08767308,  0.12075024,  0.08767308]])
&gt;&gt;&gt; # For RGB images, each is filtered separately
&gt;&gt;&gt; from skimage.data import astronaut
&gt;&gt;&gt; image = astronaut()
&gt;&gt;&gt; filtered_img = gaussian(image, sigma=1, multichannel=True)
</pre> </dd>
</dl>   <h2 id="gaussian-filter">gaussian_filter</h2> <dl class="function"> <dt id="skimage.filters.gaussian_filter">
<code>skimage.filters.gaussian_filter(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.gaussian</code> instead.</p> <p>Multi-dimensional Gaussian filter</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array-like</p>  <p>input image (grayscale or color) to filter.</p>  <p><strong>sigma</strong> : scalar or sequence of scalars</p>  <p>standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes.</p>  <p><strong>output</strong> : array, optional</p>  <p>The <code>output</code> parameter passes an array in which to store the filter output.</p>  <p><strong>mode</strong> : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</p>  <p>The <code>mode</code> parameter determines how the array borders are handled, where <code>cval</code> is the value when mode is equal to ‘constant’. Default is ‘nearest’.</p>  <p><strong>cval</strong> : scalar, optional</p>  <p>Value to fill past edges of input if <code>mode</code> is ‘constant’. Default is 0.0</p>  <p><strong>multichannel</strong> : bool, optional (default: None)</p>  <p>Whether the last axis of the image is to be interpreted as multiple channels. If True, each channel is filtered separately (channels are not mixed together). Only 3 channels are supported. If <code>None</code>, the function will attempt to guess this, and raise a warning if ambiguous, when the array has shape (M, N, 3).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>filtered_image</strong> : ndarray</p>  <p>the filtered array</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This function is a wrapper around <code>scipy.ndi.gaussian_filter()</code>.</p> <p>Integer arrays are converted to float.</p> <p>The multi-dimensional filter is implemented as a sequence of one-dimensional convolution filters. The intermediate arrays are stored in the same data type as the output. Therefore, for output types with a limited precision, the results may be imprecise because intermediate results may be stored with insufficient precision.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; a[1, 1] = 1
&gt;&gt;&gt; a
array([[ 0.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  0.]])
&gt;&gt;&gt; gaussian(a, sigma=0.4)  # mild smoothing
array([[ 0.00163116,  0.03712502,  0.00163116],
       [ 0.03712502,  0.84496158,  0.03712502],
       [ 0.00163116,  0.03712502,  0.00163116]])
&gt;&gt;&gt; gaussian(a, sigma=1)  # more smooting
array([[ 0.05855018,  0.09653293,  0.05855018],
       [ 0.09653293,  0.15915589,  0.09653293],
       [ 0.05855018,  0.09653293,  0.05855018]])
&gt;&gt;&gt; # Several modes are possible for handling boundaries
&gt;&gt;&gt; gaussian(a, sigma=1, mode='reflect')
array([[ 0.08767308,  0.12075024,  0.08767308],
       [ 0.12075024,  0.16630671,  0.12075024],
       [ 0.08767308,  0.12075024,  0.08767308]])
&gt;&gt;&gt; # For RGB images, each is filtered separately
&gt;&gt;&gt; from skimage.data import astronaut
&gt;&gt;&gt; image = astronaut()
&gt;&gt;&gt; filtered_img = gaussian(image, sigma=1, multichannel=True)
</pre> </dd>
</dl>   <h2 id="hprewitt">hprewitt</h2> <dl class="function"> <dt id="skimage.filters.hprewitt">
<code>skimage.filters.hprewitt(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.prewitt_h</code> instead.</p> <p>Find the horizontal edges of an image using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Prewitt edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python"> 1   1   1
 0   0   0
-1  -1  -1
</pre> </dd>
</dl>   <h2 id="hscharr">hscharr</h2> <dl class="function"> <dt id="skimage.filters.hscharr">
<code>skimage.filters.hscharr(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.scharr_h</code> instead.</p> <p>Find the horizontal edges of an image using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Scharr edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python"> 3   10   3
 0    0   0
-3  -10  -3
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r192" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id7">[R192]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> </dd>
</dl>   <h2 id="hsobel">hsobel</h2> <dl class="function"> <dt id="skimage.filters.hsobel">
<code>skimage.filters.hsobel(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.sobel_h</code> instead.</p> <p>Find the horizontal edges of an image using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Sobel edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python"> 1   2   1
 0   0   0
-1  -2  -1
</pre> </dd>
</dl>   <h2 id="inverse">inverse</h2> <dl class="function"> <dt id="skimage.filters.inverse">
<code>skimage.filters.inverse(data, impulse_response=None, filter_params={}, max_gain=2, predefined_filter=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/lpi_filter.py#L167" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the filter in reverse to the given data.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (M,N) ndarray</p>  <p>Input data.</p>  <p><strong>impulse_response</strong> : callable <code>f(r, c, **filter_params)</code></p>  <p>Impulse response of the filter. See LPIFilter2D.__init__.</p>  <p><strong>filter_params</strong> : dict</p>  <p>Additional keyword parameters to the impulse_response function.</p>  <p><strong>max_gain</strong> : float</p>  <p>Limit the filter gain. Often, the filter contains zeros, which would cause the inverse filter to have infinite gain. High gain causes amplification of artefacts, so a conservative limit is recommended.</p>  </td> </tr> <tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-even field">
<td> </td>
<td class="field-body">
<p class="first"><strong>predefined_filter</strong> : LPIFilter2D</p>  <p>If you need to apply the same filter multiple times over different images, construct the LPIFilter2D and specify it here.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="laplace">laplace</h2> <dl class="function"> <dt id="skimage.filters.laplace">
<code>skimage.filters.laplace(image, ksize=3, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L768" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edges of an image using the Laplace operator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Image to process.</p>  <p><strong>ksize</strong> : int, optional</p>  <p>Define the size of the discrete Laplacian operator such that it will have a size of (ksize,) * image.ndim.</p>  <p><strong>mask</strong> : ndarray, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : ndarray</p>  <p>The Laplace edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The Laplacian operator is generated using the function skimage.restoration.uft.laplacian().</p> </dd>
</dl>   <h2 id="median">median</h2> <dl class="function"> <dt id="skimage.filters.median">
<code>skimage.filters.median(image, selem, out=None, mask=None, shift_x=False, shift_y=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/rank/generic.py#L428" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return local median of an image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array (uint8, uint16)</p>  <p>Input image.</p>  <p><strong>selem</strong> : 2-D array</p>  <p>The neighborhood expressed as a 2-D array of 1’s and 0’s.</p>  <p><strong>out</strong> : 2-D array (same dtype as input)</p>  <p>If None, a new array is allocated.</p>  <p><strong>mask</strong> : ndarray</p>  <p>Mask array that defines (&gt;0) area of the image included in the local neighborhood. If None, the complete image is used (default).</p>  <p><strong>shift_x, shift_y</strong> : int</p>  <p>Offset added to the structuring element center point. Shift is bounded to the structuring element sizes (center must be inside the given structuring element).</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : 2-D array (same dtype as input image)</p>  <p>Output image.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.morphology import disk
&gt;&gt;&gt; from skimage.filters.rank import median
&gt;&gt;&gt; img = data.camera()
&gt;&gt;&gt; med = median(img, disk(5))
</pre> </dd>
</dl>   <h2 id="prewitt">prewitt</h2> <dl class="function"> <dt id="skimage.filters.prewitt">
<code>skimage.filters.prewitt(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L429" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Prewitt edge map.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>sobel</code></a>, <a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>scharr</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>Return the square root of the sum of squares of the horizontal and vertical Prewitt transforms. The edge magnitude depends slightly on edge directions, since the approximation of the gradient operator by the Prewitt operator is not completely rotation invariant. For a better rotation invariance, the Scharr operator should be used. The Sobel operator has a better rotation invariance than the Prewitt operator, but a worse rotation invariance than the Scharr operator.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.prewitt(camera)
</pre> </dd>
</dl>   <h2 id="prewitt-h">prewitt_h</h2> <dl class="function"> <dt id="skimage.filters.prewitt_h">
<code>skimage.filters.prewitt_h(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L473" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Prewitt edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 1   1   1
 0   0   0
-1  -1  -1
</pre> </dd>
</dl>   <h2 id="prewitt-v">prewitt_v</h2> <dl class="function"> <dt id="skimage.filters.prewitt_v">
<code>skimage.filters.prewitt_v(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L505" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Prewitt edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0  -1
1   0  -1
1   0  -1
</pre> </dd>
</dl>   <h2 id="rank-order">rank_order</h2> <dl class="function"> <dt id="skimage.filters.rank_order">
<code>skimage.filters.rank_order(image)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/_rank_order.py#L14" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <code>image</code>, aka the rank-order value.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image: ndarray</strong></p> </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">labels: ndarray of type np.uint32, of shape image.shape</p>  <p>New array where each pixel has the rank-order value of the corresponding pixel in <code>image</code>. Pixel values are between 0 and n - 1, where n is the number of distinct unique values in <code>image</code>.</p>  <p>original_values: 1-D ndarray</p>  <p>Unique original values of <code>image</code></p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.array([[1, 4, 5], [4, 4, 1], [5, 1, 1]])
&gt;&gt;&gt; a
array([[1, 4, 5],
       [4, 4, 1],
       [5, 1, 1]])
&gt;&gt;&gt; rank_order(a)
(array([[0, 1, 2],
       [1, 1, 0],
       [2, 0, 0]], dtype=uint32), array([1, 4, 5]))
&gt;&gt;&gt; b = np.array([-1., 2.5, 3.1, 2.5])
&gt;&gt;&gt; rank_order(b)
(array([0, 1, 2, 1], dtype=uint32), array([-1. ,  2.5,  3.1]))
</pre> </dd>
</dl>   <h2 id="roberts">roberts</h2> <dl class="function"> <dt id="skimage.filters.roberts">
<code>skimage.filters.roberts(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L599" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using Roberts’ cross operator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Roberts’ Cross edge map.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>sobel</code></a>, <a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>scharr</code></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>prewitt</code></a>, <code>feature.canny</code></p> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.roberts(camera)
</pre> </dd>
</dl>   <h2 id="roberts-neg-diag">roberts_neg_diag</h2> <dl class="function"> <dt id="skimage.filters.roberts_neg_diag">
<code>skimage.filters.roberts_neg_diag(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L669" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the cross edges of an image using the Roberts’ Cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Robert’s edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 0   1
-1   0
</pre> </dd>
</dl>   <h2 id="roberts-negative-diagonal">roberts_negative_diagonal</h2> <dl class="function"> <dt id="skimage.filters.roberts_negative_diagonal">
<code>skimage.filters.roberts_negative_diagonal(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.roberts_neg_diag</code> instead.</p> <p>Find the cross edges of an image using the Roberts’ Cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Robert’s edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python"> 0   1
-1   0
</pre> </dd>
</dl>   <h2 id="roberts-pos-diag">roberts_pos_diag</h2> <dl class="function"> <dt id="skimage.filters.roberts_pos_diag">
<code>skimage.filters.roberts_pos_diag(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L635" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the cross edges of an image using Roberts’ cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Robert’s edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0
0  -1
</pre> </dd>
</dl>   <h2 id="roberts-positive-diagonal">roberts_positive_diagonal</h2> <dl class="function"> <dt id="skimage.filters.roberts_positive_diagonal">
<code>skimage.filters.roberts_positive_diagonal(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.roberts_pos_diag</code> instead.</p> <p>Find the cross edges of an image using Roberts’ cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Robert’s edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python">1   0
0  -1
</pre> </dd>
</dl>   <h2 id="scharr">scharr</h2> <dl class="function"> <dt id="skimage.filters.scharr">
<code>skimage.filters.scharr(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L236" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Scharr edge map.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>sobel</code></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>prewitt</code></a>, <a class="reference internal" href="#skimage.filters.canny" title="skimage.filters.canny"><code>canny</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>Take the square root of the sum of the squares of the horizontal and vertical Scharrs to get a magnitude that is somewhat insensitive to direction. The Scharr operator has a better rotation invariance than other edge filters such as the Sobel or the Prewitt operators.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r193" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id8">[R193]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r194" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id9">[R194]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators" target="_blank">http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.scharr(camera)
</pre> </dd>
</dl>   <h2 id="scharr-h">scharr_h</h2> <dl class="function"> <dt id="skimage.filters.scharr_h">
<code>skimage.filters.scharr_h(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L283" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Scharr edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 3   10   3
 0    0   0
-3  -10  -3
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r195" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id10">[R195]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> </dd>
</dl>   <h2 id="scharr-v">scharr_v</h2> <dl class="function"> <dt id="skimage.filters.scharr_v">
<code>skimage.filters.scharr_v(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L320" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Scharr edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 3   0   -3
10   0  -10
 3   0   -3
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r196" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id11">[R196]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> </dd>
</dl>   <h2 id="sobel">sobel</h2> <dl class="function"> <dt id="skimage.filters.sobel">
<code>skimage.filters.sobel(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L59" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Sobel edge map.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>scharr</code></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>prewitt</code></a>, <a class="reference internal" href="#skimage.filters.roberts" title="skimage.filters.roberts"><code>roberts</code></a>, <code>feature.canny</code></p> </div> <h4 class="rubric">Notes</h4> <p>Take the square root of the sum of the squares of the horizontal and vertical Sobels to get a magnitude that’s somewhat insensitive to direction.</p> <p>The 3x3 convolution kernel used in the horizontal and vertical Sobels is an approximation of the gradient of the image (with some slight blurring since 9 pixels are used to compute the gradient at a given pixel). As an approximation of the gradient, the Sobel operator is not completely rotation-invariant. The Scharr operator should be used for a better rotation invariance.</p> <p>Note that <code>scipy.ndimage.sobel</code> returns a directional Sobel which has to be further processed to perform edge detection.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.sobel(camera)
</pre> </dd>
</dl>   <h2 id="sobel-h">sobel_h</h2> <dl class="function"> <dt id="skimage.filters.sobel_h">
<code>skimage.filters.sobel_h(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L109" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Sobel edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 1   2   1
 0   0   0
-1  -2  -1
</pre> </dd>
</dl>   <h2 id="sobel-v">sobel_v</h2> <dl class="function"> <dt id="skimage.filters.sobel_v">
<code>skimage.filters.sobel_v(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/edges.py#L141" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The Sobel edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0  -1
2   0  -2
1   0  -1
</pre> </dd>
</dl>   <h2 id="threshold-adaptive">threshold_adaptive</h2> <dl class="function"> <dt id="skimage.filters.threshold_adaptive">
<code>skimage.filters.threshold_adaptive(image, block_size, method='gaussian', offset=0, mode='reflect', param=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/thresholding.py#L13" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies an adaptive threshold to an array.</p> <p>Also known as local or dynamic thresholding where the threshold value is the weighted mean for the local neighborhood of a pixel subtracted by a constant. Alternatively the threshold can be determined dynamically by a a given function using the ‘generic’ method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : (N, M) ndarray</p>  <p>Input image.</p>  <p><strong>block_size</strong> : int</p>  <p>Odd size of pixel neighborhood which is used to calculate the threshold value (e.g. 3, 5, 7, ..., 21, ...).</p>  <p><strong>method</strong> : {‘generic’, ‘gaussian’, ‘mean’, ‘median’}, optional</p>  <p>Method used to determine adaptive threshold for local neighbourhood in weighted mean image.</p> <ul class="simple"> <li>‘generic’: use custom function (see <code>param</code> parameter)</li> <li>‘gaussian’: apply gaussian filter (see <code>param</code> parameter for custom sigma value)</li> <li>‘mean’: apply arithmetic mean filter</li> <li>‘median’: apply median rank filter</li> </ul> <p>By default the ‘gaussian’ method is used.</p>  <p><strong>offset</strong> : float, optional</p>  <p>Constant subtracted from weighted mean of neighborhood to calculate the local threshold value. Default offset is 0.</p>  <p><strong>mode</strong> : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</p>  <p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’.</p>  <p><strong>param</strong> : {int, function}, optional</p>  <p>Either specify sigma for ‘gaussian’ method or function object for ‘generic’ method. This functions takes the flat array of local neighbourhood as a single argument and returns the calculated threshold for the centre pixel.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>threshold</strong> : (N, M) ndarray</p>  <p>Thresholded binary image</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r197" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id12">[R197]</a></td>
<td><a class="reference external" href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold" target="_blank">http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()[:50, :50]
&gt;&gt;&gt; binary_image1 = threshold_adaptive(image, 15, 'mean')
&gt;&gt;&gt; func = lambda arr: arr.mean()
&gt;&gt;&gt; binary_image2 = threshold_adaptive(image, 15, 'generic', param=func)
</pre> </dd>
</dl>   <h2 id="threshold-isodata">threshold_isodata</h2> <dl class="function"> <dt id="skimage.filters.threshold_isodata">
<code>skimage.filters.threshold_isodata(image, nbins=256, return_all=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/thresholding.py#L214" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value(s) based on ISODATA method.</p> <p>Histogram-based threshold, known as Ridler-Calvard method or inter-means. Threshold values returned satisfy the following equality:</p> <dl class="docutils"> <dt>
<code>threshold = (image[image &lt;= threshold].mean() +</code> </dt> <dd><code>image[image &gt; threshold].mean()) / 2.0</code></dd> </dl> <p>That is, returned thresholds are intensities that separate the image into two groups of pixels, where the threshold intensity is midway between the mean intensities of these groups.</p> <p>For integer images, the above equality holds to within one; for floating- point images, the equality holds to within the histogram bin-width.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Input image.</p>  <p><strong>nbins</strong> : int, optional</p>  <p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p>  <p><strong>return_all: bool, optional</strong></p>  <p>If False (default), return only the lowest threshold that satisfies the above equality. If True, return all valid thresholds.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>threshold</strong> : float or int or array</p>  <p>Threshold value(s).</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r198" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id13">[R198]</a></td>
<td>Ridler, TW &amp; Calvard, S (1978), “Picture thresholding using an iterative selection method”</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r199" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id14">[R199]</a></td>
<td>IEEE Transactions on Systems, Man and Cybernetics 8: 630-632, <a class="reference external" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4310039" target="_blank">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4310039</a>
</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r200" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id15">[R200]</a></td>
<td>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165, <a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf" target="_blank">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a>
</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r201" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id16">[R201]</a></td>
<td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold" target="_blank">http://fiji.sc/wiki/index.php/Auto_Threshold</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import coins
&gt;&gt;&gt; image = coins()
&gt;&gt;&gt; thresh = threshold_isodata(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-li">threshold_li</h2> <dl class="function"> <dt id="skimage.filters.threshold_li">
<code>skimage.filters.threshold_li(image)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/thresholding.py#L322" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on adaptation of Li’s Minimum Cross Entropy method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Input image.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>threshold</strong> : float</p>  <p>Upper threshold value. All pixels intensities more than this value are assumed to be foreground.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r202" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id17">[R202]</a></td>
<td>Li C.H. and Lee C.K. (1993) “Minimum Cross Entropy Thresholding” Pattern Recognition, 26(4): 617-625</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r203" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id18">[R203]</a></td>
<td>Li C.H. and Tam P.K.S. (1998) “An Iterative Algorithm for Minimum Cross Entropy Thresholding” Pattern Recognition Letters, 18(8): 771-776</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r204" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id19">[R204]</a></td>
<td>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165 <a class="reference external" href="http://citeseer.ist.psu.edu/sezgin04survey.html" target="_blank">http://citeseer.ist.psu.edu/sezgin04survey.html</a>
</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r205" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id20">[R205]</a></td>
<td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold" target="_blank">http://fiji.sc/wiki/index.php/Auto_Threshold</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_li(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-otsu">threshold_otsu</h2> <dl class="function"> <dt id="skimage.filters.threshold_otsu">
<code>skimage.filters.threshold_otsu(image, nbins=256)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/thresholding.py#L97" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on Otsu’s method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Grayscale input image.</p>  <p><strong>nbins</strong> : int, optional</p>  <p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>threshold</strong> : float</p>  <p>Upper threshold value. All pixels intensities that less or equal of this value assumed as foreground.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The input image must be grayscale.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r206" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id21">[R206]</a></td>
<td>Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/Otsu's_Method" target="_blank">http://en.wikipedia.org/wiki/Otsu’s_Method</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_otsu(image)
&gt;&gt;&gt; binary = image &lt;= thresh
</pre> </dd>
</dl>   <h2 id="threshold-yen">threshold_yen</h2> <dl class="function"> <dt id="skimage.filters.threshold_yen">
<code>skimage.filters.threshold_yen(image, nbins=256)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/thresholding.py#L160" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on Yen’s method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Input image.</p>  <p><strong>nbins</strong> : int, optional</p>  <p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>threshold</strong> : float</p>  <p>Upper threshold value. All pixels intensities that less or equal of this value assumed as foreground.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r207" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id22">[R207]</a></td>
<td>Yen J.C., Chang F.J., and Chang S. (1995) “A New Criterion for Automatic Multilevel Thresholding” IEEE Trans. on Image Processing, 4(3): 370-378</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r208" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id23">[R208]</a></td>
<td>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165, <a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf" target="_blank">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a>
</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r209" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id24">[R209]</a></td>
<td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold" target="_blank">http://fiji.sc/wiki/index.php/Auto_Threshold</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_yen(image)
&gt;&gt;&gt; binary = image &lt;= thresh
</pre> </dd>
</dl>   <h2 id="vprewitt">vprewitt</h2> <dl class="function"> <dt id="skimage.filters.vprewitt">
<code>skimage.filters.vprewitt(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.prewitt_v</code> instead.</p> <p>Find the vertical edges of an image using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process.</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Prewitt edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python">1   0  -1
1   0  -1
1   0  -1
</pre> </dd>
</dl>   <h2 id="vscharr">vscharr</h2> <dl class="function"> <dt id="skimage.filters.vscharr">
<code>skimage.filters.vscharr(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.scharr_v</code> instead.</p> <p>Find the vertical edges of an image using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Scharr edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python"> 3   0   -3
10   0  -10
 3   0   -3
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r210" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id25">[R210]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> </dd>
</dl>   <h2 id="vsobel">vsobel</h2> <dl class="function"> <dt id="skimage.filters.vsobel">
<code>skimage.filters.vsobel(*args, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L50" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.filters.sobel_v</code> instead.</p> <p>Find the vertical edges of an image using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2-D array</p>  <p>Image to process</p>  <p><strong>mask</strong> : 2-D array, optional</p>  <p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>output</strong> : 2-D array</p>  <p>The absolute Sobel edge map.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel and return the absolute value of the result at each point:</p> <pre data-language="python">1   0  -1
2   0  -2
1   0  -1
</pre> </dd>
</dl>   <h2 id="wiener">wiener</h2> <dl class="function"> <dt id="skimage.filters.wiener">
<code>skimage.filters.wiener(data, impulse_response=None, filter_params={}, K=0.25, predefined_filter=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/lpi_filter.py#L207" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Minimum Mean Square Error (Wiener) inverse filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (M,N) ndarray</p>  <p>Input data.</p>  <p><strong>K</strong> : float or (M,N) ndarray</p>  <p>Ratio between power spectrum of noise and undegraded image.</p>  <p><strong>impulse_response</strong> : callable <code>f(r, c, **filter_params)</code></p>  <p>Impulse response of the filter. See LPIFilter2D.__init__.</p>  <p><strong>filter_params</strong> : dict</p>  <p>Additional keyword parameters to the impulse_response function.</p>  </td> </tr> <tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr class="field-even field">
<td> </td>
<td class="field-body">
<p class="first"><strong>predefined_filter</strong> : LPIFilter2D</p>  <p>If you need to apply the same filter multiple times over different images, construct the LPIFilter2D and specify it here.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="lpifilter2d">LPIFilter2D</h2> <dl class="class"> <dt id="skimage.filters.LPIFilter2D">
<code>class skimage.filters.LPIFilter2D(impulse_response, **filter_params)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/lpi_filter.py#L42" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="http://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Linear Position-Invariant Filter (2-dimensional)</p> <dl class="method"> <dt id="skimage.filters.LPIFilter2D.__init__">
<code>__init__(impulse_response, **filter_params)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/filters/lpi_filter.py#L47" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>impulse_response</strong> : callable <code>f(r, c, **filter_params)</code></p>  <p>Function that yields the impulse response. <code>r</code> and <code>c</code> are 1-dimensional vectors that represent row and column positions, in other words coordinates are (r[0],c[0]),(r[0],c[1]) etc. <code>**filter_params</code> are passed through.</p> <p>In other words, <code>impulse_response</code> would be called like this:</p> <pre data-language="python">&gt;&gt;&gt; def impulse_response(r, c, **filter_params):
...     pass
&gt;&gt;&gt;
&gt;&gt;&gt; r = [0,0,0,1,1,1,2,2,2]
&gt;&gt;&gt; c = [0,1,2,0,1,2,0,1,2]
&gt;&gt;&gt; filter_params = {'kw1': 1, 'kw2': 2, 'kw3': 3}
&gt;&gt;&gt; impulse_response(r, c, **filter_params)
</pre>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>Gaussian filter: Use a 1-D gaussian in each direction without normalization coefficients.</p> <pre data-language="python">&gt;&gt;&gt; def filt_func(r, c, sigma = 1):
...     return np.exp(-np.hypot(r, c)/sigma)
&gt;&gt;&gt; filter = LPIFilter2D(filt_func)
</pre> </dd>
</dl> </dd>
</dl>   <h2 id="deprecated">deprecated</h2> <dl class="class"> <dt id="skimage.filters.deprecated">
<code>class skimage.filters.deprecated(alt_func=None, behavior='warn')</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L23" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="http://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)" target="_blank"><code>object</code></a></p> <p>Decorator to mark deprecated functions with warning.</p> <p>Adapted from &lt;<a class="reference external" href="http://wiki.python.org/moin/PythonDecoratorLibrary" target="_blank">http://wiki.python.org/moin/PythonDecoratorLibrary</a>&gt;.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>alt_func</strong> : str</p>  <p>If given, tell user what function to use instead.</p>  <p><strong>behavior</strong> : {‘warn’, ‘raise’}</p>  <p>Behavior during call to deprecated function: ‘warn’ = warn user that function is deprecated; ‘raise’ = raise error.</p>  </td> </tr>  </table> <dl class="method"> <dt id="skimage.filters.deprecated.__init__">
<code>__init__(alt_func=None, behavior='warn')</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/_shared/utils.py#L37" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.12.x/api/skimage.filters.html" class="_attribution-link" target="_blank">http://scikit-image.org/docs/0.12.x/api/skimage.filters.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
