
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Venv - Python 3.5 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 3.3. ">
  <meta name="keywords" content="venv, —, creation, virtual, environments, -, python, python~3.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/python~3.5/library/venv/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/python~3.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~3.5/" class="_nav-link" title="" style="margin-left:0;">Python 3.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="venv-creation-of-virtual-environments"> venv — Creation of virtual environments</h1> <div class="versionadded" id="module-venv"> <p><span class="versionmodified">New in version 3.3.</span></p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.5/Lib/venv/" target="_blank">Lib/venv/</a></p>  <p>The <a class="reference internal" href="#module-venv" title="venv: Creation of virtual environments."><code>venv</code></a> module provides support for creating lightweight “virtual environments” with their own site directories, optionally isolated from system site directories. Each virtual environment has its own Python binary (allowing creation of environments with various Python versions) and can have its own independent set of installed Python packages in its site directories.</p> <p>See <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0405" id="index-1" target="_blank"><strong>PEP 405</strong></a> for more information about Python virtual environments.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <code>pyvenv</code> script has been deprecated as of Python 3.6 in favor of using <code>python3 -m venv</code> to help prevent any potential confusion as to which Python interpreter a virtual environment will be based on.</p> </div>  <h2 id="creating-virtual-environments">1. Creating virtual environments</h2> <p>Creation of <a class="reference internal" href="#venv-def"><span>virtual environments</span></a> is done by executing the <code>pyvenv</code> script:</p> <pre data-language="python">pyvenv /path/to/new/virtual/environment
</pre> <p>Running this command creates the target directory (creating any parent directories that don’t exist already) and places a <code>pyvenv.cfg</code> file in it with a <code>home</code> key pointing to the Python installation the command was run from. It also creates a <code>bin</code> (or <code>Scripts</code> on Windows) subdirectory containing a copy of the <code>python</code> binary (or binaries, in the case of Windows). It also creates an (initially empty) <code>lib/pythonX.Y/site-packages</code> subdirectory (on Windows, this is <code>Lib\site-packages</code>).</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference external" href="https://packaging.python.org/en/latest/installing/#creating-virtual-environments" target="_blank">Python Packaging User Guide: Creating and using virtual environments</a></p> </div> <p>On Windows, you may have to invoke the <code>pyvenv</code> script as follows, if you don’t have the relevant PATH and PATHEXT settings:</p> <pre data-language="none">c:\Temp&gt;c:\Python35\python c:\Python35\Tools\Scripts\pyvenv.py myenv
</pre> <p>or equivalently:</p> <pre data-language="none">c:\Temp&gt;c:\Python35\python -m venv myenv
</pre> <p>The command, if run with <code>-h</code>, will show the available options:</p> <pre data-language="none">usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]
            [--upgrade] [--without-pip]
            ENV_DIR [ENV_DIR ...]

Creates virtual Python environments in one or more target directories.

positional arguments:
  ENV_DIR             A directory to create the environment in.

optional arguments:
  -h, --help             show this help message and exit
  --system-site-packages Give the virtual environment access to the system
                         site-packages dir.
  --symlinks             Try to use symlinks rather than copies, when symlinks
                         are not the default for the platform.
  --copies               Try to use copies rather than symlinks, even when
                         symlinks are the default for the platform.
  --clear                Delete the contents of the environment directory if it
                         already exists, before environment creation.
  --upgrade              Upgrade the environment directory to use this version
                         of Python, assuming Python has been upgraded in-place.
  --without-pip          Skips installing or upgrading pip in the virtual
                         environment (pip is bootstrapped by default)
</pre> <p>Depending on how the <code>venv</code> functionality has been invoked, the usage message may vary slightly, e.g. referencing <code>pyvenv</code> rather than <code>venv</code>.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Installs pip by default, added the <code>--without-pip</code> and <code>--copies</code> options</p> </div> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>In earlier versions, if the target directory already existed, an error was raised, unless the <code>--clear</code> or <code>--upgrade</code> option was provided. Now, if an existing directory is specified, its contents are removed and the directory is processed as if it had been newly created.</p> </div> <p>The created <code>pyvenv.cfg</code> file also includes the <code>include-system-site-packages</code> key, set to <code>true</code> if <code>venv</code> is run with the <code>--system-site-packages</code> option, <code>false</code> otherwise.</p> <p>Unless the <code>--without-pip</code> option is given, <a class="reference internal" href="../ensurepip/#module-ensurepip" title='ensurepip: Bootstrapping the "pip" installer into an existing Python installation or virtual environment.'><code>ensurepip</code></a> will be invoked to bootstrap <code>pip</code> into the virtual environment.</p> <p>Multiple paths can be given to <code>pyvenv</code>, in which case an identical virtualenv will be created, according to the given options, at each provided path.</p> <p>Once a venv has been created, it can be “activated” using a script in the venv’s binary directory. The invocation of the script is platform-specific:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Platform</th> <th class="head">Shell</th> <th class="head">Command to activate virtual environment</th> </tr> </thead>  <tr class="row-even">
<td>Posix</td> <td>bash/zsh</td> <td>$ source &lt;venv&gt;/bin/activate</td> </tr> <tr class="row-odd">
<td> </td> <td>fish</td> <td>$ . &lt;venv&gt;/bin/activate.fish</td> </tr> <tr class="row-even">
<td> </td> <td>csh/tcsh</td> <td>$ source &lt;venv&gt;/bin/activate.csh</td> </tr> <tr class="row-odd">
<td>Windows</td> <td>cmd.exe</td> <td>C:\&gt; &lt;venv&gt;\Scripts\activate.bat</td> </tr> <tr class="row-even">
<td> </td> <td>PowerShell</td> <td>PS C:\&gt; &lt;venv&gt;\Scripts\Activate.ps1</td> </tr>  </table> <p>You don’t specifically <em>need</em> to activate an environment; activation just prepends the venv’s binary directory to your path, so that “python” invokes the venv’s Python interpreter and you can run installed scripts without having to use their full path. However, all scripts installed in a venv should be runnable without activating it, and run with the venv’s Python automatically.</p> <p>You can deactivate a venv by typing “deactivate” in your shell. The exact mechanism is platform-specific: for example, the Bash activation script defines a “deactivate” function, whereas on Windows there are separate scripts called <code>deactivate.bat</code> and <code>Deactivate.ps1</code> which are installed when the venv is created.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.4: </span><code>fish</code> and <code>csh</code> activation scripts.</p> </div> <div class="admonition note" id="venv-def"> <p class="first admonition-title">Note</p> <p>A virtual environment (also called a <code>venv</code>) is a Python environment such that the Python interpreter, libraries and scripts installed into it are isolated from those installed in other virtual environments, and (by default) any libraries installed in a “system” Python, i.e. one which is installed as part of your operating system.</p> <p>A venv is a directory tree which contains Python executable files and other files which indicate that it is a venv.</p> <p>Common installation tools such as <code>Setuptools</code> and <code>pip</code> work as expected with venvs - i.e. when a venv is active, they install Python packages into the venv without needing to be told to do so explicitly.</p> <p>When a venv is active (i.e. the venv’s Python interpreter is running), the attributes <a class="reference internal" href="../sys/#sys.prefix" title="sys.prefix"><code>sys.prefix</code></a> and <a class="reference internal" href="../sys/#sys.exec_prefix" title="sys.exec_prefix"><code>sys.exec_prefix</code></a> point to the base directory of the venv, whereas <a class="reference internal" href="../sys/#sys.base_prefix" title="sys.base_prefix"><code>sys.base_prefix</code></a> and <a class="reference internal" href="../sys/#sys.base_exec_prefix" title="sys.base_exec_prefix"><code>sys.base_exec_prefix</code></a> point to the non-venv Python installation which was used to create the venv. If a venv is not active, then <a class="reference internal" href="../sys/#sys.prefix" title="sys.prefix"><code>sys.prefix</code></a> is the same as <a class="reference internal" href="../sys/#sys.base_prefix" title="sys.base_prefix"><code>sys.base_prefix</code></a> and <a class="reference internal" href="../sys/#sys.exec_prefix" title="sys.exec_prefix"><code>sys.exec_prefix</code></a> is the same as <a class="reference internal" href="../sys/#sys.base_exec_prefix" title="sys.base_exec_prefix"><code>sys.base_exec_prefix</code></a> (they all point to a non-venv Python installation).</p> <p>When a venv is active, any options that change the installation path will be ignored from all distutils configuration files to prevent projects being inadvertently installed outside of the virtual environment.</p> <p class="last">When working in a command shell, users can make a venv active by running an <code>activate</code> script in the venv’s executables directory (the precise filename is shell-dependent), which prepends the venv’s directory for executables to the <code>PATH</code> environment variable for the running shell. There should be no need in other circumstances to activate a venv – scripts installed into venvs have a shebang line which points to the venv’s Python interpreter. This means that the script will run with that interpreter regardless of the value of <code>PATH</code>. On Windows, shebang line processing is supported if you have the Python Launcher for Windows installed (this was added to Python in 3.3 - see <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0397" id="index-2" target="_blank"><strong>PEP 397</strong></a> for more details). Thus, double-clicking an installed script in a Windows Explorer window should run the script with the correct interpreter without there needing to be any reference to its venv in <code>PATH</code>.</p> </div>   <h2 id="venv-api">2. API</h2> <p id="api">The high-level method described above makes use of a simple API which provides mechanisms for third-party virtual environment creators to customize environment creation according to their needs, the <a class="reference internal" href="#venv.EnvBuilder" title="venv.EnvBuilder"><code>EnvBuilder</code></a> class.</p> <dl class="class"> <dt id="venv.EnvBuilder">
<code>class venv.EnvBuilder(system_site_packages=False, clear=False, symlinks=False, upgrade=False, with_pip=False)</code> </dt> <dd>
<p>The <a class="reference internal" href="#venv.EnvBuilder" title="venv.EnvBuilder"><code>EnvBuilder</code></a> class accepts the following keyword arguments on instantiation:</p> <ul class="simple"> <li>
<code>system_site_packages</code> – a Boolean value indicating that the system Python site-packages should be available to the environment (defaults to <code>False</code>).</li> <li>
<code>clear</code> – a Boolean value which, if true, will delete the contents of any existing target directory, before creating the environment.</li> <li>
<code>symlinks</code> – a Boolean value indicating whether to attempt to symlink the Python binary (and any necessary DLLs or other binaries, e.g. <code>pythonw.exe</code>), rather than copying. Defaults to <code>True</code> on Linux and Unix systems, but <code>False</code> on Windows.</li> <li>
<code>upgrade</code> – a Boolean value which, if true, will upgrade an existing environment with the running Python - for use when that Python has been upgraded in-place (defaults to <code>False</code>).</li> <li>
<code>with_pip</code> – a Boolean value which, if true, ensures pip is installed in the virtual environment. This uses <a class="reference internal" href="../ensurepip/#module-ensurepip" title='ensurepip: Bootstrapping the "pip" installer into an existing Python installation or virtual environment.'><code>ensurepip</code></a> with the <code>--default-pip</code> option.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Added the <code>with_pip</code> parameter</p> </div> <p>Creators of third-party virtual environment tools will be free to use the provided <code>EnvBuilder</code> class as a base class.</p> <p>The returned env-builder is an object which has a method, <code>create</code>:</p> <dl class="method"> <dt id="venv.EnvBuilder.create">
<code>create(env_dir)</code> </dt> <dd>
<p>This method takes as required argument the path (absolute or relative to the current directory) of the target directory which is to contain the virtual environment. The <code>create</code> method will either create the environment in the specified directory, or raise an appropriate exception.</p> <p>The <code>create</code> method of the <code>EnvBuilder</code> class illustrates the hooks available for subclass customization:</p> <pre data-language="python">def create(self, env_dir):
    """
    Create a virtualized Python environment in a directory.
    env_dir is the target directory to create an environment in.
    """
    env_dir = os.path.abspath(env_dir)
    context = self.ensure_directories(env_dir)
    self.create_configuration(context)
    self.setup_python(context)
    self.setup_scripts(context)
    self.post_setup(context)
</pre> <p>Each of the methods <a class="reference internal" href="#venv.EnvBuilder.ensure_directories" title="venv.EnvBuilder.ensure_directories"><code>ensure_directories()</code></a>, <a class="reference internal" href="#venv.EnvBuilder.create_configuration" title="venv.EnvBuilder.create_configuration"><code>create_configuration()</code></a>, <a class="reference internal" href="#venv.EnvBuilder.setup_python" title="venv.EnvBuilder.setup_python"><code>setup_python()</code></a>, <a class="reference internal" href="#venv.EnvBuilder.setup_scripts" title="venv.EnvBuilder.setup_scripts"><code>setup_scripts()</code></a> and <a class="reference internal" href="#venv.EnvBuilder.post_setup" title="venv.EnvBuilder.post_setup"><code>post_setup()</code></a> can be overridden.</p> </dd>
</dl> <dl class="method"> <dt id="venv.EnvBuilder.ensure_directories">
<code>ensure_directories(env_dir)</code> </dt> <dd>
<p>Creates the environment directory and all necessary directories, and returns a context object. This is just a holder for attributes (such as paths), for use by the other methods. The directories are allowed to exist already, as long as either <code>clear</code> or <code>upgrade</code> were specified to allow operating on an existing environment directory.</p> </dd>
</dl> <dl class="method"> <dt id="venv.EnvBuilder.create_configuration">
<code>create_configuration(context)</code> </dt> <dd>
<p>Creates the <code>pyvenv.cfg</code> configuration file in the environment.</p> </dd>
</dl> <dl class="method"> <dt id="venv.EnvBuilder.setup_python">
<code>setup_python(context)</code> </dt> <dd>
<p>Creates a copy of the Python executable (and, under Windows, DLLs) in the environment. On a POSIX system, if a specific executable <code>python3.x</code> was used, symlinks to <code>python</code> and <code>python3</code> will be created pointing to that executable, unless files with those names already exist.</p> </dd>
</dl> <dl class="method"> <dt id="venv.EnvBuilder.setup_scripts">
<code>setup_scripts(context)</code> </dt> <dd>
<p>Installs activation scripts appropriate to the platform into the virtual environment.</p> </dd>
</dl> <dl class="method"> <dt id="venv.EnvBuilder.post_setup">
<code>post_setup(context)</code> </dt> <dd>
<p>A placeholder method which can be overridden in third party implementations to pre-install packages in the virtual environment or perform other post-creation steps.</p> </dd>
</dl> <p>In addition, <a class="reference internal" href="#venv.EnvBuilder" title="venv.EnvBuilder"><code>EnvBuilder</code></a> provides this utility method that can be called from <a class="reference internal" href="#venv.EnvBuilder.setup_scripts" title="venv.EnvBuilder.setup_scripts"><code>setup_scripts()</code></a> or <a class="reference internal" href="#venv.EnvBuilder.post_setup" title="venv.EnvBuilder.post_setup"><code>post_setup()</code></a> in subclasses to assist in installing custom scripts into the virtual environment.</p> <dl class="method"> <dt id="venv.EnvBuilder.install_scripts">
<code>install_scripts(context, path)</code> </dt> <dd>
<p><em>path</em> is the path to a directory that should contain subdirectories “common”, “posix”, “nt”, each containing scripts destined for the bin directory in the environment. The contents of “common” and the directory corresponding to <a class="reference internal" href="../os/#os.name" title="os.name"><code>os.name</code></a> are copied after some text replacement of placeholders:</p> <ul class="simple"> <li>
<code>__VENV_DIR__</code> is replaced with the absolute path of the environment directory.</li> <li>
<code>__VENV_NAME__</code> is replaced with the environment name (final path segment of environment directory).</li> <li>
<code>__VENV_PROMPT__</code> is replaced with the prompt (the environment name surrounded by parentheses and with a following space)</li> <li>
<code>__VENV_BIN_NAME__</code> is replaced with the name of the bin directory (either <code>bin</code> or <code>Scripts</code>).</li> <li>
<code>__VENV_PYTHON__</code> is replaced with the absolute path of the environment’s executable.</li> </ul> <p>The directories are allowed to exist (for when an existing environment is being upgraded).</p> </dd>
</dl> </dd>
</dl> <p>There is also a module-level convenience function:</p> <dl class="function"> <dt id="venv.create">
<code>venv.create(env_dir, system_site_packages=False, clear=False, symlinks=False, with_pip=False)</code> </dt> <dd>
<p>Create an <a class="reference internal" href="#venv.EnvBuilder" title="venv.EnvBuilder"><code>EnvBuilder</code></a> with the given keyword arguments, and call its <a class="reference internal" href="#venv.EnvBuilder.create" title="venv.EnvBuilder.create"><code>create()</code></a> method with the <em>env_dir</em> argument.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Added the <code>with_pip</code> parameter</p> </div> </dd>
</dl>   <h2 id="an-example-of-extending-envbuilder">3. An example of extending <code>EnvBuilder</code>
</h2> <p>The following script shows how to extend <a class="reference internal" href="#venv.EnvBuilder" title="venv.EnvBuilder"><code>EnvBuilder</code></a> by implementing a subclass which installs setuptools and pip into a created venv:</p> <pre data-language="python">import os
import os.path
from subprocess import Popen, PIPE
import sys
from threading import Thread
from urllib.parse import urlparse
from urllib.request import urlretrieve
import venv

class ExtendedEnvBuilder(venv.EnvBuilder):
    """
    This builder installs setuptools and pip so that you can pip or
    easy_install other packages into the created environment.

    :param nodist: If True, setuptools and pip are not installed into the
                   created environment.
    :param nopip: If True, pip is not installed into the created
                  environment.
    :param progress: If setuptools or pip are installed, the progress of the
                     installation can be monitored by passing a progress
                     callable. If specified, it is called with two
                     arguments: a string indicating some progress, and a
                     context indicating where the string is coming from.
                     The context argument can have one of three values:
                     'main', indicating that it is called from virtualize()
                     itself, and 'stdout' and 'stderr', which are obtained
                     by reading lines from the output streams of a subprocess
                     which is used to install the app.

                     If a callable is not specified, default progress
                     information is output to sys.stderr.
    """

    def __init__(self, *args, **kwargs):
        self.nodist = kwargs.pop('nodist', False)
        self.nopip = kwargs.pop('nopip', False)
        self.progress = kwargs.pop('progress', None)
        self.verbose = kwargs.pop('verbose', False)
        super().__init__(*args, **kwargs)

    def post_setup(self, context):
        """
        Set up any packages which need to be pre-installed into the
        environment being created.

        :param context: The information for the environment creation request
                        being processed.
        """
        os.environ['VIRTUAL_ENV'] = context.env_dir
        if not self.nodist:
            self.install_setuptools(context)
        # Can't install pip without setuptools
        if not self.nopip and not self.nodist:
            self.install_pip(context)

    def reader(self, stream, context):
        """
        Read lines from a subprocess' output stream and either pass to a progress
        callable (if specified) or write progress information to sys.stderr.
        """
        progress = self.progress
        while True:
            s = stream.readline()
            if not s:
                break
            if progress is not None:
                progress(s, context)
            else:
                if not self.verbose:
                    sys.stderr.write('.')
                else:
                    sys.stderr.write(s.decode('utf-8'))
                sys.stderr.flush()
        stream.close()

    def install_script(self, context, name, url):
        _, _, path, _, _, _ = urlparse(url)
        fn = os.path.split(path)[-1]
        binpath = context.bin_path
        distpath = os.path.join(binpath, fn)
        # Download script into the env's binaries folder
        urlretrieve(url, distpath)
        progress = self.progress
        if self.verbose:
            term = '\n'
        else:
            term = ''
        if progress is not None:
            progress('Installing %s ...%s' % (name, term), 'main')
        else:
            sys.stderr.write('Installing %s ...%s' % (name, term))
            sys.stderr.flush()
        # Install in the env
        args = [context.env_exe, fn]
        p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=binpath)
        t1 = Thread(target=self.reader, args=(p.stdout, 'stdout'))
        t1.start()
        t2 = Thread(target=self.reader, args=(p.stderr, 'stderr'))
        t2.start()
        p.wait()
        t1.join()
        t2.join()
        if progress is not None:
            progress('done.', 'main')
        else:
            sys.stderr.write('done.\n')
        # Clean up - no longer needed
        os.unlink(distpath)

    def install_setuptools(self, context):
        """
        Install setuptools in the environment.

        :param context: The information for the environment creation request
                        being processed.
        """
        url = 'https://bitbucket.org/pypa/setuptools/downloads/ez_setup.py'
        self.install_script(context, 'setuptools', url)
        # clear up the setuptools archive which gets downloaded
        pred = lambda o: o.startswith('setuptools-') and o.endswith('.tar.gz')
        files = filter(pred, os.listdir(context.bin_path))
        for f in files:
            f = os.path.join(context.bin_path, f)
            os.unlink(f)

    def install_pip(self, context):
        """
        Install pip in the environment.

        :param context: The information for the environment creation request
                        being processed.
        """
        url = 'https://raw.github.com/pypa/pip/master/contrib/get-pip.py'
        self.install_script(context, 'pip', url)

def main(args=None):
    compatible = True
    if sys.version_info &lt; (3, 3):
        compatible = False
    elif not hasattr(sys, 'base_prefix'):
        compatible = False
    if not compatible:
        raise ValueError('This script is only for use with '
                         'Python 3.3 or later')
    else:
        import argparse

        parser = argparse.ArgumentParser(prog=__name__,
                                         description='Creates virtual Python '
                                                     'environments in one or '
                                                     'more target '
                                                     'directories.')
        parser.add_argument('dirs', metavar='ENV_DIR', nargs='+',
                            help='A directory to create the environment in.')
        parser.add_argument('--no-setuptools', default=False,
                            action='store_true', dest='nodist',
                            help="Don't install setuptools or pip in the "
                                 "virtual environment.")
        parser.add_argument('--no-pip', default=False,
                            action='store_true', dest='nopip',
                            help="Don't install pip in the virtual "
                                 "environment.")
        parser.add_argument('--system-site-packages', default=False,
                            action='store_true', dest='system_site',
                            help='Give the virtual environment access to the '
                                 'system site-packages dir.')
        if os.name == 'nt':
            use_symlinks = False
        else:
            use_symlinks = True
        parser.add_argument('--symlinks', default=use_symlinks,
                            action='store_true', dest='symlinks',
                            help='Try to use symlinks rather than copies, '
                                 'when symlinks are not the default for '
                                 'the platform.')
        parser.add_argument('--clear', default=False, action='store_true',
                            dest='clear', help='Delete the contents of the '
                                               'environment directory if it '
                                               'already exists, before '
                                               'environment creation.')
        parser.add_argument('--upgrade', default=False, action='store_true',
                            dest='upgrade', help='Upgrade the environment '
                                               'directory to use this version '
                                               'of Python, assuming Python '
                                               'has been upgraded in-place.')
        parser.add_argument('--verbose', default=False, action='store_true',
                            dest='verbose', help='Display the output '
                                               'from the scripts which '
                                               'install setuptools and pip.')
        options = parser.parse_args(args)
        if options.upgrade and options.clear:
            raise ValueError('you cannot supply --upgrade and --clear together.')
        builder = ExtendedEnvBuilder(system_site_packages=options.system_site,
                                       clear=options.clear,
                                       symlinks=options.symlinks,
                                       upgrade=options.upgrade,
                                       nodist=options.nodist,
                                       nopip=options.nopip,
                                       verbose=options.verbose)
        for d in options.dirs:
            builder.create(d)

if __name__ == '__main__':
    rc = 1
    try:
        main()
        rc = 0
    except Exception as e:
        print('Error: %s' % e, file=sys.stderr)
    sys.exit(rc)
</pre> <p>This script is also available for download <a class="reference external" href="https://gist.github.com/4673395" target="_blank">online</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2017 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.5/library/venv.html" class="_attribution-link" target="_blank">https://docs.python.org/3.5/library/venv.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
