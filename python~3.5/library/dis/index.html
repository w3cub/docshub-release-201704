
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Dis - Python 3.5 - W3cubDocs</title>
  
  <meta name="description" content=" Source code&#58; Lib&#47;dis.py ">
  <meta name="keywords" content="dis, —, disassembler, for, python, bytecode, -, python~3.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/python~3.5/library/dis/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/python~3.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~3.5/" class="_nav-link" title="" style="margin-left:0;">Python 3.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="dis-disassembler-for-python-bytecode"> dis — Disassembler for Python bytecode</h1> <p id="module-dis"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.5/Lib/dis.py" target="_blank">Lib/dis.py</a></p>  <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module supports the analysis of CPython <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-bytecode" target="_blank"><span class="xref std std-term">bytecode</span></a> by disassembling it. The CPython bytecode which this module takes as an input is defined in the file <code>Include/opcode.h</code> and used by the compiler and the interpreter.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> Bytecode is an implementation detail of the CPython interpreter. No guarantees are made that bytecode will not be added, removed, or changed between versions of Python. Use of this module should not be considered to work across Python VMs or Python releases.</p> </div> <p>Example: Given the function <code>myfunc()</code>:</p> <pre data-language="python">def myfunc(alist):
    return len(alist)
</pre> <p>the following command can be used to display the disassembly of <code>myfunc()</code>:</p> <pre data-language="python">&gt;&gt;&gt; dis.dis(myfunc)
  2           0 LOAD_GLOBAL              0 (len)
              3 LOAD_FAST                0 (alist)
              6 CALL_FUNCTION            1
              9 RETURN_VALUE
</pre> <p>(The “2” is a line number).</p>  <h2 id="bytecode-analysis">1. Bytecode analysis</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 3.4.</span></p> </div> <p>The bytecode analysis API allows pieces of Python code to be wrapped in a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> object that provides easy access to details of the compiled code.</p> <dl class="class"> <dt id="dis.Bytecode">
<code>class dis.Bytecode(x, *, first_line=None, current_offset=None)</code> </dt> <dd>
<p>Analyse the bytecode corresponding to a function, generator, method, string of source code, or a code object (as returned by <a class="reference internal" href="../functions/#compile" title="compile"><code>compile()</code></a>).</p> <p>This is a convenience wrapper around many of the functions listed below, most notably <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code>get_instructions()</code></a>, as iterating over a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> instance yields the bytecode operations as <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> instances.</p> <p>If <em>first_line</em> is not <code>None</code>, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</p> <p>If <em>current_offset</em> is not <code>None</code>, it refers to an instruction offset in the disassembled code. Setting this means <a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code>dis()</code></a> will display a “current instruction” marker against the specified opcode.</p> <dl class="classmethod"> <dt id="dis.Bytecode.from_traceback">
<code>classmethod from_traceback(tb)</code> </dt> <dd>
<p>Construct a <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> instance from the given traceback, setting <em>current_offset</em> to the instruction responsible for the exception.</p> </dd>
</dl> <dl class="data"> <dt id="dis.Bytecode.codeobj">
<code>codeobj</code> </dt> <dd>
<p>The compiled code object.</p> </dd>
</dl> <dl class="data"> <dt id="dis.Bytecode.first_line">
<code>first_line</code> </dt> <dd>
<p>The first source line of the code object (if available)</p> </dd>
</dl> <dl class="method"> <dt id="dis.Bytecode.dis">
<code>dis()</code> </dt> <dd>
<p>Return a formatted view of the bytecode operations (the same as printed by <a class="reference internal" href="#dis.dis" title="dis.dis"><code>dis.dis()</code></a>, but returned as a multi-line string).</p> </dd>
</dl> <dl class="method"> <dt id="dis.Bytecode.info">
<code>info()</code> </dt> <dd>
<p>Return a formatted multi-line string with detailed information about the code object, like <a class="reference internal" href="#dis.code_info" title="dis.code_info"><code>code_info()</code></a>.</p> </dd>
</dl> </dd>
</dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; bytecode = dis.Bytecode(myfunc)
&gt;&gt;&gt; for instr in bytecode:
...     print(instr.opname)
...
LOAD_GLOBAL
LOAD_FAST
CALL_FUNCTION
RETURN_VALUE
</pre>   <h2 id="analysis-functions">2. Analysis functions</h2> <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module also defines the following analysis functions that convert the input directly to the desired output. They can be useful if only a single operation is being performed, so the intermediate analysis object isn’t useful:</p> <dl class="function"> <dt id="dis.code_info">
<code>dis.code_info(x)</code> </dt> <dd>
<p>Return a formatted multi-line string with detailed code object information for the supplied function, generator, method, source code string or code object.</p> <p>Note that the exact contents of code info strings are highly implementation dependent and they may change arbitrarily across Python VMs or Python releases.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.show_code">
<code>dis.show_code(x, *, file=None)</code> </dt> <dd>
<p>Print detailed code object information for the supplied function, method, source code string or code object to <em>file</em> (or <code>sys.stdout</code> if <em>file</em> is not specified).</p> <p>This is a convenient shorthand for <code>print(code_info(x), file=file)</code>, intended for interactive exploration at the interpreter prompt.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.dis">
<code>dis.dis(x=None, *, file=None)</code> </dt> <dd>
<p>Disassemble the <em>x</em> object. <em>x</em> can denote either a module, a class, a method, a function, a generator, a code object, a string of source code or a byte sequence of raw bytecode. For a module, it disassembles all functions. For a class, it disassembles all methods (including class and static methods). For a code object or sequence of raw bytecode, it prints one line per bytecode instruction. Strings are first compiled to code objects with the <a class="reference internal" href="../functions/#compile" title="compile"><code>compile()</code></a> built-in function before being disassembled. If no object is provided, this function disassembles the last traceback.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.distb">
<code>dis.distb(tb=None, *, file=None)</code> </dt> <dd>
<p>Disassemble the top-of-stack function of a traceback, using the last traceback if none was passed. The instruction causing the exception is indicated.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.disassemble">
<code>dis.disassemble(code, lasti=-1, *, file=None)</code> </dt> <dt id="dis.disco">
<code>dis.disco(code, lasti=-1, *, file=None)</code> </dt> <dd>
<p>Disassemble a code object, indicating the last instruction if <em>lasti</em> was provided. The output is divided in the following columns:</p> <ol class="arabic simple"> <li>the line number, for the first instruction of each line</li> <li>the current instruction, indicated as <code>--&gt;</code>,</li> <li>a labelled instruction, indicated with <code>&gt;&gt;</code>,</li> <li>the address of the instruction,</li> <li>the operation code name,</li> <li>operation parameters, and</li> <li>interpretation of the parameters in parentheses.</li> </ol> <p>The parameter interpretation recognizes local and global variable names, constant values, branch targets, and compare operators.</p> <p>The disassembly is written as text to the supplied <em>file</em> argument if provided and to <code>sys.stdout</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.4: </span>Added <em>file</em> parameter.</p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.get_instructions">
<code>dis.get_instructions(x, *, first_line=None)</code> </dt> <dd>
<p>Return an iterator over the instructions in the supplied function, method, source code string or code object.</p> <p>The iterator generates a series of <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> named tuples giving the details of each operation in the supplied code.</p> <p>If <em>first_line</em> is not <code>None</code>, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.4.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="dis.findlinestarts">
<code>dis.findlinestarts(code)</code> </dt> <dd>
<p>This generator function uses the <code>co_firstlineno</code> and <code>co_lnotab</code> attributes of the code object <em>code</em> to find the offsets which are starts of lines in the source code. They are generated as <code>(offset, lineno)</code> pairs.</p> </dd>
</dl> <dl class="function"> <dt id="dis.findlabels">
<code>dis.findlabels(code)</code> </dt> <dd>
<p>Detect all offsets in the code object <em>code</em> which are jump targets, and return a list of these offsets.</p> </dd>
</dl> <dl class="function"> <dt id="dis.stack_effect">
<code>dis.stack_effect(opcode[, oparg])</code> </dt> <dd>
<p>Compute the stack effect of <em>opcode</em> with argument <em>oparg</em>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.4.</span></p> </div> </dd>
</dl>   <h2 id="bytecodes">3. Python Bytecode Instructions</h2> <p id="python-bytecode-instructions">The <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code>get_instructions()</code></a> function and <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code>Bytecode</code></a> class provide details of bytecode instructions as <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code>Instruction</code></a> instances:</p> <dl class="class"> <dt id="dis.Instruction">
<code>class dis.Instruction</code> </dt> <dd>
<p>Details for a bytecode operation</p> <dl class="data"> <dt id="dis.Instruction.opcode">
<code>opcode</code> </dt> <dd>
<p>numeric code for operation, corresponding to the opcode values listed below and the bytecode values in the <a class="reference internal" href="#opcode-collections"><span>Opcode collections</span></a>.</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.opname">
<code>opname</code> </dt> <dd>
<p>human readable name for operation</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.arg">
<code>arg</code> </dt> <dd>
<p>numeric argument to operation (if any), otherwise <code>None</code></p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.argval">
<code>argval</code> </dt> <dd>
<p>resolved arg value (if known), otherwise same as arg</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.argrepr">
<code>argrepr</code> </dt> <dd>
<p>human readable description of operation argument</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.offset">
<code>offset</code> </dt> <dd>
<p>start index of operation within bytecode sequence</p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.starts_line">
<code>starts_line</code> </dt> <dd>
<p>line started by this opcode (if any), otherwise <code>None</code></p> </dd>
</dl> <dl class="data"> <dt id="dis.Instruction.is_jump_target">
<code>is_jump_target</code> </dt> <dd>
<p><code>True</code> if other code jumps to here, otherwise <code>False</code></p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified">New in version 3.4.</span></p> </div> </dd>
</dl> <p>The Python compiler currently generates the following bytecode instructions.</p> <p><strong>General instructions</strong></p> <dl class="opcode"> <dt id="opcode-NOP">
<code>NOP</code> </dt> <dd>
<p>Do nothing code. Used as a placeholder by the bytecode optimizer.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_TOP">
<code>POP_TOP</code> </dt> <dd>
<p>Removes the top-of-stack (TOS) item.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_TWO">
<code>ROT_TWO</code> </dt> <dd>
<p>Swaps the two top-most stack items.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_THREE">
<code>ROT_THREE</code> </dt> <dd>
<p>Lifts second and third stack item one position up, moves top down to position three.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DUP_TOP">
<code>DUP_TOP</code> </dt> <dd>
<p>Duplicates the reference on top of the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DUP_TOP_TWO">
<code>DUP_TOP_TWO</code> </dt> <dd>
<p>Duplicates the two references on top of the stack, leaving them in the same order.</p> </dd>
</dl> <p><strong>Unary operations</strong></p> <p>Unary operations take the top of the stack, apply the operation, and push the result back on the stack.</p> <dl class="opcode"> <dt id="opcode-UNARY_POSITIVE">
<code>UNARY_POSITIVE</code> </dt> <dd>
<p>Implements <code>TOS = +TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_NEGATIVE">
<code>UNARY_NEGATIVE</code> </dt> <dd>
<p>Implements <code>TOS = -TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_NOT">
<code>UNARY_NOT</code> </dt> <dd>
<p>Implements <code>TOS = not TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_INVERT">
<code>UNARY_INVERT</code> </dt> <dd>
<p>Implements <code>TOS = ~TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_ITER">
<code>GET_ITER</code> </dt> <dd>
<p>Implements <code>TOS = iter(TOS)</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_YIELD_FROM_ITER">
<code>GET_YIELD_FROM_ITER</code> </dt> <dd>
<p>If <code>TOS</code> is a <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-generator-iterator" target="_blank"><span class="xref std std-term">generator iterator</span></a> or <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-coroutine" target="_blank"><span class="xref std std-term">coroutine</span></a> object it is left as is. Otherwise, implements <code>TOS = iter(TOS)</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <p><strong>Binary operations</strong></p> <p>Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.</p> <dl class="opcode"> <dt id="opcode-BINARY_POWER">
<code>BINARY_POWER</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 ** TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MULTIPLY">
<code>BINARY_MULTIPLY</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 * TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MATRIX_MULTIPLY">
<code>BINARY_MATRIX_MULTIPLY</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 @ TOS</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_FLOOR_DIVIDE">
<code>BINARY_FLOOR_DIVIDE</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 // TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_TRUE_DIVIDE">
<code>BINARY_TRUE_DIVIDE</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 / TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MODULO">
<code>BINARY_MODULO</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 % TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_ADD">
<code>BINARY_ADD</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 + TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_SUBTRACT">
<code>BINARY_SUBTRACT</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 - TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_SUBSCR">
<code>BINARY_SUBSCR</code> </dt> <dd>
<p>Implements <code>TOS = TOS1[TOS]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_LSHIFT">
<code>BINARY_LSHIFT</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &lt;&lt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_RSHIFT">
<code>BINARY_RSHIFT</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &gt;&gt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_AND">
<code>BINARY_AND</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &amp; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_XOR">
<code>BINARY_XOR</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 ^ TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_OR">
<code>BINARY_OR</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 | TOS</code>.</p> </dd>
</dl> <p><strong>In-place operations</strong></p> <p>In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.</p> <dl class="opcode"> <dt id="opcode-INPLACE_POWER">
<code>INPLACE_POWER</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 ** TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MULTIPLY">
<code>INPLACE_MULTIPLY</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 * TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MATRIX_MULTIPLY">
<code>INPLACE_MATRIX_MULTIPLY</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 @ TOS</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_FLOOR_DIVIDE">
<code>INPLACE_FLOOR_DIVIDE</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 // TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_TRUE_DIVIDE">
<code>INPLACE_TRUE_DIVIDE</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 / TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MODULO">
<code>INPLACE_MODULO</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 % TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_ADD">
<code>INPLACE_ADD</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 + TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_SUBTRACT">
<code>INPLACE_SUBTRACT</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 - TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_LSHIFT">
<code>INPLACE_LSHIFT</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &lt;&lt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_RSHIFT">
<code>INPLACE_RSHIFT</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &gt;&gt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_AND">
<code>INPLACE_AND</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &amp; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_XOR">
<code>INPLACE_XOR</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 ^ TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_OR">
<code>INPLACE_OR</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 | TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_SUBSCR">
<code>STORE_SUBSCR</code> </dt> <dd>
<p>Implements <code>TOS1[TOS] = TOS2</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_SUBSCR">
<code>DELETE_SUBSCR</code> </dt> <dd>
<p>Implements <code>del TOS1[TOS]</code>.</p> </dd>
</dl> <p><strong>Coroutine opcodes</strong></p> <dl class="opcode"> <dt id="opcode-GET_AWAITABLE">
<code>GET_AWAITABLE</code> </dt> <dd>
<p>Implements <code>TOS = get_awaitable(TOS)</code>, where <code>get_awaitable(o)</code> returns <code>o</code> if <code>o</code> is a coroutine object or a generator object with the CO_ITERABLE_COROUTINE flag, or resolves <code>o.__await__</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_AITER">
<code>GET_AITER</code> </dt> <dd>
<p>Implements <code>TOS = get_awaitable(TOS.__aiter__())</code>. See <code>GET_AWAITABLE</code> for details about <code>get_awaitable</code></p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_ANEXT">
<code>GET_ANEXT</code> </dt> <dd>
<p>Implements <code>PUSH(get_awaitable(TOS.__anext__()))</code>. See <code>GET_AWAITABLE</code> for details about <code>get_awaitable</code></p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BEFORE_ASYNC_WITH">
<code>BEFORE_ASYNC_WITH</code> </dt> <dd>
<p>Resolves <code>__aenter__</code> and <code>__aexit__</code> from the object on top of the stack. Pushes <code>__aexit__</code> and result of <code>__aenter__()</code> to the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_ASYNC_WITH">
<code>SETUP_ASYNC_WITH</code> </dt> <dd>
<p>Creates a new frame object.</p> </dd>
</dl> <p><strong>Miscellaneous opcodes</strong></p> <dl class="opcode"> <dt id="opcode-PRINT_EXPR">
<code>PRINT_EXPR</code> </dt> <dd>
<p>Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with <a class="reference internal" href="#opcode-POP_TOP"><code>POP_TOP</code></a>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BREAK_LOOP">
<code>BREAK_LOOP</code> </dt> <dd>
<p>Terminates a loop due to a <a class="reference internal" href="https://docs.python.org/3.5/reference/simple_stmts.html#break" target="_blank"><code>break</code></a> statement.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CONTINUE_LOOP">
<code>CONTINUE_LOOP(target)</code> </dt> <dd>
<p>Continues a loop due to a <a class="reference internal" href="https://docs.python.org/3.5/reference/simple_stmts.html#continue" target="_blank"><code>continue</code></a> statement. <em>target</em> is the address to jump to (which should be a <a class="reference internal" href="#opcode-FOR_ITER"><code>FOR_ITER</code></a> instruction).</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SET_ADD">
<code>SET_ADD(i)</code> </dt> <dd>
<p>Calls <code>set.add(TOS1[-i], TOS)</code>. Used to implement set comprehensions.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LIST_APPEND">
<code>LIST_APPEND(i)</code> </dt> <dd>
<p>Calls <code>list.append(TOS[-i], TOS)</code>. Used to implement list comprehensions.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-MAP_ADD">
<code>MAP_ADD(i)</code> </dt> <dd>
<p>Calls <code>dict.setitem(TOS1[-i], TOS, TOS1)</code>. Used to implement dict comprehensions.</p> </dd>
</dl> <p>For all of the <a class="reference internal" href="#opcode-SET_ADD"><code>SET_ADD</code></a>, <a class="reference internal" href="#opcode-LIST_APPEND"><code>LIST_APPEND</code></a> and <a class="reference internal" href="#opcode-MAP_ADD"><code>MAP_ADD</code></a> instructions, while the added value or key/value pair is popped off, the container object remains on the stack so that it is available for further iterations of the loop.</p> <dl class="opcode"> <dt id="opcode-RETURN_VALUE">
<code>RETURN_VALUE</code> </dt> <dd>
<p>Returns with TOS to the caller of the function.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-YIELD_VALUE">
<code>YIELD_VALUE</code> </dt> <dd>
<p>Pops TOS and yields it from a <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-generator" target="_blank"><span class="xref std std-term">generator</span></a>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-YIELD_FROM">
<code>YIELD_FROM</code> </dt> <dd>
<p>Pops TOS and delegates to it as a subiterator from a <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-generator" target="_blank"><span class="xref std std-term">generator</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_STAR">
<code>IMPORT_STAR</code> </dt> <dd>
<p>Loads all symbols not starting with <code>'_'</code> directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements <code>from module import *</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_BLOCK">
<code>POP_BLOCK</code> </dt> <dd>
<p>Removes one block from the block stack. Per frame, there is a stack of blocks, denoting nested loops, try statements, and such.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_EXCEPT">
<code>POP_EXCEPT</code> </dt> <dd>
<p>Removes one block from the block stack. The popped block must be an exception handler block, as implicitly created when entering an except handler. In addition to popping extraneous values from the frame stack, the last three popped values are used to restore the exception state.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-END_FINALLY">
<code>END_FINALLY</code> </dt> <dd>
<p>Terminates a <a class="reference internal" href="https://docs.python.org/3.5/reference/compound_stmts.html#finally" target="_blank"><code>finally</code></a> clause. The interpreter recalls whether the exception has to be re-raised, or whether the function returns, and continues with the outer-next block.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_BUILD_CLASS">
<code>LOAD_BUILD_CLASS</code> </dt> <dd>
<p>Pushes <code>builtins.__build_class__()</code> onto the stack. It is later called by <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a> to construct a class.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_WITH">
<code>SETUP_WITH(delta)</code> </dt> <dd>
<p>This opcode performs several operations before a with block starts. First, it loads <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__exit__" title="object.__exit__" target="_blank"><code>__exit__()</code></a> from the context manager and pushes it onto the stack for later use by <code>WITH_CLEANUP</code>. Then, <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__enter__" title="object.__enter__" target="_blank"><code>__enter__()</code></a> is called, and a finally block pointing to <em>delta</em> is pushed. Finally, the result of calling the enter method is pushed onto the stack. The next opcode will either ignore it (<a class="reference internal" href="#opcode-POP_TOP"><code>POP_TOP</code></a>), or store it in (a) variable(s) (<a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a>, <a class="reference internal" href="#opcode-STORE_NAME"><code>STORE_NAME</code></a>, or <a class="reference internal" href="#opcode-UNPACK_SEQUENCE"><code>UNPACK_SEQUENCE</code></a>).</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-WITH_CLEANUP_START">
<code>WITH_CLEANUP_START</code> </dt> <dd>
<p>Cleans up the stack when a <a class="reference internal" href="https://docs.python.org/3.5/reference/compound_stmts.html#with" target="_blank"><code>with</code></a> statement block exits. TOS is the context manager’s <a class="reference internal" href="https://docs.python.org/3.5/reference/datamodel.html#object.__exit__" title="object.__exit__" target="_blank"><code>__exit__()</code></a> bound method. Below TOS are 1–3 values indicating how/why the finally clause was entered:</p> <ul class="simple"> <li>SECOND = <code>None</code>
</li> <li>(SECOND, THIRD) = (<code>WHY_{RETURN,CONTINUE}</code>), retval</li> <li>SECOND = <code>WHY_*</code>; no retval below it</li> <li>(SECOND, THIRD, FOURTH) = exc_info()</li> </ul> <p>In the last case, <code>TOS(SECOND, THIRD, FOURTH)</code> is called, otherwise <code>TOS(None, None, None)</code>. Pushes SECOND and result of the call to the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-WITH_CLEANUP_FINISH">
<code>WITH_CLEANUP_FINISH</code> </dt> <dd>
<p>Pops exception type and result of ‘exit’ function call from the stack.</p> <p>If the stack represents an exception, <em>and</em> the function call returns a ‘true’ value, this information is “zapped” and replaced with a single <code>WHY_SILENCED</code> to prevent <a class="reference internal" href="#opcode-END_FINALLY"><code>END_FINALLY</code></a> from re-raising the exception. (But non-local gotos will still be resumed.)</p> </dd>
</dl> <p>All of the following opcodes expect arguments. An argument is two bytes, with the more significant byte last.</p> <dl class="opcode"> <dt id="opcode-STORE_NAME">
<code>STORE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>name = TOS</code>. <em>namei</em> is the index of <em>name</em> in the attribute <code>co_names</code> of the code object. The compiler tries to use <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> or <a class="reference internal" href="#opcode-STORE_GLOBAL"><code>STORE_GLOBAL</code></a> if possible.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_NAME">
<code>DELETE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>del name</code>, where <em>namei</em> is the index into <code>co_names</code> attribute of the code object.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNPACK_SEQUENCE">
<code>UNPACK_SEQUENCE(count)</code> </dt> <dd>
<p>Unpacks TOS into <em>count</em> individual values, which are put onto the stack right-to-left.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNPACK_EX">
<code>UNPACK_EX(counts)</code> </dt> <dd>
<p>Implements assignment with a starred target: Unpacks an iterable in TOS into individual values, where the total number of values can be smaller than the number of items in the iterable: one of the new values will be a list of all leftover items.</p> <p>The low byte of <em>counts</em> is the number of values before the list value, the high byte of <em>counts</em> the number of values after it. The resulting values are put onto the stack right-to-left.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_ATTR">
<code>STORE_ATTR(namei)</code> </dt> <dd>
<p>Implements <code>TOS.name = TOS1</code>, where <em>namei</em> is the index of name in <code>co_names</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_ATTR">
<code>DELETE_ATTR(namei)</code> </dt> <dd>
<p>Implements <code>del TOS.name</code>, using <em>namei</em> as index into <code>co_names</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_GLOBAL">
<code>STORE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-STORE_NAME"><code>STORE_NAME</code></a>, but stores the name as a global.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_GLOBAL">
<code>DELETE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-DELETE_NAME"><code>DELETE_NAME</code></a>, but deletes a global name.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CONST">
<code>LOAD_CONST(consti)</code> </dt> <dd>
<p>Pushes <code>co_consts[consti]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_NAME">
<code>LOAD_NAME(namei)</code> </dt> <dd>
<p>Pushes the value associated with <code>co_names[namei]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_TUPLE">
<code>BUILD_TUPLE(count)</code> </dt> <dd>
<p>Creates a tuple consuming <em>count</em> items from the stack, and pushes the resulting tuple onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_LIST">
<code>BUILD_LIST(count)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a>, but creates a list.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_SET">
<code>BUILD_SET(count)</code> </dt> <dd>
<p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code>BUILD_TUPLE</code></a>, but creates a set.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_MAP">
<code>BUILD_MAP(count)</code> </dt> <dd>
<p>Pushes a new dictionary object onto the stack. Pops <code>2 * count</code> items so that the dictionary holds <em>count</em> entries: <code>{..., TOS3: TOS2, TOS1: TOS}</code>.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.5: </span>The dictionary is created from stack items instead of creating an empty dictionary pre-sized to hold <em>count</em> items.</p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_TUPLE_UNPACK">
<code>BUILD_TUPLE_UNPACK(count)</code> </dt> <dd>
<p>Pops <em>count</em> iterables from the stack, joins them in a single tuple, and pushes the result. Implements iterable unpacking in tuple displays <code>(*x, *y, *z)</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_LIST_UNPACK">
<code>BUILD_LIST_UNPACK(count)</code> </dt> <dd>
<p>This is similar to <a class="reference internal" href="#opcode-BUILD_TUPLE_UNPACK"><code>BUILD_TUPLE_UNPACK</code></a>, but pushes a list instead of tuple. Implements iterable unpacking in list displays <code>[*x, *y, *z]</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_SET_UNPACK">
<code>BUILD_SET_UNPACK(count)</code> </dt> <dd>
<p>This is similar to <a class="reference internal" href="#opcode-BUILD_TUPLE_UNPACK"><code>BUILD_TUPLE_UNPACK</code></a>, but pushes a set instead of tuple. Implements iterable unpacking in set displays <code>{*x, *y, *z}</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_MAP_UNPACK">
<code>BUILD_MAP_UNPACK(count)</code> </dt> <dd>
<p>Pops <em>count</em> mappings from the stack, merges them into a single dictionary, and pushes the result. Implements dictionary unpacking in dictionary displays <code>{**x, **y, **z}</code>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_MAP_UNPACK_WITH_CALL">
<code>BUILD_MAP_UNPACK_WITH_CALL(oparg)</code> </dt> <dd>
<p>This is similar to <a class="reference internal" href="#opcode-BUILD_MAP_UNPACK"><code>BUILD_MAP_UNPACK</code></a>, but is used for <code>f(**x, **y, **z)</code> call syntax. The lowest byte of <em>oparg</em> is the count of mappings, the relative position of the corresponding callable <code>f</code> is encoded in the second byte of <em>oparg</em>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_ATTR">
<code>LOAD_ATTR(namei)</code> </dt> <dd>
<p>Replaces TOS with <code>getattr(TOS, co_names[namei])</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-COMPARE_OP">
<code>COMPARE_OP(opname)</code> </dt> <dd>
<p>Performs a Boolean operation. The operation name can be found in <code>cmp_op[opname]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_NAME">
<code>IMPORT_NAME(namei)</code> </dt> <dd>
<p>Imports the module <code>co_names[namei]</code>. TOS and TOS1 are popped and provide the <em>fromlist</em> and <em>level</em> arguments of <a class="reference internal" href="../functions/#__import__" title="__import__"><code>__import__()</code></a>. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> instruction modifies the namespace.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_FROM">
<code>IMPORT_FROM(namei)</code> </dt> <dd>
<p>Loads the attribute <code>co_names[namei]</code> from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a <a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a> instruction.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_FORWARD">
<code>JUMP_FORWARD(delta)</code> </dt> <dd>
<p>Increments bytecode counter by <em>delta</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_JUMP_IF_TRUE">
<code>POP_JUMP_IF_TRUE(target)</code> </dt> <dd>
<p>If TOS is true, sets the bytecode counter to <em>target</em>. TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_JUMP_IF_FALSE">
<code>POP_JUMP_IF_FALSE(target)</code> </dt> <dd>
<p>If TOS is false, sets the bytecode counter to <em>target</em>. TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_IF_TRUE_OR_POP">
<code>JUMP_IF_TRUE_OR_POP(target)</code> </dt> <dd>
<p>If TOS is true, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_IF_FALSE_OR_POP">
<code>JUMP_IF_FALSE_OR_POP(target)</code> </dt> <dd>
<p>If TOS is false, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_ABSOLUTE">
<code>JUMP_ABSOLUTE(target)</code> </dt> <dd>
<p>Set bytecode counter to <em>target</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-FOR_ITER">
<code>FOR_ITER(delta)</code> </dt> <dd>
<p>TOS is an <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-iterator" target="_blank"><span class="xref std std-term">iterator</span></a>. Call its <a class="reference internal" href="../stdtypes/#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted TOS is popped, and the byte code counter is incremented by <em>delta</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_GLOBAL">
<code>LOAD_GLOBAL(namei)</code> </dt> <dd>
<p>Loads the global named <code>co_names[namei]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_LOOP">
<code>SETUP_LOOP(delta)</code> </dt> <dd>
<p>Pushes a block for a loop onto the block stack. The block spans from the current instruction with a size of <em>delta</em> bytes.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_EXCEPT">
<code>SETUP_EXCEPT(delta)</code> </dt> <dd>
<p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the first except block.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_FINALLY">
<code>SETUP_FINALLY(delta)</code> </dt> <dd>
<p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the finally block.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_FAST">
<code>LOAD_FAST(var_num)</code> </dt> <dd>
<p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_FAST">
<code>STORE_FAST(var_num)</code> </dt> <dd>
<p>Stores TOS into the local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_FAST">
<code>DELETE_FAST(var_num)</code> </dt> <dd>
<p>Deletes local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CLOSURE">
<code>LOAD_CLOSURE(i)</code> </dt> <dd>
<p>Pushes a reference to the cell contained in slot <em>i</em> of the cell and free variable storage. The name of the variable is <code>co_cellvars[i]</code> if <em>i</em> is less than the length of <em>co_cellvars</em>. Otherwise it is <code>co_freevars[i -
len(co_cellvars)]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_DEREF">
<code>LOAD_DEREF(i)</code> </dt> <dd>
<p>Loads the cell contained in slot <em>i</em> of the cell and free variable storage. Pushes a reference to the object the cell contains on the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CLASSDEREF">
<code>LOAD_CLASSDEREF(i)</code> </dt> <dd>
<p>Much like <a class="reference internal" href="#opcode-LOAD_DEREF"><code>LOAD_DEREF</code></a> but first checks the locals dictionary before consulting the cell. This is used for loading free variables in class bodies.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_DEREF">
<code>STORE_DEREF(i)</code> </dt> <dd>
<p>Stores TOS into the cell contained in slot <em>i</em> of the cell and free variable storage.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_DEREF">
<code>DELETE_DEREF(i)</code> </dt> <dd>
<p>Empties the cell contained in slot <em>i</em> of the cell and free variable storage. Used by the <a class="reference internal" href="https://docs.python.org/3.5/reference/simple_stmts.html#del" target="_blank"><code>del</code></a> statement.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-RAISE_VARARGS">
<code>RAISE_VARARGS(argc)</code> </dt> <dd>
<p>Raises an exception. <em>argc</em> indicates the number of parameters to the raise statement, ranging from 0 to 3. The handler will find the traceback as TOS2, the parameter as TOS1, and the exception as TOS.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION">
<code>CALL_FUNCTION(argc)</code> </dt> <dd>
<p>Calls a function. The low byte of <em>argc</em> indicates the number of positional parameters, the high byte the number of keyword parameters. On the stack, the opcode finds the keyword parameters first. For each keyword argument, the value is on top of the key. Below the keyword parameters, the positional parameters are on the stack, with the right-most parameter on top. Below the parameters, the function object to call is on the stack. Pops all function arguments, and the function itself off the stack, and pushes the return value.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-MAKE_FUNCTION">
<code>MAKE_FUNCTION(argc)</code> </dt> <dd>
<p>Pushes a new function object on the stack. From bottom to top, the consumed stack must consist of</p> <ul class="simple"> <li>
<code>argc &amp; 0xFF</code> default argument objects in positional order</li> <li>
<code>(argc &gt;&gt; 8) &amp; 0xFF</code> pairs of name and default argument, with the name just below the object on the stack, for keyword-only parameters</li> <li>
<code>(argc &gt;&gt; 16) &amp; 0x7FFF</code> parameter annotation objects</li> <li>a tuple listing the parameter names for the annotations (only if there are ony annotation objects)</li> <li>the code associated with the function (at TOS1)</li> <li>the <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-qualified-name" target="_blank"><span class="xref std std-term">qualified name</span></a> of the function (at TOS)</li> </ul> </dd>
</dl> <dl class="opcode"> <dt id="opcode-MAKE_CLOSURE">
<code>MAKE_CLOSURE(argc)</code> </dt> <dd>
<p>Creates a new function object, sets its <em>__closure__</em> slot, and pushes it on the stack. TOS is the <a class="reference internal" href="https://docs.python.org/3.5/glossary.html#term-qualified-name" target="_blank"><span class="xref std std-term">qualified name</span></a> of the function, TOS1 is the code associated with the function, and TOS2 is the tuple containing cells for the closure’s free variables. <em>argc</em> is interpreted as in <code>MAKE_FUNCTION</code>; the annotations and defaults are also in the same order below TOS2.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_SLICE">
<code>BUILD_SLICE(argc)</code> </dt> <dd>
<p id="index-0">Pushes a slice object on the stack. <em>argc</em> must be 2 or 3. If it is 2, <code>slice(TOS1, TOS)</code> is pushed; if it is 3, <code>slice(TOS2, TOS1, TOS)</code> is pushed. See the <a class="reference internal" href="../functions/#slice" title="slice"><code>slice()</code></a> built-in function for more information.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-EXTENDED_ARG">
<code>EXTENDED_ARG(ext)</code> </dt> <dd>
<p>Prefixes any opcode which has an argument too big to fit into the default two bytes. <em>ext</em> holds two additional bytes which, taken together with the subsequent opcode’s argument, comprise a four-byte argument, <em>ext</em> being the two most-significant bytes.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_VAR">
<code>CALL_FUNCTION_VAR(argc)</code> </dt> <dd>
<p>Calls a function. <em>argc</em> is interpreted as in <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top element on the stack contains the variable argument list, followed by keyword and positional arguments.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_KW">
<code>CALL_FUNCTION_KW(argc)</code> </dt> <dd>
<p>Calls a function. <em>argc</em> is interpreted as in <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top element on the stack contains the keyword arguments dictionary, followed by explicit keyword and positional arguments.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_VAR_KW">
<code>CALL_FUNCTION_VAR_KW(argc)</code> </dt> <dd>
<p>Calls a function. <em>argc</em> is interpreted as in <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top element on the stack contains the keyword arguments dictionary, followed by the variable-arguments tuple, followed by explicit keyword and positional arguments.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-HAVE_ARGUMENT">
<code>HAVE_ARGUMENT</code> </dt> <dd>
<p>This is not really an opcode. It identifies the dividing line between opcodes which don’t take arguments <code>&lt; HAVE_ARGUMENT</code> and those which do <code>&gt;= HAVE_ARGUMENT</code>.</p> </dd>
</dl>   <h2 id="id1">4. Opcode collections</h2> <p id="opcode-collections">These collections are provided for automatic introspection of bytecode instructions:</p> <dl class="data"> <dt id="dis.opname">
<code>dis.opname</code> </dt> <dd>
<p>Sequence of operation names, indexable using the bytecode.</p> </dd>
</dl> <dl class="data"> <dt id="dis.opmap">
<code>dis.opmap</code> </dt> <dd>
<p>Dictionary mapping operation names to bytecodes.</p> </dd>
</dl> <dl class="data"> <dt id="dis.cmp_op">
<code>dis.cmp_op</code> </dt> <dd>
<p>Sequence of all compare operation names.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasconst">
<code>dis.hasconst</code> </dt> <dd>
<p>Sequence of bytecodes that have a constant parameter.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasfree">
<code>dis.hasfree</code> </dt> <dd>
<p>Sequence of bytecodes that access a free variable (note that ‘free’ in this context refers to names in the current scope that are referenced by inner scopes or names in outer scopes that are referenced from this scope. It does <em>not</em> include references to global or builtin scopes).</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasname">
<code>dis.hasname</code> </dt> <dd>
<p>Sequence of bytecodes that access an attribute by name.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasjrel">
<code>dis.hasjrel</code> </dt> <dd>
<p>Sequence of bytecodes that have a relative jump target.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasjabs">
<code>dis.hasjabs</code> </dt> <dd>
<p>Sequence of bytecodes that have an absolute jump target.</p> </dd>
</dl> <dl class="data"> <dt id="dis.haslocal">
<code>dis.haslocal</code> </dt> <dd>
<p>Sequence of bytecodes that access a local variable.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hascompare">
<code>dis.hascompare</code> </dt> <dd>
<p>Sequence of bytecodes of Boolean operations.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2017 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.5/library/dis.html" class="_attribution-link" target="_blank">https://docs.python.org/3.5/library/dis.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
