
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Noteworthy Differences From Other Languages - Julia - W3cubDocs</title>
  
  <meta name="description" content="Although MATLAB users may find Julia’s syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The &hellip;">
  <meta name="keywords" content="noteworthy, differences, from, other, languages, -, julia">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia/manual/noteworthy-differences/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/julia.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia/" class="_nav-link" title="" style="margin-left:0;">Julia</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="man-noteworthy-differences">Noteworthy Differences from other Languages</h1>  <h2 id="noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</h2> <p>Although MATLAB users may find Julia’s syntax familiar, Julia is not a MATLAB clone. There are major syntactic and functional differences. The following are some noteworthy differences that may trip up Julia users accustomed to MATLAB:</p> <ul class="simple"> <li>Julia arrays are indexed with square brackets, <code>A[i,j]</code>.</li> <li>Julia arrays are assigned by reference. After <code>A=B</code>, changing elements of <code>B</code> will modify <code>A</code> as well.</li> <li>Julia values are passed and assigned by reference. If a function modifies an array, the changes will be visible in the caller.</li> <li>Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB <code>a(4) = 3.2</code> can create the array <code>a = [0 0 0 3.2]</code> and <code>a(5) = 7</code> can grow it into <code>a = [0 0 0 3.2 7]</code>, the corresponding Julia statement <code>a[5] = 7</code> throws an error if the length of <code>a</code> is less than 5 or if this statement is the first use of the identifier <code>a</code>. Julia has <a class="reference internal" href="../../stdlib/collections/#Base.push!" title="Base.push!"><code>push!()</code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.append!" title="Base.append!"><code>append!()</code></a>, which grow <code>Vector</code>s much more efficiently than MATLAB’s <code>a(end+1) = val</code>.</li> <li>The imaginary unit <code>sqrt(-1)</code> is represented in Julia as <a class="reference internal" href="../../stdlib/numbers/#Base.im" title="Base.im"><code>im</code></a>, not <code>i</code> or <code>j</code> as in MATLAB.</li> <li>In Julia, literal numbers without a decimal point (such as <code>42</code>) create integers instead of floating point numbers. Arbitrarily large integer literals are supported. As a result, some operations such as <code>2^-1</code> will throw a domain error as the result is not an integer (see <a class="reference internal" href="../faq/#man-domain-error"><span>the FAQ entry on domain errors</span></a> for details).</li> <li>In Julia, multiple values are returned and assigned as tuples, e.g. <code>(a, b) = (1, 2)</code> or <code>a, b = 1, 2</code>. MATLAB’s <code>nargout</code>, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</li> <li>Julia has true one-dimensional arrays. Column vectors are of size <code>N</code>, not <code>Nx1</code>. For example, <a class="reference internal" href="../../stdlib/numbers/#Base.rand" title="Base.rand"><code>rand(N)</code></a> makes a 1-dimensional array.</li> <li>In Julia v0.3, concatenating scalars and arrays with the syntax <code>[x,y,z]</code> concatenates in the first dimension (“vertically”). For concatenation in the second dimension (“horizontally”), use spaces as in <code>[x y z]</code>. To construct block matrices (concatenating in the first two dimensions), the syntax <code>[a b; c d]</code> is used to avoid confusion. In Julia v0.4, the concatenation syntax <code>[x, [y, z]]</code> is deprecated in favor of <code>[x; [y, z]]</code>.</li> <li>In Julia, <code>a:b</code> and <code>a:b:c</code> construct <code>Range</code> objects. To construct a full vector like in MATLAB, use <a class="reference internal" href="../../stdlib/collections/#Base.collect" title="Base.collect"><code>collect(a:b)</code></a>. Generally, there is no need to call <code>collect</code> though. <code>Range</code> will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as <a class="reference internal" href="../../stdlib/arrays/#Base.linspace" title="Base.linspace"><code>linspace</code></a>, or with iterators such as <a class="reference internal" href="../../stdlib/collections/#Base.enumerate" title="Base.enumerate"><code>enumerate</code></a>, and <a class="reference internal" href="../../stdlib/collections/#Base.zip" title="Base.zip"><code>zip</code></a>. The special objects can mostly be used as if they were normal arrays.</li> <li>Functions in Julia return values from their last expression or the <code>return</code> keyword instead of listing the names of variables to return in the function definition (see <a class="reference internal" href="../functions/#man-return-keyword"><span>The return Keyword</span></a> for details).</li> <li>A Julia script may contain any number of functions, and all definitions will be externally visible when the file is loaded. Function definitions can be loaded from files outside the current working directory.</li> <li>In Julia, reductions such as <a class="reference internal" href="../../stdlib/collections/#Base.sum" title="Base.sum"><code>sum()</code></a>, <a class="reference internal" href="../../stdlib/collections/#Base.prod" title="Base.prod"><code>prod()</code></a>, and <a class="reference internal" href="../../stdlib/math/#Base.max" title="Base.max"><code>max()</code></a> are performed over every element of an array when called with a single argument, as in <code>sum(A)</code>, even if <code>A</code> has more than one dimension.</li> <li>In Julia, functions such as <a class="reference internal" href="../../stdlib/sort/#Base.sort" title="Base.sort"><code>sort()</code></a> that operate column-wise by default (<code>sort(A)</code> is equivalent to <code>sort(A,1)</code>) do not have special behavior for <code>1xN</code> arrays; the argument is returned unmodified since it still performs <code>sort(A,1)</code>. To sort a <code>1xN</code> matrix like a vector, use <code>sort(A,2)</code>.</li> <li>In Julia, if <code>A</code> is a 2-dimensional array, <code>fft(A)</code> computes a 2D FFT. In particular, it is not equivalent to <code>fft(A,1)</code>, which computes a 1D FFT acting column-wise.</li> <li>In Julia, parentheses must be used to call a function with zero arguments, like in <a class="reference internal" href="../../stdlib/base/#Base.tic" title="Base.tic"><code>tic()</code></a> and <a class="reference internal" href="../../stdlib/base/#Base.toc" title="Base.toc"><code>toc()</code></a>.</li> <li>Julia discourages the used of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. <a class="reference internal" href="../../stdlib/io-network/#Base.println" title="Base.println"><code>println()</code></a> or <a class="reference internal" href="../../stdlib/io-network/#Base.@printf" title="Base.@printf"><code>@printf()</code></a> can be used to print specific output.</li> <li>In Julia, if <code>A</code> and <code>B</code> are arrays, logical comparison operations like <code>A == B</code> do not return an array of booleans. Instead, use <code>A .== B</code>, and similarly for the other boolean operators like <a class="reference internal" href="#" title="Base.&lt;"><code>&lt;</code></a>, <a class="reference internal" href="#" title="Base.&gt;"><code>&gt;</code></a> and <code>=</code>.</li> <li>In Julia, the operators <a class="reference internal" href="../../stdlib/math/#Base.&amp;" title="Base.&amp;"><code>&amp;</code></a>, <a class="reference internal" href="#" title="Base.|"><code>|</code></a>, and <a class="reference internal" href="../../stdlib/math/#Base.%24" title="Base.$"><code>$</code></a> perform the bitwise operations equivalent to <code>and</code>, <code>or</code>, and <code>xor</code> respectively in MATLAB, and have precedence similar to Python’s bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of <code>A</code> equal to 1 or 2 use <code>(A .== 1) | (A .== 2)</code>).</li> <li>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator <code>...</code>, as in <code>xs=[1,2]; f(xs...)</code>.</li> <li>Julia’s <a class="reference internal" href="../../stdlib/linalg/#Base.svd" title="Base.svd"><code>svd()</code></a> returns singular values as a vector instead of as a dense diagonal matrix.</li> <li>In Julia, <code>...</code> is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</li> <li>In both Julia and MATLAB, the variable <code>ans</code> is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, <code>ans</code> is not set when Julia code is run in non-interactive mode.</li> <li>Julia’s <code>type</code>s do not support dynamically adding fields at runtime, unlike MATLAB’s <code>class</code>es. Instead, use a <a class="reference internal" href="../../stdlib/collections/#Base.Dict" title="Base.Dict"><code>Dict</code></a>.</li> <li>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</li> <li>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x(x&gt;3)</code> or in the statement <code>x(x&gt;3) = []</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a class="reference internal" href="../../stdlib/collections/#Base.filter" title="Base.filter"><code>filter()</code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.filter!" title="Base.filter!"><code>filter!()</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a class="reference internal" href="../../stdlib/collections/#Base.filter!" title="Base.filter!"><code>filter!()</code></a> reduces the use of temporary arrays.</li> <li>The analogue of extracting (or “dereferencing”) all elements of a cell array, e.g. in <code>vertcat(A{:})</code> in MATLAB, is written using the splat operator in Julia, e.g. as <code>vcat(A...)</code>.</li> </ul>   <h2 id="noteworthy-differences-from-r">Noteworthy differences from R</h2> <p>One of Julia’s goals is to provide an effective language for data analysis and statistical programming. For users coming to Julia from R, these are some noteworthy differences:</p> <ul class="simple"> <li>Julia’s single quotes enclose characters, not strings.</li> <li>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</li> <li>In Julia, like Python but unlike R, strings can be created with triple quotes <code>""" ... """</code>. This syntax is convenient for constructing strings that contain line breaks.</li> <li>In Julia, varargs are specified using the splat operator <code>...</code>, which always follows the name of a specific variable, unlike R, for which <code>...</code> can occur in isolation.</li> <li>In Julia, modulus is <code>mod(a, b)</code>, not <code>a %% b</code>. <code>%</code> in Julia is the remainder operator.</li> <li>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example: - In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE)]</code> is equivalent to <code>c(1,3)</code>. - In R, <code>c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]</code> is equivalent to <code>c(1,3)</code>. - In Julia, <code>[1, 2, 3, 4][[true, false]]</code> throws a <a class="reference internal" href="../../stdlib/base/#Base.BoundsError" title="Base.BoundsError"><code>BoundsError</code></a>. - In Julia, <code>[1, 2, 3, 4][[true, false, true, false]]</code> produces <code>[1, 3]</code>.</li> <li>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, <code>c(1,2,3,4) + c(1,2)</code> is valid R but the equivalent <code>[1:4] + [1:2]</code> will throw an error in Julia.</li> <li>Julia’s <code>apply()</code> takes the function first, then its arguments, unlike <code>lapply(&lt;structure&gt;, function, arg2, ...)</code> in R.</li> <li>Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/<code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>.</li> <li>In Julia, <code>&lt;-</code>, <code>&lt;&lt;-</code> and <code>-&gt;</code> are not assignment operators.</li> <li>Julia’s <code>-&gt;</code> creates an anonymous function, like Python.</li> <li>Julia constructs vectors using brackets. Julia’s <code>[1, 2, 3]</code> is the equivalent of R’s <code>c(1, 2, 3)</code>.</li> <li>Julia’s <a class="reference internal" href="../../stdlib/strings/#Base.*" title="Base.*"><code>*</code></a> operator can perform matrix multiplication, unlike in R. If <code>A</code> and <code>B</code> are matrices, then <code>A * B</code> denotes a matrix multiplication in Julia, equivalent to R’s <code>A %*% B</code>. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write <code>A .* B</code> in Julia.</li> <li>Julia performs matrix transposition using the <code>.'</code> operator and conjugated transposition using the <code>'</code> operator. Julia’s <code>A.'</code> is therefore equivalent to R’s <code>t(A)</code>.</li> <li>Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (i in c(1, 2, 3))</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</li> <li>Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</li> <li>Julia does not provide <code>nrow</code> and <code>ncol</code>. Instead, use <code>size(M, 1)</code> for <code>nrow(M)</code> and <code>size(M, 2)</code> for <code>ncol(M)</code>.</li> <li>Julia is careful to distinguish scalars, vectors and matrices. In R, <code>1</code> and <code>c(1)</code> are the same. In Julia, they can not be used interchangeably. One potentially confusing result of this is that <code>x' * y</code> for vectors <code>x</code> and <code>y</code> is a 1-element vector, not a scalar. To get a scalar, use <a class="reference internal" href="../../stdlib/linalg/#Base.dot" title="Base.dot"><code>dot(x, y)</code></a>.</li> <li>Julia’s <a class="reference internal" href="../../stdlib/linalg/#Base.diag" title="Base.diag"><code>diag()</code></a> and <a class="reference internal" href="../../stdlib/linalg/#Base.diagm" title="Base.diagm"><code>diagm()</code></a> are not like R’s.</li> <li>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write <code>diag(M) = ones(n)</code>.</li> <li>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in <a class="reference external" href="http://pkg.julialang.org/" target="_blank">packages</a> under the <a class="reference external" href="https://github.com/JuliaStats" target="_blank">JuliaStats organization</a>. For example:<ul> <li>Functions pertaining to probability distributions are provided by the <a class="reference external" href="https://github.com/JuliaStats/Distributions.jl" target="_blank">Distributions package</a>.</li> <li>The <a class="reference external" href="https://github.com/JuliaStats/DataFrames.jl" target="_blank">DataFrames package</a> provides data frames.</li> <li>Generalized linear models are provided by the <a class="reference external" href="https://github.com/JuliaStats/GLM.jl" target="_blank">GLM package</a>.</li> </ul> </li> <li>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple: instead of <code>list(a = 1, b = 2)</code>, use <code>(1, 2)</code>.</li> <li>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia’s multiple dispatch system means that <code>table(x::TypeA)</code> and <code>table(x::TypeB)</code> act like R’s <code>table.TypeA(x)</code> and <code>table.TypeB(x)</code>.</li> <li>In Julia, values are passed and assigned by reference. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</li> <li>In Julia, vectors and matrices are concatenated using <a class="reference internal" href="../../stdlib/arrays/#Base.hcat" title="Base.hcat"><code>hcat()</code></a>, <a class="reference internal" href="../../stdlib/arrays/#Base.vcat" title="Base.vcat"><code>vcat()</code></a> and <a class="reference internal" href="../../stdlib/arrays/#Base.hvcat" title="Base.hvcat"><code>hvcat()</code></a>, not <code>c</code>, <code>rbind</code> and <code>cbind</code> like in R.</li> <li>In Julia, a range like <code>a:b</code> is not shorthand for a vector like in R, but is a specialized <code>Range</code> that is used for iteration without high memory overhead. To convert a range into a vector, use <a class="reference internal" href="../../stdlib/collections/#Base.collect" title="Base.collect"><code>collect(a:b)</code></a>.</li> <li>Julia’s <a class="reference internal" href="../../stdlib/math/#Base.max" title="Base.max"><code>max()</code></a> and <a class="reference internal" href="../../stdlib/math/#Base.min" title="Base.min"><code>min()</code></a> are the equivalent of <code>pmax</code> and <code>pmin</code> respectively in R, but both arguments need to have the same dimensions. While <a class="reference internal" href="../../stdlib/collections/#Base.maximum" title="Base.maximum"><code>maximum()</code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.minimum" title="Base.minimum"><code>minimum()</code></a> replace <code>max</code> and <code>min</code> in R, there are important differences.</li> <li>Julia’s <a class="reference internal" href="../../stdlib/collections/#Base.sum" title="Base.sum"><code>sum()</code></a>, <a class="reference internal" href="../../stdlib/collections/#Base.prod" title="Base.prod"><code>prod()</code></a>, <a class="reference internal" href="../../stdlib/collections/#Base.maximum" title="Base.maximum"><code>maximum()</code></a>, and <a class="reference internal" href="../../stdlib/collections/#Base.minimum" title="Base.minimum"><code>minimum()</code></a> are different from their counterparts in R. They all accept one or two arguments. The first argument is an iterable collection such as an array. If there is a second argument, then this argument indicates the dimensions, over which the operation is carried out. For instance, let <code>A=[[1 2],[3 4]]</code> in Julia and <code>B=rbind(c(1,2),c(3,4))</code> be the same matrix in R. Then <code>sum(A)</code> gives the same result as <code>sum(B)</code>, but <code>sum(A, 1)</code> is a row vector containing the sum over each column and <code>sum(A, 2)</code> is a column vector containing the sum over each row. This contrasts to the behavior of R, where <code>sum(B,1)=11</code> and <code>sum(B,2)=12</code>. If the second argument is a vector, then it specifies all the dimensions over which the sum is performed, e.g., <code>sum(A,[1,2])=10</code>. It should be noted that there is no error checking regarding the second argument.</li> <li>Julia has several functions that can mutate their arguments. For example, it has both <a class="reference internal" href="../../stdlib/sort/#Base.sort" title="Base.sort"><code>sort()</code></a> and <a class="reference internal" href="../../stdlib/sort/#Base.sort!" title="Base.sort!"><code>sort!()</code></a>.</li> <li>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</li> <li>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</li> <li>Julia does not support the <code>NULL</code> type.</li> <li>Julia lacks the equivalent of R’s <code>assign</code> or <code>get</code>.</li> <li>In Julia, <code>return</code> does not require parentheses.</li> <li>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression <code>x[x&gt;3]</code> or in the statement <code>x = x[x&gt;3]</code> to modify <code>x</code> in-place. In contrast, Julia provides the higher order functions <a class="reference internal" href="../../stdlib/collections/#Base.filter" title="Base.filter"><code>filter()</code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.filter!" title="Base.filter!"><code>filter!()</code></a>, allowing users to write <code>filter(z-&gt;z&gt;3, x)</code> and <code>filter!(z-&gt;z&gt;3, x)</code> as alternatives to the corresponding transliterations <code>x[x.&gt;3]</code> and <code>x = x[x.&gt;3]</code>. Using <a class="reference internal" href="../../stdlib/collections/#Base.filter!" title="Base.filter!"><code>filter!()</code></a> reduces the use of temporary arrays.</li> </ul>   <h2 id="noteworthy-differences-from-python">Noteworthy differences from Python</h2> <ul class="simple"> <li>In Julia, a vector of vectors can automatically concatenate into a one-dimensional vector <em>if</em> no explicit element type is specified. For example:<ul> <li>In Julia, <code>[1, [2, 3]]</code> concatenates into <code>[1, 2, 3]</code>, like in R.</li> <li>In Julia, <code>Int[1, Int[2, 3]]</code> will <em>not</em> concatenate, but instead throw an error.</li> <li>In Julia, <code>Any[1, [2,3]]</code> will <em>not</em> concatenate.</li> <li>In Julia, <code>Vector{Int}[[1, 2], [3, 4]]</code> will <em>not</em> concatenate, but produces an object similar to Python’s list of lists. This object is <em>different</em> from a two-dimensional <a class="reference internal" href="../../stdlib/arrays/#Base.Array" title="Base.Array"><code>Array</code></a> of <code>Int</code>s.</li> </ul> </li> <li>Julia requires <code>end</code> to end a block. Unlike Python, Julia has no <code>pass</code> keyword.</li> <li>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</li> <li>Julia’s slice indexing includes the last element, unlike in Python. <code>a[2:3]</code> in Julia is <code>a[1:3]</code> in Python.</li> <li>Julia does not support negative indexes. In particular, the last element of a list or array is indexed with <code>end</code> in Julia, not <code>-1</code> as in Python.</li> <li>Julia’s list comprehensions do not support the optional <code>if</code> clause that Python has.</li> <li>Julia’s <code>for</code>, <code>if</code>, <code>while</code>, etc. blocks are terminated by the <code>end</code> keyword. Indentation level is not significant as it is in Python.</li> <li>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</li> <li>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of <a class="reference internal" href="../performance-tips/#man-performance-tips"><span>Performance Tips</span></a>).</li> <li>Julia’s updating operators (e.g. <code>+=</code>, <code>-=</code>, ...) are <em>not in-place</em> whereas NumPy’s are. This means <code>A = ones(4); B = A; B += 3</code> doesn’t change values in <code>A</code>, it rather rebinds the name <code>B</code> to the result of the right- hand side <code>B = B + 3</code>, which is a new array. Use <code>B[:] += 3</code>, explicit loops, or <code>InplaceOps.jl</code>.</li> <li>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function <code>f(x=rand()) = x</code> returns a new random number every time it is invoked without argument. On the other hand, the function <code>g(x=[1,2]) = push!(x,3)</code> returns <code>[1,2,3]</code> every time it is called as <code>g()</code>.</li> <li>In Julia <code>%</code> is the remainder operator, whereas in Python it is the modulus.</li> </ul>   <h2 id="noteworthy-differences-from-c-c">Noteworthy differences from C/C++</h2> <ul class="simple"> <li>Julia arrays are indexed with square brackets, and can have more than one dimension <code>A[i,j]</code>. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</li> <li>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</li> <li>Julia arrays are assigned by reference. After <code>A=B</code>, changing elements of <code>B</code> will modify <code>A</code> as well. Updating operators like <code>+=</code> do not operate in-place, they are equivalent to <code>A = A + B</code> which rebinds the left-hand side to the result of the right-hand side expression.</li> <li>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of <a class="reference internal" href="../performance-tips/#man-performance-tips"><span>Performance Tips</span></a>).</li> <li>Julia values are passed and assigned by reference. If a function modifies an array, the changes will be visible in the caller.</li> <li>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</li> <li>In Julia, literal numbers without a decimal point (such as <code>42</code>) create signed integers, of type <code>Int</code>, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as <code>Int64</code> (if <code>Int</code> is <code>Int32</code>), <code>Int128</code>, or the arbitrarily large <code>BigInt</code> type. There are no numeric literal suffixes, such as <code>L</code>, <code>LL</code>, <code>U</code>, <code>UL</code>, <code>ULL</code> to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with <code>0x</code> like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the <em>length</em> of the literal, including leading 0s. For example, <code>0x0</code> and <code>0x00</code> have type UInt8, <code>0x000</code> and <code>0x0000</code> have type <code>UInt16</code>, then literals with 5 to 8 hex digits have type <code>UInt32</code>, 9 to 16 hex digits type <code>UInt64</code> and 17 to 32 hex digits type <code>UInt128</code>. This needs to be taken into account when defining hexadecimal masks, for example <code>~0xf == 0xf0</code> is very different from <code>~0x000f == 0xfff0</code>. 64 bit <code>Float64</code> and 32 bit <code>Float32</code> bit literals are expressed as <code>1.0</code> and <code>1.0f0</code> respectively. Floating point literals are rounded (and not promoted to the <code>BigFloat</code> type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with <code>0o</code>) and binary (prefixed with <code>0b</code>) literals are also treated as unsigned.</li> <li>String literals can be delimited with either <code>"</code> or <code>"""</code>, <code>"""</code> delimited literals can contain <code>"</code> characters without quoting it like <code>"\""</code> String literals can have values of other variables or expressions interpolated into them, indicated by <code>$variablename</code> or <code>$(expression)</code>, which evaluates the variable name or the expression in the context of the function.</li> <li>
<code>//</code> indicates a <code>Rational</code> number, and not a single-line comment (which is <code>#</code> in Julia)</li> <li>
<code>#=</code> indicates the start of a multiline comment, and <code>=#</code> ends it.</li> <li>Functions in Julia return values from their last expression(s) or the <code>return</code> keyword. Multiple values can be returned from functions and assigned as tuples, e.g. <code>(a, b) = myfunction()</code> or <code>a, b = myfunction()</code>, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. <code>a = myfunction(&amp;b)</code>.</li> <li>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. <a class="reference internal" href="../../stdlib/io-network/#Base.println" title="Base.println"><code>println()</code></a> or <a class="reference internal" href="../../stdlib/io-network/#Base.@printf" title="Base.@printf"><code>@printf()</code></a> can be used to print specific output. In the REPL, <code>;</code> can be used to suppress output. <code>;</code> also has a different meaning within <code>[ ]</code>, something to watch out for. <code>;</code> can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</li> <li>In Julia, the operator <a class="reference internal" href="../../stdlib/math/#Base.%24" title="Base.$"><code>$</code></a> performs the bitwise XOR operation, i.e. <a class="reference internal" href="#" title="Base.^"><code>^</code></a> in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</li> <li>Julia’s <a class="reference internal" href="#" title="Base.^"><code>^</code></a> is exponentiation (pow), not bitwise XOR as in C/C++ (use <a class="reference internal" href="../../stdlib/math/#Base.%24" title="Base.$"><code>$</code></a> in Julia)</li> <li>Julia has two right-shift operators, <code>&gt;&gt;</code> and <code>&gt;&gt;&gt;</code>. <code>&gt;&gt;&gt;</code> performs an arithmetic shift, <code>&gt;&gt;</code> always performs a logical shift, unlike C/C++, where the meaning of <code>&gt;&gt;</code> depends on the type of the value being shifted.</li> <li>Julia’s <code>-&gt;</code> creates an anonymous function, it does not access a member via a pointer.</li> <li>Julia does not require parentheses when writing <code>if</code> statements or <code>for</code>/<code>while</code> loops: use <code>for i in [1, 2, 3]</code> instead of <code>for (int i=1; i &lt;= 3; i++)</code> and <code>if i == 1</code> instead of <code>if (i == 1)</code>.</li> <li>Julia does not treat the numbers <code>0</code> and <code>1</code> as Booleans. You cannot write <code>if (1)</code> in Julia, because <code>if</code> statements accept only booleans. Instead, you can write <code>if true</code>, <code>if Bool(1)</code>, or <code>if 1==1</code>.</li> <li>Julia uses <code>end</code> to denote the end of conditional blocks, like <code>if</code>, loop blocks, like <code>while</code>/<code>for</code>, and functions. In lieu of the one-line <code>if ( cond ) statement</code>, Julia allows statements of the form <code>if cond; statement; end</code>, <code>cond &amp;&amp; statement</code> and <code>!cond || statement</code>. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. <code>cond &amp;&amp; (x = value)</code>, because of the operator precedence.</li> <li>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</li> <li>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the <code>@</code> character, and have both a function-like syntax, <code>@mymacro(arg1, arg2, arg3)</code>, and a statement-like syntax, <code>@mymacro arg1 arg2 arg3</code>. The forms are interchangable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the parallel <code>for</code> construct: <code>@parallel for i in 1:n; #= body =#; end</code>. Where the end of the macro construct may be unclear, use the function-like form.</li> <li>Julia now has an enumeration type, expressed using the macro <code>@enum(name, value1, value2, ...)</code> For example: <code>@enum(Fruit, Banana=1, Apple, Pear)</code>
</li> <li>By convention, functions that modify their arguments have a <code>!</code> at the end of the name, for example <code>push!</code>.</li> <li>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is “virtual” (although it’s more general than that since methods are dispatched on every argument type, not only <code>this</code>, using the most-specific-declaration rule).</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.julialang.org/en/release-0.5/manual/noteworthy-differences/" class="_attribution-link" target="_blank">http://docs.julialang.org/en/release-0.5/manual/noteworthy-differences/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
