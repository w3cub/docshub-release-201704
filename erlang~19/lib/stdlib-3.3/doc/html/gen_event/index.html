
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Gen_event - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" gen_event ">
  <meta name="keywords" content="gen, event, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/stdlib-3.3/doc/html/gen_event/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>gen_event</h1> <h2>Module</h2> <p class="REFBODY">gen_event</p> <h2>Module summary</h2> <p class="REFBODY">Generic event handling behavior.</p> <h2>Description</h2> 
<p>This behavior module provides event handling functionality. It consists of a generic event manager process with any number of event handlers that are added and deleted dynamically.</p> <p>An event manager implemented using this module has a standard set of interface functions and includes functionality for tracing and error reporting. It also fits into an OTP supervision tree. For more information, see <code class="bold_code">OTP Design Principles</code>. </p> <p>Each event handler is implemented as a callback module exporting a predefined set of functions. The relationship between the behavior functions and the callback functions is as follows:</p> <div class="example"><pre>
gen_event module                   Callback module
----------------                   ---------------
gen_event:start
gen_event:start_link       -----&gt;  -

gen_event:add_handler
gen_event:add_sup_handler  -----&gt;  Module:init/1

gen_event:notify
gen_event:sync_notify      -----&gt;  Module:handle_event/2

gen_event:call             -----&gt;  Module:handle_call/2

-                          -----&gt;  Module:handle_info/2

gen_event:delete_handler   -----&gt;  Module:terminate/2

gen_event:swap_handler
gen_event:swap_sup_handler -----&gt;  Module1:terminate/2
                                   Module2:init/1

gen_event:which_handlers   -----&gt;  -

gen_event:stop             -----&gt;  Module:terminate/2

-                          -----&gt;  Module:code_change/3</pre></div> <p>As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. <code class="code">gen_event</code> is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with <code class="code">Reason</code>, or returns a bad value <code class="code">Term</code>, the event manager does not fail. It deletes the event handler by calling callback function <code class="bold_code"><a href="#Module:terminate-2"><span class="code">Module:terminate/2</span></a></code>, giving as argument <code class="code">{error,{'EXIT',Reason}}</code> or <code class="code">{error,Term}</code>, respectively. No other event handler is affected.</p> <p>A <code class="code">gen_event</code> process handles system messages as described in <code class="bold_code"><a href="../sys/"><span class="code">sys(3)</span></a></code>. The <code class="code">sys</code> module can be used for debugging an event manager.</p> <p>Notice that an event manager <strong>does</strong> trap exit signals automatically.</p> <p>The <code class="code">gen_event</code> process can go into hibernation (see <code class="bold_code"><span class="code">erlang:hibernate/3</span></code>) if a callback function in a handler module specifies <code class="code">hibernate</code> in its return value. This can be useful if the server is expected to be idle for a long time. However, use this feature with care, as hibernation implies at least two garbage collections (when hibernating and shortly after waking up) and is not something you want to do between each event handled by a busy event manager.</p> <p>Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a <code class="code">hibernate</code> request for the whole event manager to go into hibernation.</p> <p>Unless otherwise stated, all functions in this module fail if the specified event manager does not exist or if bad arguments are specified.</p>  <h2>Data types</h2> <h3 class="code">handler() = atom() | {atom(), term()}</h3> <h3 class="code">handler_args() = term()</h3> <h3 class="code">add_handler_ret() = ok | term() | {'EXIT', term()}</h3> <h3 class="code">del_handler_ret() = ok | term() | {'EXIT', term()}</h3> <h2>Exports</h2> <h3 id="add_handler-3" class="code">add_handler(EventMgrRef, Handler, Args) -&gt; Result</h3>  <p>Types:</p>           <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Handler = Module | {Module,Id}
 Module = atom()
 Id = term()
Args = term()
Result = ok | {'EXIT',Reason} | term()
 Reason = term()</pre>

<p>Adds a new event handler to event manager <code class="code">EventMgrRef</code>. The event manager calls <code class="bold_code"><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> to initiate the event handler and its internal state.</p> <p><code class="code">EventMgrRef</code> can be any of the following:</p> <ul> <li>The pid</li> <li> <code class="code">Name</code>, if the event manager is locally registered</li> <li> <code class="code">{Name,Node}</code>, if the event manager is locally registered at another node</li> <li> <code class="code">{global,GlobalName}</code>, if the event manager is globally registered</li> <li> <code class="code">{via,Module,ViaName}</code>, if the event manager is registered through an alternative process registry</li> </ul> <p><code class="code">Handler</code> is the name of the callback module <code class="code">Module</code> or a tuple <code class="code">{Module,Id}</code>, where <code class="code">Id</code> is any term. The <code class="code">{Module,Id}</code> representation makes it possible to identify a specific event handler when many event handlers use the same callback module.</p> <p><code class="code">Args</code> is any term that is passed as the argument to <code class="code">Module:init/1</code>.</p> <p>If <code class="code">Module:init/1</code> returns a correct value indicating successful completion, the event manager adds the event handler and this function returns <code class="code">ok</code>. If <code class="code">Module:init/1</code> fails with <code class="code">Reason</code> or returns <code class="code">{error,Reason}</code>, the event handler is ignored and this function returns <code class="code">{'EXIT',Reason}</code> or <code class="code">{error,Reason}</code>, respectively.</p>  <h3 id="add_sup_handler-3" class="code">add_sup_handler(EventMgrRef, Handler, Args) -&gt; Result</h3>  <p>Types:</p>           <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Handler = Module | {Module,Id}
 Module = atom()
 Id = term()
Args = term()
Result = ok | {'EXIT',Reason} | term()
 Reason = term()</pre>

<p>Adds a new event handler in the same way as <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>, but also supervises the connection between the event handler and the calling process.</p> <ul> <li>If the calling process later terminates with <code class="code">Reason</code>, the event manager deletes the event handler by calling <code class="bold_code"><a href="#Module:terminate-2"><span class="code">Module:terminate/2</span></a></code> with <code class="code">{stop,Reason}</code> as argument. </li> <li> <p>If the event handler is deleted later, the event manager sends a message<code class="code">{gen_event_EXIT,Handler,Reason}</code> to the calling process. <code class="code">Reason</code> is one of the following:</p> <ul> <li> <p><code class="code">normal</code>, if the event handler has been removed because of a call to <code class="code">delete_handler/3</code>, or <code class="code">remove_handler</code> has been returned by a callback function (see below).</p> </li> <li> <p><code class="code">shutdown</code>, if the event handler has been removed because the event manager is terminating.</p> </li> <li> <p><code class="code">{swapped,NewHandler,Pid}</code>, if the process <code class="code">Pid</code> has replaced the event handler with another event handler <code class="code">NewHandler</code> using a call to <code class="bold_code"><a href="#swap_handler-3"><span class="code">swap_handler/3</span></a></code> or <code class="bold_code"><a href="#swap_sup_handler-3"><span class="code">swap_sup_handler/3</span></a></code>.</p> </li> <li> <p>A term, if the event handler is removed because of an error. Which term depends on the error.</p> </li> </ul> </li> </ul> <p>For a description of the arguments and return values, see <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>.</p>  <h3 id="call-4" class="code">call(EventMgrRef, Handler, Request) -&gt; Result<br>call(EventMgrRef, Handler, Request, Timeout) -&gt; Result</h3>  <p>Types:</p>              <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Handler = Module | {Module,Id}
 Module = atom()
 Id = term()
Request = term()
Timeout = int()&gt;0 | infinity
Result = Reply | {error,Error}
 Reply = term()
 Error = bad_module | {'EXIT',Reason} | term()
  Reason = term()</pre>

<p>Makes a synchronous call to event handler <code class="code">Handler</code> installed in event manager <code class="code">EventMgrRef</code> by sending a request and waiting until a reply arrives or a time-out occurs. The event manager calls <code class="bold_code"><a href="#Module:handle_call-2"><span class="code">Module:handle_call/2</span></a></code> to handle the request.</p> <p>For a description of <code class="code">EventMgrRef</code> and <code class="code">Handler</code>, see <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>.</p> <p><code class="code">Request</code> is any term that is passed as one of the arguments to <code class="code">Module:handle_call/2</code>.</p> <p><code class="code">Timeout</code> is an integer greater than zero that specifies how many milliseconds to wait for a reply, or the atom <code class="code">infinity</code> to wait indefinitely. Defaults to 5000. If no reply is received within the specified time, the function call fails.</p> <p>The return value <code class="code">Reply</code> is defined in the return value of <code class="code">Module:handle_call/2</code>. If the specified event handler is not installed, the function returns <code class="code">{error,bad_module}</code>. If the callback function fails with <code class="code">Reason</code> or returns an unexpected value <code class="code">Term</code>, this function returns <code class="code">{error,{'EXIT',Reason}}</code> or <code class="code">{error,Term}</code>, respectively.</p>  <h3 id="delete_handler-3" class="code">delete_handler(EventMgrRef, Handler, Args) -&gt; Result</h3>  <p>Types:</p>           <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Handler = Module | {Module,Id}
 Module = atom()
 Id = term()
Args = term()
Result = term() | {error,module_not_found} | {'EXIT',Reason}
 Reason = term()</pre>

<p>Deletes an event handler from event manager <code class="code">EventMgrRef</code>. The event manager calls <code class="bold_code"><a href="#Module:terminate-2"><span class="code">Module:terminate/2</span></a></code> to terminate the event handler.</p> <p>For a description of <code class="code">EventMgrRef</code> and <code class="code">Handler</code>, see <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>.</p> <p><code class="code">Args</code> is any term that is passed as one of the arguments to <code class="code">Module:terminate/2</code>.</p> <p>The return value is the return value of <code class="code">Module:terminate/2</code>. If the specified event handler is not installed, the function returns <code class="code">{error,module_not_found}</code>. If the callback function fails with <code class="code">Reason</code>, the function returns <code class="code">{'EXIT',Reason}</code>.</p>  <h3 id="sync_notify-2" class="code">notify(EventMgrRef, Event) -&gt; ok<br>sync_notify(EventMgrRef, Event) -&gt; ok</h3>  <p>Types:</p>      <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Event = term()</pre>

<p>Sends an event notification to event manager <code class="code">EventMgrRef</code>. The event manager calls <code class="bold_code"><a href="#Module:handle_event-2"><span class="code">Module:handle_event/2</span></a></code> for each installed event handler to handle the event.</p> <p><code class="code">notify/2</code> is asynchronous and returns immediately after the event notification has been sent. <code class="code">sync_notify/2</code> is synchronous in the sense that it returns <code class="code">ok</code> after the event has been handled by all event handlers.</p> <p>For a description of <code class="code">EventMgrRef</code>, see <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>.</p> <p><code class="code">Event</code> is any term that is passed as one of the arguments to <code class="bold_code"><a href="#Module:handle_event-2"><span class="code">Module:handle_event/2</span></a></code>.</p> <p><code class="code">notify/1</code> does not fail even if the specified event manager does not exist, unless it is specified as <code class="code">Name</code>.</p>  <h3 id="start-1" class="code">start() -&gt; Result<br>start(EventMgrName) -&gt; Result</h3>  <p>Types:</p>       <pre>EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}
 Name = atom()
 GlobalName = ViaName = term()
Result = {ok,Pid} | {error,{already_started,Pid}}
 Pid = pid()</pre>

<p>Creates a stand-alone event manager process, that is, an event manager that is not part of a supervision tree and thus has no supervisor.</p> <p>For a description of the arguments and return values, see <code class="bold_code"><a href="#start_link-0"><span class="code">start_link/0,1</span></a></code>.</p>  <h3 id="start_link-1" class="code">start_link() -&gt; Result<br>start_link(EventMgrName) -&gt; Result</h3>  <p>Types:</p>       <pre>EventMgrName = {local,Name} | {global,GlobalName} | {via,Module,ViaName}
 Name = atom()
 GlobalName = ViaName = term()
Result = {ok,Pid} | {error,{already_started,Pid}}
 Pid = pid()</pre>

<p>Creates an event manager process as part of a supervision tree. The function is to be called, directly or indirectly, by the supervisor. For example, it ensures that the event manager is linked to the supervisor.</p> <ul> <li> <p>If <code class="code">EventMgrName={local,Name}</code>, the event manager is registered locally as <code class="code">Name</code> using <code class="code">register/2</code>.</p> </li> <li> <p>If <code class="code">EventMgrName={global,GlobalName}</code>, the event manager is registered globally as <code class="code">GlobalName</code> using <code class="bold_code"><span class="code">global:register_name/2</span></code>. If no name is provided, the event manager is not registered.</p> </li> <li> <p>If <code class="code">EventMgrName={via,Module,ViaName}</code>, the event manager registers with the registry represented by <code class="code">Module</code>. The <code class="code">Module</code> callback is to export the functions <code class="code">register_name/2</code>, <code class="code">unregister_name/1</code>, <code class="code">whereis_name/1</code>, and <code class="code">send/2</code>, which are to behave as the corresponding functions in <code class="bold_code"><span class="code">global</span></code>. Thus, <code class="code">{via,global,GlobalName}</code> is a valid reference.</p> </li> </ul> <p>If the event manager is successfully created, the function returns <code class="code">{ok,Pid}</code>, where <code class="code">Pid</code> is the pid of the event manager. If a process with the specified <code class="code">EventMgrName</code> exists already, the function returns <code class="code">{error,{already_started,Pid}}</code>, where <code class="code">Pid</code> is the pid of that process.</p>  <h3 id="stop-3" class="code">stop(EventMgrRef) -&gt; ok<br>stop(EventMgrRef, Reason, Timeout) -&gt; ok</h3>  <p>Types:</p>       <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
Name = Node = atom()
GlobalName = ViaName = term()
Reason = term()
Timeout = int()&gt;0 | infinity</pre>

<p>Orders event manager <code class="code">EventMgrRef</code> to exit with the specifies <code class="code">Reason</code> and waits for it to terminate. Before terminating, <code class="code">gen_event</code> calls <code class="bold_code"><a href="#Module:terminate-2"><span class="code">Module:terminate(stop,...)</span></a></code> for each installed event handler.</p> <p>The function returns <code class="code">ok</code> if the event manager terminates with the expected reason. Any other reason than <code class="code">normal</code>, <code class="code">shutdown</code>, or <code class="code">{shutdown,Term}</code> causes an error report to be issued using <code class="bold_code"><span class="code">error_logger:format/2</span></code>. The default <code class="code">Reason</code> is <code class="code">normal</code>.</p> <p><code class="code">Timeout</code> is an integer greater than zero that specifies how many milliseconds to wait for the event manager to terminate, or the atom <code class="code">infinity</code> to wait indefinitely. Defaults to <code class="code">infinity</code>. If the event manager has not terminated within the specified time, a <code class="code">timeout</code> exception is raised.</p> <p>If the process does not exist, a <code class="code">noproc</code> exception is raised.</p> <p>For a description of <code class="code">EventMgrRef</code>, see <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>.</p>  <h3 id="swap_handler-3" class="code">swap_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result</h3>  <p>Types:</p>            <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Handler1 = Handler2 = Module | {Module,Id}
 Module = atom()
 Id = term()
Args1 = Args2 = term()
Result = ok | {error,Error}
 Error = {'EXIT',Reason} | term()
  Reason = term()</pre>

<p>Replaces an old event handler with a new event handler in event manager <code class="code">EventMgrRef</code>.</p> <p>For a description of the arguments, see <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>.</p> <p>First the old event handler <code class="code">Handler1</code> is deleted. The event manager calls <code class="code">Module1:terminate(Args1, ...)</code>, where <code class="code">Module1</code> is the callback module of <code class="code">Handler1</code>, and collects the return value.</p> <p>Then the new event handler <code class="code">Handler2</code> is added and initiated by calling <code class="code">Module2:init({Args2,Term})</code>, where <code class="code">Module2</code> is the callback module of <code class="code">Handler2</code> and <code class="code">Term</code> is the return value of <code class="code">Module1:terminate/2</code>. This makes it possible to transfer information from <code class="code">Handler1</code> to <code class="code">Handler2</code>.</p> <p>The new handler is added even if the the specified old event handler is not installed, in which case <code class="code">Term=error</code>, or if <code class="code">Module1:terminate/2</code> fails with <code class="code">Reason</code>, in which case <code class="code">Term={'EXIT',Reason}</code>. The old handler is deleted even if <code class="code">Module2:init/1</code> fails.</p> <p>If there was a supervised connection between <code class="code">Handler1</code> and a process <code class="code">Pid</code>, there is a supervised connection between <code class="code">Handler2</code> and <code class="code">Pid</code> instead.</p> <p>If <code class="code">Module2:init/1</code> returns a correct value, this function returns <code class="code">ok</code>. If <code class="code">Module2:init/1</code> fails with <code class="code">Reason</code> or returns an unexpected value <code class="code">Term</code>, this function returns <code class="code">{error,{'EXIT',Reason}}</code> or <code class="code">{error,Term}</code>, respectively.</p>  <h3 id="swap_sup_handler-3" class="code">swap_sup_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result</h3>  <p>Types:</p>            <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Handler1 = Handler 2 = Module | {Module,Id}
 Module = atom()
 Id = term()
Args1 = Args2 = term()
Result = ok | {error,Error}
 Error = {'EXIT',Reason} | term()
  Reason = term()</pre>

<p>Replaces an event handler in event manager <code class="code">EventMgrRef</code> in the same way as <code class="code">swap_handler/3</code>, but also supervises the connection between <code class="code">Handler2</code> and the calling process.</p> <p>For a description of the arguments and return values, see <code class="bold_code"><a href="#swap_handler-3"><span class="code">swap_handler/3</span></a></code>.</p>  <h3 id="which_handlers-1" class="code">which_handlers(EventMgrRef) -&gt; [Handler]</h3>  <p>Types:</p>        <pre>EventMgrRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
 Name = Node = atom()
 GlobalName = ViaName = term()
Handler = Module | {Module,Id}
 Module = atom()
 Id = term()</pre>

<p>Returns a list of all event handlers installed in event manager <code class="code">EventMgrRef</code>.</p> <p>For a description of <code class="code">EventMgrRef</code> and <code class="code">Handler</code>, see <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code>.</p>  <h2 id="id212647">Callback Functions</h2>  <p>The following functions are to be exported from a <code class="code">gen_event</code> callback module.</p>  <h2>Exports</h2> <h3 id="Module:code_change-3" class="code">Module:code_change(OldVsn, State, Extra) -&gt; {ok, NewState}</h3>  <p>Types:</p>      <pre>OldVsn = Vsn | {down, Vsn}
  Vsn = term()
State = NewState = term()
Extra = term()</pre>

<p>This function is called for an installed event handler that is to update its internal state during a release upgrade/downgrade, that is, when the instruction <code class="code">{update,Module,Change,...}</code>, where <code class="code">Change={advanced,Extra}</code>, is specified in the <code class="code">.appup</code> file. For more information, see <code class="bold_code">OTP Design Principles</code>.</p> <p>For an upgrade, <code class="code">OldVsn</code> is <code class="code">Vsn</code>, and for a downgrade, <code class="code">OldVsn</code> is <code class="code">{down,Vsn}</code>. <code class="code">Vsn</code> is defined by the <code class="code">vsn</code> attribute(s) of the old version of the callback module <code class="code">Module</code>. If no such attribute is defined, the version is the checksum of the Beam file.</p> <p><code class="code">State</code> is the internal state of the event handler.</p> <p><code class="code">Extra</code> is passed "as is" from the <code class="code">{advanced,Extra}</code> part of the update instruction.</p> <p>The function is to return the updated internal state.</p>  <h3 id="Module:format_status-2" class="code">Module:format_status(Opt, [PDict, State]) -&gt; Status</h3>  <p>Types:</p>      <pre>Opt = normal | terminate
PDict = [{Key, Value}]
State = term()
Status = term()</pre>

<div class="note"> <div class="label">Note</div> <div class="content">

<p>This callback is optional, so event handler modules need not export it. If a handler does not export this function, the <code class="code">gen_event</code> module uses the handler state directly for the purposes described below.</p> </div> </div> <p>This function is called by a <code class="code">gen_event</code> process in the following situations:</p> <ul> <li>One of <code class="bold_code"><a href="../sys/#get_status-1"><span class="code">sys:get_status/1,2</span></a></code> is invoked to get the <code class="code">gen_event</code> status. <code class="code">Opt</code> is set to the atom <code class="code">normal</code> for this case.</li> <li>The event handler terminates abnormally and <code class="code">gen_event</code> logs an error. <code class="code">Opt</code> is set to the atom <code class="code">terminate</code> for this case.</li> </ul> <p>This function is useful for changing the form and appearance of the event handler state for these cases. An event handler callback module wishing to change the the <code class="code">sys:get_status/1,2</code> return value as well as how its state appears in termination error logs, exports an instance of <code class="code">format_status/2</code> that returns a term describing the current state of the event handler.</p> <p><code class="code">PDict</code> is the current value of the process dictionary of <code class="code">gen_event</code>.</p> <p><code class="code">State</code> is the internal state of the event handler.</p> <p>The function is to return <code class="code">Status</code>, a term that change the details of the current state of the event handler. Any term is allowed for <code class="code">Status</code>. The <code class="code">gen_event</code> module uses <code class="code">Status</code> as follows:</p> <ul> <li><p>When <code class="code">sys:get_status/1,2</code> is called, <code class="code">gen_event</code> ensures that its return value contains <code class="code">Status</code> in place of the state term of the event handler.</p></li> <li><p>When an event handler terminates abnormally, <code class="code">gen_event</code> logs <code class="code">Status</code> in place of the state term of the event handler.</p></li> </ul> <p>One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.</p>  <h3 id="Module:handle_call-2" class="code">Module:handle_call(Request, State) -&gt; Result</h3>  <p>Types:</p>             <pre>Request = term()
State = term()
Result = {ok,Reply,NewState} | {ok,Reply,NewState,hibernate}
 | {swap_handler,Reply,Args1,NewState,Handler2,Args2}
 | {remove_handler, Reply}
 Reply = term()
 NewState = term()
 Args1 = Args2 = term()
 Handler2 = Module2 | {Module2,Id}
  Module2 = atom()
  Id = term()</pre>

<p>Whenever an event manager receives a request sent using <code class="bold_code"><a href="#call-3"><span class="code">call/3,4</span></a></code>, this function is called for the specified event handler to handle the request.</p> <p><code class="code">Request</code> is the <code class="code">Request</code> argument of <code class="code">call/3,4</code>.</p> <p><code class="code">State</code> is the internal state of the event handler.</p> <p>The return values are the same as for <code class="bold_code"><a href="#Module:handle_event-2"><span class="code">Module:handle_event/2</span></a></code> except that they also contain a term <code class="code">Reply</code>, which is the reply to the client as the return value of <code class="code">call/3,4</code>.</p>  <h3 id="Module:handle_event-2" class="code">Module:handle_event(Event, State) -&gt; Result</h3>  <p>Types:</p>           <pre>Event = term()
State = term()
Result = {ok,NewState} | {ok,NewState,hibernate}
  | {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler
 NewState = term()
 Args1 = Args2 = term()
 Handler2 = Module2 | {Module2,Id}
  Module2 = atom()
  Id = term()</pre>

<p>Whenever an event manager receives an event sent using <code class="bold_code"><a href="#notify-2"><span class="code">notify/2</span></a></code> or <code class="bold_code"><a href="#sync_notify-2"><span class="code">sync_notify/2</span></a></code>, this function is called for each installed event handler to handle the event.</p> <p><code class="code">Event</code> is the <code class="code">Event</code> argument of <code class="code">notify/2</code>/<code class="code">sync_notify/2</code>.</p> <p><code class="code">State</code> is the internal state of the event handler.</p> <ul> <li> <p>If <code class="code">{ok,NewState}</code> or <code class="code">{ok,NewState,hibernate}</code> is returned, the event handler remains in the event manager with the possible updated internal state <code class="code">NewState</code>.</p> </li> <li> <p>If <code class="code">{ok,NewState,hibernate}</code> is returned, the event manager also goes into hibernation (by calling <code class="bold_code"><a href="../proc_lib/#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></code>), waiting for the next event to occur. It is sufficient that one of the event handlers return <code class="code">{ok,NewState,hibernate}</code> for the whole event manager process to hibernate.</p> </li> <li> <p>If <code class="code">{swap_handler,Args1,NewState,Handler2,Args2}</code> is returned, the event handler is replaced by <code class="code">Handler2</code> by first calling <code class="code">Module:terminate(Args1,NewState)</code> and then <code class="code">Module2:init({Args2,Term})</code>, where <code class="code">Term</code> is the return value of <code class="code">Module:terminate/2</code>. For more information, see <code class="bold_code"><a href="#swap_handler-3"><span class="code">swap_handler/3</span></a></code>. </p> </li> <li> <p>If <code class="code">remove_handler</code> is returned, the event handler is deleted by calling <code class="code">Module:terminate(remove_handler,State)</code>.</p> </li> </ul>  <h3 id="Module:handle_info-2" class="code">Module:handle_info(Info, State) -&gt; Result</h3>  <p>Types:</p>           <pre>Info = term()
State = term()
Result = {ok,NewState} | {ok,NewState,hibernate}
 | {swap_handler,Args1,NewState,Handler2,Args2} | remove_handler
 NewState = term()
 Args1 = Args2 = term()
 Handler2 = Module2 | {Module2,Id}
  Module2 = atom()
  Id = term()</pre>

<p>This function is called for each installed event handler when an event manager receives any other message than an event or a synchronous request (or a system message).</p> <p><code class="code">Info</code> is the received message.</p> <p>For a description of <code class="code">State</code> and possible return values, see <code class="bold_code"><a href="#Module:handle_event-2"><span class="code">Module:handle_event/2</span></a></code>.</p>  <h3 id="Module:init-1" class="code">Module:init(InitArgs) -&gt; {ok,State} | {ok,State,hibernate} | {error,Reason}</h3>  <p>Types:</p>      <pre>InitArgs = Args | {Args,Term}
 Args = Term = term()
State = term()
Reason = term()</pre>

<p>Whenever a new event handler is added to an event manager, this function is called to initialize the event handler.</p> <p>If the event handler is added because of a call to <code class="bold_code"><a href="#add_handler-3"><span class="code">add_handler/3</span></a></code> or <code class="bold_code"><a href="#add_sup_handler-3"><span class="code">add_sup_handler/3</span></a></code>, <code class="code">InitArgs</code> is the <code class="code">Args</code> argument of these functions.</p> <p>If the event handler replaces another event handler because of a call to <code class="bold_code"><a href="#swap_handler-3"><span class="code">swap_handler/3</span></a></code> or <code class="bold_code"><a href="#swap_sup_handler-3"><span class="code">swap_sup_handler/3</span></a></code>, or because of a <code class="code">swap</code> return tuple from one of the other callback functions, <code class="code">InitArgs</code> is a tuple <code class="code">{Args,Term}</code>, where <code class="code">Args</code> is the argument provided in the function call/return tuple and <code class="code">Term</code> is the result of terminating the old event handler, see <code class="bold_code"><a href="#swap_handler-3"><span class="code">swap_handler/3</span></a></code>.</p> <p>If successful, the function returns <code class="code">{ok,State}</code> or <code class="code">{ok,State,hibernate}</code>, where <code class="code">State</code> is the initial internal state of the event handler.</p> <p>If <code class="code">{ok,State,hibernate}</code> is returned, the event manager goes into hibernation (by calling <code class="bold_code"><a href="../proc_lib/#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></code>), waiting for the next event to occur.</p>  <h3 id="Module:terminate-2" class="code">Module:terminate(Arg, State) -&gt; term()</h3>  <p>Types:</p>     <pre>Arg = Args | {stop,Reason} | stop | remove_handler
 | {error,{'EXIT',Reason}} | {error,Term}
 Args = Reason = Term = term()</pre>

<p>Whenever an event handler is deleted from an event manager, this function is called. It is to be the opposite of <code class="bold_code"><a href="#Module:init-1"><span class="code">Module:init/1</span></a></code> and do any necessary cleaning up.</p> <p>If the event handler is deleted because of a call to <code class="bold_code"><a href="#delete_handler-3"><span class="code">delete_handler/3</span></a></code>, <code class="bold_code"><a href="#swap_handler-3"><span class="code">swap_handler/3</span></a></code>, or <code class="bold_code"><a href="#swap_sup_handler-3"><span class="code">swap_sup_handler/3</span></a></code>, <code class="code">Arg</code> is the <code class="code">Args</code> argument of this function call.</p> <p><code class="code">Arg={stop,Reason}</code> if the event handler has a supervised connection to a process that has terminated with reason <code class="code">Reason</code>.</p> <p><code class="code">Arg=stop</code> if the event handler is deleted because the event manager is terminating.</p> <p>The event manager terminates if it is part of a supervision tree and it is ordered by its supervisor to terminate. Even if it is <strong>not</strong> part of a supervision tree, it terminates if it receives an <code class="code">'EXIT'</code> message from its parent.</p> <p><code class="code">Arg=remove_handler</code> if the event handler is deleted because another callback function has returned <code class="code">remove_handler</code> or <code class="code">{remove_handler,Reply}</code>.</p> <p><code class="code">Arg={error,Term}</code> if the event handler is deleted because a callback function returned an unexpected value <code class="code">Term</code>, or <code class="code">Arg={error,{'EXIT',Reason}}</code> if a callback function failed.</p> <p><code class="code">State</code> is the internal state of the event handler.</p> <p>The function can return any term. If the event handler is deleted because of a call to <code class="code">gen_event:delete_handler/3</code>, the return value of that function becomes the return value of this function. If the event handler is to be replaced with another event handler because of a swap, the return value is passed to the <code class="code">init</code> function of the new event handler. Otherwise the return value is ignored.</p>  <h2 id="id213664">See Also</h2>  <p><code class="bold_code"><a href="../supervisor/"><span class="code">supervisor(3)</span></a></code>, <code class="bold_code"><a href="../sys/"><span class="code">sys(3)</span></a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
