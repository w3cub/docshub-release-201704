
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Supervisor - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" supervisor ">
  <meta name="keywords" content="supervisor, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/stdlib-3.3/doc/html/supervisor/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>supervisor</h1> <h2>Module</h2> <p class="REFBODY">supervisor</p> <h2>Module summary</h2> <p class="REFBODY">Generic supervisor behavior.</p> <h2>Description</h2> 
<p>This behavior module provides a supervisor, a process that supervises other processes called child processes. A child process can either be another supervisor or a worker process. Worker processes are normally implemented using one of the <code class="bold_code"><a href="../gen_event/"><span class="code">gen_event</span></a></code>, <code class="bold_code"><a href="../gen_fsm/"><span class="code">gen_fsm</span></a></code>, <code class="bold_code"><a href="../gen_server/"><span class="code">gen_server</span></a></code>, or <code class="bold_code"><a href="../gen_statem/"><span class="code">gen_statem</span></a></code> behaviors. A supervisor implemented using this module has a standard set of interface functions and include functionality for tracing and error reporting. Supervisors are used to build a hierarchical process structure called a supervision tree, a nice way to structure a fault-tolerant application. For more information, see <code class="bold_code">Supervisor Behaviour</code> in OTP Design Principles.</p> <p>A supervisor expects the definition of which child processes to supervise to be specified in a callback module exporting a predefined set of functions.</p> <p>Unless otherwise stated, all functions in this module fail if the specified supervisor does not exist or if bad arguments are specified.</p>  <h2 id="id270631"> Supervision Principles </h2>  <p>The supervisor is responsible for starting, stopping, and monitoring its child processes. The basic idea of a supervisor is that it must keep its child processes alive by restarting them when necessary.</p> <p>The children of a supervisor are defined as a list of <strong>child specifications</strong>. When the supervisor is started, the child processes are started in order from left to right according to this list. When the supervisor terminates, it first terminates its child processes in reversed start order, from right to left.</p>  <p>The supervisor properties are defined by the supervisor flags. The type definition for the supervisor flags is as follows:</p> <div class="example"><pre>
sup_flags() = #{strategy =&gt; strategy(),         % optional
                intensity =&gt; non_neg_integer(), % optional
                period =&gt; pos_integer()}        % optional</pre></div> <p>A supervisor can have one of the following <strong>restart strategies</strong> specified with the <code class="code">strategy</code> key in the above map:</p> <ul> <li> <p><code class="code">one_for_one</code> - If one child process terminates and is to be restarted, only that child process is affected. This is the default restart strategy.</p> </li> <li> <p><code class="code">one_for_all</code> - If one child process terminates and is to be restarted, all other child processes are terminated and then all child processes are restarted.</p> </li> <li> <p><code class="code">rest_for_one</code> - If one child process terminates and is to be restarted, the 'rest' of the child processes (that is, the child processes after the terminated child process in the start order) are terminated. Then the terminated child process and all child processes after it are restarted.</p> </li> <li> <p><code class="code">simple_one_for_one</code> - A simplified <code class="code">one_for_one</code> supervisor, where all child processes are dynamically added instances of the same process type, that is, running the same code.</p> <p>Functions <code class="bold_code"><a href="#delete_child-2"><span class="code">delete_child/2</span></a></code> and <code class="bold_code"><a href="#restart_child-2"><span class="code">restart_child/2</span></a></code> are invalid for <code class="code">simple_one_for_one</code> supervisors and return <code class="code">{error,simple_one_for_one}</code> if the specified supervisor uses this restart strategy.</p> <p>Function <code class="bold_code"><a href="#terminate_child-2"><span class="code">terminate_child/2</span></a></code> can be used for children under <code class="code">simple_one_for_one</code> supervisors by specifying the child's <code class="code">pid()</code> as the second argument. If instead the child specification identifier is used, <code class="code">terminate_child/2</code> return <code class="code">{error,simple_one_for_one}</code>.</p> <p>As a <code class="code">simple_one_for_one</code> supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</p> </li> </ul> <p>To prevent a supervisor from getting into an infinite loop of child process terminations and restarts, a <strong>maximum restart intensity</strong> is defined using two integer values specified with keys <code class="code">intensity</code> and <code class="code">period</code> in the above map. Assuming the values <code class="code">MaxR</code> for <code class="code">intensity</code> and <code class="code">MaxT</code> for <code class="code">period</code>, then, if more than <code class="code">MaxR</code> restarts occur within <code class="code">MaxT</code> seconds, the supervisor terminates all child processes and then itself. <code class="code">intensity</code> defaults to <code class="code">1</code> and <code class="code">period</code> defaults to <code class="code">5</code>.</p>  <p>The type definition of a child specification is as follows:</p> <div class="example"><pre>
child_spec() = #{id =&gt; child_id(),       % mandatory
                 start =&gt; mfargs(),      % mandatory
                 restart =&gt; restart(),   % optional
                 shutdown =&gt; shutdown(), % optional
                 type =&gt; worker(),       % optional
                 modules =&gt; modules()}   % optional</pre></div> <p>The old tuple format is kept for backwards compatibility, see <code class="bold_code"><a href="#type-child_spec">child_spec()</a></code>, but the map is preferred.</p> <ul> <li> <p><code class="code">id</code> is used to identify the child specification internally by the supervisor.</p> <p>The <code class="code">id</code> key is mandatory.</p> <p>Notice that this identifier on occations has been called "name". As far as possible, the terms "identifier" or "id" are now used but to keep backward compatibility, some occurences of "name" can still be found, for example in error messages.</p> </li> <li> <p><code class="code">start</code> defines the function call used to start the child process. It must be a module-function-arguments tuple <code class="code">{M,F,A}</code> used as <code class="code">apply(M,F,A)</code>.</p> <p>The start function <strong>must create and link to</strong> the child process, and must return <code class="code">{ok,Child}</code> or <code class="code">{ok,Child,Info}</code>, where <code class="code">Child</code> is the pid of the child process and <code class="code">Info</code> any term that is ignored by the supervisor.</p> <p>The start function can also return <code class="code">ignore</code> if the child process for some reason cannot be started, in which case the child specification is kept by the supervisor (unless it is a temporary child) but the non-existing child process is ignored.</p> <p>If something goes wrong, the function can also return an error tuple <code class="code">{error,Error}</code>.</p> <p>Notice that the <code class="code">start_link</code> functions of the different behavior modules fulfill the above requirements.</p> <p>The <code class="code">start</code> key is mandatory.</p> </li> <li> <p><code class="code">restart</code> defines when a terminated child process must be restarted. A <code class="code">permanent</code> child process is always restarted. A <code class="code">temporary</code> child process is never restarted (even when the supervisor's restart strategy is <code class="code">rest_for_one</code> or <code class="code">one_for_all</code> and a sibling's death causes the temporary process to be terminated). A <code class="code">transient</code> child process is restarted only if it terminates abnormally, that is, with another exit reason than <code class="code">normal</code>, <code class="code">shutdown</code>, or <code class="code">{shutdown,Term}</code>.</p> <p>The <code class="code">restart</code> key is optional. If it is not specified, it defaults to <code class="code">permanent</code>.</p> </li> <li> <p><code class="code">shutdown</code> defines how a child process must be terminated. <code class="code">brutal_kill</code> means that the child process is unconditionally terminated using <code class="code">exit(Child,kill)</code>. An integer time-out value means that the supervisor tells the child process to terminate by calling <code class="code">exit(Child,shutdown)</code> and then wait for an exit signal with reason <code class="code">shutdown</code> back from the child process. If no exit signal is received within the specified number of milliseconds, the child process is unconditionally terminated using <code class="code">exit(Child,kill)</code>.</p> <p>If the child process is another supervisor, the shutdown time is to be set to <code class="code">infinity</code> to give the subtree ample time to shut down. It is also allowed to set it to <code class="code">infinity</code>, if the child process is a worker.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Be careful when setting the shutdown time to <code class="code">infinity</code> when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</p> </div> </div> <p>Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</p> <p>The <code class="code">shutdown</code> key is optional. If it is not specified, it defaults to <code class="code">5000</code> if the child is of type <code class="code">worker</code> and it defaults to <code class="code">infinity</code> if the child is of type <code class="code">supervisor</code>.</p> </li> <li> <p><code class="code">type</code> specifies if the child process is a supervisor or a worker.</p> <p>The <code class="code">type</code> key is optional. If it is not specified, it defaults to <code class="code">worker</code>.</p> </li> <li> <p><code class="code">modules</code> is used by the release handler during code replacement to determine which processes are using a certain module. As a rule of thumb, if the child process is a <code class="code">supervisor</code>, <code class="code">gen_server</code>, <code class="code">gen_statem</code>, or <code class="code">gen_fsm</code>, this is to be a list with one element <code class="code">[Module]</code>, where <code class="code">Module</code> is the callback module. If the child process is an event manager (<code class="code">gen_event</code>) with a dynamic set of callback modules, value <code class="code">dynamic</code> must be used. For more information about release handling, see <code class="bold_code">Release Handling</code> in OTP Design Principles.</p> <p>The <code class="code">modules</code> key is optional. If it is not specified, it defaults to <code class="code">[M]</code>, where <code class="code">M</code> comes from the child's start <code class="code">{M,F,A}</code>.</p> </li> <li> <p>Internally, the supervisor also keeps track of the pid <code class="code">Child</code> of the child process, or <code class="code">undefined</code> if no pid exists.</p> </li> </ul>  <h2>Data types</h2> <h3 class="code">child() = undefined | pid()</h3> <h3 class="code">child_id() = term()</h3> 
<p>Not a <code class="code">pid()</code>.</p> <h3 class="code">child_spec() = <br>    #{id := <a href="#type-child_id">child_id()</a>,<br>      start := <a href="#type-mfargs">mfargs()</a>,<br>      restart =&gt; <a href="#type-restart">restart()</a>,<br>      shutdown =&gt; <a href="#type-shutdown">shutdown()</a>,<br>      type =&gt; <a href="#type-worker">worker()</a>,<br>      modules =&gt; <a href="#type-modules">modules()</a>} |<br>    {Id :: <a href="#type-child_id">child_id()</a>,<br>     StartFunc :: <a href="#type-mfargs">mfargs()</a>,<br>     Restart :: <a href="#type-restart">restart()</a>,<br>     Shutdown :: <a href="#type-shutdown">shutdown()</a>,<br>     Type :: <a href="#type-worker">worker()</a>,<br>     Modules :: <a href="#type-modules">modules()</a>}</h3> 
<p>The tuple format is kept for backward compatibility only. A map is preferred; see more details <code class="bold_code"><a href="#child_spec">above</a></code>.</p> <h3 class="code">mfargs() = <br>    {M :: module(), F :: atom(), A :: [term()] | undefined}</h3> 
<p>Value <code class="code">undefined</code> for <code class="code">A</code> (the argument list) is only to be used internally in <code class="code">supervisor</code>. If the restart type of the child is <code class="code">temporary</code>, the process is never to be restarted and therefore there is no need to store the real argument list. Value <code class="code">undefined</code> is then stored instead.</p>  <h3 class="code">modules() = [module()] | dynamic</h3> <h3 class="code">restart() = permanent | transient | temporary</h3> <h3 class="code">shutdown() = brutal_kill | timeout()</h3> <h3 class="code">strategy() = <br>    one_for_all | one_for_one | rest_for_one | simple_one_for_one</h3> <h3 class="code">sup_flags() = <br>    #{strategy =&gt; <a href="#type-strategy">strategy()</a>,<br>      intensity =&gt; integer() &gt;= 0,<br>      period =&gt; integer() &gt;= 1} |<br>    {RestartStrategy :: <a href="#type-strategy">strategy()</a>,<br>     Intensity :: integer() &gt;= 0,<br>     Period :: integer() &gt;= 1}</h3> 
<p>The tuple format is kept for backward compatibility only. A map is preferred; see more details <code class="bold_code"><a href="#sup_flags">above</a></code>.</p> <h3 class="code">sup_ref() = <br>    (Name :: atom()) |<br>    {Name :: atom(), Node :: node()} |<br>    {global, Name :: atom()} |<br>    {via, Module :: module(), Name :: any()} |<br>    pid()</h3> <h3 class="code">worker() = worker | supervisor</h3> <h2>Exports</h2> <h3 id="check_childspecs-1" class="code">check_childspecs(ChildSpecs) -&gt; Result</h3> <p>Types:</p>    <pre>ChildSpecs = [<a href="#type-child_spec">child_spec()</a>]
Result = ok | {error, Error :: term()}</pre>

<p>Takes a list of child specification as argument and returns <code class="code">ok</code> if all of them are syntactically correct, otherwise <code class="code">{error,Error}</code>.</p>  <h3 id="count_children-1" class="code">count_children(SupRef) -&gt; PropListOfCounts</h3> <p>Types:</p>     <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
PropListOfCounts = [Count]
Count = 
    {specs, ChildSpecCount :: integer() &gt;= 0} |
    {active, ActiveProcessCount :: integer() &gt;= 0} |
    {supervisors, ChildSupervisorCount :: integer() &gt;= 0} |
    {workers, ChildWorkerCount :: integer() &gt;= 0}</pre>

<p>Returns a property list (see <code class="bold_code"><a href="../proplists/"><span class="code">proplists</span></a></code>) containing the counts for each of the following elements of the supervisor's child specifications and managed processes:</p> <ul> <li> <p><code class="code">specs</code> - The total count of children, dead or alive.</p> </li> <li> <p><code class="code">active</code> - The count of all actively running child processes managed by this supervisor. For a <code class="code">simple_one_for_one</code> supervisors, no check is done to ensure that each child process is still alive, although the result provided here is likely to be very accurate unless the supervisor is heavily overloaded.</p> </li> <li> <p><code class="code">supervisors</code> - The count of all children marked as <code class="code">child_type = supervisor</code> in the specification list, regardless if the child process is still alive.</p> </li> <li> <p><code class="code">workers</code> - The count of all children marked as <code class="code">child_type = worker</code> in the specification list, regardless if the child process is still alive.</p> </li> </ul> <p>For a description of <code class="code">SupRef</code>, see <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code>.</p>  <h3 id="delete_child-2" class="code">delete_child(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = <a href="#type-child_id">child_id()</a>
Result = ok | {error, Error}
Error = running | restarting | not_found | simple_one_for_one</pre>

<p>Tells supervisor <code class="code">SupRef</code> to delete the child specification identified by <code class="code">Id</code>. The corresponding child process must not be running. Use <code class="bold_code"><a href="#terminate_child-2"><span class="code">terminate_child/2</span></a></code> to terminate it.</p> <p>For a description of <code class="code">SupRef</code>, see <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code>.</p> <p>If successful, the function returns <code class="code">ok</code>. If the child specification identified by <code class="code">Id</code> exists but the corresponding child process is running or is about to be restarted, the function returns <code class="code">{error,running}</code> or <code class="code">{error,restarting}</code>, respectively. If the child specification identified by <code class="code">Id</code> does not exist, the function returns <code class="code">{error,not_found}</code>.</p>  <h3 id="get_childspec-2" class="code">get_childspec(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = pid() | <a href="#type-child_id">child_id()</a>
Result = {ok, <a href="#type-child_spec">child_spec()</a>} | {error, Error}
Error = not_found</pre>

<p>Returns the child specification map for the child identified by <code class="code">Id</code> under supervisor <code class="code">SupRef</code>. The returned map contains all keys, both mandatory and optional.</p> <p>For a description of <code class="code">SupRef</code>, see <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code>.</p>  <h3 id="restart_child-2" class="code">restart_child(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = <a href="#type-child_id">child_id()</a>
Result = 
    {ok, Child :: <a href="#type-child">child()</a>} |
    {ok, Child :: <a href="#type-child">child()</a>, Info :: term()} |
    {error, Error}
Error = 
    running | restarting | not_found | simple_one_for_one | term()</pre>

<p>Tells supervisor <code class="code">SupRef</code> to restart a child process corresponding to the child specification identified by <code class="code">Id</code>. The child specification must exist, and the corresponding child process must not be running.</p> <p>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</p> <p>For a description of <code class="code">SupRef</code>, see <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code>.</p> <p>If the child specification identified by <code class="code">Id</code> does not exist, the function returns <code class="code">{error,not_found}</code>. If the child specification exists but the corresponding process is already running, the function returns <code class="code">{error,running}</code>.</p> <p>If the child process start function returns <code class="code">{ok,Child}</code> or <code class="code">{ok,Child,Info}</code>, the pid is added to the supervisor and the function returns the same value.</p> <p>If the child process start function returns <code class="code">ignore</code>, the pid remains set to <code class="code">undefined</code> and the function returns <code class="code">{ok,undefined}</code>.</p> <p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the function returns <code class="code">{error,Error}</code>, where <code class="code">Error</code> is a term containing information about the error.</p>  <h3 id="start_child-2" class="code">start_child(SupRef, ChildSpec) -&gt; startchild_ret()</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
ChildSpec = <a href="#type-child_spec">child_spec()</a> | (List :: [term()])
startchild_ret() = 
    {ok, Child :: <a href="#type-child">child()</a>} |
    {ok, Child :: <a href="#type-child">child()</a>, Info :: term()} |
    {error, startchild_err()}
startchild_err() = 
    already_present | {already_started, Child :: <a href="#type-child">child()</a>} | term()</pre>

<p>Dynamically adds a child specification to supervisor <code class="code">SupRef</code>, which starts the corresponding child process.</p> <p id="SupRef"><code class="code">SupRef</code> can be any of the following:</p> <ul> <li>The pid</li> <li> <code class="code">Name</code>, if the supervisor is locally registered</li> <li> <code class="code">{Name,Node}</code>, if the supervisor is locally registered at another node</li> <li> <code class="code">{global,Name}</code>, if the supervisor is globally registered</li> <li> <code class="code">{via,Module,Name}</code>, if the supervisor is registered through an alternative process registry</li> </ul> <p><code class="code">ChildSpec</code> must be a valid child specification (unless the supervisor is a <code class="code">simple_one_for_one</code> supervisor; see below). The child process is started by using the start function as defined in the child specification.</p> <p>For a <code class="code">simple_one_for_one</code> supervisor, the child specification defined in <code class="code">Module:init/1</code> is used, and <code class="code">ChildSpec</code> must instead be an arbitrary list of terms <code class="code">List</code>. The child process is then started by appending <code class="code">List</code> to the existing start function arguments, that is, by calling <code class="code">apply(M, F, A++List)</code>, where <code class="code">{M,F,A}</code> is the start function defined in the child specification.</p> <ul> <li> <p>If there already exists a child specification with the specified identifier, <code class="code">ChildSpec</code> is discarded, and the function returns <code class="code">{error,already_present}</code> or <code class="code">{error,{already_started,Child}}</code>, depending on if the corresponding child process is running or not.</p> </li> <li> <p>If the child process start function returns <code class="code">{ok,Child}</code> or <code class="code">{ok,Child,Info}</code>, the child specification and pid are added to the supervisor and the function returns the same value.</p> </li> <li> <p>If the child process start function returns <code class="code">ignore</code>, the child specification is added to the supervisor (unless the supervisor is a <code class="code">simple_one_for_one</code> supervisor, see below), the pid is set to <code class="code">undefined</code>, and the function returns <code class="code">{ok,undefined}</code>.</p> </li> </ul> <p>For a <code class="code">simple_one_for_one</code> supervisor, when a child process start function returns <code class="code">ignore</code>, the functions returns <code class="code">{ok,undefined}</code> and no child is added to the supervisor.</p> <p>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded, and the function returns <code class="code">{error,Error}</code>, where <code class="code">Error</code> is a term containing information about the error and child specification.</p>  <h3 id="start_link-3" class="code">start_link(Module, Args) -&gt; startlink_ret()<br>start_link(SupName, Module, Args) -&gt; startlink_ret()</h3> <p>Types:</p>        <pre>SupName = sup_name()
Module = module()
Args = term()
startlink_ret() = 
    {ok, pid()} | ignore | {error, startlink_err()}
startlink_err() = 
    {already_started, pid()} | {shutdown, term()} | term()
sup_name() = 
    {local, Name :: atom()} |
    {global, Name :: atom()} |
    {via, Module :: module(), Name :: any()}</pre>

<p>Creates a supervisor process as part of a supervision tree. For example, the function ensures that the supervisor is linked to the calling process (its supervisor).</p> <p>The created supervisor process calls <code class="code">Module:init/1</code> to find out about restart strategy, maximum restart intensity, and child processes. To ensure a synchronized startup procedure, <code class="code">start_link/2,3</code> does not return until <code class="code">Module:init/1</code> has returned and all child processes have been started.</p> <ul> <li> <p>If <code class="code">SupName={local,Name}</code>, the supervisor is registered locally as <code class="code">Name</code> using <code class="code">register/2</code>.</p> </li> <li> <p>If <code class="code">SupName={global,Name}</code>, the supervisor is registered globally as <code class="code">Name</code> using <code class="bold_code"><span class="code">global:register_name/2</span></code>.</p> </li> <li> <p>If <code class="code">SupName={via,Module,Name}</code>, the supervisor is registered as <code class="code">Name</code> using the registry represented by <code class="code">Module</code>. The <code class="code">Module</code> callback must export the functions <code class="code">register_name/2</code>, <code class="code">unregister_name/1</code>, and <code class="code">send/2</code>, which must behave like the corresponding functions in <code class="bold_code"><span class="code">global</span></code>. Thus, <code class="code">{via,global,Name}</code> is a valid reference.</p> </li> </ul> <p>If no name is provided, the supervisor is not registered.</p> <p><code class="code">Module</code> is the name of the callback module.</p> <p><code class="code">Args</code> is any term that is passed as the argument to <code class="code">Module:init/1</code>.</p> <ul> <li> <p>If the supervisor and its child processes are successfully created (that is, if all child process start functions return <code class="code">{ok,Child}</code>, <code class="code">{ok,Child,Info}</code>, or <code class="code">ignore</code>), the function returns <code class="code">{ok,Pid}</code>, where <code class="code">Pid</code> is the pid of the supervisor.</p> </li> <li> <p>If there already exists a process with the specified <code class="code">SupName</code>, the function returns <code class="code">{error,{already_started,Pid}}</code>, where <code class="code">Pid</code> is the pid of that process.</p> </li> <li> <p>If <code class="code">Module:init/1</code> returns <code class="code">ignore</code>, this function returns <code class="code">ignore</code> as well, and the supervisor terminates with reason <code class="code">normal</code>.</p> </li> <li> <p>If <code class="code">Module:init/1</code> fails or returns an incorrect value, this function returns <code class="code">{error,Term}</code>, where <code class="code">Term</code> is a term with information about the error, and the supervisor terminates with reason <code class="code">Term</code>.</p> </li> <li> <p>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason <code class="code">shutdown</code> and then terminate itself and returns <code class="code">{error, {shutdown, Reason}}</code>.</p> </li> </ul>  <h3 id="terminate_child-2" class="code">terminate_child(SupRef, Id) -&gt; Result</h3> <p>Types:</p>      <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = pid() | <a href="#type-child_id">child_id()</a>
Result = ok | {error, Error}
Error = not_found | simple_one_for_one</pre>

<p>Tells supervisor <code class="code">SupRef</code> to terminate the specified child.</p> <p>If the supervisor is not <code class="code">simple_one_for_one</code>, <code class="code">Id</code> must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling <code class="bold_code"><a href="#restart_child-2"><span class="code">restart_child/2</span></a></code>. Use <code class="bold_code"><a href="#delete_child-2"><span class="code">delete_child/2</span></a></code> to remove the child specification.</p> <p>If the child is temporary, the child specification is deleted as soon as the process terminates. This means that <code class="code">delete_child/2</code> has no meaning and <code class="code">restart_child/2</code> cannot be used for these children.</p> <p>If the supervisor is <code class="code">simple_one_for_one</code>, <code class="code">Id</code> must be the <code class="code">pid()</code> of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns <code class="code">{error,not_found}</code>. If the child specification identifier is specified instead of a <code class="code">pid()</code>, the function returns <code class="code">{error,simple_one_for_one}</code>.</p> <p>If successful, the function returns <code class="code">ok</code>. If there is no child specification with the specified <code class="code">Id</code>, the function returns <code class="code">{error,not_found}</code>.</p> <p>For a description of <code class="code">SupRef</code>, see <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code>.</p>  <h3 id="which_children-1" class="code">which_children(SupRef) -&gt; [{Id, Child, Type, Modules}]</h3> <p>Types:</p>       <pre>SupRef = <a href="#type-sup_ref">sup_ref()</a>
Id = <a href="#type-child_id">child_id()</a> | undefined
Child = <a href="#type-child">child()</a> | restarting
Type = <a href="#type-worker">worker()</a>
Modules = <a href="#type-modules">modules()</a></pre>

<p>Returns a newly created list with information about all child specifications and child processes belonging to supervisor <code class="code">SupRef</code>.</p> <p>Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception.</p> <p>For a description of <code class="code">SupRef</code>, see <code class="bold_code"><a href="#SupRef"><span class="code">start_child/2</span></a></code>.</p> <p>The following information is given for each child specification/process:</p> <ul> <li> <p><code class="code">Id</code> - As defined in the child specification or <code class="code">undefined</code> for a <code class="code">simple_one_for_one</code> supervisor.</p> </li> <li> <p><code class="code">Child</code> - The pid of the corresponding child process, the atom <code class="code">restarting</code> if the process is about to be restarted, or <code class="code">undefined</code> if there is no such process.</p> </li> <li> <p><code class="code">Type</code> - As defined in the child specification.</p> </li> <li> <p><code class="code">Modules</code> - As defined in the child specification.</p> </li> </ul>  <h2 id="id272618">Callback Functions</h2>  <p>The following function must be exported from a <code class="code">supervisor</code> callback module.</p>  <h2>Exports</h2> <h3 id="Module:init-1" class="code">Module:init(Args) -&gt; Result</h3>  <p>Types:</p>      <pre>Args = term()
Result = {ok,{SupFlags,[ChildSpec]}} | ignore
 SupFlags = <a href="#type-sup_flags">sup_flags()</a>
 ChildSpec = <a href="#type-child_spec">child_spec()</a></pre>

<p>Whenever a supervisor is started using <code class="bold_code"><a href="#start_link-2"><span class="code">start_link/2,3</span></a></code>, this function is called by the new process to find out about restart strategy, maximum restart intensity, and child specifications.</p> <p><code class="code">Args</code> is the <code class="code">Args</code> argument provided to the start function.</p> <p><code class="code">SupFlags</code> is the supervisor flags defining the restart strategy and maximum restart intensity for the supervisor. <code class="code">[ChildSpec]</code> is a list of valid child specifications defining which child processes the supervisor must start and monitor. See the discussion in section <code class="bold_code"><a href="#supervision_princ"><span class="code">Supervision Principles</span></a></code> earlier.</p> <p>Notice that when the restart strategy is <code class="code">simple_one_for_one</code>, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using <code class="bold_code"><a href="#start_child-2"><span class="code">start_child/2</span></a></code>.</p> <p>The function can also return <code class="code">ignore</code>.</p> <p>Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section <code class="bold_code">Changing a Supervisor</code> in OTP Design Principles.</p>  <h2 id="id272762">See Also</h2>  <p><code class="bold_code"><a href="../gen_event/"><span class="code">gen_event(3)</span></a></code>, <code class="bold_code"><a href="../gen_fsm/"><span class="code">gen_fsm(3)</span></a></code>, <code class="bold_code"><a href="../gen_statem/"><span class="code">gen_statem(3)</span></a></code>, <code class="bold_code"><a href="../gen_server/"><span class="code">gen_server(3)</span></a></code>, <code class="bold_code"><a href="../sys/"><span class="code">sys(3)</span></a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
