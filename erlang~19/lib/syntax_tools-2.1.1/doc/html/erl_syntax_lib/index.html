
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erl_syntax_lib - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" erl_syntax_lib ">
  <meta name="keywords" content="erl, syntax, lib, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/syntax_tools-2.1.1/doc/html/erl_syntax_lib/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erl_syntax_lib</h1> <h2>Module</h2> <p class="REFBODY">erl_syntax_lib</p> <h2>Module summary</h2> <p class="REFBODY">Support library for abstract Erlang syntax trees.</p> <h2>Description</h2> 
<p>Support library for abstract Erlang syntax trees.</p> <p>This module contains utility functions for working with the abstract data type defined in the module <code class="bold_code"><a href="../erl_syntax/">erl_syntax</a></code>. </p> <h2 id="id113822">Data types</h2>   <dl> <dt><strong id="type-info_pair">info_pair() = {<code class="bold_code"><a href="#type-key">key()</a></code>, term()}</strong></dt>  <dt><strong id="type-key">key() = attributes | errors | exports | functions | imports | module | records | warnings</strong></dt>  <dt><strong id="type-ordset">ordset(T) = <code class="bold_code">ordsets:ordset(T)</code></strong></dt>  <dt><strong id="type-set">set(T) = <code class="bold_code">sets:set(T)</code></strong></dt>  <dt><strong id="type-syntaxTree">syntaxTree() = <code class="bold_code"><a href="../erl_syntax/#type-syntaxTree">erl_syntax:syntaxTree()</a></code></strong></dt> <dd>  <p>An abstract syntax tree. See the <code class="bold_code"><a href="../erl_syntax/">erl_syntax</a></code> module for details.</p> </dd> </dl>  <h2>Exports</h2> <h3 id="analyze_application-1" class="code">analyze_application(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; FunctionName | Arity</h3>  <p>Types:</p>     <pre>FunctionName = {atom(), Arity} | {ModuleName, FunctionName}
Arity = integer()
ModuleName = atom()</pre>

<p>Returns the name of a called function. The result is a representation of the name of the applied function <code class="code">F/A</code>, if <code class="code">Node</code> represents a function application "<code class="code">&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;X_1&lt;/em&gt;, ..., &lt;em&gt;X_A&lt;/em&gt;)</code>". If the function is not explicitly named (i.e., <code class="code">F</code> is given by some expression), only the arity <code class="code">A</code> is returned.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed application expression. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_function_name-1">analyze_function_name/1</a></code>.</p>  <h3 id="analyze_attribute-1" class="code">analyze_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; preprocessor | {atom(), atom()}</h3> 
<p>Analyzes an attribute node. If <code class="code">Node</code> represents a preprocessor directive, the atom <code class="code">preprocessor</code> is returned. Otherwise, if <code class="code">Node</code> represents a module attribute "<code class="code">-&lt;em&gt;Name&lt;/em&gt;...</code>", a tuple <code class="code">{Name, Info}</code> is returned, where <code class="code">Info</code> depends on <code class="code">Name</code>, as follows: </p>
<dl> <dt><strong><code class="code">{module, Info}</code></strong></dt> <dd><p>where <code class="code">Info = analyze_module_attribute(Node)</code>.</p></dd> <dt><strong><code class="code">{export, Info}</code></strong></dt> <dd><p>where <code class="code">Info = analyze_export_attribute(Node)</code>.</p></dd> <dt><strong><code class="code">{import, Info}</code></strong></dt> <dd><p>where <code class="code">Info = analyze_import_attribute(Node)</code>.</p></dd> <dt><strong><code class="code">{file, Info}</code></strong></dt> <dd><p>where <code class="code">Info = analyze_file_attribute(Node)</code>.</p></dd> <dt><strong><code class="code">{record, Info}</code></strong></dt> <dd><p>where <code class="code">Info = analyze_record_attribute(Node)</code>.</p></dd> <dt><strong><code class="code">{Name, Info}</code></strong></dt> <dd><p>where <code class="code">{Name, Info} = analyze_wild_attribute(Node)</code>.</p></dd> </dl>
<p> The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed module attribute. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_export_attribute-1">analyze_export_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_file_attribute-1">analyze_file_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_import_attribute-1">analyze_import_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_module_attribute-1">analyze_module_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_wild_attribute-1">analyze_wild_attribute/1</a></code>.</p>  <h3 id="analyze_export_attribute-1" class="code">analyze_export_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [FunctionName]</h3>  <p>Types:</p>    <pre>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}
ModuleName = atom()</pre>

<p>Returns the list of function names declared by an export attribute. We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed export attribute. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p>  <h3 id="analyze_file_attribute-1" class="code">analyze_file_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {string(), integer()}</h3> 
<p>Returns the file name and line number of a <code class="code">file</code> attribute. The result is the pair <code class="code">{File, Line}</code> if <code class="code">Node</code> represents "<code class="code">-file(File, Line).</code>".</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed <code class="code">file</code> attribute. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p>  <h3 id="analyze_form-1" class="code">analyze_form(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {atom(), term()} | atom()</h3> 
<p>Analyzes a "source code form" node. If <code class="code">Node</code> is a "form" type (cf. <code class="code">erl_syntax:is_form/1</code>), the returned value is a tuple <code class="code">{Type, Info}</code> where <code class="code">Type</code> is the node type and <code class="code">Info</code> depends on <code class="code">Type</code>, as follows: </p>
<dl> <dt><strong><code class="code">{attribute, Info}</code></strong></dt> <dd><p>where <code class="code">Info = analyze_attribute(Node)</code>.</p></dd> <dt><strong><code class="code">{error_marker, Info}</code></strong></dt> <dd><p>where <code class="code">Info = erl_syntax:error_marker_info(Node)</code>.</p></dd> <dt><strong><code class="code">{function, Info}</code></strong></dt> <dd><p>where <code class="code">Info = analyze_function(Node)</code>.</p></dd> <dt><strong><code class="code">{warning_marker, Info}</code></strong></dt> <dd><p>where <code class="code">Info = erl_syntax:warning_marker_info(Node)</code>.</p></dd> </dl>
<p> For other types of forms, only the node type is returned.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> is not well-formed. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_attribute-1">analyze_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_function-1">analyze_function/1</a></code>, <code class="bold_code"><a href="../erl_syntax/#error_marker_info-1">erl_syntax:error_marker_info/1</a></code>, <code class="bold_code"><a href="../erl_syntax/#is_form-1">erl_syntax:is_form/1</a></code>, <code class="bold_code"><a href="../erl_syntax/#warning_marker_info-1">erl_syntax:warning_marker_info/1</a></code>.</p>  <h3 id="analyze_forms-1" class="code">analyze_forms(Forms) -&gt; [{Key, term()}]</h3>  <p>Types:</p>    <pre>Forms = <a href="#type-syntaxTree">syntaxTree()</a> | [<a href="#type-syntaxTree">syntaxTree()</a>]
Key = attributes | errors | exports | functions | imports | module | records | warnings</pre>

<p>Analyzes a sequence of "program forms". The given <code class="code">Forms</code> may be a single syntax tree of type <code class="code">form_list</code>, or a list of "program form" syntax trees. The returned value is a list of pairs <code class="code">{Key, Info}</code>, where each value of <code class="code">Key</code> occurs at most once in the list; the absence of a particular key indicates that there is no well-defined value for that key.</p> <p>Each entry in the resulting list contains the following corresponding information about the program forms: </p>
<dl> <dt><strong><code class="code">{attributes, Attributes}</code></strong></dt> <dd> <ul> <li><p><code class="code">Attributes = [{atom(), term()}]</code></p></li> </ul> <p> <code class="code">Attributes</code> is a list of pairs representing the names and corresponding values of all so-called "wild" attributes (as e.g. "<code class="code">-compile(...)</code>") occurring in <code class="code">Forms</code> (cf. <code class="code">analyze_wild_attribute/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt><strong><code class="code">{errors, Errors}</code></strong></dt> <dd> <ul> <li><p><code class="code">Errors = [term()]</code></p></li> </ul> <p> <code class="code">Errors</code> is the list of error descriptors of all <code class="code">error_marker</code> nodes that occur in <code class="code">Forms</code>. The order of listing is not defined.</p> </dd> <dt><strong><code class="code">{exports, Exports}</code></strong></dt> <dd> <ul> <li><p><code class="code">Exports = [FunctionName]</code></p></li> <li><p><code class="code">FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</code></p></li> <li><p><code class="code">ModuleName = atom()</code></p></li> </ul> <p> <code class="code">Exports</code> is a list of representations of those function names that are listed by export declaration attributes in <code class="code">Forms</code> (cf. <code class="code">analyze_export_attribute/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt><strong><code class="code">{functions, Functions}</code></strong></dt> <dd> <ul> <li><p><code class="code">Functions = [{atom(), integer()}]</code></p></li> </ul> <p> <code class="code">Functions</code> is a list of the names of the functions that are defined in <code class="code">Forms</code> (cf. <code class="code">analyze_function/1</code>). We do not guarantee that each name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt><strong><code class="code">{imports, Imports}</code></strong></dt> <dd> <ul> <li><p><code class="code">Imports = [{Module, Names}]</code></p></li> <li><p><code class="code">Module = atom()</code></p></li> <li><p><code class="code">Names = [FunctionName]</code></p></li> <li><p><code class="code">FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</code></p></li> <li><p><code class="code">ModuleName = atom()</code></p></li> </ul> <p> <code class="code">Imports</code> is a list of pairs representing those module names and corresponding function names that are listed by import declaration attributes in <code class="code">Forms</code> (cf. <code class="code">analyze_import_attribute/1</code>), where each <code class="code">Module</code> occurs at most once in <code class="code">Imports</code>. We do not guarantee that each name occurs at most once in the lists of function names. The order of listing is not defined.</p> </dd> <dt><strong><code class="code">{module, ModuleName}</code></strong></dt> <dd> <ul> <li><p><code class="code">ModuleName = atom()</code></p></li> </ul> <p> <code class="code">ModuleName</code> is the name declared by a module attribute in <code class="code">Forms</code>. If no module name is defined in <code class="code">Forms</code>, the result will contain no entry for the <code class="code">module</code> key. If multiple module name declarations should occur, all but the first will be ignored.</p> </dd> <dt><strong><code class="code">{records, Records}</code></strong></dt> <dd> <ul> <li><p><code class="code">Records = [{atom(), Fields}]</code></p></li> <li><p><code class="code">Fields = [{atom(), {Default, Type}}]</code></p></li> <li><p><code class="code">Default = none | syntaxTree()</code></p></li> <li><p><code class="code">Type = none | syntaxTree()</code></p></li> </ul> <p> <code class="code">Records</code> is a list of pairs representing the names and corresponding field declarations of all record declaration attributes occurring in <code class="code">Forms</code>. For fields declared without a default value, the corresponding value for <code class="code">Default</code> is the atom <code class="code">none</code>. Similarly, for fields declared without a type, the corresponding value for <code class="code">Type</code> is the atom <code class="code">none</code> (cf. <code class="code">analyze_record_attribute/1</code>). We do not guarantee that each record name occurs at most once in the list. The order of listing is not defined.</p> </dd> <dt><strong><code class="code">{warnings, Warnings}</code></strong></dt> <dd> <ul> <li><p><code class="code">Warnings = [term()]</code></p></li> </ul> <p> <code class="code">Warnings</code> is the list of error descriptors of all <code class="code">warning_marker</code> nodes that occur in <code class="code">Forms</code>. The order of listing is not defined.</p> </dd> </dl> <p>The evaluation throws <code class="code">syntax_error</code> if an ill-formed Erlang construct is encountered. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_export_attribute-1">analyze_export_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_function-1">analyze_function/1</a></code>, <code class="bold_code"><a href="#analyze_import_attribute-1">analyze_import_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_wild_attribute-1">analyze_wild_attribute/1</a></code>, <code class="bold_code"><a href="../erl_syntax/#error_marker_info-1">erl_syntax:error_marker_info/1</a></code>, <code class="bold_code"><a href="../erl_syntax/#warning_marker_info-1">erl_syntax:warning_marker_info/1</a></code>.</p>  <h3 id="analyze_function-1" class="code">analyze_function(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {atom(), integer()}</h3> 
<p>Returns the name and arity of a function definition. The result is a pair <code class="code">{Name, A}</code> if <code class="code">Node</code> represents a function definition "<code class="code">Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) -&gt; ...</code>".</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed function definition.</p>  <h3 id="analyze_function_name-1" class="code">analyze_function_name(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; FunctionName</h3>  <p>Types:</p>    <pre>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}
ModuleName = atom()</pre>

<p>Returns the function name represented by a syntax tree. If <code class="code">Node</code> represents a function name, such as "<code class="code">foo/1</code>" or "<code class="code">bloggs:fred/2</code>", a uniform representation of that name is returned. Different nestings of arity and module name qualifiers in the syntax tree does not affect the result.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed function name.</p>  <h3 id="analyze_implicit_fun-1" class="code">analyze_implicit_fun(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; FunctionName</h3>  <p>Types:</p>    <pre>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}
ModuleName = atom()</pre>

<p>Returns the name of an implicit fun expression "<code class="code">fun &lt;em&gt;F&lt;/em&gt;</code>". The result is a representation of the function name <code class="code">F</code>. (Cf. <code class="code">analyze_function_name/1</code>.)</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed implicit fun. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_function_name-1">analyze_function_name/1</a></code>.</p>  <h3 id="analyze_import_attribute-1" class="code">analyze_import_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {atom(), [FunctionName]} | atom()</h3>  <p>Types:</p>    <pre>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}
ModuleName = atom()</pre>

<p>Returns the module name and (if present) list of function names declared by an import attribute. The returned value is an atom <code class="code">Module</code> or a pair <code class="code">{Module, Names}</code>, where <code class="code">Names</code> is a list of function names declared as imported from the module named by <code class="code">Module</code>. We do not guarantee that each name occurs at most once in <code class="code">Names</code>. The order of listing is not defined.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed import attribute. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p>  <h3 id="analyze_module_attribute-1" class="code">analyze_module_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; Name::atom() | {Name::atom(), Variables::[atom()]}</h3> 
<p>Returns the module name and possible parameters declared by a module attribute. If the attribute is a plain module declaration such as <code class="code">-module(name)</code>, the result is the module name. If the attribute is a parameterized module declaration, the result is a tuple containing the module name and a list of the parameter variable names.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed module attribute. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p>  <h3 id="analyze_record_attribute-1" class="code">analyze_record_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {atom(), Fields}</h3>  <p>Types:</p>     <pre>Fields = [{atom(), {Default, Type}}]
Default = none | <a href="#type-syntaxTree">syntaxTree()</a>
Type = none | <a href="#type-syntaxTree">syntaxTree()</a></pre>

<p>Returns the name and the list of fields of a record declaration attribute. The result is a pair <code class="code">{Name, Fields}</code>, if <code class="code">Node</code> represents "<code class="code">-record(Name, {...}).</code>", where <code class="code">Fields</code> is a list of pairs <code class="code">{Label, {Default, Type}}</code> for each field "<code class="code">Label</code>", "<code class="code">Label = &lt;em&gt;Default&lt;/em&gt;</code>", "<code class="code">Label :: &lt;em&gt;Type&lt;/em&gt;</code>", or "<code class="code">Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</code>" in the declaration, listed in left-to-right order. If the field has no default-value declaration, the value for <code class="code">Default</code> will be the atom <code class="code">none</code>. If the field has no type declaration, the value for <code class="code">Type</code> will be the atom <code class="code">none</code>. We do not guarantee that each label occurs at most once in the list.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed record declaration attribute. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_attribute-1">analyze_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_record_field-1">analyze_record_field/1</a></code>.</p>  <h3 id="analyze_record_expr-1" class="code">analyze_record_expr(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {atom(), Info} | atom()</h3>  <p>Types:</p>    <pre>Info = {atom(), [{atom(), Value}]} | {atom(), atom()} | atom()
Value = <a href="#type-syntaxTree">syntaxTree()</a></pre>

<p>Returns the record name and field name/names of a record expression. If <code class="code">Node</code> has type <code class="code">record_expr</code>, <code class="code">record_index_expr</code> or <code class="code">record_access</code>, a pair <code class="code">{Type, Info}</code> is returned, otherwise an atom <code class="code">Type</code> is returned. <code class="code">Type</code> is the node type of <code class="code">Node</code>, and <code class="code">Info</code> depends on <code class="code">Type</code>, as follows: </p>
<dl> <dt><strong><code class="code">record_expr</code>:</strong></dt> <dd><p><code class="code">{atom(), [{atom(), Value}]}</code></p></dd> <dt><strong><code class="code">record_access</code>:</strong></dt> <dd><p><code class="code">{atom(), atom()}</code></p></dd> <dt><strong><code class="code">record_index_expr</code>:</strong></dt> <dd><p><code class="code">{atom(), atom()}</code></p></dd> </dl>

<p>For a <code class="code">record_expr</code> node, <code class="code">Info</code> represents the record name and the list of descriptors for the involved fields, listed in the order they appear. A field descriptor is a pair <code class="code">{Label, Value}</code>, if <code class="code">Node</code> represents "<code class="code">Label = &lt;em&gt;Value&lt;/em&gt;</code>". For a <code class="code">record_access</code> node, <code class="code">Info</code> represents the record name and the field name. For a <code class="code">record_index_expr</code> node, <code class="code">Info</code> represents the record name and the name field name.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> represents a record expression that is not well-formed. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_record_field-1">analyze_record_field/1</a></code>.</p>  <h3 id="analyze_record_field-1" class="code">analyze_record_field(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {atom(), {Default, Type}}</h3>  <p>Types:</p>    <pre>Default = none | <a href="#type-syntaxTree">syntaxTree()</a>
Type = none | <a href="#type-syntaxTree">syntaxTree()</a></pre>

<p>Returns the label, value-expression, and type of a record field specifier. The result is a pair <code class="code">{Label, {Default, Type}}</code>, if <code class="code">Node</code> represents "<code class="code">Label</code>", "<code class="code">Label = &lt;em&gt;Default&lt;/em&gt;</code>", "<code class="code">Label :: &lt;em&gt;Type&lt;/em&gt;</code>", or "<code class="code">Label = &lt;em&gt;Default&lt;/em&gt; :: &lt;em&gt;Type&lt;/em&gt;</code>". If the field has no value-expression, the value for <code class="code">Default</code> will be the atom <code class="code">none</code>. If the field has no type, the value for <code class="code">Type</code> will be the atom <code class="code">none</code>.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed record field specifier. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_record_attribute-1">analyze_record_attribute/1</a></code>, <code class="bold_code"><a href="#analyze_record_expr-1">analyze_record_expr/1</a></code>.</p>  <h3 id="analyze_type_application-1" class="code">analyze_type_application(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; TypeName</h3>  <p>Types:</p>    <pre>TypeName = {atom(), integer()} | {ModuleName, {atom(), integer()}}
ModuleName = atom()</pre>

<p>Returns the name of a used type. The result is a representation of the name of the used pre-defined or local type <code class="code">N/A</code>, if <code class="code">Node</code> represents a local (user) type application "<code class="code">&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</code>", or a representation of the name of the used remote type <code class="code">M:N/A</code> if <code class="code">Node</code> represents a remote user type application "<code class="code">&lt;em&gt;M&lt;/em&gt;:&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T_1&lt;/em&gt;, ..., &lt;em&gt;T_A&lt;/em&gt;)</code>".</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed (user) type application expression. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_type_name-1">analyze_type_name/1</a></code>.</p>  <h3 id="analyze_type_name-1" class="code">analyze_type_name(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; TypeName</h3>  <p>Types:</p>    <pre>TypeName = atom() | {atom(), integer()} | {ModuleName, {atom(), integer()}}
ModuleName = atom()</pre>

<p>Returns the type name represented by a syntax tree. If <code class="code">Node</code> represents a type name, such as "<code class="code">foo/1</code>" or "<code class="code">bloggs:fred/2</code>", a uniform representation of that name is returned.</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed type name.</p>  <h3 id="analyze_wild_attribute-1" class="code">analyze_wild_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {atom(), term()}</h3> 
<p>Returns the name and value of a "wild" attribute. The result is the pair <code class="code">{Name, Value}</code>, if <code class="code">Node</code> represents "<code class="code">-Name(Value)</code>".</p> <p>Note that no checking is done whether <code class="code">Name</code> is a reserved attribute name such as <code class="code">module</code> or <code class="code">export</code>: it is assumed that the attribute is "wild".</p> <p>The evaluation throws <code class="code">syntax_error</code> if <code class="code">Node</code> does not represent a well-formed wild attribute. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_attribute-1">analyze_attribute/1</a></code>.</p>  <h3 id="annotate_bindings-1" class="code">annotate_bindings(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3> 
<p>Adds or updates annotations on nodes in a syntax tree. Equivalent to <code class="code">annotate_bindings(Tree, Bindings)</code> where the top-level environment <code class="code">Bindings</code> is taken from the annotation <code class="code">{env, Bindings}</code> on the root node of <code class="code">Tree</code>. An exception is thrown if no such annotation should exist. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#annotate_bindings-2">annotate_bindings/2</a></code>.</p>  <h3 id="annotate_bindings-2" class="code">annotate_bindings(Tree::<a href="#type-syntaxTree">syntaxTree()</a>, Bindings::<a href="#type-ordset">ordset(atom())</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3> 
<p>Adds or updates annotations on nodes in a syntax tree. <code class="code">Bindings</code> specifies the set of bound variables in the environment of the top level node. The following annotations are affected: </p>
<ul> <li><p><code class="code">{env, Vars}</code>, representing the input environment of the subtree.</p></li> <li><p><code class="code">{bound, Vars}</code>, representing the variables that are bound in the subtree.</p></li> <li><p><code class="code">{free, Vars}</code>, representing the free variables in the subtree.</p></li> </ul>
<p> <code class="code">Bindings</code> and <code class="code">Vars</code> are ordered-set lists (cf. module <code class="code">ordsets</code>) of atoms representing variable names. </p> <p><strong>See also:</strong> <code class="bold_code">ordsets(3)</code>, <code class="bold_code"><a href="#annotate_bindings-1">annotate_bindings/1</a></code>.</p>  <h3 id="fold-3" class="code">fold(F::Function, Start::term(), Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; term()</h3>  <p>Types:</p>   <pre>Function = (<a href="#type-syntaxTree">syntaxTree()</a>, term()) -&gt; term()</pre>

<p>Folds a function over all nodes of a syntax tree. The result is the value of <code class="code">Function(X1, Function(X2, ... Function(Xn, Start) ... ))</code>, where <code class="code">[X1, X2, ..., Xn]</code> are the nodes of <code class="code">Tree</code> in a post-order traversal. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#fold_subtrees-3">fold_subtrees/3</a></code>, <code class="bold_code"><a href="#foldl_listlist-3">foldl_listlist/3</a></code>.</p>  <h3 id="fold_subtrees-3" class="code">fold_subtrees(F::Function, Start::term(), Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; term()</h3>  <p>Types:</p>   <pre>Function = (<a href="#type-syntaxTree">syntaxTree()</a>, term()) -&gt; term()</pre>

<p>Folds a function over the immediate subtrees of a syntax tree. This is similar to <code class="code">fold/3</code>, but only on the immediate subtrees of <code class="code">Tree</code>, in left-to-right order; it does not include the root node of <code class="code">Tree</code>. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#fold-3">fold/3</a></code>.</p>  <h3 id="foldl_listlist-3" class="code">foldl_listlist(F::Function, Start::term(), Ls::[[term()]]) -&gt; term()</h3>  <p>Types:</p>   <pre>Function = (term(), term()) -&gt; term()</pre>

<p>Like <code class="code">lists:foldl/3</code>, but over a list of lists. </p> <p><strong>See also:</strong> <code class="bold_code">lists:foldl/3</code>, <code class="bold_code"><a href="#fold-3">fold/3</a></code>.</p>  <h3 id="function_name_expansions-1" class="code">function_name_expansions(Names::[Name]) -&gt; [{ShortName, Name}]</h3>  <p>Types:</p>    <pre>Name = ShortName | {atom(), Name}
ShortName = atom() | {atom(), integer()}</pre>

<p>Creates a mapping from corresponding short names to full function names. Names are represented by nested tuples of atoms and integers (cf. <code class="code">analyze_function_name/1</code>). The result is a list containing a pair <code class="code">{ShortName, Name}</code> for each element <code class="code">Name</code> in the given list, where the corresponding <code class="code">ShortName</code> is the rightmost-innermost part of <code class="code">Name</code>. The list thus represents a finite mapping from unqualified names to the corresponding qualified names.</p> <p>Note: the resulting list can contain more than one tuple <code class="code">{ShortName, Name}</code> for the same <code class="code">ShortName</code>, possibly with different values for <code class="code">Name</code>, depending on the given list. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#analyze_function_name-1">analyze_function_name/1</a></code>.</p>  <h3 id="is_fail_expr-1" class="code">is_fail_expr(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; boolean()</h3> 
<p>Returns <code class="code">true</code> if <code class="code">Tree</code> represents an expression which never terminates normally. Note that the reverse does not apply. Currently, the detected cases are calls to <code class="code">exit/1</code>, <code class="code">throw/1</code>, <code class="code">erlang:error/1</code> and <code class="code">erlang:error/2</code>. </p> <p><strong>See also:</strong> <code class="bold_code">erlang:error/1</code>, <code class="bold_code">erlang:error/2</code>, <code class="bold_code">erlang:exit/1</code>, <code class="bold_code">erlang:throw/1</code>.</p>  <h3 id="limit-2" class="code">limit(Tree, Depth) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3> 
<p>Equivalent to <code class="code">limit(Tree, Depth, Text)</code> using the text <code class="code">"..."</code> as default replacement. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#limit-3">limit/3</a></code>, <code class="bold_code"><a href="../erl_syntax/#text-1">erl_syntax:text/1</a></code>.</p>  <h3 id="limit-3" class="code">limit(Tree::<a href="#type-syntaxTree">syntaxTree()</a>, Depth::integer(), Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3> 
<p>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in <code class="code">Tree</code> at the given <code class="code">Depth</code> by <code class="code">Node</code>. If <code class="code">Depth</code> is negative, the result is always <code class="code">Node</code>, even if <code class="code">Tree</code> has no subtrees.</p> <p>When a group of subtrees (as e.g., the argument list of an <code class="code">application</code> node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by <code class="code">Node</code> even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if <code class="code">Tree</code> represents a list of integers "<code class="code">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>", the result of <code class="code">limit(Tree, 5)</code> will represent <code class="code">[1, 2, 3, 4, ...]</code>.</p> <p>The resulting syntax tree is typically only useful for pretty-printing or similar visual formatting. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#limit-2">limit/2</a></code>.</p>  <h3 id="map-2" class="code">map(F::Function, Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3>  <p>Types:</p>   <pre>Function = (<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a></pre>

<p>Applies a function to each node of a syntax tree. The result of each application replaces the corresponding original node. The order of traversal is bottom-up. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#map_subtrees-2">map_subtrees/2</a></code>.</p>  <h3 id="map_subtrees-2" class="code">map_subtrees(F::Function, Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3>  <p>Types:</p>   <pre>Function = (Tree) -&gt; Tree1</pre>

<p>Applies a function to each immediate subtree of a syntax tree. The result of each application replaces the corresponding original node. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#map-2">map/2</a></code>.</p>  <h3 id="mapfold-3" class="code">mapfold(F::Function, Start::term(), Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {<a href="#type-syntaxTree">syntaxTree()</a>, term()}</h3>  <p>Types:</p>   <pre>Function = (<a href="#type-syntaxTree">syntaxTree()</a>, term()) -&gt; {<a href="#type-syntaxTree">syntaxTree()</a>, term()}</pre>

<p>Combines map and fold in a single operation. This is similar to <code class="code">map/2</code>, but also propagates an extra value from each application of the <code class="code">Function</code> to the next, while doing a post-order traversal of the tree like <code class="code">fold/3</code>. The value <code class="code">Start</code> is passed to the first function application, and the final result is the result of the last application. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#fold-3">fold/3</a></code>, <code class="bold_code"><a href="#map-2">map/2</a></code>.</p>  <h3 id="mapfold_subtrees-3" class="code">mapfold_subtrees(F::Function, Start::term(), Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {<a href="#type-syntaxTree">syntaxTree()</a>, term()}</h3>  <p>Types:</p>   <pre>Function = (<a href="#type-syntaxTree">syntaxTree()</a>, term()) -&gt; {<a href="#type-syntaxTree">syntaxTree()</a>, term()}</pre>

<p>Does a mapfold operation over the immediate subtrees of a syntax tree. This is similar to <code class="code">mapfold/3</code>, but only on the immediate subtrees of <code class="code">Tree</code>, in left-to-right order; it does not include the root node of <code class="code">Tree</code>. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#mapfold-3">mapfold/3</a></code>.</p>  <h3 id="mapfoldl_listlist-3" class="code">mapfoldl_listlist(F::Function, S::State, Ls::[[term()]]) -&gt; {[[term()]], term()}</h3>  <p>Types:</p>   <pre>Function = (term(), term()) -&gt; {term(), term()}</pre>

<p>Like <code class="code">lists:mapfoldl/3</code>, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</p>  <h3 id="new_variable_name-1" class="code">new_variable_name(Used::<a href="#type-set">set(atom())</a>) -&gt; atom()</h3> 
<p>Returns an atom which is not already in the set <code class="code">Used</code>. This is equivalent to <code class="code">new_variable_name(Function, Used)</code>, where <code class="code">Function</code> maps a given integer <code class="code">N</code> to the atom whose name consists of "<code class="code">V</code>" followed by the numeral for <code class="code">N</code>. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#new_variable_name-2">new_variable_name/2</a></code>.</p>  <h3 id="new_variable_name-2" class="code">new_variable_name(F::Function, Used::<a href="#type-set">set(atom())</a>) -&gt; atom()</h3>  <p>Types:</p>   <pre>Function = (integer()) -&gt; atom()</pre>

<p>Returns a user-named atom which is not already in the set <code class="code">Used</code>. The atom is generated by applying the given <code class="code">Function</code> to a generated integer. Integers are generated using an algorithm which tries to keep the names randomly distributed within a reasonably small range relative to the number of elements in the set.</p> <p>This function uses the module <code class="code">rand</code> to generate new keys. The seed it uses may be initialized by calling <code class="code">rand:seed/1</code> or <code class="code">rand:seed/2</code> before this function is first called. </p> <p><strong>See also:</strong> <code class="bold_code">random(3)</code>, <code class="bold_code">sets(3)</code>, <code class="bold_code"><a href="#new_variable_name-1">new_variable_name/1</a></code>.</p>  <h3 id="new_variable_names-2" class="code">new_variable_names(N::integer(), Used::<a href="#type-set">set(atom())</a>) -&gt; [atom()]</h3> 
<p>Like <code class="code">new_variable_name/1</code>, but generates a list of <code class="code">N</code> new names. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#new_variable_name-1">new_variable_name/1</a></code>.</p>  <h3 id="new_variable_names-3" class="code">new_variable_names(N::integer(), F::Function, Used::<a href="#type-set">set(atom())</a>) -&gt; [atom()]</h3>  <p>Types:</p>   <pre>Function = (integer()) -&gt; atom()</pre>

<p>Like <code class="code">new_variable_name/2</code>, but generates a list of <code class="code">N</code> new names. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#new_variable_name-2">new_variable_name/2</a></code>.</p>  <h3 id="strip_comments-1" class="code">strip_comments(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3> 
<p>Removes all comments from all nodes of a syntax tree. All other attributes (such as position information) remain unchanged. Standalone comments in form lists are removed; any other standalone comments are changed into null-comments (no text, no indentation).</p>  <h3 id="to_comment-1" class="code">to_comment(Tree) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3> 
<p>Equivalent to <code class="bold_code"><a href="#to_comment-2">to_comment(Tree, "% ")</a></code>.</p>  <h3 id="to_comment-2" class="code">to_comment(Tree::<a href="#type-syntaxTree">syntaxTree()</a>, Prefix::string()) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3> 
<p>Equivalent to <code class="code">to_comment(Tree, Prefix, F)</code> for a default formatting function <code class="code">F</code>. The default <code class="code">F</code> simply calls <code class="code">erl_prettypr:format/1</code>. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#to_comment-3">to_comment/3</a></code>, <code class="bold_code"><a href="../erl_prettypr/#format-1">erl_prettypr:format/1</a></code>.</p>  <h3 id="to_comment-3" class="code">to_comment(Tree::<a href="#type-syntaxTree">syntaxTree()</a>, Prefix::string(), F::Printer) -&gt; <a href="#type-syntaxTree">syntaxTree()</a>
</h3>  <p>Types:</p>   <pre>Printer = (<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; string()</pre>

<p>Transforms a syntax tree into an abstract comment. The lines of the comment contain the text for <code class="code">Node</code>, as produced by the given <code class="code">Printer</code> function. Each line of the comment is prefixed by the string <code class="code">Prefix</code> (this does not include the initial "<code class="code">%</code>" character of the comment line).</p> <p>For example, the result of <code class="code">to_comment(erl_syntax:abstract([a,b,c]))</code> represents </p>
<div class="example"><pre>
%% [a,b,c]</pre></div>
<p> (cf. <code class="code">to_comment/1</code>).</p> <p>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed. </p> <p><strong>See also:</strong> <code class="bold_code"><a href="#to_comment-1">to_comment/1</a></code>, <code class="bold_code"><a href="#to_comment-2">to_comment/2</a></code>.</p>  <h3 id="variables-1" class="code">variables(Tree::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; <a href="#type-set">set(atom())</a>
</h3> 
<p>Returns the names of variables occurring in a syntax tree, The result is a set of variable names represented by atoms. Macro names are not included. </p> <p><strong>See also:</strong> <code class="bold_code">sets(3)</code>.</p>  Richard Carlsson carlsson.richard@gmail.com<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
