
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Application - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" application ">
  <meta name="keywords" content="application, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/kernel-5.2/doc/html/application/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>application</h1> <h2>Module</h2> <p class="REFBODY">application</p> <h2>Module summary</h2> <p class="REFBODY">Generic OTP application functions</p> <h2>Description</h2> 
<p>In OTP, <strong>application</strong> denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with <strong>application controller</strong>, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</p> <p>An application is defined by an <strong>application specification</strong>. The specification is normally located in an <strong>application resource file</strong> named <code class="code">Application.app</code>, where <code class="code">Application</code> is the application name. For details about the application specification, see <code class="bold_code"><a href="../app/"><span class="code">app(4)</span></a></code>.</p> <p>This module can also be viewed as a behaviour for an application implemented according to the OTP design principles as a supervision tree. The definition of how to start and stop the tree is to be located in an <strong>application callback module</strong>, exporting a predefined set of functions.</p> <p>For details about applications and behaviours, see <code class="bold_code">OTP Design Principles</code>.</p>  <h2>Data types</h2> <h3 class="code">start_type() = <br>    normal |<br>    {takeover, Node :: node()} |<br>    {failover, Node :: node()}</h3> <h3 class="code">restart_type() = permanent | transient | temporary</h3> <h3 id="type-tuple_of" class="code">tuple_of(T)</h3> 
<p>A tuple where the elements are of type <code class="code">T</code>.</p> <h2>Exports</h2> <h3 id="ensure_all_started-2" class="code">ensure_all_started(Application) -&gt; {ok, Started} | {error, Reason}<br>ensure_all_started(Application, Type) -&gt;<br>                      {ok, Started} | {error, Reason}</h3> <p>Types:</p>      <pre>Application = atom()
Type = <a href="#type-restart_type">restart_type()</a>
Started = [atom()]
Reason = term()</pre>

<p>Equivalent to calling <code class="bold_code"><a href="#start-1"><span class="code">start/1,2</span></a></code> repeatedly on all dependencies that are not yet started for an application.</p> <p>Returns <code class="code">{ok, AppNames}</code> for a successful start or for an already started application (which is, however, omitted from the <code class="code">AppNames</code> list).</p> <p>The function reports <code class="code">{error, {AppName,Reason}}</code> for errors, where <code class="code">Reason</code> is any possible reason returned by <code class="bold_code"><a href="#start-1"><span class="code">start/1,2</span></a></code> when starting a specific dependency.</p> <p>If an error occurs, the applications started by the function are stopped to bring the set of running applications back to its initial state.</p>  <h3 id="ensure_started-2" class="code">ensure_started(Application) -&gt; ok | {error, Reason}<br>ensure_started(Application, Type) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Application = atom()
Type = <a href="#type-restart_type">restart_type()</a>
Reason = term()</pre>

<p>Equivalent to <code class="bold_code"><a href="#start-1"><span class="code">start/1,2</span></a></code> except it returns <code class="code">ok</code> for already started applications.</p>  <h3 id="get_all_env-1" class="code">get_all_env() -&gt; Env<br>get_all_env(Application) -&gt; Env</h3> <p>Types:</p>    <pre>Application = atom()
Env = [{Par :: atom(), Val :: term()}]</pre>

<p>Returns the configuration parameters and their values for <code class="code">Application</code>. If the argument is omitted, it defaults to the application of the calling process.</p> <p>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns <code class="code">[]</code>.</p>  <h3 id="get_all_key-1" class="code">get_all_key() -&gt; [] | {ok, Keys}<br>get_all_key(Application) -&gt; undefined | Keys</h3> <p>Types:</p>    <pre>Application = atom()
Keys = {ok, [{Key :: atom(), Val :: term()}, ...]}</pre>

<p>Returns the application specification keys and their values for <code class="code">Application</code>. If the argument is omitted, it defaults to the application of the calling process.</p> <p>If the specified application is not loaded, the function returns <code class="code">undefined</code>. If the process executing the call does not belong to any application, the function returns <code class="code">[]</code>.</p>  <h3 id="get_application-1" class="code">get_application() -&gt; undefined | {ok, Application}<br>get_application(PidOrModule) -&gt; undefined | {ok, Application}</h3> <p>Types:</p>    <pre>PidOrModule = (Pid :: pid()) | (Module :: module())
Application = atom()</pre>

<p>Returns the name of the application to which the process <code class="code">Pid</code> or the module <code class="code">Module</code> belongs. Providing no argument is the same as calling <code class="code">get_application(self())</code>.</p> <p>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns <code class="code">undefined</code>.</p>  <h3 id="get_env-2" class="code">get_env(Par) -&gt; undefined | {ok, Val}<br>get_env(Application, Par) -&gt; undefined | {ok, Val}</h3> <p>Types:</p>     <pre>Application = Par = atom()

Val = term()</pre>

<p>Returns the value of configuration parameter <code class="code">Par</code> for <code class="code">Application</code>. If the application argument is omitted, it defaults to the application of the calling process.</p> <p>Returns <code class="code">undefined</code> if any of the following applies:</p> <ul> <li>The specified application is not loaded.</li> <li>The configuration parameter does not exist.</li> <li>The process executing the call does not belong to any application.</li> </ul>  <h3 id="get_env-3" class="code">get_env(Application, Par, Def) -&gt; Val</h3> <p>Types:</p>      <pre>Application = Par = atom()

Def = Val = term()</pre>

<p>Works like <code class="bold_code"><a href="#get_env-2"><span class="code">get_env/2</span></a></code> but returns value <code class="code">Def</code> when configuration parameter <code class="code">Par</code> does not exist.</p>  <h3 id="get_key-2" class="code">get_key(Key) -&gt; undefined | {ok, Val}<br>get_key(Application, Key) -&gt; undefined | {ok, Val}</h3> <p>Types:</p>     <pre>Application = Key = atom()

Val = term()</pre>

<p>Returns the value of the application specification key <code class="code">Key</code> for <code class="code">Application</code>. If the application argument is omitted, it defaults to the application of the calling process.</p> <p>Returns <code class="code">undefined</code> if any of the following applies:</p> <ul> <li>The specified application is not loaded.</li> <li>The specification key does not exist.</li> <li>The process executing the call does not belong to any application.</li> </ul>  <h3 id="load-2" class="code">load(AppDescr) -&gt; ok | {error, Reason}<br>load(AppDescr, Distributed) -&gt; ok | {error, Reason}</h3> <p>Types:</p>          <pre>AppDescr = Application | (AppSpec :: application_spec())
Application = atom()
Distributed = 
    {Application, Nodes} | {Application, Time, Nodes} | default
Nodes = [node() | <a href="#type-tuple_of">tuple_of</a>(node())]
Time = integer() &gt;= 1
Reason = term()
application_spec() = 
    {application,
     Application :: atom(),
     AppSpecKeys :: [application_opt()]}
application_opt() = 
    {description, Description :: string()} |
    {vsn, Vsn :: string()} |
    {id, Id :: string()} |
    {modules, [Module :: module()]} |
    {registered, Names :: [Name :: atom()]} |
    {applications, [Application :: atom()]} |
    {included_applications, [Application :: atom()]} |
    {env, [{Par :: atom(), Val :: term()}]} |
    {start_phases,
     [{Phase :: atom(), PhaseArgs :: term()}] | undefined} |
    {maxT, MaxT :: timeout()} |
    {maxP, MaxP :: integer() &gt;= 1 | infinity} |
    {mod, Start :: {Module :: module(), StartArgs :: term()}}</pre>

<p>Loads the application specification for an application into the application controller. It also loads the application specifications for any included applications. Notice that the function does not load the Erlang object code.</p> <p>The application can be specified by its name <code class="code">Application</code>. In this case, the application controller searches the code path for the application resource file <code class="code">Application.app</code> and loads the specification it contains.</p> <p>The application specification can also be specified directly as a tuple <code class="code">AppSpec</code>, having the format and contents as described in <code class="bold_code"><a href="../app/"><span class="code">app(4)</span></a></code>.</p> <p>If <code class="code">Distributed == {Application,[Time,]Nodes}</code>, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter <code class="code">distributed</code>. <code class="code">Application</code> must be the application name (same as in the first argument). If a node crashes and <code class="code">Time</code> is specified, the application controller waits for <code class="code">Time</code> milliseconds before attempting to restart the application on another node. If <code class="code">Time</code> is not specified, it defaults to <code class="code">0</code> and the application is restarted immediately.</p> <p><code class="code">Nodes</code> is a list of node names where the application can run, in priority from left to right. Node names can be grouped using tuples to indicate that they have the same priority.</p> <p><strong>Example:</strong></p> <div class="example"><pre>
Nodes = [cp1@cave, {cp2@cave, cp3@cave}]</pre></div> <p>This means that the application is preferably to be started at <code class="code">cp1@cave</code>. If <code class="code">cp1@cave</code> is down, the application is to be started at <code class="code">cp2@cave</code> or <code class="code">cp3@cave</code>.</p> <p>If <code class="code">Distributed == default</code>, the value for the application in the Kernel configuration parameter <code class="code">distributed</code> is used.</p>  <h3 id="loaded_applications-0" class="code">loaded_applications() -&gt; [{Application, Description, Vsn}]</h3> <p>Types:</p>     <pre>Application = atom()
Description = Vsn = string()</pre>

<p>Returns a list with information about the applications, and included applications, which are loaded using <code class="code">load/1,2</code>. <code class="code">Application</code> is the application name. <code class="code">Description</code> and <code class="code">Vsn</code> are the values of their <code class="code">description</code> and <code class="code">vsn</code> application specification keys, respectively.</p>  <h3 id="permit-2" class="code">permit(Application, Permission) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Application = atom()
Permission = boolean()
Reason = term()</pre>

<p>Changes the permission for <code class="code">Application</code> to run at the current node. The application must be loaded using <code class="code">load/1,2</code> for the function to have effect.</p> <p>If the permission of a loaded, but not started, application is set to <code class="code">false</code>, <code class="code">start</code> returns <code class="code">ok</code> but the application is not started until the permission is set to <code class="code">true</code>.</p> <p>If the permission of a running application is set to <code class="code">false</code>, the application is stopped. If the permission later is set to <code class="code">true</code>, it is restarted.</p> <p>If the application is distributed, setting the permission to <code class="code">false</code> means that the application will be started at, or moved to, another node according to how its distribution is configured (see <code class="bold_code"><a href="#load-2"><span class="code">load/2</span></a></code>).</p> <p>The function does not return until the application is started, stopped, or successfully moved to another node. However, in some cases where permission is set to <code class="code">true</code>, the function returns <code class="code">ok</code> even though the application is not started. This is true when an application cannot start because of dependencies to other applications that are not yet started. When they are started, <code class="code">Application</code> is started as well.</p> <p>By default, all applications are loaded with permission <code class="code">true</code> on all nodes. The permission can be configured using the Kernel configuration parameter <code class="code">permissions</code>.</p>  <h3 id="set_env-4" class="code">set_env(Application, Par, Val) -&gt; ok<br>set_env(Application, Par, Val, Opts) -&gt; ok</h3> <p>Types:</p>      <pre>Application = Par = atom()

Val = term()
Opts = [{timeout, timeout()} | {persistent, boolean()}]</pre>

<p>Sets the value of configuration parameter <code class="code">Par</code> for <code class="code">Application</code>.</p> <p><code class="code">set_env/4</code> uses the standard <code class="code">gen_server</code> time-out value (5000 ms). Option <code class="code">timeout</code> can be specified if another time-out value is useful, for example, in situations where the application controller is heavily loaded.</p> <p>If <code class="code">set_env/4</code> is called before the application is loaded, the application environment values specified in file <code class="code">Application.app</code> override the ones previously set. This is also true for application reloads.</p> <p>Option <code class="code">persistent</code> can be set to <code class="code">true</code> to guarantee that parameters set with <code class="code">set_env/4</code> are not overridden by those defined in the application resource file on load. This means that persistent values will stick after the application is loaded and also on application reload.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Use this function only if you know what you are doing, that is, on your own applications. It is very application-dependent and configuration parameter-dependent when and how often the value is read by the application. Careless use of this function can put the application in a weird, inconsistent, and malfunctioning state.</p> </div> </div>  <h3 id="start-2" class="code">start(Application) -&gt; ok | {error, Reason}<br>start(Application, Type) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Application = atom()
Type = <a href="#type-restart_type">restart_type()</a>
Reason = term()</pre>

<p>Starts <code class="code">Application</code>. If it is not loaded, the application controller first loads it using <code class="code">load/1</code>. It ensures that any included applications are loaded, but does not start them. That is assumed to be taken care of in the code for <code class="code">Application</code>.</p> <p>The application controller checks the value of the application specification key <code class="code">applications</code>, to ensure that all applications needed to be started before this application are running. Otherwise, <code class="code">{error,{not_started,App}}</code> is returned, where <code class="code">App</code> is the name of the missing application.</p> <p>The application controller then creates an <strong>application master</strong> for the application. The application master is the group leader of all the processes in the application. The application master starts the application by calling the application callback function <code class="code">Module:start/2</code> as defined by the application specification key <code class="code">mod</code>.</p> <p>Argument <code class="code">Type</code> specifies the type of the application. If omitted, it defaults to <code class="code">temporary</code>.</p> <ul> <li>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</li> <li> <ul> <li>If a transient application terminates with <code class="code">Reason == normal</code>, this is reported but no other applications are terminated.</li> <li>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</li> </ul> </li> <li>If a temporary application terminates, this is reported but no other applications are terminated.</li> </ul> <p>Notice that an application can always be stopped explicitly by calling <code class="code">stop/1</code>. Regardless of the type of the application, no other applications are affected.</p> <p>Notice also that the transient type is of little practical use, because when a supervision tree terminates, the reason is set to <code class="code">shutdown</code>, not <code class="code">normal</code>.</p>  <h3 id="start_type-0" class="code">start_type() -&gt; StartType | undefined | local</h3> <p>Types:</p>   <pre>StartType = <a href="#type-start_type">start_type()</a></pre>

<p>This function is intended to be called by a process belonging to an application, when the application is started, to determine the start type, which is <code class="code">StartType</code> or <code class="code">local</code>.</p> <p>For a description of <code class="code">StartType</code>, see <code class="bold_code"><a href="#start_type"><span class="code">Module:start/2</span></a></code>.</p> <p><code class="code">local</code> is returned if only parts of the application are restarted (by a supervisor), or if the function is called outside a startup.</p> <p>If the process executing the call does not belong to any application, the function returns <code class="code">undefined</code>.</p>  <h3 id="stop-1" class="code">stop(Application) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Application = atom()
Reason = term()</pre>

<p>Stops <code class="code">Application</code>. The application master calls <code class="code">Module:prep_stop/1</code>, if such a function is defined, and then tells the top supervisor of the application to shut down (see <code class="bold_code"><span class="code">supervisor(3)</span></code>). This means that the entire supervision tree, including included applications, is terminated in reversed start order. After the shutdown, the application master calls <code class="code">Module:stop/1</code>. <code class="code">Module</code> is the callback module as defined by the application specification key <code class="code">mod</code>.</p> <p>Last, the application master terminates. Notice that all processes with the application master as group leader, that is, processes spawned from a process belonging to the application, are also terminated.</p> <p>When stopped, the application is still loaded.</p> <p>To stop a distributed application, <code class="code">stop/1</code> must be called on all nodes where it can execute (that is, on all nodes where it has been started). The call to <code class="code">stop/1</code> on the node where the application currently executes stops its execution. The application is not moved between nodes, as <code class="code">stop/1</code> is called on the node where the application currently executes before <code class="code">stop/1</code> is called on the other nodes.</p>  <h3 id="takeover-2" class="code">takeover(Application, Type) -&gt; ok | {error, Reason}</h3> <p>Types:</p>     <pre>Application = atom()
Type = <a href="#type-restart_type">restart_type()</a>
Reason = term()</pre>

<p>Takes over the distributed application <code class="code">Application</code>, which executes at another node <code class="code">Node</code>. At the current node, the application is restarted by calling <code class="code">Module:start({takeover,Node},StartArgs)</code>. <code class="code">Module</code> and <code class="code">StartArgs</code> are retrieved from the loaded application specification. The application at the other node is not stopped until the startup is completed, that is, when <code class="code">Module:start/2</code> and any calls to <code class="code">Module:start_phase/3</code> have returned.</p> <p>Thus, two instances of the application run simultaneously during the takeover, so that data can be transferred from the old to the new instance. If this is not an acceptable behavior, parts of the old instance can be shut down when the new instance is started. However, the application cannot be stopped entirely, at least the top supervisor must remain alive.</p> <p>For a description of <code class="code">Type</code>, see <code class="bold_code"><a href="#start-1"><span class="code">start/1,2</span></a></code>.</p>  <h3 id="unload-1" class="code">unload(Application) -&gt; ok | {error, Reason}</h3> <p>Types:</p>    <pre>Application = atom()
Reason = term()</pre>

<p>Unloads the application specification for <code class="code">Application</code> from the application controller. It also unloads the application specifications for any included applications. Notice that the function does not purge the Erlang object code.</p>  <h3 id="unset_env-3" class="code">unset_env(Application, Par) -&gt; ok<br>unset_env(Application, Par, Opts) -&gt; ok</h3> <p>Types:</p>     <pre>Application = Par = atom()

Opts = [{timeout, timeout()} | {persistent, boolean()}]</pre>

<p>Removes the configuration parameter <code class="code">Par</code> and its value for <code class="code">Application</code>.</p> <p><code class="code">unset_env/2</code> uses the standard <code class="code">gen_server</code> time-out value (5000 ms). Option <code class="code">timeout</code> can be specified if another time-out value is useful, for example, in situations where the application controller is heavily loaded.</p> <p><code class="code">unset_env/3</code> also allows the persistent option to be passed (see <code class="bold_code"><a href="#set_env-4"><span class="code">set_env/4</span></a></code>).</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Use this function only if you know what you are doing, that is, on your own applications. It is very application-dependent and configuration parameter-dependent when and how often the value is read by the application. Careless use of this function can put the application in a weird, inconsistent, and malfunctioning state.</p> </div> </div>  <h3 id="which_applications-1" class="code">which_applications() -&gt; [{Application, Description, Vsn}]<br>which_applications(Timeout) -&gt; [{Application, Description, Vsn}]</h3> <p>Types:</p>      <pre>Timeout = timeout()
Application = atom()
Description = Vsn = string()</pre>

<p>Returns a list with information about the applications that are currently running. <code class="code">Application</code> is the application name. <code class="code">Description</code> and <code class="code">Vsn</code> are the values of their <code class="code">description</code> and <code class="code">vsn</code> application specification keys, respectively.</p> <p><code class="code">which_applications/0</code> uses the standard <code class="code">gen_server</code> time-out value (5000 ms). A <code class="code">Timeout</code> argument can be specified if another time-out value is useful, for example, in situations where the application controller is heavily loaded.</p>  <h2 id="id106999">Callback Module</h2>  <p>The following functions are to be exported from an <code class="code">application</code> callback module.</p>  <h2>Exports</h2> <h3 id="Module:start-2" class="code">Module:start(StartType, StartArgs) -&gt; {ok, Pid} | {ok, Pid, State} | {error, Reason}</h3>  <p>Types:</p>      <pre>StartType = <a href="#type-start_type">start_type()</a>
StartArgs = term()
Pid = pid()
State = term()</pre>

<p>This function is called whenever an application is started using <code class="code">start/1,2</code>, and is to start the processes of the application. If the application is structured according to the OTP design principles as a supervision tree, this means starting the top supervisor of the tree.</p> <p id="start_type"><code class="code">StartType</code> defines the type of start:</p> <ul> <li> <code class="code">normal</code> if it is a normal startup.</li> <li> <code class="code">normal</code> also if the application is distributed and started at the current node because of a failover from another node, and the application specification key <code class="code">start_phases == undefined</code>.</li> <li> <code class="code">{takeover,Node}</code> if the application is distributed and started at the current node because of a takeover from <code class="code">Node</code>, either because <code class="code">takeover/2</code> has been called or because the current node has higher priority than <code class="code">Node</code>.</li> <li> <code class="code">{failover,Node}</code> if the application is distributed and started at the current node because of a failover from <code class="code">Node</code>, and the application specification key <code class="code">start_phases /= undefined</code>.</li> </ul> <p><code class="code">StartArgs</code> is the <code class="code">StartArgs</code> argument defined by the application specification key <code class="code">mod</code>.</p> <p>The function is to return <code class="code">{ok,Pid}</code> or <code class="code">{ok,Pid,State}</code>, where <code class="code">Pid</code> is the pid of the top supervisor and <code class="code">State</code> is any term. If omitted, <code class="code">State</code> defaults to <code class="code">[]</code>. If the application is stopped later, <code class="code">State</code> is passed to <code class="code">Module:prep_stop/1</code>.</p>  <h3 id="Module:start_phase-3" class="code">Module:start_phase(Phase, StartType, PhaseArgs) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>       <pre>Phase = atom()
StartType = <a href="#type-start_type">start_type()</a>
PhaseArgs = term()
Pid = pid()
State = state()</pre>

<p>Starts an application with included applications, when synchronization is needed between processes in the different applications during startup.</p> <p>The start phases are defined by the application specification key <code class="code">start_phases == [{Phase,PhaseArgs}]</code>. For included applications, the set of phases must be a subset of the set of phases defined for the including application.</p> <p>The function is called for each start phase (as defined for the primary application) for the primary application and all included applications, for which the start phase is defined.</p> <p>For a description of <code class="code">StartType</code>, see <code class="bold_code"><span class="code">Module:start/2</span></code>.</p>  <h3 id="Module:prep_stop-1" class="code">Module:prep_stop(State) -&gt; NewState</h3>  <p>Types:</p>   <pre>State = NewState = term()</pre>

<p>This function is called when an application is about to be stopped, before shutting down the processes of the application.</p> <p><code class="code">State</code> is the state returned from <code class="code">Module:start/2</code>, or <code class="code">[]</code> if no state was returned. <code class="code">NewState</code> is any term and is passed to <code class="code">Module:stop/1</code>.</p> <p>The function is optional. If it is not defined, the processes are terminated and then <code class="code">Module:stop(State)</code> is called.</p>  <h3 id="Module:stop-1" class="code">Module:stop(State)</h3>  <p>Types:</p>   <pre>State = term()</pre>

<p>This function is called whenever an application has stopped. It is intended to be the opposite of <code class="code">Module:start/2</code> and is to do any necessary cleaning up. The return value is ignored.</p> <p><code class="code">State</code> is the return value of <code class="code">Module:prep_stop/1</code>, if such a function exists. Otherwise <code class="code">State</code> is taken from the return value of <code class="code">Module:start/2</code>.</p>  <h3 id="Module:config_change-3" class="code">Module:config_change(Changed, New, Removed) -&gt; ok</h3>  <p>Types:</p>       <pre>Changed = [{Par,Val}]
New = [{Par,Val}]
Removed = [Par]
 Par = atom()
 Val = term()</pre>

<p>This function is called by an application after a code replacement, if the configuration parameters have changed.</p> <p><code class="code">Changed</code> is a list of parameter-value tuples including all configuration parameters with changed values.</p> <p><code class="code">New</code> is a list of parameter-value tuples including all added configuration parameters.</p> <p><code class="code">Removed</code> is a list of all removed parameters.</p>  <h2 id="id107430">See Also</h2>  <p><code class="bold_code">OTP Design Principles</code>, <code class="bold_code"><span>kernel(6)</span></code>, <code class="bold_code"><a href="../app/">app(4)</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
