
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>8. Performance Comparison - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content="The Megaco&#47;H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for &hellip;">
  <meta name="keywords" content="performance, comparison, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/megaco-3.18.1/doc/html/megaco_performance/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>8 Performance comparison</h1> <h2 id="id67632">8.1 Comparison of encoder/decoders</h2> <p>The Megaco/H.248 standard defines both a plain text encoding and a binary encoding (ASN.1 BER) and we have implemented encoders and decoders for both. We do supply a bunch of different encoding/decoding modules and the user may in fact implement their own (like our erl_dist module). Using a non-standard encoding format has its obvious drawbacks, but may be useful in some configurations.</p> <p>We have made four different measurements of our Erlang/OTP implementation of the Megaco/H.248 protocol stack, in order to compare our different encoders/decoders. The result of each one is summarized in the table below.</p> <p>The result above are the fastest of these configurations for each codec. The figures presented are the average of all used messages.</p> <p>For comparison, also included are first, performance figures with megaco (including the measurement software) and asn1 applications hipe-compiled (second figure in the time columns, note that per bin decode had some issues so those figures are not included), and second, performance figures where the flex driver was built as <code class="code">non-reentrant</code> flex (third figure in the time columns, only valid for text codecs using the flex-scanner, figures within parenthesis). </p> <table> <tr> <td><strong>Codec and config</strong></td> <td><strong>Size</strong></td> <td><strong>Encode</strong></td> <td><strong>Decode</strong></td> <td><strong>Total</strong></td> </tr> <tr> <td>pretty</td> <td>336</td> <td>20 / 13</td> <td>75 / 40</td> <td>95 / 53</td> </tr> <tr> <td>pretty [flex]</td> <td>336</td> <td>20 / 13 / 20</td> <td>39 / 33 / 38</td> <td>59 / 46 / 58</td> </tr> <tr> <td>compact</td> <td>181</td> <td>17 / 10</td> <td>62 / 35</td> <td>79 / 45</td> </tr> <tr> <td>compact [flex]</td> <td>181</td> <td>17 / 10 / 17</td> <td>37 / 31 / 36</td> <td>54 / 41 / 53</td> </tr> <tr> <td>per bin</td> <td>91</td> <td>60 / 29</td> <td>64 / -</td> <td>124 / -</td> </tr> <tr> <td>per bin [driver]</td> <td>91</td> <td>39 / 24</td> <td>42 / 26</td> <td>81 / 50</td> </tr> <tr> <td>per bin [native]</td> <td>91</td> <td>45 / 21</td> <td>48 / -</td> <td>93 / -</td> </tr> <tr> <td>per bin [driver,native]</td> <td>91</td> <td>25 / 15</td> <td>27 / 18</td> <td>52 / 33</td> </tr> <tr> <td>ber bin</td> <td>165</td> <td>32 / 19</td> <td>38 / 21</td> <td>70 / 40</td> </tr> <tr> <td>ber bin [driver]</td> <td>165</td> <td>32 / 19</td> <td>33 / 20</td> <td>65 / 39</td> </tr> <tr> <td>ber bin [native]</td> <td>165</td> <td>17 / 11</td> <td>25 / 13</td> <td>42 / 24</td> </tr> <tr> <td>ber bin [driver,native]</td> <td>165</td> <td>17 / 11</td> <td>17 / 12</td> <td>34 / 23</td> </tr> <tr> <td>erl_dist</td> <td>875</td> <td>5 / 5</td> <td>10 / 10</td> <td>15 / 15</td> </tr> <tr> <td>erl_dist [megaco_compressed]</td> <td>405</td> <td>6 / 4</td> <td>7 / 4</td> <td>13 / 8</td> </tr> <tr> <td>erl_dist [compressed]</td> <td>345</td> <td>47 / 47</td> <td>20 / 20</td> <td>67 / 67</td> </tr> <tr> <td>erl_dist [megaco_compressed,compressed]</td> <td>200</td> <td>34 / 33</td> <td>11 / 9</td> <td>45 / 42</td> </tr> </table> <em>Table 8.1: Codec performance</em> <h2 id="id68463">8.2 System performance characteristics</h2> <p>This is primarily a way to show the effects of using the reentrant flex scanner instead of the non-reentrant. </p> <p>As can be seen from the figures above there is no real difference between a non-reentrant and an reentrant flex scanner when it comes to the decode times of an individual message. </p> <p>The real difference is instead in system characteristics, which is best shown with the mstone1 test. </p> <p>When running SMP erlang on a multi-core machine the "throughput" is significantly higher. The mstone1 test is an extreme test, but it shows what is gained by using the reentrant flex-scanner. </p>  <p><em>Figure 8.1: MStone1 with mstone1.sh -d flex -s 4</em></p> <h2 id="id68500">8.3 Description of encoders/decoders</h2> <p>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</p> <p>The test compares the following encoder/decoders:</p> <ul> <li> <p><strong>pretty</strong> - pretty printed text. In the text encoding, the protocol stack implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. The pretty text encoding utilizes long keywords and an indentation style like the text examples in the Megaco/H.248 specification.</p> </li> <li> <p><strong>compact</strong> - the compact text encoding uses the shortest possible keywords and no optional white spaces.</p> </li> <li> <p><strong>ber</strong> - ASN.1 BER.</p> </li> <li> <p><strong>per</strong> - ASN.1 PER. Not standardized as a valid Megaco/H.248 encoding, but included for the matter of completeness as its encoding is extremely compact.</p> </li> <li> <p><strong>erl_dist</strong> - Erlang's native distribution format. Not standardized as a valid Megaco/H.248 encoding, but included as a reference due to its well known performance characteristics. Erlang is a dynamically typed language and any Erlang data structure may be serialized to the erl_dist format by using built-in functions.</p> </li> </ul> <p>The actual encoded messages have been collected in one directory per encoding type, containing one file per encoded message.</p> <p>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty printed, well indented version with long keywords:</p>  <div class="example"><pre>
MEGACO/1 [124.124.124.222] 
  Transaction = 9998 { 
    Context = - { 
      ServiceChange = ROOT { 
        Services { 
          Method = Restart, 
          ServiceChangeAddress = 55555, 
          Profile = ResGW/1, 
          Reason = "901 MG Cold Boot"
        }
      }  
    }
  }    </pre></div> <p>Then the compact text version without indentation and with short keywords:</p> <div class="example"><pre>
!/1 [124.124.124.222] T=9998{
  C=-{SC=ROOT{SV{MT=RS,AD=55555,PF=ResGW/1,RE="901 MG Cold Boot"}}}}    </pre></div> <h2 id="id68610">8.4 Setup</h2> <p>The measurements has been performed on a HP xw4600 Workstation with a Intel(R) Core(TM)2 Quad CPU Q9550 @ 2.83GHz, with 4 GB memory and running Ubuntu 10.04 x86_64, kernel 2.6.32-22-generic. Software versions was open source OTP R13B04 (megaco-3.14).</p> <h2 id="id68623">8.5 Summary</h2> <p>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</p> <p>When it comes to pure encode/decode performance, it turns out that:</p> <ul> <li> <p>our fastest binary encoder (ber) is about equal to our fastest text encoder (compact). </p> </li> <li> <p>our fastest binary decoder (ber) is about 54% (61%) faster than our fastest text decoder (compact). </p> </li> </ul> <p>If the pure encode/decode performance really is a serious issue, our erl_dist encoder could be used, as the encoding/decoding of the erlang distribution format is much faster than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</p> <p>There is no performance advantage of building (and using) a non-reentrant flex scanner over a reentrant flex scanner (if flex supports building such a scanner). </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Please, observe that these performance figures are related to our implementation in Erlang/OTP. Measurements of other implementations using other tools and techniques may of course result in other figures. </p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
