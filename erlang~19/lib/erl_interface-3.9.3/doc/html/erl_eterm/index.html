
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erl_eterm - Erlang 19 - W3cubDocs</title>
  
  <meta name="description" content=" erl_eterm ">
  <meta name="keywords" content="erl, eterm, -, erlang, erlang~19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~19/lib/erl_interface-3.9.3/doc/html/erl_eterm/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~19/" class="_nav-link" title="" style="margin-left:0;">Erlang 19</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erl_eterm</h1> <h2>C library</h2> <p class="REFBODY">erl_eterm</p> <h2>Library summary</h2> <p class="REFBODY">Functions for Erlang term construction.</p> <h2>Description</h2> 
<p>This module provides functions for creating and manipulating Erlang terms.</p> <p>An Erlang term is represented by a C structure of type <code class="code">ETERM</code>. Applications should not reference any fields in this structure directly, as it can be changed in future releases to provide faster and more compact term storage. Instead, applications should use the macros and functions provided.</p> <p>Each of the following macros takes a single <code class="code">ETERM</code> pointer as an argument. The macros return a non-zero value if the test is true, otherwise <code class="code">0</code>.</p> <dl> <dt><strong><code class="code">ERL_IS_INTEGER(t)</code></strong></dt> <dd>True if <code class="code">t</code> is an integer.</dd> <dt><strong><code class="code">ERL_IS_UNSIGNED_INTEGER(t)</code></strong></dt> <dd>True if <code class="code">t</code> is an integer.</dd> <dt><strong><code class="code">ERL_IS_FLOAT(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a floating point number.</dd> <dt><strong><code class="code">ERL_IS_ATOM(t)</code></strong></dt> <dd>True if <code class="code">t</code> is an atom.</dd> <dt><strong><code class="code">ERL_IS_PID(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a pid (process identifier).</dd> <dt><strong><code class="code">ERL_IS_PORT(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a port.</dd> <dt><strong><code class="code">ERL_IS_REF(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a reference.</dd> <dt><strong><code class="code">ERL_IS_TUPLE(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a tuple.</dd> <dt><strong><code class="code">ERL_IS_BINARY(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a binary.</dd> <dt><strong><code class="code">ERL_IS_LIST(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a list with zero or more elements.</dd> <dt><strong><code class="code">ERL_IS_EMPTY_LIST(t)</code></strong></dt> <dd>True if <code class="code">t</code> is an empty list.</dd> <dt><strong><code class="code">ERL_IS_CONS(t)</code></strong></dt> <dd>True if <code class="code">t</code> is a list with at least one element.</dd> </dl> <p>The following macros can be used for retrieving parts of Erlang terms. None of these do any type checking. Results are undefined if you pass an <code class="code">ETERM*</code> containing the wrong type. For example, passing a tuple to <code class="code">ERL_ATOM_PTR()</code> likely results in garbage.</p> <dl> <dt><strong><code class="code">char *ERL_ATOM_PTR(t)</code></strong></dt>  <dt><strong><code class="code">char *ERL_ATOM_PTR_UTF8(t)</code></strong></dt> <dd>A string representing atom <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_ATOM_SIZE(t)</code></strong></dt>  <dt><strong><code class="code">int ERL_ATOM_SIZE_UTF8(t)</code></strong></dt> <dd>The length (in bytes) of atom <code class="code">t</code>.</dd> <dt><strong><code class="code">void *ERL_BIN_PTR(t)</code></strong></dt> <dd>A pointer to the contents of <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_BIN_SIZE(t)</code></strong></dt> <dd>The length (in bytes) of binary object <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_INT_VALUE(t)</code></strong></dt> <dd>The integer of <code class="code">t</code>.</dd> <dt><strong><code class="code">unsigned int ERL_INT_UVALUE(t)</code></strong></dt> <dd>The unsigned integer value of <code class="code">t</code>.</dd> <dt><strong><code class="code">double ERL_FLOAT_VALUE(t)</code></strong></dt> <dd>The floating point value of <code class="code">t</code>.</dd> <dt><strong><code class="code">ETERM *ERL_PID_NODE(t)</code></strong></dt>  <dt><strong><code class="code">ETERM *ERL_PID_NODE_UTF8(t)</code></strong></dt> <dd>The node in pid <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_PID_NUMBER(t)</code></strong></dt> <dd>The sequence number in pid <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_PID_SERIAL(t)</code></strong></dt> <dd>The serial number in pid <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_PID_CREATION(t)</code></strong></dt> <dd>The creation number in pid <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_PORT_NUMBER(t)</code></strong></dt> <dd>The sequence number in port <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_PORT_CREATION(t)</code></strong></dt> <dd>The creation number in port <code class="code">t</code>.</dd> <dt><strong><code class="code">ETERM *ERL_PORT_NODE(t)</code></strong></dt>  <dt><strong><code class="code">ETERM *ERL_PORT_NODE_UTF8(t)</code></strong></dt> <dd>The node in port <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_REF_NUMBER(t)</code></strong></dt> <dd>The first part of the reference number in ref <code class="code">t</code>. Use only for compatibility.</dd> <dt><strong><code class="code">int ERL_REF_NUMBERS(t)</code></strong></dt> <dd>Pointer to the array of reference numbers in ref <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_REF_LEN(t)</code></strong></dt> <dd>The number of used reference numbers in ref <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_REF_CREATION(t)</code></strong></dt> <dd>The creation number in ref <code class="code">t</code>.</dd> <dt><strong><code class="code">int ERL_TUPLE_SIZE(t)</code></strong></dt> <dd>The number of elements in tuple <code class="code">t</code>.</dd> <dt><strong><code class="code">ETERM *ERL_CONS_HEAD(t)</code></strong></dt> <dd>The head element of list <code class="code">t</code>.</dd> <dt><strong><code class="code">ETERM *ERL_CONS_TAIL(t)</code></strong></dt> <dd>A list representing the tail elements of list <code class="code">t</code>.</dd> </dl>  <h2>Exports</h2> <h3 id="erl_cons" class="code">ETERM *erl_cons(head, tail)</h3>  <p>Types:</p>    <pre>ETERM *head;
ETERM *tail;</pre>

<p>Concatenates two Erlang terms, prepending <code class="code">head</code> onto <code class="code">tail</code> and thereby creating a <code class="code">cons</code> cell. To make a proper list, <code class="code">tail</code> is always to be a list or an empty list. Notice that <code class="code">NULL</code> is not a valid list.</p> <ul> <li> <code class="code">head</code> is the new term to be added.</li> <li> <code class="code">tail</code> is the existing list to which <code class="code">head</code> is concatenated.</li> </ul> <p>The function returns a new list.</p> <p><code class="code">ERL_CONS_HEAD(list)</code> and <code class="code">ERL_CONS_TAIL(list)</code> can be used to retrieve the head and tail components from the list. <code class="code">erl_hd(list)</code> and <code class="code">erl_tl(list)</code> do the same thing, but check that the argument really is a list.</p> <p><strong>Example:</strong></p> <div class="example"><pre>
ETERM *list,*anAtom,*anInt;
anAtom = erl_mk_atom("madonna");
anInt  = erl_mk_int(21);
list   = erl_mk_empty_list();
list   = erl_cons(anAtom, list);
list   = erl_cons(anInt, list);
 ... /* do some work */
erl_free_compound(list);
        </pre></div>  <h3 id="erl_copy_term" class="code">ETERM *erl_copy_term(term)</h3>  <p>Types:</p>   <pre>ETERM *term;</pre>

<p>Creates and returns a copy of the Erlang term <code class="code">term</code>.</p>  <h3 id="erl_element" class="code">ETERM *erl_element(position, tuple)</h3>  <p>Types:</p>    <pre>int position;
ETERM *tuple;</pre>

<p>Extracts a specified element from an Erlang tuple.</p> <ul> <li> <code class="code">position</code> specifies which element to retrieve from <code class="code">tuple</code>. The elements are numbered starting from 1.</li> <li> <code class="code">tuple</code> is an Erlang term containing at least <code class="code">position</code> elements.</li> </ul> <p>Returns a new Erlang term corresponding to the requested element, or <code class="code">NULL</code> if <code class="code">position</code> was greater than the arity of <code class="code">tuple</code>.</p>  <h3 id="erl_hd" class="code">ETERM *erl_hd(list)</h3>  <p>Types:</p>   <pre>ETERM *list;</pre>

<p>Extracts the first element from a list.</p> <p><code class="code">list</code> is an Erlang term containing a list.</p> <p>Returns an Erlang term corresponding to the head head element in the list, or a <code class="code">NULL</code> pointer if <code class="code">list</code> was not a list.</p>  <h3 id="erl_init" class="code">void erl_init(NULL, 0)</h3>  <p>Types:</p>    <pre>void *NULL;
int 0;</pre>

<p>This function must be called before any of the others in the <code class="code">Erl_Interface</code> library to initialize the library functions. The arguments must be specified as <code class="code">erl_init(NULL,0)</code>.</p>  <h3 id="erl_iolist_length" class="code">int erl_iolist_length(list)</h3>  <p>Types:</p>   <pre>ETERM *list;</pre>

<p>Returns the length of an I/O list.</p> <p><code class="code">list</code> is an Erlang term containing an I/O list.</p> <p>Returns the length of <code class="code">list</code>, or <code class="code">-1</code> if <code class="code">list</code> is not an I/O list.</p> <p>For the definition of an I/O list, see <code class="bold_code"><a href="#erl_iolist_to_binary"><span class="code">erl_iolist_to_binary</span></a></code>.</p>  <h3 id="erl_iolist_to_binary" class="code">ETERM *erl_iolist_to_binary(term)</h3>  <p>Types:</p>   <pre>ETERM *list;</pre>

<p>Converts an I/O list to a binary term.</p> <p><code class="code">list</code> is an Erlang term containing a list.</p> <p>Returns an Erlang binary term, or <code class="code">NULL</code> if <code class="code">list</code> was not an I/O list.</p> <p>Informally, an I/O list is a deep list of characters and binaries that can be sent to an Erlang port. In BNF, an I/O list is formally defined as follows:</p> <div class="example"><pre>
iolist ::= []
        |   Binary
        |   [iohead | iolist]
        ;
iohead ::= Binary
        |   Byte (integer in the range [0..255])
        |   iolist
        ;
        </pre></div>  <h3 id="erl_iolist_to_string" class="code">char *erl_iolist_to_string(list)</h3>  <p>Types:</p>   <pre>ETERM *list;</pre>

<p>Converts an I/O list to a <code class="code">NULL</code>-terminated C string.</p> <p><code class="code">list</code> is an Erlang term containing an I/O list. The I/O list must not contain the integer 0, as C strings may not contain this value except as a terminating marker.</p> <p>Returns a pointer to a dynamically allocated buffer containing a string. If <code class="code">list</code> is not an I/O list, or if <code class="code">list</code> contains the integer 0, <code class="code">NULL</code> is returned. It is the caller's responsibility to free the allocated buffer with <code class="code">erl_free()</code>.</p> <p>For the definition of an I/O list, see <code class="bold_code"><a href="#erl_iolist_to_binary"><span class="code">erl_iolist_to_binary</span></a></code>.</p>  <h3 id="erl_length" class="code">int erl_length(list)</h3>  <p>Types:</p>   <pre>ETERM *list;</pre>

<p>Determines the length of a proper list.</p> <p><code class="code">list</code> is an Erlang term containing a proper list. In a proper list, all tails except the last point to another list cell, and the last tail points to an empty list.</p> <p>Returns <code class="code">-1</code> if <code class="code">list</code> is not a proper list.</p>  <h3 id="erl_mk_atom" class="code">ETERM *erl_mk_atom(string)</h3>  <p>Types:</p>   <pre>const char *string;</pre>

<p>Creates an atom.</p> <p><code class="code">string</code> is the sequence of characters that will be used to create the atom.</p> <p>Returns an Erlang term containing an atom. Notice that it is the caller's responsibility to ensure that <code class="code">string</code> contains a valid name for an atom.</p> <p><code class="code">ERL_ATOM_PTR(atom)</code> and <code class="code">ERL_ATOM_PTR_UTF8(atom)</code> can be used to retrieve the atom name (as a <code class="code">NULL</code>-terminated string). <code class="code">ERL_ATOM_SIZE(atom)</code> and <code class="code">ERL_ATOM_SIZE_UTF8(atom)</code> return the length of the atom name.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The UTF-8 variants were introduced in Erlang/OTP R16 and the string returned by <code class="code">ERL_ATOM_PTR(atom)</code> was not <code class="code">NULL</code>-terminated on older releases.</p> </div> </div>  <h3 id="erl_mk_binary" class="code">ETERM *erl_mk_binary(bptr, size)</h3>  <p>Types:</p>    <pre>char *bptr;
int size;</pre>

<p>Produces an Erlang binary object from a buffer containing a sequence of bytes.</p> <ul> <li> <code class="code">bptr</code> is a pointer to a buffer containing data to be converted.</li> <li> <code class="code">size</code> indicates the length of <code class="code">bptr</code>.</li> </ul> <p>Returns an Erlang binary object.</p> <p><code class="code">ERL_BIN_PTR(bin)</code> retrieves a pointer to the binary data. <code class="code">ERL_BIN_SIZE(bin)</code> retrieves the size.</p>  <h3 id="erl_mk_empty_list" class="code">ETERM *erl_mk_empty_list()</h3> 
<p>Creates and returns an empty Erlang list. Notice that <code class="code">NULL</code> is not used to represent an empty list; Use this function instead.</p>  <h3 id="erl_mk_estring" class="code">ETERM *erl_mk_estring(string, len)</h3>  <p>Types:</p>    <pre>char *string;
int len;</pre>

<p>Creates a list from a sequence of bytes.</p> <ul> <li> <code class="code">string</code> is a buffer containing a sequence of bytes. The buffer does not need to be <code class="code">NULL</code>-terminated.</li> <li> <code class="code">len</code> is the length of <code class="code">string</code>.</li> </ul> <p>Returns an Erlang list object corresponding to the character sequence in <code class="code">string</code>.</p>  <h3 id="erl_mk_float" class="code">ETERM *erl_mk_float(f)</h3>  <p>Types:</p>   <pre>double f;</pre>

<p>Creates an Erlang float.</p> <p><code class="code">f</code> is a value to be converted to an Erlang float.</p> <p>Returns an Erlang float object with the value specified in <code class="code">f</code> or <code class="code">NULL</code> if <code class="code">f</code> is not finite.</p> <p><code class="code">ERL_FLOAT_VALUE(t)</code> can be used to retrieve the value from an Erlang float.</p>  <h3 id="erl_mk_int" class="code">ETERM *erl_mk_int(n)</h3>  <p>Types:</p>   <pre>int n;</pre>

<p>Creates an Erlang integer.</p> <p><code class="code">n</code> is a value to be converted to an Erlang integer.</p> <p>Returns an Erlang integer object with the value specified in <code class="code">n</code>.</p> <p><code class="code">ERL_INT_VALUE(t)</code> can be used to retrieve the value from an Erlang integer.</p>  <h3 id="erl_mk_list" class="code">ETERM *erl_mk_list(array, arrsize)</h3>  <p>Types:</p>    <pre>ETERM **array;
int arrsize;</pre>

<p>Creates an Erlang list from an array of Erlang terms, such that each element in the list corresponds to one element in the array.</p> <ul> <li> <code class="code">array</code> is an array of Erlang terms.</li> <li> <code class="code">arrsize</code> is the number of elements in <code class="code">array</code>.</li> </ul> <p>The function creates an Erlang list object, whose length <code class="code">arrsize</code> and whose elements are taken from the terms in <code class="code">array</code>.</p>  <h3 id="erl_mk_long_ref" class="code">ETERM *erl_mk_long_ref(node, n1, n2, n3, creation)</h3>  <p>Types:</p>     <pre>const char *node;
unsigned int n1, n2, n3;
unsigned int creation;</pre>

<p>Creates an Erlang reference, with 82 bits.</p> <ul> <li> <code class="code">node</code> is the name of the C-node.</li> <li> <code class="code">n1</code>, <code class="code">n2</code>, and <code class="code">n3</code> can be seen as one big number <code class="code">n1*2^64+n2*2^32+n3</code>, which is to be chosen uniquely for each reference created for a given C-node.</li> <li> <code class="code">creation</code> is an arbitrary number.</li> </ul> <p>Notice that <code class="code">n3</code> and <code class="code">creation</code> are limited in precision, so only the low 18 and 2 bits of these numbers are used.</p> <p>Returns an Erlang reference object.</p> <p><code class="code">ERL_REF_NODE(ref)</code>, <code class="code">ERL_REF_NUMBERS(ref)</code>, <code class="code">ERL_REF_LEN(ref)</code>, and <code class="code">ERL_REF_CREATION(ref)</code> can be used to retrieve the values used to create the reference.</p>  <h3 id="erl_mk_pid" class="code">ETERM *erl_mk_pid(node, number, serial, creation)</h3>  <p>Types:</p>      <pre>const char *node;
unsigned int number;
unsigned int serial;
unsigned int creation;</pre>

<p>Creates an Erlang process identifier (pid). The resulting pid can be used by Erlang processes wishing to communicate with the C-node.</p> <ul> <li> <code class="code">node</code> is the name of the C-node.</li> <li> <code class="code">number</code>, <code class="code">serial</code>, and <code class="code">creation</code> are arbitrary numbers. Notice that these are limited in precision, so only the low 15, 3, and 2 bits of these numbers are used.</li> </ul> <p>Returns an Erlang pid object.</p> <p><code class="code">ERL_PID_NODE(pid)</code>, <code class="code">ERL_PID_NUMBER(pid)</code>, <code class="code">ERL_PID_SERIAL(pid)</code>, and <code class="code">ERL_PID_CREATION(pid)</code> can be used to retrieve the four values used to create the pid.</p>  <h3 id="erl_mk_port" class="code">ETERM *erl_mk_port(node, number, creation)</h3>  <p>Types:</p>     <pre>const char *node;
unsigned int number;
unsigned int creation;</pre>

<p>Creates an Erlang port identifier.</p> <ul> <li> <code class="code">node</code> is the name of the C-node.</li> <li> <code class="code">number</code> and <code class="code">creation</code> are arbitrary numbers. Notice that these are limited in precision, so only the low 18 and 2 bits of these numbers are used.</li> </ul> <p>Returns an Erlang port object.</p> <p><code class="code">ERL_PORT_NODE(port)</code>, <code class="code">ERL_PORT_NUMBER(port)</code>, and <code class="code">ERL_PORT_CREATION</code> can be used to retrieve the three values used to create the port.</p>  <h3 id="erl_mk_ref" class="code">ETERM *erl_mk_ref(node, number, creation)</h3>  <p>Types:</p>     <pre>const char *node;
unsigned int number;
unsigned int creation;</pre>

<p>Creates an old Erlang reference, with only 18 bits - use <code class="code">erl_mk_long_ref</code> instead.</p> <ul> <li> <code class="code">node</code> is the name of the C-node.</li> <li> <code class="code">number</code> is to be chosen uniquely for each reference created for a given C-node.</li> <li> <code class="code">creation</code> is an arbitrary number.</li> </ul> <p>Notice that <code class="code">number</code> and <code class="code">creation</code> are limited in precision, so only the low 18 and 2 bits of these numbers are used.</p> <p>Returns an Erlang reference object.</p> <p><code class="code">ERL_REF_NODE(ref)</code>, <code class="code">ERL_REF_NUMBER(ref)</code>, and <code class="code">ERL_REF_CREATION(ref)</code> can be used to retrieve the three values used to create the reference.</p>  <h3 id="erl_mk_string" class="code">ETERM *erl_mk_string(string)</h3>  <p>Types:</p>   <pre>char *string;</pre>

<p>Creates a list from a <code class="code">NULL</code>-terminated string.</p> <p><code class="code">string</code> is a <code class="code">NULL</code>-terminated sequence of characters (that is, a C string) from which the list will be created.</p> <p>Returns an Erlang list.</p>  <h3 id="erl_mk_tuple" class="code">ETERM *erl_mk_tuple(array, arrsize)</h3>  <p>Types:</p>    <pre>ETERM **array;
int arrsize;</pre>

<p>Creates an Erlang tuple from an array of Erlang terms.</p> <ul> <li> <code class="code">array</code> is an array of Erlang terms.</li> <li> <code class="code">arrsize</code> is the number of elements in <code class="code">array</code>.</li> </ul> <p>The function creates an Erlang tuple, whose arity is <code class="code">size</code> and whose elements are taken from the terms in <code class="code">array</code>.</p> <p>To retrieve the size of a tuple, either use function <code class="code">erl_size</code> (which checks the type of the checked term and works for a binary as well as for a tuple) or <code class="code">ERL_TUPLE_SIZE(tuple)</code> returns the arity of a tuple. <code class="code">erl_size()</code> does the same thing, but it checks that the argument is a tuple. <code class="code">erl_element(index,tuple)</code> returns the element corresponding to a given position in the tuple.</p>  <h3 id="erl_mk_uint" class="code">ETERM *erl_mk_uint(n)</h3>  <p>Types:</p>   <pre>unsigned int n;</pre>

<p>Creates an Erlang unsigned integer.</p> <p><code class="code">n</code> is a value to be converted to an Erlang unsigned integer.</p> <p>Returns an Erlang unsigned integer object with the value specified in <code class="code">n</code>.</p> <p><code class="code">ERL_INT_UVALUE(t)</code> can be used to retrieve the value from an Erlang unsigned integer.</p>  <h3 id="erl_mk_var" class="code">ETERM *erl_mk_var(name)</h3>  <p>Types:</p>   <pre>char *name;</pre>

<p>Creates an unbound Erlang variable. The variable can later be bound through pattern matching or assignment.</p> <p><code class="code">name</code> specifies a name for the variable.</p> <p>Returns an Erlang variable object with the name <code class="code">name</code>.</p>  <h3 id="erl_print_term" class="code">int erl_print_term(stream, term)</h3>  <p>Types:</p>    <pre>FILE *stream;
ETERM *term;</pre>

<p>Prints the specified Erlang term to the specified output stream.</p> <ul> <li> <code class="code">stream</code> indicates where the function is to send its output.</li> <li> <code class="code">term</code> is the Erlang term to print.</li> </ul> <p>Returns the number of characters written on success, otherwise a negative value.</p>  <h3 id="erl_set_compat_rel" class="code">void erl_set_compat_rel(release_number)</h3>  <p>Types:</p>   <pre>unsigned release_number;</pre>

<p>By default, the <code class="code">Erl_Interface</code> library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the <code class="code">Erl_Interface</code> library itself. For example, <code class="code">Erl_Interface</code> from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</p> <p>A call to <code class="code">erl_set_compat_rel(release_number)</code> sets the <code class="code">Erl_Interface</code> library in compatibility mode of release <code class="code">release_number</code>. Valid range of <code class="code">release_number</code> is [7, current release]. This makes it possible to communicate with Erlang/OTP components from earlier releases.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>If this function is called, it may only be called once directly after the call to function <code class="bold_code"><a href="#erl_init">erl_init()</a></code>.</p> </div> </div> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>You may run into trouble if this feature is used carelessly. Always ensure that all communicating components are either from the same Erlang/OTP release, or from release X and release Y where all components from release Y are in compatibility mode of release X.</p> </div> </div>  <h3 id="erl_size" class="code">int erl_size(term)</h3>  <p>Types:</p>   <pre>ETERM *term;</pre>

<p>Returns either the arity of an Erlang tuple or the number of bytes in an Erlang binary object.</p> <p><code class="code">term</code> is an Erlang tuple or an Erlang binary object.</p> <p>Returns the size of <code class="code">term</code> as described above, or <code class="code">-1</code> if <code class="code">term</code> is not one of the two supported types.</p>  <h3 id="erl_tl" class="code">ETERM *erl_tl(list)</h3>  <p>Types:</p>   <pre>ETERM *list;</pre>

<p>Extracts the tail from a list.</p> <p><code class="code">list</code> is an Erlang term containing a list.</p> <p>Returns an Erlang list corresponding to the original list minus the first element, or <code class="code">NULL</code> pointer if <code class="code">list</code> was not a list.</p>  <h3 id="erl_var_content" class="code">ETERM *erl_var_content(term, name)</h3>  <p>Types:</p>    <pre>ETERM *term;
char *name;</pre>

<p>Returns the contents of the specified variable in an Erlang term.</p> <ul> <li> <code class="code">term</code> is an Erlang term. In order for this function to succeed, <code class="code">term</code> must either be an Erlang variable with the specified name, or it must be an Erlang list or tuple containing a variable with the specified name. Other Erlang types cannot contain variables.</li> <li> <code class="code">name</code> is the name of an Erlang variable. </li> </ul> <p>Returns the Erlang object corresponding to the value of <code class="code">name</code> in <code class="code">term</code>. If no variable with the name <code class="code">name</code> is found in <code class="code">term</code>, or if <code class="code">term</code> is not a valid Erlang term, <code class="code">NULL</code> is returned.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
