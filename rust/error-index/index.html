
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Compiler Errors - Rust - W3cubDocs</title>
  
  <meta name="description" content="This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression &hellip;">
  <meta name="keywords" content="rust, compiler, error, index, errors, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/error-index/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1>Rust Compiler Error Index</h1> <h3 id="E0001" class="section-header">E0001</h3> <h3 id="note-this-error-code-is-no-longer-emitted-by-the-compiler" class="section-header">Note: this error code is no longer emitted by the compiler.</h3> <p>This error suggests that the expression arm corresponding to the noted pattern will never be reached as for all possible values of the expression being matched, one of the preceding patterns will match.</p> <p>This means that perhaps some of the preceding patterns are too general, this one is too specific or the ordering is incorrect.</p> <p>For example, the following <code>match</code> block has too many arms:</p> <pre class="rust rust-example-rendered" data-language="rust">
match Some(0) {
    Some(bar) =&gt; {/* ... */}
    x =&gt; {/* ... */} // This handles the `None` case
    _ =&gt; {/* ... */} // All possible cases have already been handled
}</pre> <p><code>match</code> blocks have their patterns matched in order, so, for example, putting a wildcard arm above a more specific arm will make the latter arm irrelevant.</p> <p>Ensure the ordering of the match arm is correct and remove any superfluous arms.</p>  <h3 id="E0002" class="section-header">E0002</h3> <h3 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-1" class="section-header">Note: this error code is no longer emitted by the compiler.</h3> <p>This error indicates that an empty match expression is invalid because the type it is matching on is non-empty (there exist values of this type). In safe code it is impossible to create an instance of an empty type, so empty match expressions are almost never desired. This error is typically fixed by adding one or more cases to the match expression.</p> <p>An example of an empty type is <code>enum Empty { }</code>. So, the following will work:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Empty {}

fn foo(x: Empty) {
    match x {
        // empty
    }
}</pre> <p>However, this won't:</p> <pre>fn foo(x: Option&lt;String&gt;) {
    match x {
        // empty
    }
}
</pre>  <h3 id="E0003" class="section-header">E0003</h3> <h3 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-2" class="section-header">Note: this error code is no longer emitted by the compiler.</h3> <p>Not-a-Number (NaN) values cannot be compared for equality and hence can never match the input to a match expression. So, the following will not compile:</p> <pre>const NAN: f32 = 0.0 / 0.0;

let number = 0.1f32;

match number {
    NAN =&gt; { /* ... */ },
    _ =&gt; {}
}
</pre> <p>To match against NaN values, you should instead use the <code>is_nan()</code> method in a guard, like so:</p> <pre class="rust rust-example-rendered" data-language="rust">
let number = 0.1f32;

match number {
    x if x.is_nan() =&gt; { /* ... */ }
    _ =&gt; {}
}</pre>  <h3 id="E0004" class="section-header">E0004</h3> <p>This error indicates that the compiler cannot guarantee a matching pattern for one or more possible inputs to a match expression. Guaranteed matches are required in order to assign values to match expressions, or alternatively, determine the flow of execution. Erroneous code example:</p> <pre>enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand =&gt; {}
}
</pre> <p>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore <code>_</code> wildcard pattern can be added after all other patterns to match "anything else". Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x {
    Terminator::TalkToMyHand =&gt; {}
    Terminator::HastaLaVistaBaby =&gt; {}
}

// or:

match x {
    Terminator::TalkToMyHand =&gt; {}
    _ =&gt; {}
}</pre>  <h3 id="E0005" class="section-header">E0005</h3> <p>Patterns used to bind names must be irrefutable, that is, they must guarantee that a name will be extracted in all cases. Erroneous code example:</p> <pre>let x = Some(1);
let Some(y) = x;
// error: refutable pattern in local binding: `None` not covered
</pre> <p>If you encounter this error you probably need to use a <code>match</code> or <code>if let</code> to deal with the possibility of failure. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = Some(1);

match x {
    Some(y) =&gt; {
        // do something
    },
    None =&gt; {}
}

// or:

if let Some(y) = x {
    // do something
}</pre>  <h3 id="E0007" class="section-header">E0007</h3> <p>This error indicates that the bindings in a match arm would require a value to be moved into more than one location, thus violating unique ownership. Code like the following is invalid as it requires the entire <code>Option&lt;String&gt;</code> to be moved into a variable called <code>op_string</code> while simultaneously requiring the inner <code>String</code> to be moved into a variable called <code>s</code>.</p> <pre>let x = Some("s".to_string());

match x {
    op_string @ Some(s) =&gt; {}, // error: cannot bind by-move with sub-bindings
    None =&gt; {},
}
</pre> <p>See also the error E0303.</p>  <h3 id="E0008" class="section-header">E0008</h3> <p>Names bound in match arms retain their type in pattern guards. As such, if a name is bound by move in a pattern, it should also be moved to wherever it is referenced in the pattern guard code. Doing so however would prevent the name from being available in the body of the match arm. Consider the following:</p> <pre>match Some("hi".to_string()) {
    Some(s) if s.len() == 0 =&gt; {}, // use s.
    _ =&gt; {},
}
</pre> <p>The variable <code>s</code> has type <code>String</code>, and its use in the guard is as a variable of type <code>String</code>. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</p> <p>The problem above can be solved by using the <code>ref</code> keyword.</p> <pre class="rust rust-example-rendered" data-language="rust">
match Some("hi".to_string()) {
    Some(ref s) if s.len() == 0 =&gt; {},
    _ =&gt; {},
}</pre> <p>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</p> <pre>struct A{}

impl A {
    fn consume(self) -&gt; usize {
        0
    }
}

fn main() {
    let a = Some(A{});
    match a {
        Some(y) if y.consume() &gt; 0 =&gt; {}
        _ =&gt; {}
    }
}
</pre> <p>In this situation, even the <code>ref</code> keyword cannot solve it, since borrowed content cannot be moved. This problem cannot be solved generally. If the value can be cloned, here is a not-so-specific solution:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone)]
struct A{}

impl A {
    fn consume(self) -&gt; usize {
        0
    }
}

fn main() {
    let a = Some(A{});
    match a{
        Some(ref y) if y.clone().consume() &gt; 0 =&gt; {}
        _ =&gt; {}
    }
}</pre> <p>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</p>  <h3 id="E0009" class="section-header">E0009</h3> <p>In a pattern, all values that don't implement the <code>Copy</code> trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</p> <p>This limitation may be removed in a future version of Rust.</p> <p>Erroneous code example:</p> <pre>struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {}, // error: cannot bind by-move and by-ref in the
                            //        same pattern
    None =&gt; panic!()
}
</pre> <p>You have two solutions:</p> <p>Solution #1: Bind the pattern's values the same way.</p> <pre class="rust rust-example-rendered" data-language="rust">
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((ref y, ref z)) =&gt; {},
    // or Some((y, z)) =&gt; {}
    None =&gt; panic!()
}</pre> <p>Solution #2: Implement the <code>Copy</code> trait for the <code>X</code> structure.</p> <p>However, please keep in mind that the first solution should be preferred.</p> <pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)]
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {},
    None =&gt; panic!()
}</pre>  <h3 id="E0020" class="section-header">E0020</h3> <p>This error indicates that an attempt was made to divide by zero (or take the remainder of a zero divisor) in a static or constant expression. Erroneous code example:</p> <pre>#[deny(const_err)]

const X: i32 = 42 / 0;
// error: attempt to divide by zero in a constant expression
</pre>  <h3 id="E0023" class="section-header">E0023</h3> <p>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}</pre> <p>Here the <code>Apple</code> variant has two fields, and should be matched against like so:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Correct.
match x {
    Fruit::Apple(a, b) =&gt; {},
    _ =&gt; {}
}</pre> <p>Matching with the wrong number of fields has no sensible interpretation:</p> <pre>enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Incorrect.
match x {
    Fruit::Apple(a) =&gt; {},
    Fruit::Apple(a, b, c) =&gt; {},
}
</pre> <p>Check how many fields the enum was declared with and ensure that your pattern uses the same number.</p>  <h3 id="E0025" class="section-header">E0025</h3> <p>Each field of a struct can only be bound once in a pattern. Erroneous code example:</p> <pre>struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, a: y } = x;
    // error: field `a` bound multiple times in the pattern
}
</pre> <p>Each occurrence of a field name binds the value of that field, so to fix this error you will have to remove or alter the duplicate uses of the field name. Perhaps you misspelled another field name? Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, b: y } = x; // ok!
}</pre>  <h3 id="E0026" class="section-header">E0026</h3> <p>This error indicates that a struct pattern attempted to extract a non-existent field from a struct. Struct fields are identified by the name used before the colon <code>:</code> so struct patterns should resemble the declaration of the struct type being matched.</p> <pre class="rust rust-example-rendered" data-language="rust">
// Correct matching.
struct Thing {
    x: u32,
    y: u32
}

let thing = Thing { x: 1, y: 2 };

match thing {
    Thing { x: xfield, y: yfield } =&gt; {}
}</pre> <p>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</p> <p>Change this:</p> <pre>struct Thing {
    x: u32,
    y: u32
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, z } =&gt; {}
}
</pre> <p>To this:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Thing {
    x: u32,
    y: u32
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, y: z } =&gt; {}
}</pre>  <h3 id="E0027" class="section-header">E0027</h3> <p>This error indicates that a pattern for a struct fails to specify a sub-pattern for every one of the struct's fields. Ensure that each field from the struct's definition is mentioned in the pattern, or use <code>..</code> to ignore unwanted fields.</p> <p>For example:</p> <pre>struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

// This is incorrect.
match d {
    Dog { age: x } =&gt; {}
}
</pre> <p>This is correct (explicit):</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: "Rusty".to_string(), age: 8 };

match d {
    Dog { name: ref n, age: x } =&gt; {}
}

// This is also correct (ignore unused fields).
match d {
    Dog { age: x, .. } =&gt; {}
}</pre>  <h3 id="E0029" class="section-header">E0029</h3> <p>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</p> <pre>let string = "salutations !";

// The ordering relation for strings can't be evaluated at compile time,
// so this doesn't work:
match string {
    "hello" ... "world" =&gt; {}
    _ =&gt; {}
}

// This is a more general version, using a guard:
match string {
    s if s &gt;= "hello" &amp;&amp; s &lt;= "world" =&gt; {}
    _ =&gt; {}
}
</pre>  <h3 id="E0033" class="section-header">E0033</h3> <p>This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</p> <pre class="rust rust-example-rendered" data-language="rust">
let trait_obj: &amp;SomeTrait = ...;

// This tries to implicitly dereference to create an unsized local variable.
let &amp;invalid = trait_obj;

// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();</pre> <p>You can read more about trait objects in the Trait Object section of the Reference:</p> <p><a href="../reference/#trait-objects">https://doc.rust-lang.org/reference.html#trait-objects</a></p>  <h3 id="E0034" class="section-header">E0034</h3> <p>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</p> <pre>struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    Test::foo() // error, which foo() to call?
}
</pre> <p>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }

fn main() {
    Test::foo() // and now that's good!
}</pre> <p>However, a better solution would be using fully explicit naming of type and trait:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    &lt;Test as Trait1&gt;::foo()
}</pre> <p>One last example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait F {
    fn m(&amp;self);
}

trait G {
    fn m(&amp;self);
}

struct X;

impl F for X { fn m(&amp;self) { println!("I am F"); } }
impl G for X { fn m(&amp;self) { println!("I am G"); } }

fn main() {
    let f = X;

    F::m(&amp;f); // it displays "I am F"
    G::m(&amp;f); // it displays "I am G"
}</pre>  <h3 id="E0035" class="section-header">E0035</h3> <p>You tried to give a type parameter where it wasn't needed. Erroneous code example:</p> <pre>struct Test;

impl Test {
    fn method(&amp;self) {}
}

fn main() {
    let x = Test;

    x.method::&lt;i32&gt;(); // Error: Test::method doesn't need type parameter!
}
</pre> <p>To fix this error, just remove the type parameter:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Test;

impl Test {
    fn method(&amp;self) {}
}

fn main() {
    let x = Test;

    x.method(); // OK, we're good!
}</pre>  <h3 id="E0036" class="section-header">E0036</h3> <p>This error occurrs when you pass too many or not enough type parameters to a method. Erroneous code example:</p> <pre>struct Test;

impl Test {
    fn method&lt;T&gt;(&amp;self, v: &amp;[T]) -&gt; usize {
        v.len()
    }
}

fn main() {
    let x = Test;
    let v = &amp;[0];

    x.method::&lt;i32, i32&gt;(v); // error: only one type parameter is expected!
}
</pre> <p>To fix it, just specify a correct number of type parameters:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Test;

impl Test {
    fn method&lt;T&gt;(&amp;self, v: &amp;[T]) -&gt; usize {
        v.len()
    }
}

fn main() {
    let x = Test;
    let v = &amp;[0];

    x.method::&lt;i32&gt;(v); // OK, we're good!
}</pre> <p>Please note on the last example that we could have called <code>method</code> like this:</p> <pre class="rust rust-example-rendered" data-language="rust">
x.method(v);</pre>  <h3 id="E0038" class="section-header">E0038</h3> <p>Trait objects like <code>Box&lt;Trait&gt;</code> can only be constructed when certain requirements are satisfied by the trait in question.</p> <p>Trait objects are a form of dynamic dispatch and use a dynamically sized type for the inner type. So, for a given trait <code>Trait</code>, when <code>Trait</code> is treated as a type, as in <code>Box&lt;Trait&gt;</code>, the inner type is 'unsized'. In such cases the boxed pointer is a 'fat pointer' that contains an extra pointer to a table of methods (among other things) for dynamic dispatch. This design mandates some restrictions on the types of traits that are allowed to be used in trait objects, which are collectively termed as 'object safety' rules.</p> <p>Attempting to create a trait object for a non object-safe trait will trigger this error.</p> <p>There are various rules:</p> <h3 id="the-trait-cannot-require-self-sized" class="section-header">The trait cannot require <code>Self: Sized</code>
</h3> <p>When <code>Trait</code> is treated as a type, the type does not implement the special <code>Sized</code> trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo where Self: Sized {

}</pre> <p>We cannot create an object of type <code>Box&lt;Foo&gt;</code> or <code>&amp;Foo</code> since in this case <code>Self</code> would not be <code>Sized</code>.</p> <p>Generally, <code>Self : Sized</code> is used to indicate that the trait should not be used as a trait object. If the trait comes from your own crate, consider removing this restriction.</p> <h3 id="method-references-the-self-type-in-its-arguments-or-return-type" class="section-header">Method references the <code>Self</code> type in its arguments or return type</h3> <p>This happens when a trait has a method like the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

impl Trait for String {
    fn foo(&amp;self) -&gt; Self {
        "hi".to_owned()
    }
}

impl Trait for u8 {
    fn foo(&amp;self) -&gt; Self {
        1
    }
}</pre> <p>(Note that <code>&amp;self</code> and <code>&amp;mut self</code> are okay, it's additional <code>Self</code> types which cause this problem.)</p> <p>In such a case, the compiler cannot predict the return type of <code>foo()</code> in a situation like the following:</p> <pre>trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

fn call_foo(x: Box&lt;Trait&gt;) {
    let y = x.foo(); // What type is y?
    // ...
}
</pre> <p>If only some methods aren't object-safe, you can add a <code>where Self: Sized</code> bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including <code>Box&lt;Trait&gt;</code> which is itself sized (assuming you <code>impl Trait for Box&lt;Trait&gt;</code>).</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self) -&gt; Self where Self: Sized;
    // more functions
}</pre> <p>Now, <code>foo()</code> can no longer be called on a trait object, but you will now be allowed to make a trait object, and that will be able to call any object-safe methods. With such a bound, one can still call <code>foo()</code> on types implementing that trait that aren't behind trait objects.</p> <h3 id="method-has-generic-type-parameters" class="section-header">Method has generic type parameters</h3> <p>As mentioned before, trait objects contain pointers to method tables. So, if we have:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo(&amp;self);
}

impl Trait for String {
    fn foo(&amp;self) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo(&amp;self) {
        // implementation 2
    }
}
// ...</pre> <p>At compile time each implementation of <code>Trait</code> will produce a table containing the various methods (and other items) related to the implementation.</p> <p>This works fine, but when the method gains generic parameters, we can have a problem.</p> <p>Usually, generic parameters get <em>monomorphized</em>. For example, if I have</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    // ...
}</pre> <p>The machine code for <code>foo::&lt;u8&gt;()</code>, <code>foo::&lt;bool&gt;()</code>, <code>foo::&lt;String&gt;()</code>, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call <code>foo()</code> with a <code>bool</code> parameter, the compiler will only generate code for <code>foo::&lt;bool&gt;()</code>. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</p> <p>However, with trait objects we have to make a table containing <em>every</em> object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</p> <p>For example, with:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T);
    // more methods
}

impl Trait for String {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 2
    }
}

// 8 more implementations</pre> <p>Now, if we have the following code:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn call_foo(thing: Box&lt;Trait&gt;) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo("hello");
}</pre> <p>We don't just need to create a table of all implementations of all methods of <code>Trait</code>, we need to create such a table, for each different type fed to <code>foo()</code>. In this case this turns out to be (10 types implementing <code>Trait</code>)*(3 types being fed to <code>foo()</code>) = 30 implementations!</p> <p>With real world traits these numbers can grow drastically.</p> <p>To fix this, it is suggested to use a <code>where Self: Sized</code> bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;
    // more methods
}</pre> <p>If this is not an option, consider replacing the type parameter with another trait object (e.g. if <code>T: OtherTrait</code>, use <code>on: Box&lt;OtherTrait&gt;</code>). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</p> <h3 id="method-has-no-receiver" class="section-header">Method has no receiver</h3> <p>Methods that do not take a <code>self</code> parameter can't be called since there won't be a way to get a pointer to the method table for them.</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo() -&gt; u8;
}</pre> <p>This could be called as <code>&lt;Foo as Foo&gt;::foo()</code>, which would not be able to pick an implementation.</p> <p>Adding a <code>Self: Sized</code> bound to these methods will generally make this compile.</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo() -&gt; u8 where Self: Sized;
}</pre> <h3 id="the-trait-cannot-use-self-as-a-type-parameter-in-the-supertrait-listing" class="section-header">The trait cannot use <code>Self</code> as a type parameter in the supertrait listing</h3> <p>This is similar to the second sub-error, but subtler. It happens in situations like the following:</p> <pre>trait Super&lt;A&gt; {}

trait Trait: Super&lt;Self&gt; {
}

struct Foo;

impl Super&lt;Foo&gt; for Foo{}

impl Trait for Foo {}
</pre> <p>Here, the supertrait might have methods as follows:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Super&lt;A&gt; {
    fn get_a(&amp;self) -&gt; A; // note that this is object safe!
}</pre> <p>If the trait <code>Foo</code> was deriving from something like <code>Super&lt;String&gt;</code> or <code>Super&lt;T&gt;</code> (where <code>Foo</code> itself is <code>Foo&lt;T&gt;</code>), this is okay, because given a type <code>get_a()</code> will definitely return an object of that type.</p> <p>However, if it derives from <code>Super&lt;Self&gt;</code>, even though <code>Super</code> is object safe, the method <code>get_a()</code> would return an object of unknown type when called on the function. <code>Self</code> type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</p> <p>There's no easy fix for this, generally code will need to be refactored so that you no longer need to derive from <code>Super&lt;Self&gt;</code>.</p>  <h3 id="E0040" class="section-header">E0040</h3> <p>It is not allowed to manually call destructors in Rust. It is also not necessary to do this since <code>drop</code> is called automatically whenever a value goes out of scope.</p> <p>Here's an example of this error:</p> <pre>struct Foo {
    x: i32,
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!("kaboom");
    }
}

fn main() {
    let mut x = Foo { x: -7 };
    x.drop(); // error: explicit use of destructor method
}
</pre>  <h3 id="E0044" class="section-header">E0044</h3> <p>You can't use type parameters on foreign items. Example of erroneous code:</p> <pre>extern { fn some_func&lt;T&gt;(x: T); }
</pre> <p>To fix this, replace the type parameter with the specializations that you need:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern { fn some_func_i32(x: i32); }
extern { fn some_func_i64(x: i64); }</pre>  <h3 id="E0045" class="section-header">E0045</h3> <p>Rust only supports variadic parameters for interoperability with C code in its FFI. As such, variadic parameters can only be used with functions which are using the C ABI. Examples of erroneous code:</p> <pre>#![feature(unboxed_closures)]

extern "rust-call" { fn foo(x: u8, ...); }

// or

fn foo(x: u8, ...) {}
</pre> <p>To fix such code, put them in an extern "C" block:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern "C" {
    fn foo (x: u8, ...);
}</pre>  <h3 id="E0046" class="section-header">E0046</h3> <p>Items are missing in a trait implementation. Erroneous code example:</p> <pre>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {}
// error: not all trait items implemented, missing: `foo`
</pre> <p>When trying to make some type implement a trait <code>Foo</code>, you must, at minimum, provide implementations for all of <code>Foo</code>'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}</pre>  <h3 id="E0049" class="section-header">E0049</h3> <p>This error indicates that an attempted implementation of a trait method has the wrong number of type parameters.</p> <p>For example, the trait below has a method <code>foo</code> with a type parameter <code>T</code>, but the implementation of <code>foo</code> for the type <code>Bar</code> is missing this parameter:</p> <pre>trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

// error: method `foo` has 0 type parameters but its trait declaration has 1
// type parameter
impl Foo for Bar {
    fn foo(x: bool) -&gt; Self { Bar }
}
</pre>  <h3 id="E0050" class="section-header">E0050</h3> <p>This error indicates that an attempted implementation of a trait method has the wrong number of function parameters.</p> <p>For example, the trait below has a method <code>foo</code> with two function parameters (<code>&amp;self</code> and <code>u8</code>), but the implementation of <code>foo</code> for the type <code>Bar</code> omits the <code>u8</code> parameter:</p> <pre>trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`
// has 2
impl Foo for Bar {
    fn foo(&amp;self) -&gt; bool { true }
}
</pre>  <h3 id="E0053" class="section-header">E0053</h3> <p>The parameters of any trait method must match between a trait implementation and the trait definition.</p> <p>Here are a couple examples of this error:</p> <pre>trait Foo {
    fn foo(x: u16);
    fn bar(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, expected u16, found i16
    fn foo(x: i16) { }

    // error, types differ in mutability
    fn bar(&amp;mut self) { }
}
</pre>  <h3 id="E0054" class="section-header">E0054</h3> <p>It is not allowed to cast to a bool. If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</p> <pre>let x = 5;

// Not allowed, won't compile
let x_is_nonzero = x as bool;
</pre> <pre class="rust rust-example-rendered" data-language="rust">
let x = 5;

// Ok
let x_is_nonzero = x != 0;</pre>  <h3 id="E0055" class="section-header">E0055</h3> <p>During a method call, a value is automatically dereferenced as many times as needed to make the value's type match the method's receiver. The catch is that the compiler will only attempt to dereference a number of times up to the recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p> <p>For a somewhat artificial example:</p> <pre>#![recursion_limit="2"]

struct Foo;

impl Foo {
    fn foo(&amp;self) {}
}

fn main() {
    let foo = Foo;
    let ref_foo = &amp;&amp;Foo;

    // error, reached the recursion limit while auto-dereferencing &amp;&amp;Foo
    ref_foo.foo();
}
</pre> <p>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</p>  <h3 id="E0057" class="section-header">E0057</h3> <p>When invoking closures or other implementations of the function traits <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> using call notation, the number of parameters passed to the function must match its definition.</p> <p>An example using a closure:</p> <pre>let f = |x| x * 3;
let a = f();        // invalid, too few parameters
let b = f(4);       // this works!
let c = f(2, 3);    // invalid, too many parameters
</pre> <p>A generic function must be treated similarly:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: Fn()&gt;(f: F) {
    f(); // this is valid, but f(3) would not work
}</pre>  <h3 id="E0059" class="section-header">E0059</h3> <p>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (<code>Fn&lt;(T,), Output=U&gt;</code>) instead of parentheses (<code>Fn(T) -&gt; U</code>) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</p> <p>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</p> <pre>#![feature(unboxed_closures)]

fn foo&lt;F: Fn&lt;i32&gt;&gt;(f: F) -&gt; F::Output { f(3) }
</pre> <p>It can be fixed by adjusting the trait bound like this:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(unboxed_closures)]

fn foo&lt;F: Fn&lt;(i32,)&gt;&gt;(f: F) -&gt; F::Output { f(3) }</pre> <p>Note that <code>(T,)</code> always denotes the type of a 1-tuple containing an element of type <code>T</code>. The comma is necessary for syntactic disambiguation.</p>  <h3 id="E0060" class="section-header">E0060</h3> <p>External C functions are allowed to be variadic. However, a variadic function takes a minimum number of arguments. For example, consider C's variadic <code>printf</code> function:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate libc;
use libc::{ c_char, c_int };

extern "C" {
    fn printf(_: *const c_char, ...) -&gt; c_int;
}</pre> <p>Using this declaration, it must be called with at least one argument, so simply calling <code>printf()</code> is invalid. But the following uses are allowed:</p> <pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    use std::ffi::CString;

    printf(CString::new("test\n").unwrap().as_ptr());
    printf(CString::new("number = %d\n").unwrap().as_ptr(), 3);
    printf(CString::new("%d, %d\n").unwrap().as_ptr(), 10, 5);
}</pre>  <h3 id="E0061" class="section-header">E0061</h3> <p>The number of arguments passed to a function must match the number of arguments specified in the function signature.</p> <p>For example, a function like:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn f(a: u16, b: &amp;str) {}</pre> <p>Must always be called with exactly two arguments, e.g. <code>f(2, "test")</code>.</p> <p>Note that Rust does not have a notion of optional function arguments or variadic functions (except for its C-FFI).</p>  <h3 id="E0062" class="section-header">E0062</h3> <p>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was specified more than once. Erroneous code example:</p> <pre>struct Foo {
    x: i32,
}

fn main() {
    let x = Foo {
                x: 0,
                x: 0, // error: field `x` specified more than once
            };
}
</pre> <p>Each field should be specified exactly one time. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32,
}

fn main() {
    let x = Foo { x: 0 }; // ok!
}</pre>  <h3 id="E0063" class="section-header">E0063</h3> <p>This error indicates that during an attempt to build a struct or struct-like enum variant, one of the fields was not provided. Erroneous code example:</p> <pre>struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0 }; // error: missing field: `y`
}
</pre> <p>Each field should be specified exactly once. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0, y: 0 }; // ok!
}</pre>  <h3 id="E0066" class="section-header">E0066</h3> <p>Box placement expressions (like C++'s "placement new") do not yet support any place expression except the exchange heap (i.e. <code>std::boxed::HEAP</code>). Furthermore, the syntax is changing to use <code>in</code> instead of <code>box</code>. See <a href="https://github.com/rust-lang/rfcs/pull/470" target="_blank">RFC 470</a> and <a href="https://github.com/rust-lang/rfcs/pull/809" target="_blank">RFC 809</a> for more details.</p>  <h3 id="E0067" class="section-header">E0067</h3> <p>The left-hand side of a compound assignment expression must be an lvalue expression. An lvalue expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</p> <p>Let's start with some erroneous code examples:</p> <pre>use std::collections::LinkedList;

// Bad: assignment to non-lvalue expression
LinkedList::new() += 1;

// ...

fn some_func(i: &amp;mut i32) {
    i += 12; // Error : '+=' operation cannot be applied on a reference !
}
</pre> <p>And now some working examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut i : i32 = 0;

i += 12; // Good !

// ...

fn some_func(i: &amp;mut i32) {
    *i += 12; // Good !
}</pre>  <h3 id="E0069" class="section-header">E0069</h3> <p>The compiler found a function whose body contains a <code>return;</code> statement but whose return type is not <code>()</code>. An example of this is:</p> <pre>// error
fn foo() -&gt; u8 {
    return;
}
</pre> <p>Since <code>return;</code> is just like <code>return ();</code>, there is a mismatch between the function's return type and the value being returned.</p>  <h3 id="E0070" class="section-header">E0070</h3> <p>The left-hand side of an assignment operator must be an lvalue expression. An lvalue expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</p> <p>More details can be found here: <a href="../reference/#lvalues-rvalues-and-temporaries">https://doc.rust-lang.org/reference.html#lvalues-rvalues-and-temporaries</a></p> <p>Now, we can go further. Here are some erroneous code examples:</p> <pre>struct SomeStruct {
    x: i32,
    y: i32
}

const SOME_CONST : i32 = 12;

fn some_other_func() {}

fn some_function() {
    SOME_CONST = 14; // error : a constant value cannot be changed!
    1 = 3; // error : 1 isn't a valid lvalue!
    some_other_func() = 4; // error : we can't assign value to a function!
    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used
                       // like a variable!
}
</pre> <p>And now let's give working examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct SomeStruct {
    x: i32,
    y: i32
}
let mut s = SomeStruct {x: 0, y: 0};

s.x = 3; // that's good !

// ...

fn some_func(x: &amp;mut i32) {
    *x = 12; // that's good !
}</pre>  <h3 id="E0071" class="section-header">E0071</h3> <p>You tried to use structure-literal syntax to create an item that is not a structure or enum variant.</p> <p>Example of erroneous code:</p> <pre>type U32 = u32;
let t = U32 { value: 4 }; // error: expected struct, variant or union type,
                          // found builtin type `u32`
</pre> <p>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</p> <p>For example, the code above can be fixed to:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    FirstValue(i32)
}

fn main() {
    let u = Foo::FirstValue(0i32);

    let t = 4;
}</pre>  <h3 id="E0072" class="section-header">E0072</h3> <p>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like <code>Box</code> or <code>&amp;</code>). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</p> <p>Consider the following erroneous definition of a type for a list of bytes:</p> <pre>// error, invalid recursive struct type
struct ListNode {
    head: u8,
    tail: Option&lt;ListNode&gt;,
}
</pre> <p>This type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest <code>ListNode</code>s to any depth). Specifically,</p> <pre>size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</pre> <p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct ListNode {
    head: u8,
    tail: Option&lt;Box&lt;ListNode&gt;&gt;,
}</pre> <p>This works because <code>Box</code> is a pointer, so its size is well-known.</p>  <h3 id="E0073" class="section-header">E0073</h3> <p>You cannot define a struct (or enum) <code>Foo</code> that requires an instance of <code>Foo</code> in order to make a new <code>Foo</code> value. This is because there would be no way a first instance of <code>Foo</code> could be made to initialize another instance!</p> <p>Here's an example of a struct that has this problem:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo { x: Box&lt;Foo&gt; } // error</pre> <p>One fix is to use <code>Option</code>, like so:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo { x: Option&lt;Box&lt;Foo&gt;&gt; }</pre> <p>Now it's possible to create at least one instance of <code>Foo</code>: <code>Foo { x: None }</code>.</p>  <h3 id="E0074" class="section-header">E0074</h3> <p>When using the <code>#[simd]</code> attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</p> <p>This will cause an error:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Bad&lt;T&gt;(T, T, T);</pre> <p>This will not:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32);</pre>  <h3 id="E0075" class="section-header">E0075</h3> <p>The <code>#[simd]</code> attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</p> <p>This will cause an error:</p> <pre>#![feature(repr_simd)]

#[repr(simd)]
struct Bad;
</pre> <p>This will not:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32);</pre>  <h3 id="E0076" class="section-header">E0076</h3> <p>When using the <code>#[simd]</code> attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</p> <p>This will cause an error:</p> <pre>#![feature(repr_simd)]

#[repr(simd)]
struct Bad(u16, u32, u32);
</pre> <p>This will not:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32);</pre>  <h3 id="E0077" class="section-header">E0077</h3> <p>When using the <code>#[simd]</code> attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</p> <p>This will cause an error:</p> <pre>#![feature(repr_simd)]

#[repr(simd)]
struct Bad(String);
</pre> <p>This will not:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]

#[repr(simd)]
struct Good(u32, u32, u32);</pre>  <h3 id="E0079" class="section-header">E0079</h3> <p>Enum variants which contain no data can be given a custom integer representation. This error indicates that the value provided is not an integer literal and is therefore invalid.</p> <p>For example, in the following code:</p> <pre>enum Foo {
    Q = "32",
}
</pre> <p>We try to set the representation to a string.</p> <p>There's no general fix for this; if you can work with an integer then just set it to one:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    Q = 32,
}</pre> <p>However if you actually wanted a mapping between variants and non-integer objects, it may be preferable to use a method with a match instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo { Q }
impl Foo {
    fn get_str(&amp;self) -&gt; &amp;'static str {
        match *self {
            Foo::Q =&gt; "32",
        }
    }
}</pre>  <h3 id="E0080" class="section-header">E0080</h3> <p>This error indicates that the compiler was unable to sensibly evaluate an constant expression that had to be evaluated. Attempting to divide by 0 or causing integer overflow are two ways to induce this error. For example:</p> <pre>enum Enum {
    X = (1 &lt;&lt; 500),
    Y = (1 / 0)
}
</pre> <p>Ensure that the expressions given can be evaluated as the desired integer type. See the FFI section of the Reference for more information about using a custom integer type:</p> <p><a href="../reference/#ffi-attributes">https://doc.rust-lang.org/reference.html#ffi-attributes</a></p>  <h3 id="E0081" class="section-header">E0081</h3> <p>Enum discriminants are used to differentiate enum variants stored in memory. This error indicates that the same value was used for two or more variants, making them impossible to tell apart.</p> <pre>// Bad.
enum Enum {
    P = 3,
    X = 3,
    Y = 5,
}
</pre> <pre class="rust rust-example-rendered" data-language="rust">
// Good.
enum Enum {
    P,
    X = 3,
    Y = 5,
}</pre> <p>Note that variants without a manually specified discriminant are numbered from top to bottom starting from 0, so clashes can occur with seemingly unrelated variants.</p> <pre>enum Bad {
    X,
    Y = 0
}
</pre> <p>Here <code>X</code> will have already been specified the discriminant 0 by the time <code>Y</code> is encountered, so a conflict occurs.</p>  <h3 id="E0082" class="section-header">E0082</h3> <p>When you specify enum discriminants with <code>=</code>, the compiler expects <code>isize</code> values by default. Or you can add the <code>repr</code> attibute to the enum declaration for an explicit choice of the discriminant type. In either cases, the discriminant values must fall within a valid range for the expected type; otherwise this error is raised. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[repr(u8)]
enum Thing {
    A = 1024,
    B = 5,
}</pre> <p>Here, 1024 lies outside the valid range for <code>u8</code>, so the discriminant for <code>A</code> is invalid. Here is another, more subtle example which depends on target word size:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum DependsOnPointerSize {
    A = 1 &lt;&lt; 32,
}</pre> <p>Here, <code>1 &lt;&lt; 32</code> is interpreted as an <code>isize</code> value. So it is invalid for 32 bit target (<code>target_pointer_width = "32"</code>) but valid for 64 bit target.</p> <p>You may want to change representation types to fix this, or else change invalid discriminant values so that they fit within the existing type.</p>  <h3 id="E0084" class="section-header">E0084</h3> <p>An unsupported representation was attempted on a zero-variant enum.</p> <p>Erroneous code example:</p> <pre>#[repr(i32)]
enum NightsWatch {} // error: unsupported representation for zero-variant enum
</pre> <p>It is impossible to define an integer type to be used to represent zero-variant enum values because there are no zero-variant enum values. There is no way to construct an instance of the following type using only safe code. So you have two solutions. Either you add variants in your enum:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[repr(i32)]
enum NightsWatch {
    JonSnow,
    Commander,
}</pre> <p>or you remove the integer represention of your enum:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum NightsWatch {}</pre>  <h3 id="E0087" class="section-header">E0087</h3> <p>Too many type parameters were supplied for a function. For example:</p> <pre>fn foo&lt;T&gt;() {}

fn main() {
    foo::&lt;f64, bool&gt;(); // error, expected 1 parameter, found 2 parameters
}
</pre> <p>The number of supplied parameters must exactly match the number of defined type parameters.</p>  <h3 id="E0088" class="section-header">E0088</h3> <p>You gave too many lifetime parameters. Erroneous code example:</p> <pre>fn f() {}

fn main() {
    f::&lt;'static&gt;() // error: too many lifetime parameters provided
}
</pre> <p>Please check you give the right number of lifetime parameters. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn f() {}

fn main() {
    f() // ok!
}</pre> <p>It's also important to note that the Rust compiler can generally determine the lifetime by itself. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    value: String
}

impl Foo {
    // it can be written like this
    fn get_value&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str { &amp;self.value }
    // but the compiler works fine with this too:
    fn without_lifetime(&amp;self) -&gt; &amp;str { &amp;self.value }
}

fn main() {
    let f = Foo { value: "hello".to_owned() };

    println!("{}", f.get_value());
    println!("{}", f.without_lifetime());
}</pre>  <h3 id="E0089" class="section-header">E0089</h3> <p>Not enough type parameters were supplied for a function. For example:</p> <pre>fn foo&lt;T, U&gt;() {}

fn main() {
    foo::&lt;f64&gt;(); // error, expected 2 parameters, found 1 parameter
}
</pre> <p>Note that if a function takes multiple type parameters but you want the compiler to infer some of them, you can use type placeholders:</p> <pre>fn foo&lt;T, U&gt;(x: T) {}

fn main() {
    let x: bool = true;
    foo::&lt;f64&gt;(x);    // error, expected 2 parameters, found 1 parameter
    foo::&lt;_, f64&gt;(x); // same as `foo::&lt;bool, f64&gt;(x)`
}
</pre>   <h3 id="E0091" class="section-header">E0091</h3> <p>You gave an unnecessary type parameter in a type alias. Erroneous code example:</p> <pre>type Foo&lt;T&gt; = u32; // error: type parameter `T` is unused
// or:
type Foo&lt;A,B&gt; = Box&lt;A&gt;; // error: type parameter `B` is unused
</pre> <p>Please check you didn't write too many type parameters. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
type Foo = u32; // ok!
type Foo2&lt;A&gt; = Box&lt;A&gt;; // ok!</pre>  <h3 id="E0092" class="section-header">E0092</h3> <p>You tried to declare an undefined atomic operation function. Erroneous code example:</p> <pre>#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_foo(); // error: unrecognized atomic operation
                     //        function
}
</pre> <p>Please check you didn't make a mistake in the function's name. All intrinsic functions are defined in librustc_trans/trans/intrinsic.rs and in libcore/intrinsics.rs in the Rust source code. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
}</pre>  <h3 id="E0093" class="section-header">E0093</h3> <p>You declared an unknown intrinsic function. Erroneous code example:</p> <pre>#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn foo(); // error: unrecognized intrinsic function: `foo`
}

fn main() {
    unsafe {
        foo();
    }
}
</pre> <p>Please check you didn't make a mistake in the function's name. All intrinsic functions are defined in librustc_trans/trans/intrinsic.rs and in libcore/intrinsics.rs in the Rust source code. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn atomic_fence(); // ok!
}

fn main() {
    unsafe {
        atomic_fence();
    }
}</pre>  <h3 id="E0094" class="section-header">E0094</h3> <p>You gave an invalid number of type parameters to an intrinsic function. Erroneous code example:</p> <pre>#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T, U&gt;() -&gt; usize; // error: intrinsic has wrong number
                                 //        of type parameters
}
</pre> <p>Please check that you provided the right number of type parameters and verify with the function declaration in the Rust source code. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(intrinsics)]

extern "rust-intrinsic" {
    fn size_of&lt;T&gt;() -&gt; usize; // ok!
}</pre>  <h3 id="E0101" class="section-header">E0101</h3> <p>You hit this error because the compiler lacks the information to determine a type for this expression. Erroneous code example:</p> <pre>let x = |_| {}; // error: cannot determine a type for this expression
</pre> <p>You have two possibilities to solve this situation:</p> <ul> <li>Give an explicit definition of the expression</li> <li>Infer the expression</li> </ul> <p>Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = |_ : u32| {}; // ok!
// or:
let x = |_| {};
x(0u32);</pre>  <h3 id="E0102" class="section-header">E0102</h3> <p>You hit this error because the compiler lacks the information to determine the type of this variable. Erroneous code example:</p> <pre>// could be an array of anything
let x = []; // error: cannot determine a type for this local variable
</pre> <p>To solve this situation, constrain the type of the variable. Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![allow(unused_variables)]

fn main() {
    let x: [u8; 0] = [];
}</pre>    <h3 id="E0106" class="section-header">E0106</h3> <p>This error indicates that a lifetime is missing from a type. If it is an error inside a function signature, the problem may be with failing to adhere to the lifetime elision rules (see below).</p> <p>Here are some simple examples of where you'll run into this error:</p> <pre>struct Foo { x: &amp;bool }        // error
struct Foo&lt;'a&gt; { x: &amp;'a bool } // correct

enum Bar { A(u8), B(&amp;bool), }        // error
enum Bar&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr = &amp;str;        // error
type MyStr&lt;'a&gt; = &amp;'a str; // correct
</pre> <p>Lifetime elision is a special, limited kind of inference for lifetimes in function signatures which allows you to leave out lifetimes in certain cases. For more background on lifetime elision see <a href="https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision" target="_blank">the book</a>.</p> <p>The lifetime elision rules require that any function signature with an elided output lifetime must either have</p> <ul> <li>exactly one input lifetime</li> <li>or, multiple input lifetimes, but the function must also be a method with a <code>&amp;self</code> or <code>&amp;mut self</code> receiver</li> </ul> <p>In the first case, the output lifetime is inferred to be the same as the unique input lifetime. In the second case, the lifetime is instead inferred to be the same as the lifetime on <code>&amp;self</code> or <code>&amp;mut self</code>.</p> <p>Here are some examples of elision errors:</p> <pre>// error, no input lifetimes
fn foo() -&gt; &amp;str { }

// error, `x` and `y` have distinct lifetimes inferred
fn bar(x: &amp;str, y: &amp;str) -&gt; &amp;str { }

// error, `y`'s lifetime is inferred to be distinct from `x`'s
fn baz&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;str { }
</pre> <p>Here's an example that is currently an error, but may work in a future version of Rust:</p> <pre>struct Foo&lt;'a&gt;(&amp;'a str);

trait Quux { }
impl Quux for Foo { }
</pre> <p>Lifetime elision in implementation headers was part of the lifetime elision RFC. It is, however, <a href="https://github.com/rust-lang/rust/issues/15872" target="_blank">currently unimplemented</a>.</p>  <h3 id="E0107" class="section-header">E0107</h3> <p>This error means that an incorrect number of lifetime parameters were provided for a type (like a struct or enum) or trait:</p> <pre>struct Foo&lt;'a, 'b&gt;(&amp;'a str, &amp;'b str);
enum Bar { A, B, C }

struct Baz&lt;'a&gt; {
    foo: Foo&lt;'a&gt;, // error: expected 2, found 1
    bar: Bar&lt;'a&gt;, // error: expected 0, found 1
}
</pre>  <h3 id="E0109" class="section-header">E0109</h3> <p>You tried to give a type parameter to a type which doesn't need it. Erroneous code example:</p> <pre>type X = u32&lt;i32&gt;; // error: type parameters are not allowed on this type
</pre> <p>Please check that you used the correct type and recheck its definition. Perhaps it doesn't need the type parameter.</p> <p>Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
type X = u32; // this compiles</pre> <p>Note that type parameters for enum-variant constructors go after the variant, not after the enum (Option::None::<u32>, not Option::<u32>::None).</u32></u32></p>  <h3 id="E0110" class="section-header">E0110</h3> <p>You tried to give a lifetime parameter to a type which doesn't need it. Erroneous code example:</p> <pre>type X = u32&lt;'static&gt;; // error: lifetime parameters are not allowed on
                       //        this type
</pre> <p>Please check that the correct type was used and recheck its definition; perhaps it doesn't need the lifetime parameter. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
type X = u32; // ok!</pre>  <h3 id="E0116" class="section-header">E0116</h3> <p>You can only define an inherent implementation for a type in the same crate where the type was defined. For example, an <code>impl</code> block as below is not allowed since <code>Vec</code> is defined in the standard library:</p> <pre>impl Vec&lt;u8&gt; { } // error
</pre> <p>To fix this problem, you can do either of these things:</p> <ul> <li>define a trait that has the desired associated functions/types/constants and implement the trait for the type in question</li> <li>define a new type wrapping the type and define an implementation on the new type</li> </ul> <p>Note that using the <code>type</code> keyword does not work here because <code>type</code> only introduces a type alias:</p> <pre>type Bytes = Vec&lt;u8&gt;;

impl Bytes { } // error, same as above
</pre>  <h3 id="E0117" class="section-header">E0117</h3> <p>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait (a trait defined in another crate) where</p> <ul> <li>the type that is implementing the trait is foreign</li> <li>all of the parameters being passed to the trait (if there are any) are also foreign.</li> </ul> <p>Here's one example of this error:</p> <pre>impl Drop for u32 {}
</pre> <p>To avoid this kind of error, ensure that at least one local type is referenced by the <code>impl</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
pub struct Foo; // you define your type in your crate

impl Drop for Foo { // and you can implement the trait on it!
    // code of trait implementation here
}

impl From&lt;Foo&gt; for i32 { // or you use a type from your crate as
                         // a type parameter
    fn from(i: Foo) -&gt; i32 {
        0
    }
}</pre> <p>Alternatively, define a trait locally and implement that instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Bar {
    fn get(&amp;self) -&gt; usize;
}

impl Bar for u32 {
    fn get(&amp;self) -&gt; usize { 0 }
}</pre> <p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/pull/1023" target="_blank">RFC 1023</a>.</p>  <h3 id="E0118" class="section-header">E0118</h3> <p>You're trying to write an inherent implementation for something which isn't a struct nor an enum. Erroneous code example:</p> <pre>impl (u8, u8) { // error: no base type found for inherent implementation
    fn get_state(&amp;self) -&gt; String {
        // ...
    }
}
</pre> <p>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
// we create a trait here
trait LiveLongAndProsper {
    fn get_state(&amp;self) -&gt; String;
}

// and now you can implement it on (u8, u8)
impl LiveLongAndProsper for (u8, u8) {
    fn get_state(&amp;self) -&gt; String {
        "He's dead, Jim!".to_owned()
    }
}</pre> <p>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, <code>NewType</code> is a newtype over <code>Foo</code> in <code>struct NewType(Foo)</code>. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct TypeWrapper((u8, u8));

impl TypeWrapper {
    fn get_state(&amp;self) -&gt; String {
        "Fascinating!".to_owned()
    }
}</pre>  <h3 id="E0119" class="section-header">E0119</h3> <p>There are conflicting trait implementations for the same type. Example of erroneous code:</p> <pre>trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo {
    value: usize
}

impl MyTrait for Foo { // error: conflicting implementations of trait
                       //        `MyTrait` for type `Foo`
    fn get(&amp;self) -&gt; usize { self.value }
}
</pre> <p>When looking for the implementation for the trait, the compiler finds both the <code>impl&lt;T&gt; MyTrait for T</code> where T is all types and the <code>impl MyTrait for Foo</code>. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}</pre> <p>This makes the trait implemented on all types in the scope. So if you try to implement it on another one after that, the implementations will conflict. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo;

fn main() {
    let f = Foo;

    f.get(); // the trait is implemented so we can use it
}</pre>  <h3 id="E0120" class="section-header">E0120</h3> <p>An attempt was made to implement Drop on a trait, which is not allowed: only structs and enums can implement Drop. An example causing this error:</p> <pre>trait MyTrait {}

impl Drop for MyTrait {
    fn drop(&amp;mut self) {}
}
</pre> <p>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {}
struct MyWrapper&lt;T: MyTrait&gt; { foo: T }

impl &lt;T: MyTrait&gt; Drop for MyWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
</pre> <p>Alternatively, wrapping trait objects requires something like the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {}

//or Box&lt;MyTrait&gt;, if you wanted an owned trait object
struct MyWrapper&lt;'a&gt; { foo: &amp;'a MyTrait }

impl &lt;'a&gt; Drop for MyWrapper&lt;'a&gt; {
    fn drop(&amp;mut self) {}
}</pre>  <h3 id="E0121" class="section-header">E0121</h3> <p>In order to be consistent with Rust's lack of global type inference, type placeholders are disallowed by design in item signatures.</p> <p>Examples of this error include:</p> <pre>fn foo() -&gt; _ { 5 } // error, explicitly write out the return type instead

static BAR: _ = "test"; // error, explicitly write out the type instead
</pre>  <h3 id="E0122" class="section-header">E0122</h3> <p>An attempt was made to add a generic constraint to a type alias. While Rust will allow this with a warning, it will not currently enforce the constraint. Consider the example below:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo{}

type MyType&lt;R: Foo&gt; = (R, ());

fn main() {
    let t: MyType&lt;u32&gt;;
}</pre> <p>We're able to declare a variable of type <code>MyType&lt;u32&gt;</code>, despite the fact that <code>u32</code> does not implement <code>Foo</code>. As a result, one should avoid using generic constraints in concert with type aliases.</p>  <h3 id="E0124" class="section-header">E0124</h3> <p>You declared two fields of a struct with the same name. Erroneous code example:</p> <pre>struct Foo {
    field1: i32,
    field1: i32, // error: field is already declared
}
</pre> <p>Please verify that the field names have been correctly spelled. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    field1: i32,
    field2: i32, // ok!
}</pre>  <h3 id="E0128" class="section-header">E0128</h3> <p>Type parameter defaults can only use parameters that occur before them. Erroneous code example:</p> <pre>struct Foo&lt;T=U, U=()&gt; {
    field1: T,
    filed2: U,
}
// error: type parameters with a default cannot use forward declared
// identifiers
</pre> <p>Since type parameters are evaluated in-order, you may be able to fix this issue by doing:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;U=(), T=U&gt; {
    field1: T,
    filed2: U,
}</pre> <p>Please also verify that this wasn't because of a name-clash and rename the type parameter if so.</p>  <h3 id="E0131" class="section-header">E0131</h3> <p>It is not possible to define <code>main</code> with type parameters, or even with function parameters. When <code>main</code> is present, it must take no arguments and return <code>()</code>. Erroneous code example:</p> <pre>fn main&lt;T&gt;() { // error: main function is not allowed to have type parameters
}
</pre>  <h3 id="E0132" class="section-header">E0132</h3> <p>A function with the <code>start</code> attribute was declared with type parameters.</p> <p>Erroneous code example:</p> <pre>#![feature(start)]

#[start]
fn f&lt;T&gt;() {}
</pre> <p>It is not possible to declare type parameters on a function that has the <code>start</code> attribute. Such a function must have the following type signature (for more information: <a href="http://doc.rust-lang.org/stable/book/no-stdlib.html" target="_blank">http://doc.rust-lang.org/stable/book/no-stdlib.html</a>):</p> <pre class="rust rust-example-rendered" data-language="rust">
fn(isize, *const *const u8) -&gt; isize;</pre> <p>Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(start)]

#[start]
fn my_start(argc: isize, argv: *const *const u8) -&gt; isize {
    0
}</pre>  <h3 id="E0133" class="section-header">E0133</h3> <p>Unsafe code was used outside of an unsafe function or block.</p> <p>Erroneous code example:</p> <pre>unsafe fn f() { return; } // This is the unsafe code

fn main() {
    f(); // error: call to unsafe function requires unsafe function or block
}
</pre> <p>Using unsafe functionality is potentially dangerous and disallowed by safety checks. Examples:</p> <ul> <li>Dereferencing raw pointers</li> <li>Calling functions via FFI</li> <li>Calling functions marked unsafe</li> </ul> <p>These safety checks can be relaxed for a section of the code by wrapping the unsafe instructions with an <code>unsafe</code> block. For instance:</p> <pre class="rust rust-example-rendered" data-language="rust">
unsafe fn f() { return; }

fn main() {
    unsafe { f(); } // ok!
}</pre> <p>See also <a href="../book/unsafe/">https://doc.rust-lang.org/book/unsafe.html</a></p>  <h3 id="E0136" class="section-header">E0136</h3> <p>A binary can only have one entry point, and by default that entry point is the function <code>main()</code>. If there are multiple such functions, please rename one.</p>  <h3 id="E0137" class="section-header">E0137</h3> <p>More than one function was declared with the <code>#[main]</code> attribute.</p> <p>Erroneous code example:</p> <pre>#![feature(main)]

#[main]
fn foo() {}

#[main]
fn f() {} // error: multiple functions with a #[main] attribute
</pre> <p>This error indicates that the compiler found multiple functions with the <code>#[main]</code> attribute. This is an error because there must be a unique entry point into a Rust program. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(main)]

#[main]
fn f() {} // ok!</pre>  <h3 id="E0138" class="section-header">E0138</h3> <p>More than one function was declared with the <code>#[start]</code> attribute.</p> <p>Erroneous code example:</p> <pre>#![feature(start)]

#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize {}

#[start]
fn f(argc: isize, argv: *const *const u8) -&gt; isize {}
// error: multiple 'start' functions
</pre> <p>This error indicates that the compiler found multiple functions with the <code>#[start]</code> attribute. This is an error because there must be a unique entry point into a Rust program. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(start)]

#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize { 0 } // ok!</pre>  <h3 id="E0139" class="section-header">E0139</h3> <p>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</p> <p>So, for example, the following is not allowed:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

fn foo&lt;T&gt;(x: Vec&lt;T&gt;) {
    // we are transmuting between Vec&lt;T&gt; and Foo&lt;F&gt; here
    let y: Foo&lt;T&gt; = unsafe { transmute(x) };
    // do something with y
}</pre> <p>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter substitutions. It's not possible to check this for <em>all</em> possible types, so <code>transmute()</code> simply only accepts types without any unsubstituted type parameters.</p> <p>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</p> <p>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt;(Vec&lt;T&gt;);

trait MyTransmutableType {
    fn transmute(Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;
}

impl MyTransmutableType for u8 {
    fn transmute(x: Foo&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
        transmute(x)
    }
}

impl MyTransmutableType for String {
    fn transmute(x: Foo&lt;String&gt;) -&gt; Vec&lt;String&gt; {
        transmute(x)
    }
}

// ... more impls for the types you intend to transmute

fn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {
    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);
    // do something with y
}</pre> <p>Each impl will be checked for a size match in the transmute as usual, and since there are no unbound type parameters involved, this should compile unless there is a size mismatch in one of the impls.</p> <p>It is also possible to manually transmute:</p> <pre class="rust rust-example-rendered" data-language="rust">
ptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`</pre> <p>Note that this does not move <code>v</code> (unlike <code>transmute</code>), and may need a call to <code>mem::forget(v)</code> in case you want to avoid destructors being called.</p>  <h3 id="E0152" class="section-header">E0152</h3> <p>A lang item was redefined.</p> <p>Erroneous code example:</p> <pre>#![feature(lang_items)]

#[lang = "panic_fmt"]
struct Foo; // error: duplicate lang item found: `panic_fmt`
</pre> <p>Lang items are already implemented in the standard library. Unless you are writing a free-standing application (e.g. a kernel), you do not need to provide them yourself.</p> <p>You can build a free-standing crate by adding <code>#![no_std]</code> to the crate attributes:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![no_std]</pre> <p>See also <a href="../book/no-stdlib/">https://doc.rust-lang.org/book/no-stdlib.html</a></p>  <h3 id="E0154" class="section-header">E0154</h3> <h3 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-3" class="section-header">Note: this error code is no longer emitted by the compiler.</h3> <p>Imports (<code>use</code> statements) are not allowed after non-item statements, such as variable declarations and expression statements.</p> <p>Here is an example that demonstrates the error:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn f() {
    // Variable declaration before import
    let x = 0;
    use std::io::Read;
    // ...
}</pre> <p>The solution is to declare the imports at the top of the block, function, or file.</p> <p>Here is the previous example again, with the correct order:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn f() {
    use std::io::Read;
    let x = 0;
    // ...
}</pre> <p>See the Declaration Statements section of the reference for more information about what constitutes an Item declaration and what does not:</p> <p><a href="../reference/#statements">https://doc.rust-lang.org/reference.html#statements</a></p>  <h3 id="E0158" class="section-header">E0158</h3> <p><code>const</code> and <code>static</code> mean different things. A <code>const</code> is a compile-time constant, an alias for a literal value. This property means you can match it directly within a pattern.</p> <p>The <code>static</code> keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared <code>static</code> as well.</p> <p>If you want to match against a <code>static</code>, consider using a guard instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
static FORTY_TWO: i32 = 42;

match Some(42) {
    Some(x) if x == FORTY_TWO =&gt; {}
    _ =&gt; {}
}</pre>  <h3 id="E0162" class="section-header">E0162</h3> <p>An if-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular <code>let</code>-binding instead. For instance:</p> <pre>struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
if let Irrefutable(x) = irr {
    // This body will always be executed.
    // ...
}
</pre> <p>Try this instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

let Irrefutable(x) = irr;
println!("{}", x);</pre>  <h3 id="E0164" class="section-header">E0164</h3> <p>This error means that an attempt was made to match a struct type enum variant as a non-struct type:</p> <pre>enum Foo { B { i: u32 } }

fn bar(foo: Foo) -&gt; u32 {
    match foo {
        Foo::B(i) =&gt; i, // error E0164
    }
}
</pre> <p>Try using <code>{}</code> instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo { B { i: u32 } }

fn bar(foo: Foo) -&gt; u32 {
    match foo {
        Foo::B{i} =&gt; i,
    }
}</pre>  <h3 id="E0165" class="section-header">E0165</h3> <p>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular <code>let</code>-binding inside a <code>loop</code> instead. For instance:</p> <pre>struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
while let Irrefutable(x) = irr {
    // ...
}
</pre> <p>Try this instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Irrefutable(i32);
let irr = Irrefutable(0);

loop {
    let Irrefutable(x) = irr;
    // ...
}</pre>  <h3 id="E0170" class="section-header">E0170</h3> <p>Enum variants are qualified by default. For example, given this type:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Method {
    GET,
    POST,
}</pre> <p>You would match it using:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Method {
    GET,
    POST,
}

let m = Method::GET;

match m {
    Method::GET =&gt; {},
    Method::POST =&gt; {},
}</pre> <p>If you don't qualify the names, the code will bind new variables named "GET" and "POST" instead. This behavior is likely not what you want, so <code>rustc</code> warns when that happens.</p> <p>Qualified names are good practice, and most code works well with them. But if you prefer them unqualified, you can import the variants into scope:</p> <pre class="rust rust-example-rendered" data-language="rust">
use Method::*;
enum Method { GET, POST }</pre> <p>If you want others to be able to import variants from your module directly, use <code>pub use</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
pub use Method::*;
enum Method { GET, POST }</pre>  <h3 id="E0182" class="section-header">E0182</h3> <p>You bound an associated type in an expression path which is not allowed.</p> <p>Erroneous code example:</p> <pre>trait Foo {
    type A;
    fn bar() -&gt; isize;
}

impl Foo for isize {
    type A = usize;
    fn bar() -&gt; isize { 42 }
}

// error: unexpected binding of associated item in expression path
let x: isize = Foo::&lt;A=usize&gt;::bar();
</pre> <p>To give a concrete type when using the Universal Function Call Syntax, use "Type as Trait". Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    type A;
    fn bar() -&gt; isize;
}

impl Foo for isize {
    type A = usize;
    fn bar() -&gt; isize { 42 }
}

let x: isize = &lt;isize as Foo&gt;::bar(); // ok!</pre>   <h3 id="E0184" class="section-header">E0184</h3> <p>Explicitly implementing both Drop and Copy for a type is currently disallowed. This feature can make some sense in theory, but the current implementation is incorrect and can lead to memory unsafety (see <a href="https://github.com/rust-lang/rust/issues/20126" target="_blank">issue #20126</a>), so it has been disabled for now.</p>  <h3 id="E0185" class="section-header">E0185</h3> <p>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e. to take a <code>self</code> parameter).</p> <p>Here's an example of this error:</p> <pre>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the impl, but not in
    // the trait
    fn foo(&amp;self) {}
}
</pre>  <h3 id="E0186" class="section-header">E0186</h3> <p>An associated function for a trait was defined to be a method (i.e. to take a <code>self</code> parameter), but an implementation of the trait declared the same function to be static.</p> <p>Here's an example of this error:</p> <pre>trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the trait, but not in
    // the impl
    fn foo() {}
}
</pre>  <h3 id="E0191" class="section-header">E0191</h3> <p>Trait objects need to have all associated types specified. Erroneous code example:</p> <pre>trait Trait {
    type Bar;
}

type Foo = Trait; // error: the value of the associated type `Bar` (from
                  //        the trait `Trait`) must be specified
</pre> <p>Please verify you specified all associated types of the trait and that you used the right trait. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    type Bar;
}

type Foo = Trait&lt;Bar=i32&gt;; // ok!</pre>  <h3 id="E0192" class="section-header">E0192</h3> <p>Negative impls are only allowed for traits with default impls. For more information see the <a href="https://github.com/rust-lang/%0Arfcs/blob/master/text/0019-opt-in-builtin-traits.md" target="_blank">opt-in builtin traits RFC</a>.</p>  <h3 id="E0193" class="section-header">E0193</h3> <p><code>where</code> clauses must use generic type parameters: it does not make sense to use them otherwise. An example causing this error:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}

impl Foo for Wrapper&lt;u32&gt; where Wrapper&lt;u32&gt;: Clone {
    fn bar(&amp;self) { }
}</pre> <p>This use of a <code>where</code> clause is strange - a more common usage would look something like the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}
impl &lt;T&gt; Foo for Wrapper&lt;T&gt; where Wrapper&lt;T&gt;: Clone {
    fn bar(&amp;self) { }
}</pre> <p>Here, we're saying that the implementation exists on Wrapper only when the wrapped type <code>T</code> implements <code>Clone</code>. The <code>where</code> clause is important because some types will not implement <code>Clone</code>, and thus will not get this method.</p> <p>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that <code>Wrapper&lt;u32&gt;</code> implements <code>Clone</code>, there's no reason to also specify it in a <code>where</code> clause.</p>  <h3 id="E0194" class="section-header">E0194</h3> <p>A type parameter was declared which shadows an existing one. An example of this error:</p> <pre>trait Foo&lt;T&gt; {
    fn do_something(&amp;self) -&gt; T;
    fn do_something_else&lt;T: Clone&gt;(&amp;self, bar: T);
}
</pre> <p>In this example, the trait <code>Foo</code> and the trait method <code>do_something_else</code> both define a type parameter <code>T</code>. This is not allowed: if the method wishes to define a type parameter, it must use a different name for it.</p>  <h3 id="E0195" class="section-header">E0195</h3> <p>Your method's lifetime parameters do not match the trait declaration. Erroneous code example:</p> <pre>trait Trait {
    fn bar&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn bar&lt;'a,'b&gt;(x: &amp;'a str, y: &amp;'b str) {
    // error: lifetime parameters or bounds on method `bar`
    // do not match the trait declaration
    }
}
</pre> <p>The lifetime constraint <code>'b</code> for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str) { // ok!
    }
}</pre>   <h3 id="E0197" class="section-header">E0197</h3> <p>Inherent implementations (one that do not implement a trait but provide methods associated with a type) are always safe because they are not implementing an unsafe trait. Removing the <code>unsafe</code> keyword from the inherent implementation will resolve this error.</p> <pre>struct Foo;

// this will cause this error
unsafe impl Foo { }
// converting it to this will fix it
impl Foo { }
</pre>  <h3 id="E0198" class="section-header">E0198</h3> <p>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</p> <pre>#![feature(optin_builtin_traits)]

struct Foo;

// unsafe is unnecessary
unsafe impl !Clone for Foo { }
</pre> <p>This will compile:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(optin_builtin_traits)]

struct Foo;

trait Enterprise {}

impl Enterprise for .. { }

impl !Enterprise for Foo { }</pre> <p>Please note that negative impls are only allowed for traits with default impls.</p>  <h3 id="E0199" class="section-header">E0199</h3> <p>Safe traits should not have unsafe implementations, therefore marking an implementation for a safe trait unsafe will cause a compiler error. Removing the unsafe marker on the trait noted in the error will resolve this problem.</p> <pre>struct Foo;

trait Bar { }

// this won't compile because Bar is safe
unsafe impl Bar for Foo { }
// this will compile
impl Bar for Foo { }
</pre>  <h3 id="E0200" class="section-header">E0200</h3> <p>Unsafe traits must have unsafe implementations. This error occurs when an implementation for an unsafe trait isn't marked as unsafe. This may be resolved by marking the unsafe implementation as unsafe.</p> <pre>struct Foo;

unsafe trait Bar { }

// this won't compile because Bar is unsafe and impl isn't unsafe
impl Bar for Foo { }
// this will compile
unsafe impl Bar for Foo { }
</pre>  <h3 id="E0201" class="section-header">E0201</h3> <p>It is an error to define two associated items (like methods, associated types, associated functions, etc.) with the same identifier.</p> <p>For example:</p> <pre>struct Foo(u8);

impl Foo {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
    fn bar() {} // error: duplicate associated function
}

trait Baz {
    type Quux;
    fn baz(&amp;self) -&gt; bool;
}

impl Baz for Foo {
    type Quux = u32;

    fn baz(&amp;self) -&gt; bool { true }

    // error: duplicate method
    fn baz(&amp;self) -&gt; bool { self.0 &gt; 5 }

    // error: duplicate associated type
    type Quux = u32;
}
</pre> <p>Note, however, that items with the same name are allowed for inherent <code>impl</code> blocks that don't overlap:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt;(T);

impl Foo&lt;u8&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
}

impl Foo&lt;bool&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 }
}</pre>  <h3 id="E0202" class="section-header">E0202</h3> <p>Inherent associated types were part of <a href="https://github.com/rust-lang/rfcs/pull/195" target="_blank">RFC 195</a> but are not yet implemented. See <a href="https://github.com/rust-lang/rust/issues/8995" target="_blank">the tracking issue</a> for the status of this implementation.</p>   <h3 id="E0204" class="section-header">E0204</h3> <p>An attempt to implement the <code>Copy</code> trait for a struct failed because one of the fields does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for the mentioned field. Note that this may not be possible, as in the example of</p> <pre>struct Foo {
    foo : Vec&lt;u32&gt;,
}

impl Copy for Foo { }
</pre> <p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p> <p>Here's another example that will fail:</p> <pre>#[derive(Copy)]
struct Foo&lt;'a&gt; {
    ty: &amp;'a mut bool,
}
</pre> <p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>  <h3 id="E0206" class="section-header">E0206</h3> <p>You can only implement <code>Copy</code> for a struct or enum. Both of the following examples will fail, because neither <code>i32</code> (primitive type) nor <code>&amp;'static Bar</code> (reference to <code>Bar</code>) is a struct or enum:</p> <pre>type Foo = i32;
impl Copy for Foo { } // error

#[derive(Copy, Clone)]
struct Bar;
impl Copy for &amp;'static Bar { } // error
</pre>  <h3 id="E0207" class="section-header">E0207</h3> <p>Any type parameter or lifetime parameter of an <code>impl</code> must meet at least one of the following criteria:</p> <ul> <li>it appears in the self type of the impl</li> <li>for a trait impl, it appears in the trait reference</li> <li>it is bound as an associated type</li> </ul> <h3 id="error-example-1" class="section-header">Error example 1</h3> <p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it. The following definition leads to a compiler error:</p> <pre>struct Foo;

impl&lt;T: Default&gt; Foo {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}
</pre> <p>The problem is that the parameter <code>T</code> does not appear in the self type (<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type parameter from the <code>impl</code> to the method <code>get</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}</pre> <h3 id="error-example-2" class="section-header">Error example 2</h3> <p>As another example, suppose we have a <code>Maker</code> trait and want to establish a type <code>FooMaker</code> that makes <code>Foo</code>s:</p> <pre>trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}
</pre> <p>This fails to compile because <code>T</code> does not appear in the trait or in the implementing type.</p> <p>One way to work around this is to introduce a phantom type parameter into <code>FooMaker</code>, like so:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}</pre> <p>Another way is to do away with the associated type in <code>Maker</code> and use an input type parameter instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
// Use a type parameter instead of an associated type here
trait Maker&lt;Item&gt; {
    fn make(&amp;mut self) -&gt; Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker&lt;Foo&lt;T&gt;&gt; for FooMaker {
    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}</pre> <h3 id="additional-information" class="section-header">Additional information</h3> <p>For more information, please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md" target="_blank">RFC 447</a>.</p>   <h3 id="E0210" class="section-header">E0210</h3> <p>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be "covered" by a local type. To understand what this means, it is perhaps easiest to consider a few examples.</p> <p>If <code>ForeignTrait</code> is a trait defined in some external crate <code>foo</code>, then the following trait <code>impl</code> is an error:</p> <pre>extern crate collections;
use collections::range::RangeArgument;

impl&lt;T&gt; RangeArgument&lt;T&gt; for T { } // error

fn main() {}
</pre> <p>To work around this, it can be covered with a local type, <code>MyType</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct MyType&lt;T&gt;(T);
impl&lt;T&gt; ForeignTrait for MyType&lt;T&gt; { } // Ok</pre> <p>Please note that a type alias is not sufficient.</p> <p>For another example of an error, suppose there's another trait defined in <code>foo</code> named <code>ForeignTrait2</code> that takes two type parameters. Then this <code>impl</code> results in the same rule violation:</p> <pre>struct MyType2;
impl&lt;T&gt; ForeignTrait2&lt;T, MyType&lt;T&gt;&gt; for MyType2 { } // error
</pre> <p>The reason for this is that there are two appearances of type parameter <code>T</code> in the <code>impl</code> header, both as parameters for <code>ForeignTrait2</code>. The first appearance is uncovered, and so runs afoul of the orphan rule.</p> <p>Consider one more example:</p> <pre class="rust rust-example-rendered" data-language="rust">
impl&lt;T&gt; ForeignTrait2&lt;MyType&lt;T&gt;, T&gt; for MyType2 { } // Ok</pre> <p>This only differs from the previous <code>impl</code> in that the parameters <code>T</code> and <code>MyType&lt;T&gt;</code> for <code>ForeignTrait2</code> have been swapped. This example does <em>not</em> violate the orphan rule; it is permitted.</p> <p>To see why that last example was allowed, you need to understand the general rule. Unfortunately this rule is a bit tricky to state. Consider an <code>impl</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
impl&lt;P1, ..., Pm&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0 { ... }</pre> <p>where <code>P1, ..., Pm</code> are the type parameters of the <code>impl</code> and <code>T0, ..., Tn</code> are types. One of the types <code>T0, ..., Tn</code> must be a local type (this is another orphan rule, see the explanation for E0117). Let <code>i</code> be the smallest integer such that <code>Ti</code> is a local type. Then no type parameter can appear in any of the <code>Tj</code> for <code>j &lt; i</code>.</p> <p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/pull/1023" target="_blank">RFC 1023</a>.</p>   <h3 id="E0214" class="section-header">E0214</h3> <p>A generic type was described using parentheses rather than angle brackets. For example:</p> <pre>fn main() {
    let v: Vec(&amp;str) = vec!["foo"];
}
</pre> <p>This is not currently supported: <code>v</code> should be defined as <code>Vec&lt;&amp;str&gt;</code>. Parentheses are currently only used with generic types when defining parameters for <code>Fn</code>-family traits.</p>  <h3 id="E0220" class="section-header">E0220</h3> <p>You used an associated type which isn't defined in the trait. Erroneous code example:</p> <pre>trait T1 {
    type Bar;
}

type Foo = T1&lt;F=i32&gt;; // error: associated type `F` not found for `T1`

// or:

trait T2 {
    type Bar;

    // error: Baz is used but not declared
    fn return_bool(&amp;self, &amp;Self::Bar, &amp;Self::Baz) -&gt; bool;
}
</pre> <p>Make sure that you have defined the associated type in the trait body. Also, verify that you used the right trait or you didn't misspell the associated type name. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait T1 {
    type Bar;
}

type Foo = T1&lt;Bar=i32&gt;; // ok!

// or:

trait T2 {
    type Bar;
    type Baz; // we declare `Baz` in our trait.

    // and now we can use it here:
    fn return_bool(&amp;self, &amp;Self::Bar, &amp;Self::Baz) -&gt; bool;
}</pre>  <h3 id="E0221" class="section-header">E0221</h3> <p>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</p> <pre>trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: Self::A;
    }
}
</pre> <p>In this example, <code>Foo</code> defines an associated type <code>A</code>. <code>Bar</code> inherits that type from <code>Foo</code>, and defines another associated type of the same name. As a result, when we attempt to use <code>Self::A</code>, it's ambiguous whether we mean the <code>A</code> defined by <code>Foo</code> or the one defined by <code>Bar</code>.</p> <p>There are two options to work around this issue. The first is simply to rename one of the types. Alternatively, one can specify the intended type using the following syntax:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: &lt;Self as Bar&gt;::A;
    }
}</pre>  <h3 id="E0223" class="section-header">E0223</h3> <p>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</p> <pre>trait MyTrait {type X; }

fn main() {
    let foo: MyTrait::X;
}
</pre> <p>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait MyTrait {type X; }
struct MyStruct;

impl MyTrait for MyStruct {
    type X = u32;
}

fn main() {
    let foo: &lt;MyStruct as MyTrait&gt;::X;
}</pre> <p>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use <code>MyStruct::X</code> is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</p>   <h3 id="E0225" class="section-header">E0225</h3> <p>You attempted to use multiple types as bounds for a closure or trait object. Rust does not currently support this. A simple example that causes this error:</p> <pre>fn main() {
    let _: Box&lt;std::io::Read + std::io::Write&gt;;
}
</pre> <p>Send and Sync are an exception to this rule: it's possible to have bounds of one non-builtin trait, plus either or both of Send and Sync. For example, the following compiles correctly:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let _: Box&lt;std::io::Read + Send + Sync&gt;;
}</pre>    <h3 id="E0229" class="section-header">E0229</h3> <p>An associated type binding was done outside of the type parameter declaration and <code>where</code> clause. Erroneous code example:</p> <pre>pub trait Foo {
    type A;
    fn boo(&amp;self) -&gt; &lt;Self as Foo&gt;::A;
}

struct Bar;

impl Foo for isize {
    type A = usize;
    fn boo(&amp;self) -&gt; usize { 42 }
}

fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&lt;A=Bar&gt;&gt;::A) {}
// error: associated type bindings are not allowed here
</pre> <p>To solve this error, please move the type bindings in the type parameter declaration:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn baz&lt;I: Foo&lt;A=Bar&gt;&gt;(x: &amp;&lt;I as Foo&gt;::A) {} // ok!</pre> <p>Or in the <code>where</code> clause:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&gt;::A) where I: Foo&lt;A=Bar&gt; {}</pre>  <h3 id="E0230" class="section-header">E0230</h3> <p>The trait has more type parameters specified than appear in its definition.</p> <p>Erroneous example code:</p> <pre>#![feature(on_unimplemented)]
#[rustc_on_unimplemented = "Trait error on `{Self}` with `&lt;{A},{B},{C}&gt;`"]
// error: there is no type parameter C on trait TraitWithThreeParams
trait TraitWithThreeParams&lt;A,B&gt;
{}
</pre> <p>Include the correct number of type parameters and the compilation should proceed:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(on_unimplemented)]
#[rustc_on_unimplemented = "Trait error on `{Self}` with `&lt;{A},{B},{C}&gt;`"]
trait TraitWithThreeParams&lt;A,B,C&gt; // ok!
{}</pre>   <h3 id="E0232" class="section-header">E0232</h3> <p>The attribute must have a value. Erroneous code example:</p> <pre>#![feature(on_unimplemented)]

#[rustc_on_unimplemented] // error: this attribute must have a value
trait Bar {}
</pre> <p>Please supply the missing value of the attribute. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(on_unimplemented)]

#[rustc_on_unimplemented = "foo"] // ok!
trait Bar {}</pre>  <h3 id="E0243" class="section-header">E0243</h3> <p>This error indicates that not enough type parameters were found in a type or trait.</p> <p>For example, the <code>Foo</code> struct below is defined to be generic in <code>T</code>, but the type parameter is missing in the definition of <code>Bar</code>:</p> <pre>struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }
</pre>  <h3 id="E0244" class="section-header">E0244</h3> <p>This error indicates that too many type parameters were found in a type or trait.</p> <p>For example, the <code>Foo</code> struct below has no type parameters, but is supplied with two in the definition of <code>Bar</code>:</p> <pre>struct Foo { x: bool }

struct Bar&lt;S, T&gt; { x: Foo&lt;S, T&gt; }
</pre>   <h3 id="E0251" class="section-header">E0251</h3> <h3 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-4" class="section-header">Note: this error code is no longer emitted by the compiler.</h3> <p>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</p> <p>An example of this error:</p> <pre class="rust rust-example-rendered" data-language="rust">
use foo::baz;
use bar::*; // error, do `use foo::baz as quux` instead on the previous line

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre>  <h3 id="E0252" class="section-header">E0252</h3> <p>Two items of the same name cannot be imported without rebinding one of the items under a new local name.</p> <p>Erroneous code example:</p> <pre>use foo::baz;
use bar::baz; // error, do `use bar::baz as quux` instead

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}
</pre> <p>You can use aliases in order to fix this error. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
use foo::baz as foo_baz;
use bar::baz; // ok!

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre> <p>Or you can reference the item with its parent:</p> <pre class="rust rust-example-rendered" data-language="rust">
use bar::baz;

fn main() {
    let x = foo::baz; // ok!
}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</pre>  <h3 id="E0253" class="section-header">E0253</h3> <p>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</p> <p>Erroneous code example:</p> <pre>mod foo {
    pub trait MyTrait {
        fn do_something();
    }
}

use foo::MyTrait::do_something;
// error: `do_something` is not directly importable

fn main() {}
</pre> <p>It's invalid to directly import methods belonging to a trait or concrete type.</p>  <h3 id="E0254" class="section-header">E0254</h3> <p>Attempt was made to import an item whereas an extern crate with this name has already been imported.</p> <p>Erroneous code example:</p> <pre>extern crate collections;

mod foo {
    pub trait collections {
        fn do_something();
    }
}

use foo::collections; // error: an extern crate named `collections` has already
                      //        been imported in this module

fn main() {}
</pre> <p>To fix issue issue, you have to rename at least one of the two imports. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate collections as libcollections; // ok!

mod foo {
    pub trait collections {
        fn do_something();
    }
}

use foo::collections;

fn main() {}</pre>  <h3 id="E0255" class="section-header">E0255</h3> <p>You can't import a value whose name is the same as another value defined in the module.</p> <p>Erroneous code example:</p> <pre>use bar::foo; // error: an item named `foo` is already in scope

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}
</pre> <p>You can use aliases in order to fix this error. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
use bar::foo as bar_foo; // ok!

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</pre> <p>Or you can reference the item with its parent:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {
    bar::foo(); // we get the item by referring to its parent
}</pre>  <h3 id="E0256" class="section-header">E0256</h3> <h3 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-5" class="section-header">Note: this error code is no longer emitted by the compiler.</h3> <p>You can't import a type or module when the name of the item being imported is the same as another type or submodule defined in the module.</p> <p>An example of this error:</p> <pre>use foo::Bar; // error

type Bar = u32;

mod foo {
    pub mod Bar { }
}

fn main() {}
</pre>  <h3 id="E0259" class="section-header">E0259</h3> <p>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</p> <p>Erroneous code example:</p> <pre>extern crate std;
extern crate libc as std;

fn main() {}
</pre> <p>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</p> <p>Correct example:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate std;
extern crate libc as other_name;</pre>  <h3 id="E0260" class="section-header">E0260</h3> <p>The name for an item declaration conflicts with an external crate's name.</p> <p>Erroneous code example:</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate abc;

struct abc;</pre> <p>There are two possible solutions:</p> <p>Solution #1: Rename the item.</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate abc;

struct xyz;</pre> <p>Solution #2: Import the crate with a different name.</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate abc as xyz;

struct abc;</pre> <p>See the Declaration Statements section of the reference for more information about what constitutes an Item declaration and what does not:</p> <p><a href="../reference/#statements">https://doc.rust-lang.org/reference.html#statements</a></p>  <h3 id="E0261" class="section-header">E0261</h3> <p>When using a lifetime like <code>'a</code> in a type, it must be declared before being used.</p> <p>These two examples illustrate the problem:</p> <pre>// error, use of undeclared lifetime name `'a`
fn foo(x: &amp;'a str) { }

struct Foo {
    // error, use of undeclared lifetime name `'a`
    x: &amp;'a str,
}
</pre> <p>These can be fixed by declaring lifetime parameters:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(x: &amp;'a str) {}

struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}</pre>  <h3 id="E0262" class="section-header">E0262</h3> <p>Declaring certain lifetime names in parameters is disallowed. For example, because the <code>'static</code> lifetime is a special built-in lifetime name denoting the lifetime of the entire program, this is an error:</p> <pre>// error, invalid lifetime parameter name `'static`
fn foo&lt;'static&gt;(x: &amp;'static str) { }
</pre>  <h3 id="E0263" class="section-header">E0263</h3> <p>A lifetime name cannot be declared more than once in the same scope. For example:</p> <pre>// error, lifetime name `'a` declared twice in the same scope
fn foo&lt;'a, 'b, 'a&gt;(x: &amp;'a str, y: &amp;'b str) { }
</pre>  <h3 id="E0264" class="section-header">E0264</h3> <p>An unknown external lang item was used. Erroneous code example:</p> <pre>#![feature(lang_items)]

extern "C" {
    #[lang = "cake"] // error: unknown external lang item: `cake`
    fn cake();
}
</pre> <p>A list of available external lang items is available in <code>src/librustc/middle/weak_lang_items.rs</code>. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(lang_items)]

extern "C" {
    #[lang = "panic_fmt"] // ok!
    fn cake();
}</pre>  <h3 id="E0271" class="section-header">E0271</h3> <p>This is because of a type mismatch between the associated type of some trait (e.g. <code>T::Bar</code>, where <code>T</code> implements <code>trait Quux { type Bar; }</code>) and another type <code>U</code> that is required to be equal to <code>T::Bar</code>, but is not. Examples follow.</p> <p>Here is a basic example:</p> <pre>trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }

foo(3_i8);
</pre> <p>Here is that same example again, with some explanatory comments:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {
//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~
//                        |            |
//         This says `foo` can         |
//           only be used with         |
//              some type that         |
//         implements `Trait`.         |
//                                     |
//                             This says not only must
//                             `T` be an impl of `Trait`
//                             but also that the impl
//                             must assign the type `u32`
//                             to the associated type.
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }
~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//      |                             |
// `i8` does have                     |
// implementation                     |
// of `Trait`...                      |
//                     ... but it is an implementation
//                     that assigns `&amp;'static str` to
//                     the associated type.

foo(3_i8);
// Here, we invoke `foo` with an `i8`, which does not satisfy
// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and
// therefore the type-checker complains with this error code.</pre> <p>Here is a more subtle instance of the same problem, that can arise with for-loops in Rust:</p> <pre>let vs: Vec&lt;i32&gt; = vec![1, 2, 3, 4];
for v in &amp;vs {
    match v {
        1 =&gt; {},
        _ =&gt; {},
    }
}
</pre> <p>The above fails because of an analogous type mismatch, though may be harder to see. Again, here are some explanatory comments for the same example:</p> <pre class="rust rust-example-rendered" data-language="rust">
{
    let vs = vec![1, 2, 3, 4];

    // `for`-loops use a protocol based on the `Iterator`
    // trait. Each item yielded in a `for` loop has the
    // type `Iterator::Item` -- that is, `Item` is the
    // associated type of the concrete iterator impl.
    for v in &amp;vs {
//      ~    ~~~
//      |     |
//      |    We borrow `vs`, iterating over a sequence of
//      |    *references* of type `&amp;Elem` (where `Elem` is
//      |    vector's element type). Thus, the associated
//      |    type `Item` must be a reference `&amp;`-type ...
//      |
//  ... and `v` has the type `Iterator::Item`, as dictated by
//  the `for`-loop protocol ...

        match v {
            1 =&gt; {}
//          ~
//          |
// ... but *here*, `v` is forced to have some integral type;
// only types like `u8`,`i8`,`u16`,`i16`, et cetera can
// match the pattern `1` ...

            _ =&gt; {}
        }

// ... therefore, the compiler complains, because it sees
// an attempt to solve the equations
// `some integral-type` = type-of-`v`
//                      = `Iterator::Item`
//                      = `&amp;Elem` (i.e. `some reference type`)
//
// which cannot possibly all be true.

    }
}</pre> <p>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</p> <pre class="rust rust-example-rendered" data-language="rust">
// Basic Example:
trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = &amp;'static str&gt; {
    println!("in foo");
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }

foo(3_i8);

// For-Loop Example:
let vs = vec![1, 2, 3, 4];
for v in &amp;vs {
    match v {
        &amp;1 =&gt; {}
        _ =&gt; {}
    }
}</pre>  <h3 id="E0272" class="section-header">E0272</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <pre>#![feature(on_unimplemented)]

fn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}

#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index&lt;Idx&gt; { /* ... */ }

foo(true); // `bool` does not implement `Index&lt;u8&gt;`
</pre> <p>There will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case, <code>bool</code>) that we tried to use.</p> <p>This error appears when the curly braces contain an identifier which doesn't match with any of the type parameters or the string <code>Self</code>. This might happen if you misspelled a type parameter, or if you intended to use literal curly braces. If it is the latter, escape the curly braces with a second curly brace of the same type; e.g. a literal <code>{</code> is <code>{{</code>.</p>  <h3 id="E0273" class="section-header">E0273</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <pre>#![feature(on_unimplemented)]

fn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}

#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index&lt;Idx&gt; { /* ... */ }

foo(true); // `bool` does not implement `Index&lt;u8&gt;`
</pre> <p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case, <code>bool</code>) that we tried to use.</p> <p>This error appears when the curly braces do not contain an identifier. Please add one of the same name as a type parameter. If you intended to use literal braces, use <code>{{</code> and <code>}}</code> to escape them.</p>  <h3 id="E0274" class="section-header">E0274</h3> <p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</p> <pre>#![feature(on_unimplemented)]

fn foo&lt;T: Index&lt;u8&gt;&gt;(x: T){}

#[rustc_on_unimplemented = "the type `{Self}` cannot be indexed by `{Idx}`"]
trait Index&lt;Idx&gt; { /* ... */ }

foo(true); // `bool` does not implement `Index&lt;u8&gt;`
</pre> <p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a note saying "the type <code>bool</code> cannot be indexed by <code>u8</code>".</p> <p>For this to work, some note must be specified. An empty attribute will not do anything, please remove the attribute or add some helpful note for users of the trait.</p>  <h3 id="E0275" class="section-header">E0275</h3> <p>This error occurs when there was a recursive trait requirement that overflowed before it could be evaluated. Often this means that there is unbounded recursion in resolving some type bounds.</p> <p>For example, in the following code:</p> <pre>trait Foo {}

struct Bar&lt;T&gt;(T);

impl&lt;T&gt; Foo for T where Bar&lt;T&gt;: Foo {}
</pre> <p>To determine if a <code>T</code> is <code>Foo</code>, we need to check if <code>Bar&lt;T&gt;</code> is <code>Foo</code>. However, to do this check, we need to determine that <code>Bar&lt;Bar&lt;T&gt;&gt;</code> is <code>Foo</code>. To determine this, we check if <code>Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;</code> is <code>Foo</code>, and so on. This is clearly a recursive requirement that can't be resolved directly.</p> <p>Consider changing your trait bounds so that they're less self-referential.</p>  <h3 id="E0276" class="section-header">E0276</h3> <p>This error occurs when a bound in an implementation of a trait does not match the bounds specified in the original trait. For example:</p> <pre>trait Foo {
    fn foo&lt;T&gt;(x: T);
}

impl Foo for bool {
    fn foo&lt;T&gt;(x: T) where T: Copy {}
}
</pre> <p>Here, all types implementing <code>Foo</code> must have a method <code>foo&lt;T&gt;(x: T)</code> which can take any type <code>T</code>. However, in the <code>impl</code> for <code>bool</code>, we have added an extra bound that <code>T</code> is <code>Copy</code>, which isn't compatible with the original trait.</p> <p>Consider removing the bound from the method or adding the bound to the original method definition in the trait.</p>  <h3 id="E0277" class="section-header">E0277</h3> <p>You tried to use a type which doesn't implement some trait in a place which expected that trait. Erroneous code example:</p> <pre>// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&amp;self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}
</pre> <p>In order to fix this error, verify that the type you're using does implement the trait. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn bar(&amp;self);
}

fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar(); // we can now use this method since i32 implements the
               // Foo trait
}

// we implement the trait on the i32 type
impl Foo for i32 {
    fn bar(&amp;self) {}
}

fn main() {
    some_func(5i32); // ok!
}</pre> <p>Or in a generic context, an erroneous code example would look like:</p> <pre>fn some_func&lt;T&gt;(foo: T) {
    println!("{:?}", foo); // error: the trait `core::fmt::Debug` is not
                           //        implemented for the type `T`
}

fn main() {
    // We now call the method with the i32 type,
    // which *does* implement the Debug trait.
    some_func(5i32);
}
</pre> <p>Note that the error here is in the definition of the generic function: Although we only call it with a parameter that does implement <code>Debug</code>, the compiler still rejects the function: It must work with all possible input types. In order to make this example compile, we need to restrict the generic type we're accepting:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::fmt;

// Restrict the input type to types that implement Debug.
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!("{:?}", foo);
}

fn main() {
    // Calling the method is still fine, as i32 implements Debug.
    some_func(5i32);

    // This would fail to compile now:
    // struct WithoutDebug;
    // some_func(WithoutDebug);
}</pre> <p>Rust only looks at the signature of the called function, as such it must already specify all requirements that will be used for every type parameter.</p>     <h3 id="E0281" class="section-header">E0281</h3> <p>You tried to supply a type which doesn't implement some trait in a location which expected that trait. This error typically occurs when working with <code>Fn</code>-based types. Erroneous code example:</p> <pre>fn foo&lt;F: Fn()&gt;(x: F) { }

fn main() {
    // type mismatch: the type ... implements the trait `core::ops::Fn&lt;(_,)&gt;`,
    // but the trait `core::ops::Fn&lt;()&gt;` is required (expected (), found tuple
    // [E0281]
    foo(|y| { });
}
</pre> <p>The issue in this case is that <code>foo</code> is defined as accepting a <code>Fn</code> with no arguments, but the closure we attempted to pass to it requires one argument.</p>  <h3 id="E0282" class="section-header">E0282</h3> <p>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</p> <p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet that reverses the characters of a string:</p> <pre>let x = "hello".chars().rev().collect();
</pre> <p>In this case, the compiler cannot infer what the type of <code>x</code> should be: <code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type to use, you can use a type annotation on <code>x</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x: Vec&lt;char&gt; = "hello".chars().rev().collect();</pre> <p>It is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x: Vec&lt;_&gt; = "hello".chars().rev().collect();</pre> <p>Another way to provide the compiler with enough information, is to specify the generic type parameter:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "hello".chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();</pre> <p>Again, you need not specify the full type if the compiler can infer it:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = "hello".chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();</pre> <p>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</p> <pre>struct Foo&lt;T&gt; {
    num: T,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    fn bar() -&gt; i32 {
        0
    }

    fn baz() {
        let number = Foo::bar();
    }
}
</pre> <p>This will fail because the compiler does not know which instance of <code>Foo</code> to call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p>  <h3 id="E0283" class="section-header">E0283</h3> <p>This error occurs when the compiler doesn't have enough information to unambiguously choose an implementation.</p> <p>For example:</p> <pre>trait Generator {
    fn create() -&gt; u32;
}

struct Impl;

impl Generator for Impl {
    fn create() -&gt; u32 { 1 }
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

fn main() {
    let cont: u32 = Generator::create();
    // error, impossible to choose one of Generator trait implementation
    // Impl or AnotherImpl? Maybe anything else?
}
</pre> <p>To resolve this error use the concrete type:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Generator {
    fn create() -&gt; u32;
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

fn main() {
    let gen1 = AnotherImpl::create();

    // if there are multiple methods with same name (different traits)
    let gen2 = &lt;AnotherImpl as Generator&gt;::create();
}</pre>   <h3 id="E0296" class="section-header">E0296</h3> <p>This error indicates that the given recursion limit could not be parsed. Ensure that the value provided is a positive integer between quotes.</p> <p>Erroneous code example:</p> <pre>#![recursion_limit]

fn main() {}
</pre> <p>And a working example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![recursion_limit="1000"]

fn main() {}</pre>  <h3 id="E0297" class="section-header">E0297</h3> <p>Patterns used to bind names must be irrefutable. That is, they must guarantee that a name will be extracted in all cases. Instead of pattern matching the loop variable, consider using a <code>match</code> or <code>if let</code> inside the loop body. For instance:</p> <pre>let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

// This fails because `None` is not covered.
for Some(x) in xs {
    // ...
}
</pre> <p>Match inside the loop instead:</p> <pre class="rust rust-example-rendered" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    match item {
        Some(x) =&gt; {},
        None =&gt; {},
    }
}</pre> <p>Or use <code>if let</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    if let Some(x) = item {
        // ...
    }
}</pre>   <h3 id="E0301" class="section-header">E0301</h3> <p>Mutable borrows are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if mutable borrows were allowed:</p> <pre>match Some(()) {
    None =&gt; { },
    option if option.take().is_none() =&gt; {
        /* impossible, option is `Some` */
    },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}
</pre>  <h3 id="E0302" class="section-header">E0302</h3> <p>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</p> <pre>match Some(()) {
    None =&gt; { },
    option if { option = None; false } =&gt; { },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}
</pre>  <h3 id="E0303" class="section-header">E0303</h3> <p>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</p> <p>Before:</p> <pre>match Some("hi".to_string()) {
    ref op_string_ref @ Some(s) =&gt; {},
    None =&gt; {},
}
</pre> <p>After:</p> <pre class="rust rust-example-rendered" data-language="rust">
match Some("hi".to_string()) {
    Some(ref s) =&gt; {
        let op_string_ref = &amp;Some(s);
        // ...
    },
    None =&gt; {},
}</pre> <p>The <code>op_string_ref</code> binding has type <code>&amp;Option&lt;&amp;String&gt;</code> in both cases.</p> <p>See also <a href="https://github.com/rust-lang/rust/issues/14587" target="_blank">https://github.com/rust-lang/rust/issues/14587</a></p>  <h3 id="E0306" class="section-header">E0306</h3> <p>In an array type <code>[T; N]</code>, <code>N</code> is the number of elements in the array. This must be an unsigned integer. Erroneous code example:</p> <pre>const X: [i32; true] = [0]; // error: expected `usize` for array length,
                            //        found boolean
</pre> <p>Working example:</p> <pre class="rust rust-example-rendered" data-language="rust">
const X: [i32; 1] = [0];</pre>  <h3 id="E0308" class="section-header">E0308</h3> <p>This error occurs when the compiler was unable to infer the concrete type of a variable. It can occur for several cases, the most common of which is a mismatch in the expected type that the compiler inferred for a variable's initializing expression, and the actual type explicitly assigned to the variable.</p> <p>For example:</p> <pre>let x: i32 = "I am not a number!";
//     ~~~   ~~~~~~~~~~~~~~~~~~~~
//      |             |
//      |    initializing expression;
//      |    compiler infers type `&amp;str`
//      |
//    type `i32` assigned to variable `x`
</pre>  <h3 id="E0309" class="section-header">E0309</h3> <p>Types in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to be live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</p> <pre>// This won't compile because T is not constrained, meaning the data
// stored in it is not guaranteed to last as long as the reference
struct Foo&lt;'a, T&gt; {
    foo: &amp;'a T
}
</pre> <p>This will compile, because it has the constraint on the type parameter:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a, T: 'a&gt; {
    foo: &amp;'a T
}</pre> <p>To see why this is important, consider the case where <code>T</code> is itself a reference (e.g., <code>T = &amp;str</code>). If we don't include the restriction that <code>T: 'a</code>, the following code would be perfectly legal:</p> <pre>struct Foo&lt;'a, T&gt; {
    foo: &amp;'a T
}

fn main() {
    let v = "42".to_string();
    let f = Foo{foo: &amp;v};
    drop(v);
    println!("{}", f.foo); // but we've already dropped v!
}
</pre>  <h3 id="E0310" class="section-header">E0310</h3> <p>Types in type definitions have lifetimes associated with them that represent how long the data stored within them is guaranteed to be live. This lifetime must be as long as the data needs to be alive, and missing the constraint that denotes this will cause this error.</p> <pre>// This won't compile because T is not constrained to the static lifetime
// the reference needs
struct Foo&lt;T&gt; {
    foo: &amp;'static T
}
</pre> <p>This will compile, because it has the constraint on the type parameter:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T: 'static&gt; {
    foo: &amp;'static T
}</pre>   <h3 id="E0312" class="section-header">E0312</h3> <p>A lifetime of reference outlives lifetime of borrowed content.</p> <p>Erroneous code example:</p> <pre>fn make_child&lt;'human, 'elve&gt;(x: &amp;mut &amp;'human isize, y: &amp;mut &amp;'elve isize) {
    *x = *y;
    // error: lifetime of reference outlives lifetime of borrowed content
}
</pre> <p>The compiler cannot determine if the <code>human</code> lifetime will live long enough to keep up on the elve one. To solve this error, you have to give an explicit lifetime hierarchy:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn make_child&lt;'human, 'elve: 'human&gt;(x: &amp;mut &amp;'human isize,
                                     y: &amp;mut &amp;'elve isize) {
    *x = *y; // ok!
}</pre> <p>Or use the same lifetime for every variable:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn make_child&lt;'elve&gt;(x: &amp;mut &amp;'elve isize, y: &amp;mut &amp;'elve isize) {
    *x = *y; // ok!
}</pre>      <h3 id="E0317" class="section-header">E0317</h3> <p>This error occurs when an <code>if</code> expression without an <code>else</code> block is used in a context where a type other than <code>()</code> is expected, for example a <code>let</code> expression:</p> <pre>fn main() {
    let x = 5;
    let a = if x == 5 { 1 };
}
</pre> <p>An <code>if</code> expression without an <code>else</code> block has the type <code>()</code>, so this is a type error. To resolve it, add an <code>else</code> block having the same type as the <code>if</code> block.</p>  <h3 id="E0318" class="section-header">E0318</h3> <p>Default impls for a trait must be located in the same crate where the trait was defined. For more information see the <a href="https://github%0A.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md" target="_blank">opt-in builtin traits RFC</a>.</p>   <h3 id="E0321" class="section-header">E0321</h3> <p>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</p> <pre>#![feature(optin_builtin_traits)]

struct Foo;

impl !Sync for Foo {}

unsafe impl Send for &amp;'static Foo {}
// error: cross-crate traits with a default impl, like `core::marker::Send`,
//        can only be implemented for a struct/enum type, not
//        `&amp;'static Foo`
</pre> <p>Only structs and enums are permitted to impl Send, Sync, and other opt-out trait, and the struct or enum must be local to the current crate. So, for example, <code>unsafe impl Send for Rc&lt;Foo&gt;</code> is not allowed.</p>  <h3 id="E0322" class="section-header">E0322</h3> <p>The <code>Sized</code> trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</p>  <h3 id="E0323" class="section-header">E0323</h3> <p>An associated const was implemented when another trait item was expected. Erroneous code example:</p> <pre>#![feature(associated_consts)]

trait Foo {
    type N;
}

struct Bar;

impl Foo for Bar {
    const N : u32 = 0;
    // error: item `N` is an associated const, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
</pre> <p>Please verify that the associated const wasn't misspelled and the correct trait was implemented. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_consts)]

struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}</pre>  <h3 id="E0324" class="section-header">E0324</h3> <p>A method was implemented when another trait item was expected. Erroneous code example:</p> <pre>#![feature(associated_consts)]

struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    fn N() {}
    // error: item `N` is an associated method, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
</pre> <p>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_consts)]

struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    const N : u32 = 0;

    fn M() {} // ok!
}</pre>  <h3 id="E0325" class="section-header">E0325</h3> <p>An associated type was implemented when another trait item was expected. Erroneous code example:</p> <pre>#![feature(associated_consts)]

struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    type N = u32;
    // error: item `N` is an associated type, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
</pre> <p>Please verify that the associated type name wasn't misspelled and your implementation corresponds to the trait definition. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_consts)]

struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}</pre>  <h3 id="E0326" class="section-header">E0326</h3> <p>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</p> <p>Here's an example of this error:</p> <pre>#![feature(associated_consts)]

trait Foo {
    const BAR: bool;
}

struct Bar;

impl Foo for Bar {
    const BAR: u32 = 5; // error, expected bool, found u32
}
</pre>  <h3 id="E0328" class="section-header">E0328</h3> <p>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</p> <p>Erroneous code example:</p> <pre>#![feature(unsize)]

use std::marker::Unsize;

pub struct MyType;

impl&lt;T&gt; Unsize&lt;T&gt; for MyType {}
</pre> <p>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md" target="_blank">DST coercion system</a>, use <a href="../std/ops/trait.coerceunsized/"><code>CoerceUnsized</code></a> instead.</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]

use std::ops::CoerceUnsized;

pub struct MyType&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

impl&lt;T, U&gt; CoerceUnsized&lt;MyType&lt;U&gt;&gt; for MyType&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre>  <h3 id="E0329" class="section-header">E0329</h3> <p>An attempt was made to access an associated constant through either a generic type parameter or <code>Self</code>. This is not supported yet. An example causing this error is shown below:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_consts)]

trait Foo {
    const BAR: f64;
}

struct MyStruct;

impl Foo for MyStruct {
    const BAR: f64 = 0f64;
}

fn get_bar_bad&lt;F: Foo&gt;(t: F) -&gt; f64 {
    F::BAR
}</pre> <p>Currently, the value of <code>BAR</code> for a particular type can only be accessed through a concrete type, as shown below:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_consts)]

trait Foo {
    const BAR: f64;
}

struct MyStruct;

fn get_bar_good() -&gt; f64 {
    &lt;MyStruct as Foo&gt;::BAR
}</pre>  <h3 id="E0364" class="section-header">E0364</h3> <p>Private items cannot be publicly re-exported. This error indicates that you attempted to <code>pub use</code> a type or value that was not itself public.</p> <p>Erroneous code example:</p> <pre>mod foo {
    const X: u32 = 1;
}

pub use foo::X;

fn main() {}
</pre> <p>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with <code>pub</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod foo {
    pub const X: u32 = 1;
}

pub use foo::X;

fn main() {}</pre> <p>See the 'Use Declarations' section of the reference for more information on this topic:</p> <p><a href="../reference/#use-declarations">https://doc.rust-lang.org/reference.html#use-declarations</a></p>  <h3 id="E0365" class="section-header">E0365</h3> <p>Private modules cannot be publicly re-exported. This error indicates that you attempted to <code>pub use</code> a module that was not itself public.</p> <p>Erroneous code example:</p> <pre>mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}
</pre> <p>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with <code>pub</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
pub mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</pre> <p>See the 'Use Declarations' section of the reference for more information on this topic:</p> <p><a href="../reference/#use-declarations">https://doc.rust-lang.org/reference.html#use-declarations</a></p>  <h3 id="E0366" class="section-header">E0366</h3> <p>An attempt was made to implement <code>Drop</code> on a concrete specialization of a generic type. An example is shown below:</p> <pre>struct Foo&lt;T&gt; {
    t: T
}

impl Drop for Foo&lt;u32&gt; {
    fn drop(&amp;mut self) {}
}
</pre> <p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of implementations of a generic type. One workaround for this is to wrap the generic type, as shown below:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;T&gt; {
    t: T
}

struct Bar {
    t: Foo&lt;u32&gt;
}

impl Drop for Bar {
    fn drop(&amp;mut self) {}
}</pre>  <h3 id="E0367" class="section-header">E0367</h3> <p>An attempt was made to implement <code>Drop</code> on a specialization of a generic type. An example is shown below:</p> <pre>trait Foo{}

struct MyStruct&lt;T&gt; {
    t: T
}

impl&lt;T: Foo&gt; Drop for MyStruct&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
</pre> <p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of implementations of a generic type. In order for this code to work, <code>MyStruct</code> must also require that <code>T</code> implements <code>Foo</code>. Alternatively, another option is to wrap the generic type in another that specializes appropriately:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo{}

struct MyStruct&lt;T&gt; {
    t: T
}

struct MyStructWrapper&lt;T: Foo&gt; {
    t: MyStruct&lt;T&gt;
}

impl &lt;T: Foo&gt; Drop for MyStructWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}</pre>  <h3 id="E0368" class="section-header">E0368</h3> <p>This error indicates that a binary assignment operator like <code>+=</code> or <code>^=</code> was applied to a type that doesn't support it. For example:</p> <pre>let mut x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
                   //        type `f32`

x &lt;&lt;= 2;
</pre> <p>To fix this error, please check that this type implements this binary operation. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait

x &lt;&lt;= 2; // ok!</pre> <p>It is also possible to overload most operators for your own type by implementing the <code>[OP]Assign</code> traits from <code>std::ops</code>.</p> <p>Another problem you might be facing is this: suppose you've overloaded the <code>+</code> operator for some type <code>Foo</code> by implementing the <code>std::ops::Add</code> trait for <code>Foo</code>, but you find that using <code>+=</code> does not work, as in this example:</p> <pre>use std::ops::Add;

struct Foo(u32);

impl Add for Foo {
    type Output = Foo;

    fn add(self, rhs: Foo) -&gt; Foo {
        Foo(self.0 + rhs.0)
    }
}

fn main() {
    let mut x: Foo = Foo(5);
    x += Foo(7); // error, `+= cannot be applied to the type `Foo`
}
</pre> <p>This is because <code>AddAssign</code> is not automatically implemented, so you need to manually implement it for your type.</p>  <h3 id="E0369" class="section-header">E0369</h3> <p>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</p> <pre>let x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
               //        type `f32`

x &lt;&lt; 2;
</pre> <p>To fix this error, please check that this type implements this binary operation. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = 12u32; // the `u32` type does implement it:
               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html

x &lt;&lt; 2; // ok!</pre> <p>It is also possible to overload most operators for your own type by implementing traits from <code>std::ops</code>.</p>  <h3 id="E0370" class="section-header">E0370</h3> <p>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</p> <pre>#[deny(overflowing_literals)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y, // error: enum discriminant overflowed on value after
       //        9223372036854775807: i64; set explicitly via
       //        Y = -9223372036854775808 if that is desired outcome
}
</pre> <p>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    X = 0x7fffffffffffffff,
    Y = 0, // ok!
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    Y = 0, // ok!
    X = 0x7fffffffffffffff,
}</pre>  <h3 id="E0371" class="section-header">E0371</h3> <p>When <code>Trait2</code> is a subtrait of <code>Trait1</code> (for example, when <code>Trait2</code> has a definition like <code>trait Trait2: Trait1 { ... }</code>), it is not allowed to implement <code>Trait1</code> for <code>Trait2</code>. This is because <code>Trait2</code> already implements <code>Trait1</code> by definition, so it is not useful to do this.</p> <p>Example:</p> <pre>trait Foo { fn foo(&amp;self) { } }
trait Bar: Foo { }
trait Baz: Bar { }

impl Bar for Baz { } // error, `Baz` implements `Bar` by definition
impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`
impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`
impl Baz for Bar { } // Note: This is OK
</pre>  <h3 id="E0373" class="section-header">E0373</h3> <p>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure:</p> <pre>fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(|y| x + y)
}
</pre> <p>Notice that <code>x</code> is stack-allocated by <code>foo()</code>. By default, Rust captures closed-over data by reference. This means that once <code>foo()</code> returns, <code>x</code> no longer exists. An attempt to access <code>x</code> within the closure would thus be unsafe.</p> <p>Another situation where this might be encountered is when spawning threads:</p> <pre>fn foo() {
    let x = 0u32;
    let y = 1u32;

    let thr = std::thread::spawn(|| {
        x + y
    });
}
</pre> <p>Since our new thread runs in parallel, the stack frame containing <code>x</code> and <code>y</code> may well have disappeared by the time we try to use them. Even if we call <code>thr.join()</code> within foo (which blocks until <code>thr</code> has completed, ensuring the stack frame won't disappear), we will not succeed: the compiler cannot prove that this behaviour is safe, and so won't let us do it.</p> <p>The solution to this problem is usually to switch to using a <code>move</code> closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(move |y| x + y)
}</pre> <p>Now that the closure has its own copy of the data, there's no need to worry about safety.</p>  <h3 id="E0374" class="section-header">E0374</h3> <p>A struct without a field containing an unsized type cannot implement <code>CoerceUnsized</code>. An <a href="../book/unsized-types/">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p>Example of erroneous code:</p> <pre>#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
}

// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}
</pre> <p><code>CoerceUnsized</code> is used to coerce one struct containing an unsized type into another struct containing a different unsized type. If the struct doesn't have any fields of unsized types then you don't need explicit coercion to get the types you want. To fix this you can either not try to implement <code>CoerceUnsized</code> or you can add a field that is unsized to the struct.</p> <p>Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

// We don't need to impl `CoerceUnsized` here.
struct Foo {
    a: i32,
}

// We add the unsized type field to the struct.
struct Bar&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

// The struct has an unsized field so we can implement
// `CoerceUnsized` for it.
impl&lt;T, U&gt; CoerceUnsized&lt;Bar&lt;U&gt;&gt; for Bar&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}</pre> <p>Note that <code>CoerceUnsized</code> is mainly used by smart pointers like <code>Box</code>, <code>Rc</code> and <code>Arc</code> to be able to mark that they can coerce unsized types that they are pointing at.</p>  <h3 id="E0375" class="section-header">E0375</h3> <p>A struct with more than one field containing an unsized type cannot implement <code>CoerceUnsized</code>. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl <code>CoerceUnsized</code> from <code>T</code> to <code>U</code> which are both types that the struct takes. An <a href="../book/unsized-types/">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p>Example of erroneous code:</p> <pre>#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized, U: ?Sized&gt; {
    a: i32,
    b: T,
    c: U,
}

// error: Struct `Foo` has more than one unsized field.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U, T&gt;&gt; for Foo&lt;T, U&gt; {}
</pre> <p><code>CoerceUnsized</code> only allows for coercion from a structure with a single unsized type field to another struct with a single unsized type field. In fact Rust only allows for a struct to have one unsized type in a struct and that unsized type must be the last field in the struct. So having two unsized types in a single struct is not allowed by the compiler. To fix this use only one field containing an unsized type in the struct and then use multiple structs to manage each unsized type field you need.</p> <p>Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

impl &lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}

fn coerce_foo&lt;T: CoerceUnsized&lt;U&gt;, U&gt;(t: T) -&gt; Foo&lt;U&gt; {
    Foo { a: 12i32, b: t } // we use coercion to get the `Foo&lt;U&gt;` type we need
}</pre>  <h3 id="E0376" class="section-header">E0376</h3> <p>The type you are trying to impl <code>CoerceUnsized</code> for is not a struct. <code>CoerceUnsized</code> can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of <code>CoerceUnsized</code> whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An <a href="../book/unsized-types/">unsized type</a> is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</p> <p>Example of erroneous code:</p> <pre>#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: T,
}

// error: The type `U` is not a struct
impl&lt;T, U&gt; CoerceUnsized&lt;U&gt; for Foo&lt;T&gt; {}
</pre> <p>The <code>CoerceUnsized</code> trait takes a struct type. Make sure the type you are providing to <code>CoerceUnsized</code> is a struct with only the last field containing an unsized type.</p> <p>Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(coerce_unsized)]
use std::ops::CoerceUnsized;

struct Foo&lt;T&gt; {
    a: T,
}

// The `Foo&lt;U&gt;` is a struct so `CoerceUnsized` can be implemented
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt; where T: CoerceUnsized&lt;U&gt; {}</pre> <p>Note that in Rust, structs can only contain an unsized type if the field containing the unsized type is the last and only unsized type field in the struct.</p>   <h3 id="E0380" class="section-header">E0380</h3> <p>Default impls are only allowed for traits with no methods or associated items. For more information see the <a href="https://github.com/rust%0A-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md" target="_blank">opt-in builtin traits RFC</a>.</p>  <h3 id="E0381" class="section-header">E0381</h3> <p>It is not allowed to use or capture an uninitialized variable. For example:</p> <pre>fn main() {
    let x: i32;
    let y = x; // error, use of possibly uninitialized variable
}
</pre> <p>To fix this, ensure that any declared variables are initialized before being used. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let x: i32 = 0;
    let y = x; // ok!
}</pre>  <h3 id="E0382" class="section-header">E0382</h3> <p>This error occurs when an attempt is made to use a variable after its contents have been moved elsewhere. For example:</p> <pre>struct MyStruct { s: u32 }

fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
}
</pre> <p>Since <code>MyStruct</code> is a type that is not marked <code>Copy</code>, the data gets moved out of <code>x</code> when we set <code>y</code>. This is fundamental to Rust's ownership system: outside of workarounds like <code>Rc</code>, a value cannot be owned by more than one variable.</p> <p>If we own the type, the easiest way to address this problem is to implement <code>Copy</code> and <code>Clone</code> on it, as shown below. This allows <code>y</code> to copy the information in <code>x</code>, while leaving the original version owned by <code>x</code>. Subsequent changes to <code>x</code> will not be reflected when accessing <code>y</code>.</p> <pre class="rust rust-example-rendered" data-language="rust">
#[derive(Copy, Clone)]
struct MyStruct { s: u32 }

fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
}</pre> <p>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use <code>Rc</code> and <code>RefCell</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;
use std::rc::Rc;

struct MyStruct { s: u32 }

fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!("{}", x.borrow().s);
}</pre> <p>With this approach, x and y share ownership of the data via the <code>Rc</code> (reference count type). <code>RefCell</code> essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</p> <p>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</p> <p><a href="../book/ownership/">https://doc.rust-lang.org/book/ownership.html</a></p>  <h3 id="E0383" class="section-header">E0383</h3> <p>This error occurs when an attempt is made to partially reinitialize a structure that is currently uninitialized.</p> <p>For example, this can happen when a drop has taken place:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    a: u32,
}

let mut x = Foo { a: 1 };
drop(x); // `x` is now uninitialized
x.a = 2; // error, partial reinitialization of uninitialized structure `t`</pre> <p>This error can be fixed by fully reinitializing the structure in question:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    a: u32,
}

let mut x = Foo { a: 1 };
drop(x);
x = Foo { a: 2 };</pre>  <h3 id="E0384" class="section-header">E0384</h3> <p>This error occurs when an attempt is made to reassign an immutable variable. For example:</p> <pre>fn main() {
    let x = 3;
    x = 5; // error, reassignment of immutable variable
}
</pre> <p>By default, variables in Rust are immutable. To fix this error, add the keyword <code>mut</code> after the keyword <code>let</code> when declaring the variable. For example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut x = 3;
    x = 5;
}</pre>   <h3 id="E0386" class="section-header">E0386</h3> <p>This error occurs when an attempt is made to mutate the target of a mutable reference stored inside an immutable container.</p> <p>For example, this can happen when storing a <code>&amp;mut</code> inside an immutable <code>Box</code>:</p> <pre>let mut x: i64 = 1;
let y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2; // error, cannot assign to data in an immutable container
</pre> <p>This error can be fixed by making the container mutable:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut x: i64 = 1;
let mut y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2;</pre> <p>It can also be fixed by using a type with interior mutability, such as <code>Cell</code> or <code>RefCell</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;

let x: i64 = 1;
let y: Box&lt;Cell&lt;_&gt;&gt; = Box::new(Cell::new(x));
y.set(2);</pre>  <h3 id="E0387" class="section-header">E0387</h3> <p>This error occurs when an attempt is made to mutate or mutably reference data that a closure has captured immutably. Examples of this error are shown below:</p> <pre>// Accepts a function or a closure that captures its environment immutably.
// Closures passed to foo will not be able to mutate their closed-over state.
fn foo&lt;F: Fn()&gt;(f: F) { }

// Attempts to mutate closed-over data. Error message reads:
// `cannot assign to data in a captured outer variable...`
fn mutable() {
    let mut x = 0u32;
    foo(|| x = 2);
}

// Attempts to take a mutable reference to closed-over data.  Error message
// reads: `cannot borrow data mutably in a captured outer variable...`
fn mut_addr() {
    let mut x = 0u32;
    foo(|| { let y = &amp;mut x; });
}
</pre> <p>The problem here is that foo is defined as accepting a parameter of type <code>Fn</code>. Closures passed into foo will thus be inferred to be of type <code>Fn</code>, meaning that they capture their context immutably.</p> <p>If the definition of <code>foo</code> is under your control, the simplest solution is to capture the data mutably. This can be done by defining <code>foo</code> to take FnMut rather than Fn:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;F: FnMut()&gt;(f: F) { }</pre> <p>Alternatively, we can consider using the <code>Cell</code> and <code>RefCell</code> types to achieve interior mutability through a shared reference. Our example's <code>mutable</code> function could be redefined as below:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::cell::Cell;

fn foo&lt;F: Fn()&gt;(f: F) { }

fn mutable() {
    let x = Cell::new(0u32);
    foo(|| x.set(2));
}</pre> <p>You can read more about cell types in the API documentation:</p> <p><a href="../std/cell/">https://doc.rust-lang.org/std/cell/</a></p>  <h3 id="E0388" class="section-header">E0388</h3> <p>A mutable borrow was attempted in a static location.</p> <p>Erroneous code example:</p> <pre>static X: i32 = 1;

static STATIC_REF: &amp;'static mut i32 = &amp;mut X;
// error: cannot borrow data mutably in a static location

const CONST_REF: &amp;'static mut i32 = &amp;mut X;
// error: cannot borrow data mutably in a static location
</pre> <p>To fix this error, you have to use constant borrow:</p> <pre class="rust rust-example-rendered" data-language="rust">
static X: i32 = 1;

static STATIC_REF: &amp;'static i32 = &amp;X;</pre>  <h3 id="E0389" class="section-header">E0389</h3> <p>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (<code>&amp;(&amp;mut T)</code>).</p> <p>Example of erroneous code:</p> <pre>struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &amp;(&amp;mut fancy);
    fancy_ref.num = 6; // error: cannot assign to data in a `&amp;` reference
    println!("{}", fancy_ref.num);
}
</pre> <p>Here, <code>&amp;mut fancy</code> is mutable, but <code>&amp;(&amp;mut fancy)</code> is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type <code>&amp;(&amp;mut T)</code> that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</p> <p>To fix this, either remove the outer reference:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut fancy;
    // `fancy_ref` is now &amp;mut FancyNum, rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</pre> <p>Or make the outer reference mutable:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut (&amp;mut fancy);
    // `fancy_ref` is now &amp;mut(&amp;mut FancyNum), rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!("{}", fancy_ref.num);
}</pre>  <h3 id="E0390" class="section-header">E0390</h3> <p>You tried to implement methods for a primitive type. Erroneous code example:</p> <pre>struct Foo {
    x: i32
}

impl *mut Foo {}
// error: only a single inherent implementation marked with
//        `#[lang = "mut_ptr"]` is allowed for the `*mut T` primitive
</pre> <p>This isn't allowed, but using a trait to implement a method is a good solution. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo {
    x: i32
}

trait Bar {
    fn bar();
}

impl Bar for *mut Foo {
    fn bar() {} // ok!
}</pre>  <h3 id="E0391" class="section-header">E0391</h3> <p>This error indicates that some types or traits depend on each other and therefore cannot be constructed.</p> <p>The following example contains a circular dependency between two traits:</p> <pre>trait FirstTrait : SecondTrait {

}

trait SecondTrait : FirstTrait {

}
</pre>  <h3 id="E0392" class="section-header">E0392</h3> <p>This error indicates that a type or lifetime parameter has been declared but not actually used. Here is an example that demonstrates the error:</p> <pre>enum Foo&lt;T&gt; {
    Bar,
}
</pre> <p>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo {
    Bar,
}</pre> <p>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Foo&lt;T&gt; {
    Bar(T),
}</pre> <p>This error may also commonly be found when working with unsafe code. For example, when using raw pointers one may wish to specify the lifetime for which the pointed-at data is valid. An initial attempt (below) causes this error:</p> <pre>struct Foo&lt;'a, T&gt; {
    x: *const T,
}
</pre> <p>We want to express the constraint that Foo should not outlive <code>'a</code>, because the data pointed to by <code>T</code> is only valid for that lifetime. The problem is that there are no actual uses of <code>'a</code>. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference <code>&amp;'a T</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::marker::PhantomData;

struct Foo&lt;'a, T: 'a&gt; {
    x: *const T,
    phantom: PhantomData&lt;&amp;'a T&gt;
}</pre> <p>PhantomData can also be used to express information about unused type parameters. You can read more about it in the API documentation:</p> <p><a href="../std/marker/struct.phantomdata/">https://doc.rust-lang.org/std/marker/struct.PhantomData.html</a></p>  <h3 id="E0393" class="section-header">E0393</h3> <p>A type parameter which references <code>Self</code> in its default value was not specified. Example of erroneous code:</p> <pre>trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A) {}
// error: the type parameter `T` must be explicitly specified in an
//        object type because its default value `Self` references the
//        type `Self`
</pre> <p>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is <code>Self</code>, the trait changes for each concrete type; i.e. <code>i32</code> will be expected to implement <code>A&lt;i32&gt;</code>, <code>bool</code> will be expected to implement <code>A&lt;bool&gt;</code>, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A&lt;i32&gt;) {} // Ok!</pre>  <h3 id="E0398" class="section-header">E0398</h3> <p>In Rust 1.3, the default object lifetime bounds are expected to change, as described in RFC #1156 <a href="https://github.com/rust-lang/rfcs/pull/1156" target="_blank">1</a>. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</p> <p>The heart of the change is that where <code>&amp;'a Box&lt;SomeTrait&gt;</code> used to default to <code>&amp;'a Box&lt;SomeTrait+'a&gt;</code>, it now defaults to <code>&amp;'a Box&lt;SomeTrait+'static&gt;</code> (here, <code>SomeTrait</code> is the name of some trait type). Note that the only types which are affected are references to boxes, like <code>&amp;Box&lt;SomeTrait&gt;</code> or <code>&amp;[Box&lt;SomeTrait&gt;]</code>. More common types like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code> are unaffected.</p> <p>To silence this warning, edit your code to use an explicit bound. Most of the time, this means that you will want to change the signature of a function that you are calling. For example, if the error is reported on a call like <code>foo(x)</code>, and <code>foo</code> is defined as follows:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo(arg: &amp;Box&lt;SomeTrait&gt;) { ... }</pre> <p>You might change it to:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;'a&gt;(arg: &amp;Box&lt;SomeTrait+'a&gt;) { ... }</pre> <p>This explicitly states that you expect the trait object <code>SomeTrait</code> to contain references (with a maximum lifetime of <code>'a</code>).</p>  <h3 id="E0399" class="section-header">E0399</h3> <p>You implemented a trait, overriding one or more of its associated types but did not reimplement its default methods.</p> <p>Example of erroneous code:</p> <pre>#![feature(associated_type_defaults)]

pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    // error - the following trait items need to be reimplemented as
    //         `Assoc` was overridden: `bar`
    type Assoc = i32;
}
</pre> <p>To fix this, add an implementation for each default method from the trait:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(associated_type_defaults)]

pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    type Assoc = i32;
    fn bar(&amp;self) {} // ok!
}</pre>  <h3 id="E0401" class="section-header">E0401</h3> <p>Inner items do not inherit type parameters from the functions they are embedded in.</p> <p>Erroneous code example:</p> <pre>fn foo&lt;T&gt;(x: T) {
    fn bar(y: T) { // T is defined in the "outer" function
        // ..
    }
    bar(x);
}
</pre> <p>Nor will this:</p> <pre>fn foo&lt;T&gt;(x: T) {
    type MaybeT = Option&lt;T&gt;;
    // ...
}
</pre> <p>Or this:</p> <pre>fn foo&lt;T&gt;(x: T) {
    struct Foo {
        x: T,
    }
    // ...
}
</pre> <p>Items inside functions are basically just like top-level items, except that they can only be used from the function they are in.</p> <p>There are a couple of solutions for this.</p> <p>If the item is a function, you may use a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
}</pre> <p>For a generic item, you can copy over the parameters:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    fn bar&lt;T&gt;(y: T) {
        // ..
    }
    bar(x);
}</pre> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T&gt;(x: T) {
    type MaybeT&lt;T&gt; = Option&lt;T&gt;;
}</pre> <p>Be sure to copy over any bounds as well:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T: Copy&gt;(x: T) {
    fn bar&lt;T: Copy&gt;(y: T) {
        // ..
    }
    bar(x);
}</pre> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T: Copy&gt;(x: T) {
    struct Foo&lt;T: Copy&gt; {
        x: T,
    }
}</pre> <p>This may require additional type hints in the function body.</p> <p>In case the item is a function inside an <code>impl</code>, defining a private helper function might be easier:</p> <pre class="rust rust-example-rendered" data-language="rust">
impl&lt;T&gt; Foo&lt;T&gt; {
    pub fn foo(&amp;self, x: T) {
        self.bar(x);
    }

    fn bar(&amp;self, y: T) {
        // ..
    }
}</pre> <p>For default impls in traits, the private helper solution won't work, however closures or copying the parameters should still work.</p>   <h3 id="E0403" class="section-header">E0403</h3> <p>Some type parameters have the same name.</p> <p>Erroneous code example:</p> <pre>fn foo&lt;T, T&gt;(s: T, u: T) {} // error: the name `T` is already used for a type
                            //        parameter in this type parameter list
</pre> <p>Please verify that none of the type parameterss are misspelled, and rename any clashing parameters. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo&lt;T, Y&gt;(s: T, u: Y) {} // ok!</pre>  <h3 id="E0404" class="section-header">E0404</h3> <p>You tried to implement something which was not a trait on an object.</p> <p>Erroneous code example:</p> <pre>struct Foo;
struct Bar;

impl Foo for Bar {} // error: `Foo` is not a trait
</pre> <p>Please verify that you didn't misspell the trait's name or otherwise use the wrong identifier. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    // some functions
}
struct Bar;

impl Foo for Bar { // ok!
    // functions implementation
}</pre>  <h3 id="E0405" class="section-header">E0405</h3> <p>The code refers to a trait that is not in scope.</p> <p>Erroneous code example:</p> <pre>struct Foo;

impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope
</pre> <p>Please verify that the name of the trait wasn't misspelled and ensure that it was imported. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
// solution 1:
use some_file::SomeTrait;

// solution 2:
trait SomeTrait {
    // some functions
}

struct Foo;

impl SomeTrait for Foo { // ok!
    // implements functions
}</pre>  <h3 id="E0407" class="section-header">E0407</h3> <p>A definition of a method not in the implemented trait was given in a trait implementation.</p> <p>Erroneous code example:</p> <pre>trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // error: method `b` is not a member of trait `Foo`
}
</pre> <p>Please verify you didn't misspell the method name and you used the correct trait. First example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn a();
    fn b();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // ok!
}</pre> <p>Second example:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
}

impl Bar {
    fn b() {}
}</pre>  <h3 id="E0408" class="section-header">E0408</h3> <p>An "or" pattern was used where the variable bindings are not consistently bound across patterns.</p> <p>Erroneous code example:</p> <pre>match x {
    Some(y) | None =&gt; { /* use y */ } // error: variable `y` from pattern #1 is
                                      //        not bound in pattern #2
    _ =&gt; ()
}
</pre> <p>Here, <code>y</code> is bound to the contents of the <code>Some</code> and can be used within the block corresponding to the match arm. However, in case <code>x</code> is <code>None</code>, we have not specified what <code>y</code> is, and the block will use a nonexistent variable.</p> <p>To fix this error, either split into multiple match arms:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = Some(1);
match x {
    Some(y) =&gt; { /* use y */ }
    None =&gt; { /* ... */ }
}</pre> <p>or, bind the variable to a field of the same type in all sub-patterns of the or pattern:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (0, y) | (y, 0) =&gt; { /* use y */}
    _ =&gt; {}
}</pre> <p>In this example, if <code>x</code> matches the pattern <code>(0, _)</code>, the second field is set to <code>y</code>. If it matches <code>(_, 0)</code>, the first field is set to <code>y</code>; so in all cases <code>y</code> is set to some value.</p>  <h3 id="E0409" class="section-header">E0409</h3> <p>An "or" pattern was used where the variable bindings are not consistently bound across patterns.</p> <p>Erroneous code example:</p> <pre>let x = (0, 2);
match x {
    (0, ref y) | (y, 0) =&gt; { /* use y */} // error: variable `y` is bound with
                                          //        different mode in pattern #2
                                          //        than in pattern #1
    _ =&gt; ()
}
</pre> <p>Here, <code>y</code> is bound by-value in one case and by-reference in the other.</p> <p>To fix this error, just use the same mode in both cases. Generally using <code>ref</code> or <code>ref mut</code> where not already used will fix this:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (0, ref y) | (ref y, 0) =&gt; { /* use y */}
    _ =&gt; ()
}</pre> <p>Alternatively, split the pattern:</p> <pre class="rust rust-example-rendered" data-language="rust">
let x = (0, 2);
match x {
    (y, 0) =&gt; { /* use y */ }
    (0, ref y) =&gt; { /* use y */}
    _ =&gt; ()
}</pre>  <h3 id="E0411" class="section-header">E0411</h3> <p>The <code>Self</code> keyword was used outside an impl or a trait.</p> <p>Erroneous code example:</p> <pre>&lt;Self&gt;::foo; // error: use of `Self` outside of an impl or trait
</pre> <p>The <code>Self</code> keyword represents the current type, which explains why it can only be used inside an impl or a trait. It gives access to the associated items of a type:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    type Bar;
}

trait Baz : Foo {
    fn bar() -&gt; Self::Bar; // like this
}</pre> <p>However, be careful when two types have a common associated type:</p> <pre>trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; Self::Bar;
    // error: ambiguous associated type `Bar` in bounds of `Self`
}
</pre> <p>This problem can be solved by specifying from which trait we want to use the <code>Bar</code> type:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; &lt;Self as Foo&gt;::Bar; // ok!
}</pre>  <h3 id="E0412" class="section-header">E0412</h3> <p>The type name used is not in scope.</p> <p>Erroneous code examples:</p> <pre>impl Something {} // error: type name `Something` is not in scope

// or:

trait Foo {
    fn bar(N); // error: type name `N` is not in scope
}

// or:

fn foo(x: T) {} // type name `T` is not in scope
</pre> <p>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Something;

impl Something {} // ok!

// or:

trait Foo {
    type N;

    fn bar(Self::N); // ok!
}

// or:

fn foo&lt;T&gt;(x: T) {} // ok!</pre>  <h3 id="E0415" class="section-header">E0415</h3> <p>More than one function parameter have the same name.</p> <p>Erroneous code example:</p> <pre>fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than
                          //        once in this parameter list
</pre> <p>Please verify you didn't misspell parameters' name. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo(f: i32, g: i32) {} // ok!</pre>  <h3 id="E0416" class="section-header">E0416</h3> <p>An identifier is bound more than once in a pattern.</p> <p>Erroneous code example:</p> <pre>match (1, 2) {
    (x, x) =&gt; {} // error: identifier `x` is bound more than once in the
                 //        same pattern
}
</pre> <p>Please verify you didn't misspell identifiers' name. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
match (1, 2) {
    (x, y) =&gt; {} // ok!
}</pre> <p>Or maybe did you mean to unify? Consider using a guard:</p> <pre class="rust rust-example-rendered" data-language="rust">
match (A, B, C) {
    (x, x2, see) if x == x2 =&gt; { /* A and B are equal, do one thing */ }
    (y, z, see) =&gt; { /* A and B unequal; do another thing */ }
}</pre>  <h3 id="E0422" class="section-header">E0422</h3> <p>You are trying to use an identifier that is either undefined or not a struct. Erroneous code example: <code>compile_fail,E0422 fn main () { let x = Foo { x: 1, y: 2 }; }</code> In this case, <code>Foo</code> is undefined, so it inherently isn't anything, and definitely not a struct. <code>compile_fail fn main () { let foo = 1; let x = foo { x: 1, y: 2 }; }</code> In this case, <code>foo</code> is defined, but is not a struct, so Rust can't use it as one.</p>  <h3 id="E0423" class="section-header">E0423</h3> <p>A <code>struct</code> variant name was used like a function name.</p> <p>Erroneous code example:</p> <pre>struct Foo { a: bool };

let f = Foo();
// error: `Foo` is a struct variant name, but this expression uses
//        it like a function name
</pre> <p>Please verify you didn't misspell the name of what you actually wanted to use here. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn Foo() -&gt; u32 { 0 }

let f = Foo(); // ok!</pre>  <h3 id="E0424" class="section-header">E0424</h3> <p>The <code>self</code> keyword was used in a static method.</p> <p>Erroneous code example:</p> <pre>struct Foo;

impl Foo {
    fn bar(self) {}

    fn foo() {
        self.bar(); // error: `self` is not available in a static method.
    }
}
</pre> <p>Please check if the method's argument list should have contained <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> (in case you didn't want to create a static method), and add it if so. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo;

impl Foo {
    fn bar(self) {}

    fn foo(self) {
        self.bar(); // ok!
    }
}</pre>  <h3 id="E0425" class="section-header">E0425</h3> <p>An unresolved name was used.</p> <p>Erroneous code examples:</p> <pre>something_that_doesnt_exist::foo;
// error: unresolved name `something_that_doesnt_exist::foo`

// or:

trait Foo {
    fn bar() {
        Self; // error: unresolved name `Self`
    }
}

// or:

let x = unknown_variable;  // error: unresolved name `unknown_variable`
</pre> <p>Please verify that the name wasn't misspelled and ensure that the identifier being referred to is valid for the given situation. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum something_that_does_exist {
    Foo,
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod something_that_does_exist {
    pub static foo : i32 = 0i32;
}

something_that_does_exist::foo; // ok!</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
let unknown_variable = 12u32;
let x = unknown_variable; // ok!</pre> <p>If the item is not defined in the current module, it must be imported using a <code>use</code> statement, like so:</p> <pre class="rust rust-example-rendered" data-language="rust">
use foo::bar;
bar();</pre> <p>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., <code>pub fn</code>).</p>  <h3 id="E0426" class="section-header">E0426</h3> <p>An undeclared label was used.</p> <p>Erroneous code example:</p> <pre>loop {
    break 'a; // error: use of undeclared label `'a`
}
</pre> <p>Please verify you spelt or declare the label correctly. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
'a: loop {
    break 'a; // ok!
}</pre>  <h3 id="E0428" class="section-header">E0428</h3> <p>A type or module has been defined more than once.</p> <p>Erroneous code example:</p> <pre>struct Bar;
struct Bar; // error: duplicate definition of value `Bar`
</pre> <p>Please verify you didn't misspell the type/module's name or remove/rename the duplicated one. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Bar;
struct Bar2; // ok!</pre>  <h3 id="E0429" class="section-header">E0429</h3> <p>The <code>self</code> keyword cannot appear alone as the last segment in a <code>use</code> declaration.</p> <p>Erroneous code example:</p> <pre>use std::fmt::self; // error: `self` imports are only allowed within a { } list
</pre> <p>To use a namespace itself in addition to some of its members, <code>self</code> may appear as part of a brace-enclosed list of imports:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::fmt::{self, Debug};</pre> <p>If you only want to import the namespace, do so directly:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::fmt;</pre>  <h3 id="E0430" class="section-header">E0430</h3> <p>The <code>self</code> import appears more than once in the list.</p> <p>Erroneous code example:</p> <pre>use something::{self, self}; // error: `self` import can only appear once in
                             //        the list
</pre> <p>Please verify you didn't misspell the import name or remove the duplicated <code>self</code> import. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
use something::self; // ok!</pre>  <h3 id="E0431" class="section-header">E0431</h3> <p>An invalid <code>self</code> import was made.</p> <p>Erroneous code example:</p> <pre>use {self}; // error: `self` import can only appear in an import list with a
            //        non-empty prefix
</pre> <p>You cannot import the current module into itself, please remove this import or verify you didn't misspell it.</p>  <h3 id="E0432" class="section-header">E0432</h3> <p>An import was unresolved.</p> <p>Erroneous code example:</p> <pre>use something::Foo; // error: unresolved import `something::Foo`.
</pre> <p>Paths in <code>use</code> statements are relative to the crate root. To import items relative to the current and parent modules, use the <code>self::</code> and <code>super::</code> prefixes, respectively. Also verify that you didn't misspell the import name and that the import exists in the module from where you tried to import it. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
use self::something::Foo; // ok!

mod something {
    pub struct Foo;
}</pre> <p>Or, if you tried to use a module from an external crate, you may have missed the <code>extern crate</code> declaration (which is usually placed in the crate root):</p> <pre class="rust rust-example-rendered" data-language="rust">
extern crate homura; // Required to use the `homura` crate

use homura::Madoka;</pre>  <h3 id="E0433" class="section-header">E0433</h3> <p>An undeclared type or module was used.</p> <p>Erroneous code example:</p> <pre>let map = HashMap::new();
// error: failed to resolve. Use of undeclared type or module `HashMap`
</pre> <p>Please verify you didn't misspell the type/module's name or that you didn't forgot to import it:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::collections::HashMap; // HashMap has been imported.
let map: HashMap&lt;u32, u32&gt; = HashMap::new(); // So it can be used!</pre>  <h3 id="E0434" class="section-header">E0434</h3> <p>This error indicates that a variable usage inside an inner function is invalid because the variable comes from a dynamic environment. Inner functions do not have access to their containing environment.</p> <p>Erroneous code example:</p> <pre>fn foo() {
    let y = 5;
    fn bar() -&gt; u32 {
        y // error: can't capture dynamic environment in a fn item; use the
          //        || { ... } closure form instead.
    }
}
</pre> <p>Functions do not capture local variables. To fix this error, you can replace the function with a closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    let y = 5;
    let bar = || {
        y
    };
}</pre> <p>or replace the captured variable with a constant or a static item:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    static mut X: u32 = 4;
    const Y: u32 = 5;
    fn bar() -&gt; u32 {
        unsafe {
            X = 3;
        }
        Y
    }
}</pre>  <h3 id="E0435" class="section-header">E0435</h3> <p>A non-constant value was used to initialise a constant.</p> <p>Erroneous code example:</p> <pre>let foo = 42u32;
const FOO : u32 = foo; // error: attempt to use a non-constant value in a
                       //        constant
</pre> <p>To fix this error, please replace the value with a constant. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
const FOO : u32 = 42u32; // ok!</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
const OTHER_FOO : u32 = 42u32;
const FOO : u32 = OTHER_FOO; // ok!</pre>   <h3 id="E0437" class="section-header">E0437</h3> <p>Trait implementations can only implement associated types that are members of the trait in question. This error indicates that you attempted to implement an associated type whose name does not match the name of any associated type in the trait.</p> <p>Erroneous code example:</p> <pre>trait Foo {}

impl Foo for i32 {
    type Bar = bool;
}
</pre> <p>The solution to this problem is to remove the extraneous associated type:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

impl Foo for i32 {}</pre>  <h3 id="E0438" class="section-header">E0438</h3> <p>Trait implementations can only implement associated constants that are members of the trait in question. This error indicates that you attempted to implement an associated constant whose name does not match the name of any associated constant in the trait.</p> <p>Erroneous code example:</p> <pre>#![feature(associated_consts)]

trait Foo {}

impl Foo for i32 {
    const BAR: bool = true;
}
</pre> <p>The solution to this problem is to remove the extraneous associated constant:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Foo {}

impl Foo for i32 {}</pre>  <h3 id="E0439" class="section-header">E0439</h3> <p>The length of the platform-intrinsic function <code>simd_shuffle</code> wasn't specified. Erroneous code example:</p> <pre>#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`
}
</pre> <p>The <code>simd_shuffle</code> function needs the length of the array passed as last parameter in its name. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_shuffle8&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
}</pre>  <h3 id="E0440" class="section-header">E0440</h3> <p>A platform-specific intrinsic function has the wrong number of type parameters. Erroneous code example:</p> <pre>#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct f64x2(f64, f64);

extern "platform-intrinsic" {
    fn x86_mm_movemask_pd&lt;T&gt;(x: f64x2) -&gt; i32;
    // error: platform-specific intrinsic has wrong number of type
    //        parameters
}
</pre> <p>Please refer to the function declaration to see if it corresponds with yours. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct f64x2(f64, f64);

extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2) -&gt; i32;
}</pre>  <h3 id="E0441" class="section-header">E0441</h3> <p>An unknown platform-specific intrinsic function was used. Erroneous code example:</p> <pre>#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);

extern "platform-intrinsic" {
    fn x86_mm_adds_ep16(x: i16x8, y: i16x8) -&gt; i16x8;
    // error: unrecognized platform-specific intrinsic function
}
</pre> <p>Please verify that the function name wasn't misspelled, and ensure that it is declared in the rust source code (in the file src/librustc_platform_intrinsics/x86.rs). Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);

extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i16x8; // ok!
}</pre>  <h3 id="E0442" class="section-header">E0442</h3> <p>Intrinsic argument(s) and/or return value have the wrong type. Erroneous code example:</p> <pre>#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,
             i8, i8, i8, i8, i8, i8, i8, i8);
#[repr(simd)]
struct i32x4(i32, i32, i32, i32);
#[repr(simd)]
struct i64x2(i64, i64);

extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i8x16, y: i32x4) -&gt; i64x2;
    // error: intrinsic arguments/return value have wrong type
}
</pre> <p>To fix this error, please refer to the function declaration to give it the awaited types. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);

extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i16x8; // ok!
}</pre>  <h3 id="E0443" class="section-header">E0443</h3> <p>Intrinsic argument(s) and/or return value have the wrong type. Erroneous code example:</p> <pre>#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
#[repr(simd)]
struct i64x8(i64, i64, i64, i64, i64, i64, i64, i64);

extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i64x8;
    // error: intrinsic argument/return value has wrong type
}
</pre> <p>To fix this error, please refer to the function declaration to give it the awaited types. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);

extern "platform-intrinsic" {
    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -&gt; i16x8; // ok!
}</pre>  <h3 id="E0444" class="section-header">E0444</h3> <p>A platform-specific intrinsic function has wrong number of arguments. Erroneous code example:</p> <pre>#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct f64x2(f64, f64);

extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2, y: f64x2, z: f64x2) -&gt; i32;
    // error: platform-specific intrinsic has invalid number of arguments
}
</pre> <p>Please refer to the function declaration to see if it corresponds with yours. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
struct f64x2(f64, f64);

extern "platform-intrinsic" {
    fn x86_mm_movemask_pd(x: f64x2) -&gt; i32; // ok!
}</pre>  <h3 id="E0445" class="section-header">E0445</h3> <p>A private trait was used on a public type parameter bound. Erroneous code examples:</p> <pre>#![deny(private_in_public)]

trait Foo {
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // error: private trait in public interface
pub struct Bar2&lt;T: Foo&gt;(pub T); // same error
pub fn foo&lt;T: Foo&gt; (t: T) {} // same error
</pre> <p>To solve this error, please ensure that the trait is also public. The trait can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with <code>pub</code>. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
pub trait Foo { // we set the Foo trait public
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // ok!
pub struct Bar2&lt;T: Foo&gt;(pub T); // ok!
pub fn foo&lt;T: Foo&gt; (t: T) {} // ok!</pre>  <h3 id="E0446" class="section-header">E0446</h3> <p>A private type was used in a public type signature. Erroneous code example:</p> <pre>#![deny(private_in_public)]

mod Foo {
    struct Bar(u32);

    pub fn bar() -&gt; Bar { // error: private type in public interface
        Bar(0)
    }
}
</pre> <p>To solve this error, please ensure that the type is also public. The type can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with <code>pub</code>. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod Foo {
    pub struct Bar(u32); // we set the Bar type public

    pub fn bar() -&gt; Bar { // ok!
        Bar(0)
    }
}</pre>  <h3 id="E0447" class="section-header">E0447</h3> <p>The <code>pub</code> keyword was used inside a function. Erroneous code example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn foo() {
    pub struct Bar; // error: visibility has no effect inside functions
}</pre> <p>Since we cannot access items defined inside a function, the visibility of its items does not impact outer code. So using the <code>pub</code> keyword in this context is invalid.</p>  <h3 id="E0448" class="section-header">E0448</h3> <p>The <code>pub</code> keyword was used inside a public enum. Erroneous code example:</p> <pre>pub enum Foo {
    pub Bar, // error: unnecessary `pub` visibility
}
</pre> <p>Since the enum is already public, adding <code>pub</code> on one its elements is unnecessary. Example:</p> <pre>enum Foo {
    pub Bar, // not ok!
}
</pre> <p>This is the correct syntax:</p> <pre class="rust rust-example-rendered" data-language="rust">
pub enum Foo {
    Bar, // ok!
}</pre>  <h3 id="E0450" class="section-header">E0450</h3> <p>A tuple constructor was invoked while some of its fields are private. Erroneous code example:</p> <pre>mod Bar {
    pub struct Foo(isize);
}

let f = Bar::Foo(0); // error: cannot invoke tuple struct constructor with
                     //        private fields
</pre> <p>To solve this issue, please ensure that all of the fields of the tuple struct are public. Alternatively, provide a <code>new()</code> method to the tuple struct to construct it from a given inner value. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod Bar {
    pub struct Foo(pub isize); // we set its field to public
}

let f = Bar::Foo(0); // ok!

// or:
mod bar {
    pub struct Foo(isize);

    impl Foo {
        pub fn new(x: isize) -&gt; Foo {
            Foo(x)
        }
    }
}

let f = bar::Foo::new(1);</pre>  <h3 id="E0451" class="section-header">E0451</h3> <p>A struct constructor with private fields was invoked. Erroneous code example:</p> <pre>mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize,
    }
}

let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`
                                //        is private
</pre> <p>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        pub b: isize, // we set `b` field public
    }
}

let f = Bar::Foo{ a: 0, b: 0 }; // ok!</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
mod Bar {
    pub struct Foo {
        pub a: isize,
        b: isize, // still private
    }

    impl Foo {
        pub fn new() -&gt; Foo { // we create a method to instantiate `Foo`
            Foo { a: 0, b: 0 }
        }
    }
}

let f = Bar::Foo::new(); // ok!</pre>  <h3 id="E0452" class="section-header">E0452</h3> <p>An invalid lint attribute has been given. Erroneous code example:</p> <pre>#![allow(foo = "")] // error: malformed lint attribute
</pre> <p>Lint attributes only accept a list of identifiers (where each identifier is a lint name). Ensure the attribute is of this form:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![allow(foo)] // ok!
// or:
#![allow(foo, foo2)] // ok!</pre>  <h3 id="E0453" class="section-header">E0453</h3> <p>A lint check attribute was overruled by a <code>forbid</code> directive set as an attribute on an enclosing scope, or on the command line with the <code>-F</code> option.</p> <p>Example of erroneous code:</p> <pre>#![forbid(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer
                      //        forbid(non_snake_case)
}
</pre> <p>The <code>forbid</code> lint setting, like <code>deny</code>, turns the corresponding compiler warning into a hard error. Unlike <code>deny</code>, <code>forbid</code> prevents itself from being overridden by inner attributes.</p> <p>If you're sure you want to override the lint check, you can change <code>forbid</code> to <code>deny</code> (or use <code>-D</code> instead of <code>-F</code> if the <code>forbid</code> setting was given as a command-line option) to allow the inner lint check attribute:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![deny(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // ok!
}</pre> <p>Otherwise, edit the code to pass the lint check, and remove the overruled attribute:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![forbid(non_snake_case)]

fn main() {
    let my_number = 2;
}</pre>  <h3 id="E0454" class="section-header">E0454</h3> <p>A link name was given with an empty name. Erroneous code example:</p> <pre>#[link(name = "")] extern {} // error: #[link(name = "")] given with empty name
</pre> <p>The rust compiler cannot link to an external library if you don't give it its name. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[link(name = "some_lib")] extern {} // ok!</pre>  <h3 id="E0455" class="section-header">E0455</h3> <p>Linking with <code>kind=framework</code> is only supported when targeting OS X, as frameworks are specific to that operating system.</p> <p>Erroneous code example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[link(name = "FooCoreServices", kind = "framework")] extern {}
// OS used to compile is Linux for example</pre> <p>To solve this error you can use conditional compilation:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[cfg_attr(target="macos", link(name = "FooCoreServices", kind = "framework"))]
extern {}</pre> <p>See more: <a href="../book/conditional-compilation/">https://doc.rust-lang.org/book/conditional-compilation.html</a></p>    <h3 id="E0458" class="section-header">E0458</h3> <p>An unknown "kind" was specified for a link attribute. Erroneous code example:</p> <pre>#[link(kind = "wonderful_unicorn")] extern {}
// error: unknown kind: `wonderful_unicorn`
</pre> <p>Please specify a valid "kind" value, from one of the following:</p> <ul> <li>static</li> <li>dylib</li> <li>framework</li> </ul>  <h3 id="E0459" class="section-header">E0459</h3> <p>A link was used without a name parameter. Erroneous code example:</p> <pre>#[link(kind = "dylib")] extern {}
// error: #[link(...)] specified without `name = "foo"`
</pre> <p>Please add the name parameter to allow the rust compiler to find the library you want. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[link(kind = "dylib", name = "some_lib")] extern {} // ok!</pre>     <h3 id="E0463" class="section-header">E0463</h3> <p>A plugin/crate was declared but cannot be found. Erroneous code example:</p> <pre>#![feature(plugin)]
#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`
extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`
</pre> <p>You need to link your code to the relevant crate in order to be able to use it (through Cargo or the <code>-L</code> option of rustc example). Plugins are crates as well, and you link to them the same way.</p>    <h3 id="E0466" class="section-header">E0466</h3> <p>Macro import declarations were malformed.</p> <p>Erroneous code examples:</p> <pre>#[macro_use(a_macro(another_macro))] // error: invalid import declaration
extern crate core as some_crate;

#[macro_use(i_want = "some_macros")] // error: invalid import declaration
extern crate core as another_crate;
</pre> <p>This is a syntax error at the level of attribute declarations. The proper syntax for macro imports is the following:</p> <pre class="rust rust-example-rendered" data-language="rust">
// In some_crate:
#[macro_export]
macro_rules! get_tacos {
    ...
}

#[macro_export]
macro_rules! get_pimientos {
    ...
}

// In your crate:
#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and
extern crate some_crate;               // `get_pimientos` macros from some_crate</pre> <p>If you would like to import all exported macros, write <code>macro_use</code> with no arguments.</p>  <h3 id="E0467" class="section-header">E0467</h3> <p>Macro reexport declarations were empty or malformed.</p> <p>Erroneous code examples:</p> <pre>#[macro_reexport]                    // error: no macros listed for export
extern crate core as macros_for_good;

#[macro_reexport(fun_macro = "foo")] // error: not a macro identifier
extern crate core as other_macros_for_good;
</pre> <p>This is a syntax error at the level of attribute declarations.</p> <p>Currently, <code>macro_reexport</code> requires at least one macro name to be listed. Unlike <code>macro_use</code>, listing no names does not reexport all macros from the given crate.</p> <p>Decide which macros you would like to export and list them properly.</p> <p>These are proper reexport declarations:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[macro_reexport(some_macro, another_macro)]
extern crate macros_for_good;</pre>  <h3 id="E0468" class="section-header">E0468</h3> <p>A non-root module attempts to import macros from another crate.</p> <p>Example of erroneous code:</p> <pre>mod foo {
    #[macro_use(helpful_macro)] // error: must be at crate root to import
    extern crate core;          //        macros from another crate
    helpful_macro!(...);
}
</pre> <p>Only <code>extern crate</code> imports at the crate root level are allowed to import macros.</p> <p>Either move the macro import to crate root or do without the foreign macros. This will work:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[macro_use(helpful_macro)]
extern crate some_crate;

mod foo {
    helpful_macro!(...)
}</pre>  <h3 id="E0469" class="section-header">E0469</h3> <p>A macro listed for import was not found.</p> <p>Erroneous code example:</p> <pre>#[macro_use(drink, be_merry)] // error: imported macro not found
extern crate collections;

fn main() {
    // ...
}
</pre> <p>Either the listed macro is not contained in the imported crate, or it is not exported from the given crate.</p> <p>This could be caused by a typo. Did you misspell the macro's name?</p> <p>Double-check the names of the macros listed for import, and that the crate in question exports them.</p> <p>A working version would be:</p> <pre class="rust rust-example-rendered" data-language="rust">
// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
}

#[macro_export]
macro_rules! drink {
    ...
}

// In your crate:
#[macro_use(eat, drink)]
extern crate some_crate; //ok!</pre>  <h3 id="E0470" class="section-header">E0470</h3> <p>A macro listed for reexport was not found.</p> <p>Erroneous code example:</p> <pre>#[macro_reexport(drink, be_merry)]
extern crate collections;

fn main() {
    // ...
}
</pre> <p>Either the listed macro is not contained in the imported crate, or it is not exported from the given crate.</p> <p>This could be caused by a typo. Did you misspell the macro's name?</p> <p>Double-check the names of the macros listed for reexport, and that the crate in question exports them.</p> <p>A working version:</p> <pre class="rust rust-example-rendered" data-language="rust">
// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
}

#[macro_export]
macro_rules! drink {
    ...
}

// In your_crate:
#[macro_reexport(eat, drink)]
extern crate some_crate;</pre>       <h3 id="E0478" class="section-header">E0478</h3> <p>A lifetime bound was not satisfied.</p> <p>Erroneous code example:</p> <pre>// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must
// outlive all the superbounds from the trait (`'kiss`, in this example).

trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite&gt; {
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;,
    // error: lifetime bound not satisfied
}
</pre> <p>In this example, the <code>'SnowWhite</code> lifetime is supposed to outlive the <code>'kiss</code> lifetime but the declaration of the <code>Prince</code> struct doesn't enforce it. To fix this issue, you need to specify it:</p> <pre class="rust rust-example-rendered" data-language="rust">
trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite: 'kiss&gt; { // You say here that 'kiss must live
                                          // longer than 'SnowWhite.
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;, // And now it's all good!
}</pre>              <h3 id="E0491" class="section-header">E0491</h3> <p>A reference has a longer lifetime than the data it references.</p> <p>Erroneous code example:</p> <pre>// struct containing a reference requires a lifetime parameter,
// because the data the reference points to must outlive the struct (see E0106)
struct Struct&lt;'a&gt; {
    ref_i32: &amp;'a i32,
}

// However, a nested struct like this, the signature itself does not tell
// whether 'a outlives 'b or the other way around.
// So it could be possible that 'b of reference outlives 'a of the data.
struct Nested&lt;'a, 'b&gt; {
    ref_struct: &amp;'b Struct&lt;'a&gt;, // compile error E0491
}
</pre> <p>To fix this issue, you can specify a bound to the lifetime like below:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Struct&lt;'a&gt; {
    ref_i32: &amp;'a i32,
}

// 'a: 'b means 'a outlives 'b
struct Nested&lt;'a: 'b, 'b&gt; {
    ref_struct: &amp;'b Struct&lt;'a&gt;,
}</pre>   <h3 id="E0496" class="section-header">E0496</h3> <p>A lifetime name is shadowing another lifetime name. Erroneous code example:</p> <pre>struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'a&gt;(x: &amp;'a i32) { // error: lifetime name `'a` shadows a lifetime
                           //        name that is already in scope
    }
}
</pre> <p>Please change the name of one of the lifetimes to remove this error. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'b&gt;(x: &amp;'b i32) { // ok!
    }
}

fn main() {
}</pre>  <h3 id="E0497" class="section-header">E0497</h3> <p>A stability attribute was used outside of the standard library. Erroneous code example:</p> <pre>#[stable] // error: stability attributes may not be used outside of the
          //        standard library
fn foo() {}
</pre> <p>It is not possible to use stability attributes outside of the standard library. Also, for now, it is not possible to write deprecation messages either.</p>  <h3 id="E0499" class="section-header">E0499</h3> <p>A variable was borrowed as mutable more than once. Erroneous code example:</p> <pre>let mut i = 0;
let mut x = &amp;mut i;
let mut a = &amp;mut i;
// error: cannot borrow `i` as mutable more than once at a time
</pre> <p>Please note that in rust, you can either have many immutable references, or one mutable reference. Take a look at <a href="https://doc.rust-lang.org/stable/book/references-and-borrowing.html" target="_blank">https://doc.rust-lang.org/stable/book/references-and-borrowing.html</a> for more information. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
let mut i = 0;
let mut x = &amp;mut i; // ok!

// or:
let mut i = 0;
let a = &amp;i; // ok!
let b = &amp;i; // still ok!
let c = &amp;i; // still ok!</pre>  <h3 id="E0500" class="section-header">E0500</h3> <p>A borrowed variable was used in another closure. Example of erroneous code:</p> <pre>fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = || {
        *jon_snow = 2;
    };
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
}
</pre> <p>In here, <code>jon_snow</code> is already borrowed by the <code>nights_watch</code> closure, so it cannot be borrowed by the <code>starks</code> closure at the same time. To fix this issue, you can put the closure in its own scope:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    {
        let nights_watch = || {
            *jon_snow = 2;
        };
    } // At this point, `jon_snow` is free.
    let starks = || {
        *jon_snow = 3;
    };
}</pre> <p>Or, if the type implements the <code>Clone</code> trait, you can clone it between closures:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let mut jon_copy = jon_snow.clone();
    let nights_watch = || {
        jon_copy = 2;
    };
    let starks = || {
        *jon_snow = 3;
    };
}</pre>  <h3 id="E0501" class="section-header">E0501</h3> <p>This error indicates that a mutable variable is being used while it is still captured by a closure. Because the closure has borrowed the variable, it is not available for use until the closure goes out of scope.</p> <p>Note that a capture will either move or borrow a variable, but in this situation, the closure is borrowing the variable. Take a look at <a href="http://rustbyexample.com/fn/closures/capture.html" target="_blank">http://rustbyexample.com/fn/closures/capture.html</a> for more information about capturing.</p> <p>Example of erroneous code:</p> <pre>fn inside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn outside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn foo(a: &amp;mut i32) {
    let bar = || {
        inside_closure(a)
    };
    outside_closure(a); // error: cannot borrow `*a` as mutable because previous
                        //        closure requires unique access.
}
</pre> <p>To fix this error, you can place the closure in its own scope:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    {
        let bar = || {
            inside_closure(a)
        };
    } // borrow on `a` ends.
    outside_closure(a); // ok!
}</pre> <p>Or you can pass the variable as a parameter to the closure:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let bar = |s: &amp;mut i32| {
        inside_closure(s)
    };
    outside_closure(a);
    bar(a);
}</pre> <p>It may be possible to define the closure later:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    outside_closure(a);
    let bar = || {
        inside_closure(a)
    };
}</pre>  <h3 id="E0502" class="section-header">E0502</h3> <p>This error indicates that you are trying to borrow a variable as mutable when it has already been borrowed as immutable.</p> <p>Example of erroneous code:</p> <pre>fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    let ref y = a; // a is borrowed as immutable.
    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed
            //        as immutable
}
</pre> <p>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    bar(a);
    let ref y = a; // ok!
}</pre> <p>For more information on the rust ownership system, take a look at <a href="https://doc.rust-lang.org/stable/book/references-and-borrowing.html" target="_blank">https://doc.rust-lang.org/stable/book/references-and-borrowing.html</a>.</p>  <h3 id="E0503" class="section-header">E0503</h3> <p>A value was used after it was mutably borrowed.</p> <p>Example of erroneous code:</p> <pre>fn main() {
    let mut value = 3;
    // Create a mutable borrow of `value`. This borrow
    // lives until the end of this function.
    let _borrow = &amp;mut value;
    let _sum = value + 1; // error: cannot use `value` because
                          //        it was mutably borrowed
}
</pre> <p>In this example, <code>value</code> is mutably borrowed by <code>borrow</code> and cannot be used to calculate <code>sum</code>. This is not possible because this would violate Rust's mutability rules.</p> <p>You can fix this error by limiting the scope of the borrow:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut value = 3;
    // By creating a new block, you can limit the scope
    // of the reference.
    {
        let _borrow = &amp;mut value; // Use `_borrow` inside this block.
    }
    // The block has ended and with it the borrow.
    // You can now use `value` again.
    let _sum = value + 1;
}</pre> <p>Or by cloning <code>value</code> before borrowing it:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let mut value = 3;
    // We clone `value`, creating a copy.
    let value_cloned = value.clone();
    // The mutable borrow is a reference to `value` and
    // not to `value_cloned`...
    let _borrow = &amp;mut value;
    // ... which means we can still use `value_cloned`,
    let _sum = value_cloned + 1;
    // even though the borrow only ends here.
}</pre> <p>You can find more information about borrowing in the rust-book: <a href="http://doc.rust-lang.org/stable/book/references-and-borrowing.html" target="_blank">http://doc.rust-lang.org/stable/book/references-and-borrowing.html</a></p>  <h3 id="E0504" class="section-header">E0504</h3> <p>This error occurs when an attempt is made to move a borrowed variable into a closure.</p> <p>Example of erroneous code:</p> <pre>struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        println!("child function: {}", fancy_num.num);
        // error: cannot move `fancy_num` into closure because it is borrowed
    };

    x();
    println!("main function: {}", fancy_ref.num);
}
</pre> <p>Here, <code>fancy_num</code> is borrowed by <code>fancy_ref</code> and so cannot be moved into the closure <code>x</code>. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</p> <p>If the closure can't outlive the value being moved, try using a reference rather than moving:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        // fancy_ref is usable here because it doesn't move `fancy_num`
        println!("child function: {}", fancy_ref.num);
    };

    x();

    println!("main function: {}", fancy_num.num);
}</pre> <p>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };

    {
        let fancy_ref = &amp;fancy_num;
        println!("main function: {}", fancy_ref.num);
        // `fancy_ref` goes out of scope here
    }

    let x = move || {
        // `fancy_num` can be moved now (no more references exist)
        println!("child function: {}", fancy_num.num);
    };

    x();
}</pre> <p>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an <code>Arc</code> to create a reference-counted value:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::Arc;
use std::thread;

struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_ref1 = Arc::new(FancyNum { num: 5 });
    let fancy_ref2 = fancy_ref1.clone();

    let x = thread::spawn(move || {
        // `fancy_ref1` can be moved and has a `'static` lifetime
        println!("child thread: {}", fancy_ref1.num);
    });

    x.join().expect("child thread should finish");
    println!("main thread: {}", fancy_ref2.num);
}</pre>  <h3 id="E0505" class="section-header">E0505</h3> <p>A value was moved out while it was still borrowed.</p> <p>Erroneous code example:</p> <pre>struct Value {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    {
        let _ref_to_val: &amp;Value = &amp;x;
        eat(x);
    }
}
</pre> <p>Here, the function <code>eat</code> takes the ownership of <code>x</code>. However, <code>x</code> cannot be moved because it was borrowed to <code>_ref_to_val</code>. To fix that you can do few different things:</p> <ul> <li>Try to avoid moving the variable.</li> <li>Release borrow before move.</li> <li>Implement the <code>Copy</code> trait on the type.</li> </ul> <p>Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Value {}

fn eat(val: &amp;Value) {}

fn main() {
    let x = Value{};
    {
        let _ref_to_val: &amp;Value = &amp;x;
        eat(&amp;x); // pass by reference, if it's possible
    }
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Value {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    {
        let _ref_to_val: &amp;Value = &amp;x;
    }
    eat(x); // release borrow and then move it.
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)] // implement Copy trait
struct Value {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    {
        let _ref_to_val: &amp;Value = &amp;x;
        eat(x); // it will be copied here.
    }
}</pre> <p>You can find more information about borrowing in the rust-book: <a href="http://doc.rust-lang.org/stable/book/references-and-borrowing.html" target="_blank">http://doc.rust-lang.org/stable/book/references-and-borrowing.html</a></p>  <h3 id="E0506" class="section-header">E0506</h3> <p>This error occurs when an attempt is made to assign to a borrowed value.</p> <p>Example of erroneous code:</p> <pre>struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;
    fancy_num = FancyNum { num: 6 };
    // error: cannot assign to `fancy_num` because it is borrowed

    println!("Num: {}, Ref: {}", fancy_num.num, fancy_ref.num);
}
</pre> <p>Because <code>fancy_ref</code> still holds a reference to <code>fancy_num</code>, <code>fancy_num</code> can't be assigned to a new value as it would invalidate the reference.</p> <p>Alternatively, we can move out of <code>fancy_num</code> into a second <code>fancy_num</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };
    let moved_num = fancy_num;
    fancy_num = FancyNum { num: 6 };

    println!("Num: {}, Moved num: {}", fancy_num.num, moved_num.num);
}</pre> <p>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };

    {
        let fancy_ref = &amp;fancy_num;
        println!("Ref: {}", fancy_ref.num);
    }

    // Works because `fancy_ref` is no longer in scope
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
}</pre> <p>Or by moving the reference into a function:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy_num = FancyNum { num: 5 };

    print_fancy_ref(&amp;fancy_num);

    // Works because function borrow has ended
    fancy_num = FancyNum { num: 6 };
    println!("Num: {}", fancy_num.num);
}

fn print_fancy_ref(fancy_ref: &amp;FancyNum){
    println!("Ref: {}", fancy_ref.num);
}</pre>  <h3 id="E0507" class="section-header">E0507</h3> <p>You tried to move out of a value which was borrowed. Erroneous code example:</p> <pre>use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
}
</pre> <p>Here, the <code>nothing_is_true</code> method takes the ownership of <code>self</code>. However, <code>self</code> cannot be moved because <code>.borrow()</code> only provides an <code>&amp;TheDarkKnight</code>, which is a borrow of the content owned by the <code>RefCell</code>. To fix this error, you have three choices:</p> <ul> <li>Try to avoid moving the variable.</li> <li>Somehow reclaim the ownership.</li> <li>Implement the <code>Copy</code> trait on the type.</li> </ul> <p>Examples:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(&amp;self) {} // First case, we don't take ownership
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership

    x.nothing_is_true(); // ok!
}</pre> <p>Or:</p> <pre class="rust rust-example-rendered" data-language="rust">
use std::cell::RefCell;

#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre> <p>Moving out of a member of a mutably borrowed struct is fine if you put something back. <code>mem::replace</code> can be used for that:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

struct Batcave {
    knight: TheDarkKnight
}

fn main() {
    use std::mem;

    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &amp;mut cave;

    borrowed.knight.nothing_is_true(); // E0507
    mem::replace(&amp;mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!
}</pre> <p>You can find more information about borrowing in the rust-book: <a href="http://doc.rust-lang.org/stable/book/references-and-borrowing.html" target="_blank">http://doc.rust-lang.org/stable/book/references-and-borrowing.html</a></p>  <h3 id="E0508" class="section-header">E0508</h3> <p>A value was moved out of a non-copy fixed-size array.</p> <p>Example of erroneous code:</p> <pre>struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,
                           //        a non-copy fixed-size array
}
</pre> <p>The first element was moved out of the array, but this is not possible because <code>NonCopy</code> does not implement the <code>Copy</code> trait.</p> <p>Consider borrowing the element instead of moving it:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = &amp;array[0]; // Borrowing is allowed, unlike moving.
}</pre> <p>Alternatively, if your type implements <code>Clone</code> and you need to own the value, consider borrowing and then cloning:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone)]
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    // Now you can clone the array element.
    let _value = array[0].clone();
}</pre>  <h3 id="E0509" class="section-header">E0509</h3> <p>This error occurs when an attempt is made to move out of a value whose type implements the <code>Drop</code> trait.</p> <p>Example of erroneous code:</p> <pre>struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let fancy_field = drop_struct.fancy; // Error E0509
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}
</pre> <p>Here, we tried to move a field out of a struct of type <code>DropStruct</code> which implements the <code>Drop</code> trait. However, a struct cannot be dropped if one or more of its fields have been moved.</p> <p>Structs implementing the <code>Drop</code> trait have an implicit destructor that gets called when they go out of scope. This destructor may use the fields of the struct, so moving out of the struct could make it impossible to run the destructor. Therefore, we must think of all values whose type implements the <code>Drop</code> trait as single units whose fields cannot be moved.</p> <p>This error can be fixed by creating a reference to the fields of a struct, enum, or tuple using the <code>ref</code> keyword:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let ref fancy_field = drop_struct.fancy; // No more errors!
    println!("Fancy: {}", fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</pre> <p>Note that this technique can also be used in the arms of a match expression:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct FancyNum {
    num: usize
}

enum DropEnum {
    Fancy(FancyNum)
}

impl Drop for DropEnum {
    fn drop(&amp;mut self) {
        // Destruct DropEnum, possibly using FancyNum
    }
}

fn main() {
    // Creates and enum of type `DropEnum`, which implements `Drop`
    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});
    match drop_enum {
        // Creates a reference to the inside of `DropEnum::Fancy`
        DropEnum::Fancy(ref fancy_field) =&gt; // No error!
            println!("It was fancy-- {}!", fancy_field.num),
    }
    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope
}</pre>  <h3 id="E0511" class="section-header">E0511</h3> <p>Invalid monomorphization of an intrinsic function was used. Erroneous code example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(platform_intrinsics)]

extern "platform-intrinsic" {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

fn main() {
    unsafe { simd_add(0, 1); }
    // error: invalid monomorphization of `simd_add` intrinsic
}</pre> <p>The generic type has to be a SIMD type. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(repr_simd)]
#![feature(platform_intrinsics)]

#[repr(simd)]
#[derive(Copy, Clone)]
struct i32x1(i32);

extern "platform-intrinsic" {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!</pre>  <h3 id="E0512" class="section-header">E0512</h3> <p>Transmute with two differently sized types was attempted. Erroneous code example:</p> <pre>fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0u16)); }
    // error: transmute called with differently sized types
}
</pre> <p>Please use types with same size or use the expected type directly. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!
    // or:
    unsafe { takes_u8(0u8); } // ok!
}</pre>   <h3 id="E0516" class="section-header">E0516</h3> <p>The <code>typeof</code> keyword is currently reserved but unimplemented. Erroneous code example:</p> <pre>fn main() {
    let x: typeof(92) = 92;
}
</pre> <p>Try using type inference instead. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    let x = 92;
}</pre>  <h3 id="E0517" class="section-header">E0517</h3> <p>This error indicates that a <code>#[repr(..)]</code> attribute was placed on an unsupported item.</p> <p>Examples of erroneous code:</p> <pre>#[repr(C)]
type Foo = u8;

#[repr(packed)]
enum Foo {Bar, Baz}

#[repr(u8)]
struct Foo {bar: bool, baz: bool}

#[repr(C)]
impl Foo {
    // ...
}
</pre> <ul> <li>The <code>#[repr(C)]</code> attribute can only be placed on structs and enums.</li> <li>The <code>#[repr(packed)]</code> and <code>#[repr(simd)]</code> attributes only work on structs.</li> <li>The <code>#[repr(u8)]</code>, <code>#[repr(i16)]</code>, etc attributes only work on enums.</li> </ul> <p>These attributes do not work on typedefs, since typedefs are just aliases.</p> <p>Representations like <code>#[repr(u8)]</code>, <code>#[repr(i64)]</code> are for selecting the discriminant size for C-like enums (when there is no associated data, e.g. <code>enum Color {Red, Blue, Green}</code>), effectively setting the size of the enum to the size of the provided type. Such an enum can be cast to a value of the same type as well. In short, <code>#[repr(u8)]</code> makes the enum behave like an integer with a constrained set of allowed values.</p> <p>Only C-like enums can be cast to numerical primitives, so this attribute will not apply to structs.</p> <p><code>#[repr(packed)]</code> reduces padding to make the struct size smaller. The representation of enums isn't strictly defined in Rust, and this attribute won't work on enums.</p> <p><code>#[repr(simd)]</code> will give a struct consisting of a homogenous series of machine types (i.e. <code>u8</code>, <code>i32</code>, etc) a representation that permits vectorization via SIMD. This doesn't make much sense for enums since they don't consist of a single list of data.</p>  <h3 id="E0518" class="section-header">E0518</h3> <p>This error indicates that an <code>#[inline(..)]</code> attribute was incorrectly placed on something other than a function or method.</p> <p>Examples of erroneous code:</p> <pre>#[inline(always)]
struct Foo;

#[inline(never)]
impl Foo {
    // ...
}
</pre> <p><code>#[inline]</code> hints the compiler whether or not to attempt to inline a method or function. By default, the compiler does a pretty good job of figuring this out itself, but if you feel the need for annotations, <code>#[inline(always)]</code> and <code>#[inline(never)]</code> can override or force the compiler's decision.</p> <p>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an <code>#[inline]</code> attribute.</p>   <h3 id="E0520" class="section-header">E0520</h3> <p>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</p> <pre>#![feature(specialization)]

trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {}
}

// non-default impl
// applies to all `Clone` T and overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    fn fly(&amp;self) {}
}

// since `i32` is clone, this conflicts with the previous implementation
impl SpaceLlama for i32 {
    default fn fly(&amp;self) {}
    // error: item `fly` is provided by an `impl` that specializes
    //        another, but the item in the parent `impl` is not marked
    //        `default` and so it cannot be specialized.
}
</pre> <p>Specialization only allows you to override <code>default</code> functions in implementations.</p> <p>To fix this error, you need to mark all the parent implementations as default. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(specialization)]

trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation.
}

// applies to all `Clone` T; overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation but was
                             // previously not a default one, causing the error
}

// applies to i32, overrides the previous two impls
impl SpaceLlama for i32 {
    fn fly(&amp;self) {} // And now that's ok!
}</pre>   <h3 id="E0522" class="section-header">E0522</h3> <p>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like <code>Copy</code> and <code>Sized</code>) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</p> <pre>#![feature(lang_items)]

#[lang = "cookie"]
fn cookie() -&gt; ! { // error: definition of an unknown language item: `cookie`
    loop {}
}
</pre>    <h3 id="E0525" class="section-header">E0525</h3> <p>A closure was used but didn't implement the expected trait.</p> <p>Erroneous code example:</p> <pre>struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x); // error: expected a closure that implements
                              //        the `Fn` trait, but this closure only
                              //        implements `FnOnce`
    bar(closure);
}
</pre> <p>In the example above, <code>closure</code> is an <code>FnOnce</code> closure whereas the <code>bar</code> function expected an <code>Fn</code> closure. In this case, it's simple to fix the issue, you just have to implement <code>Copy</code> and <code>Clone</code> traits on <code>struct X</code> and it'll be ok:</p> <pre class="rust rust-example-rendered" data-language="rust">
#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.
struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x);
    bar(closure); // ok!
}</pre> <p>To understand better how closures work in Rust, read: <a href="../book/closures/">https://doc.rust-lang.org/book/closures.html</a></p>  <h3 id="E0527" class="section-header">E0527</h3> <p>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</p> <p>Example of erroneous code:</p> <pre>#![feature(slice_patterns)]

let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b] =&gt; { // error: pattern requires 2 elements but array
                 //        has 4
        println!("a={}, b={}", a, b);
    }
}
</pre> <p>Ensure that the pattern is consistent with the size of the matched array. Additional elements can be matched with <code>..</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_patterns)]

let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b, ..] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}</pre>  <h3 id="E0528" class="section-header">E0528</h3> <p>An array or slice pattern required more elements than were present in the matched array.</p> <p>Example of erroneous code:</p> <pre>#![feature(slice_patterns)]

let r = &amp;[1, 2];
match r {
    &amp;[a, b, c, rest..] =&gt; { // error: pattern requires at least 3
                            //        elements but array has 2
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}
</pre> <p>Ensure that the matched array has at least as many elements as the pattern requires. You can match an arbitrary number of remaining elements with <code>..</code>:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_patterns)]

let r = &amp;[1, 2, 3, 4, 5];
match r {
    &amp;[a, b, c, rest..] =&gt; { // ok!
        // prints `a=1, b=2, c=3 rest=[4, 5]`
        println!("a={}, b={}, c={} rest={:?}", a, b, c, rest);
    }
}</pre>  <h3 id="E0529" class="section-header">E0529</h3> <p>An array or slice pattern was matched against some other type.</p> <p>Example of erroneous code:</p> <pre>#![feature(slice_patterns)]

let r: f32 = 1.0;
match r {
    [a, b] =&gt; { // error: expected an array or slice, found `f32`
        println!("a={}, b={}", a, b);
    }
}
</pre> <p>Ensure that the pattern and the expression being matched on are of consistent types:</p> <pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_patterns)]

let r = [1.0, 2.0];
match r {
    [a, b] =&gt; { // ok!
        println!("a={}, b={}", a, b);
    }
}</pre>  <h3 id="E0530" class="section-header">E0530</h3> <p>A binding shadowed something it shouldn't.</p> <p>Erroneous code example:</p> <pre>static TEST: i32 = 0;

let r: (i32, i32) = (0, 0);
match r {
    TEST =&gt; {} // error: match bindings cannot shadow statics
}
</pre> <p>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</p> <ul> <li>struct name</li> <li>struct/enum variant</li> <li>static</li> <li>const</li> <li>associated const</li> </ul> <p>Fixed example:</p> <pre class="rust rust-example-rendered" data-language="rust">
static TEST: i32 = 0;

let r: (i32, i32) = (0, 0);
match r {
    something =&gt; {} // ok!
}</pre>   <h3 id="E0532" class="section-header">E0532</h3> <p>Pattern arm did not match expected kind.</p> <p>Erroneous code example:</p> <pre>enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        // error: expected unit struct/variant or constant, found tuple
        //        variant `State::Failed`
        State::Failed =&gt; println!("Failed"),
        _ =&gt; ()
    }
}
</pre> <p>To fix this error, ensure the match arm kind is the same as the expression matched.</p> <p>Fixed example:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        State::Failed(ref msg) =&gt; println!("Failed with {}", msg),
        _ =&gt; ()
    }
}</pre>   <h3 id="E0559" class="section-header">E0559</h3> <p>An unknown field was specified into an enum's structure variant.</p> <p>Erroneous code example:</p> <pre>enum Field {
    Fool { x: u32 },
}

let s = Field::Fool { joke: 0 };
// error: struct variant `Field::Fool` has no field named `joke`
</pre> <p>Verify you didn't misspell the field's name or that the field exists. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
enum Field {
    Fool { joke: u32 },
}

let s = Field::Fool { joke: 0 }; // ok!</pre>  <h3 id="E0560" class="section-header">E0560</h3> <p>An unknown field was specified into a structure.</p> <p>Erroneous code example:</p> <pre>struct Simba {
    mother: u32,
}

let s = Simba { mother: 1, father: 0 };
// error: structure `Simba` has no field named `father`
</pre> <p>Verify you didn't misspell the field's name or that the field exists. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
struct Simba {
    mother: u32,
    father: u32,
}

let s = Simba { mother: 1, father: 0 }; // ok!</pre>        <h3 id="E0569" class="section-header">E0569</h3> <p>If an impl has a generic parameter with the <code>#[may_dangle]</code> attribute, then that impl must be declared as an `unsafe impl. For example:</p> <pre>#![feature(generic_param_attrs)]
#![feature(dropck_eyepatch)]

struct Foo&lt;X&gt;(X);
impl&lt;#[may_dangle] X&gt; Drop for Foo&lt;X&gt; {
    fn drop(&amp;mut self) { }
}
</pre> <p>In this example, we are asserting that the destructor for <code>Foo</code> will not access any data of type <code>X</code>, and require this assertion to be true for overall safety in our program. The compiler does not currently attempt to verify this assertion; therefore we must tag this <code>impl</code> as unsafe.</p>  <h3 id="E0570" class="section-header">E0570</h3> <p>The requested ABI is unsupported by the current target.</p> <p>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</p> <p>If necessary, you can circumvent this check using custom target specifications.</p>  <h3 id="E0572" class="section-header">E0572</h3> <p>A return statement was found outside of a function body.</p> <p>Erroneous code example:</p> <pre>const FOO: u32 = return 0; // error: return statement outside of function body

fn main() {}
</pre> <p>To fix this issue, just remove the return keyword or move the expression into a function. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
const FOO: u32 = 0;

fn some_fn() -&gt; u32 {
    return FOO;
}

fn main() {
    some_fn();
}</pre>        <h3 id="E0580" class="section-header">E0580</h3> <p>The <code>main</code> function was incorrectly declared.</p> <p>Erroneous code example:</p> <pre>fn main() -&gt; i32 { // error: main function has wrong type
    0
}
</pre> <p>The <code>main</code> function prototype should never take arguments or return type. Example:</p> <pre class="rust rust-example-rendered" data-language="rust">
fn main() {
    // your code
}</pre> <p>If you want to get command-line arguments, use <code>std::env::args</code>. To exit with a specified exit code, use <code>std::process::exit</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
     2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error-index.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/error-index.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
