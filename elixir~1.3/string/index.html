
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>String - Elixir 1.3 - W3cubDocs</title>
  
  <meta name="description" content=" A String in Elixir is a UTF-8 encoded binary. ">
  <meta name="keywords" content="string, summary, types, functions, -, elixir, elixir~1.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.3/string/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/elixir~1.3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.3/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  String  </h1>  <p>A String in Elixir is a UTF-8 encoded binary.</p> <h2 id="module-codepoints-and-graphemes" class="section-heading">  Codepoints and graphemes </h2> <p>The functions in this module act according to the Unicode Standard, version 6.3.0.</p> <p>As per the standard, a codepoint is a single Unicode Character, which may be represented by one or more bytes.</p> <p>For example, the codepoint “é” is two bytes:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; byte_size("é")
2</code></pre> <p>However, this module returns the proper length:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.length("é")
1</code></pre> <p>Furthermore, this module also presents the concept of graphemes. A single grapheme can consist of multiple codepoints that may be perceived as a single character by readers. For example, the “é” grapheme can be represented either as a single “e with acute” codepoint (like above), or as the letter “e” followed by a “combining acute accent” (two codepoints):</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; string = "\u0065\u0301"
iex&gt; byte_size(string)
3
iex&gt; String.length(string)
1
iex&gt; String.codepoints(string)
["e", "́"]
iex&gt; String.graphemes(string)
["é"]</code></pre> <p>Although the example above is made of two characters, it is perceived by users as one.</p> <p>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider “ch” as a grapheme. However, since this information depends on the locale, it is not taken into account by this module.</p> <p>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</p> <p>More information about graphemes can be found in the <a href="http://www.unicode.org/reports/tr29/" target="_blank">Unicode Standard Annex #29</a>. The current Elixir version implements Extended Grapheme Cluster algorithm.</p> <h2 id="module-string-and-binary-operations" class="section-heading">  String and binary operations </h2> <p>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode codepoints.</p> <p>For example, <a href="../string/#length/1"><code class="inline">String.length/1</code></a> will take longer as the input grows. On the other hand, <a href="../kernel/#byte_size/1"><code class="inline">Kernel.byte_size/1</code></a> always runs in constant time (i.e. regardless of the input size).</p> <p>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</p> <ul> <li>
<a href="../kernel/#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> - retrieves part of the binary </li> <li>
<a href="../kernel/#bit_size/1"><code class="inline">Kernel.bit_size/1</code></a> and <a href="../kernel/#byte_size/1"><code class="inline">Kernel.byte_size/1</code></a> - size related functions </li> <li>
<a href="../kernel/#is_bitstring/1"><code class="inline">Kernel.is_bitstring/1</code></a> and <a href="../kernel/#is_binary/1"><code class="inline">Kernel.is_binary/1</code></a> - type checking function </li> <li>Plus a number of functions for working with binaries (bytes) in the <a href="http://www.erlang.org/doc/man/binary.html" target="_blank"><code class="inline">:binary</code> module</a> </li> </ul> <p>There are many situations where using the <a href="../string/#content"><code class="inline">String</code></a> module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string <code class="inline">prefix</code> and you want to remove this prefix from another string named <code class="inline">full</code>.</p> <p>One may be tempted to write:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = String.length(prefix)
...&gt;   String.slice(full, base, String.length(full) - base)
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</code></pre> <p>Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both <code class="inline">prefix</code> and <code class="inline">full</code> strings, then slice the <code class="inline">full</code> one, traversing it again.</p> <p>A first attempt at improving it could be with ranges:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = String.length(prefix)
...&gt;   String.slice(full, base..-1)
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</code></pre> <p>While this is much better (we don’t traverse <code class="inline">full</code> twice), it could still be improved. In this case, since we want to extract a substring from a string, we can use <code class="inline">byte_size/1</code> and <code class="inline">binary_part/3</code> as there is no chance we will slice in the middle of a codepoint made of more than one byte:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = byte_size(prefix)
...&gt;   binary_part(full, base, byte_size(full) - base)
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</code></pre> <p>Or simply use pattern matching:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; take_prefix = fn full, prefix -&gt;
...&gt;   base = byte_size(prefix)
...&gt;   &lt;&lt;_::binary-size(base), rest::binary&gt;&gt; = full
...&gt;   rest
...&gt; end
iex&gt; take_prefix.("Mr. John", "Mr. ")
"John"</code></pre> <p>On the other hand, if you want to dynamically slice a string based on an integer value, then using <a href="../string/#slice/3"><code class="inline">String.slice/3</code></a> is the best option as it guarantees we won’t incorrectly split a valid codepoint into multiple bytes.</p> <h2 id="module-integer-codepoints" class="section-heading">  Integer codepoints </h2> <p>Although codepoints could be represented as integers, this module represents all codepoints as strings. For example:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.codepoints("olá")
["o", "l", "á"]</code></pre> <p>There are a couple of ways to retrieve a character integer codepoint. One may use the <code class="inline">?</code> construct:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; ?o
111

iex&gt; ?á
225</code></pre> <p>Or also via pattern matching:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; &lt;&lt;aacute::utf8&gt;&gt; = "á"
iex&gt; aacute
225</code></pre> <p>As we have seen above, codepoints can be inserted into a string by their hexadecimal code:</p> <pre data-language="elixir"><code class="elixir">"ol\u0061\u0301" #=&gt;
"olá"</code></pre> <h2 id="module-self-synchronization" class="section-heading">  Self-synchronization </h2> <p>The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one codepoint needs to be rejected.</p> <p>This module relies on this behaviour to ignore such invalid characters. For example, <a href="#length/1"><code class="inline">length/1</code></a> will return a correct result even if an invalid codepoint is fed into it.</p> <p>In other words, this module expects invalid data to be detected when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding.</p> <h2 id="module-patterns" class="section-heading">  Patterns </h2> <p>Many functions in this module work with patterns. For example, String.split/2 can split a string into multiple patterns given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.split("foo bar", " ")
["foo", "bar"]

iex&gt; String.split("foo bar!", [" ", "!"])
["foo", "bar", ""]

iex&gt; pattern = :binary.compile_pattern([" ", "!"])
iex&gt; String.split("foo bar!", pattern)
["foo", "bar", ""]</code></pre> <p>The compiled pattern is useful when the same match will be done over and over again. Note though the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile term.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:codepoint/0">codepoint()</a> </dt>   <dt class="summary-signature"> <a href="#t:grapheme/0">grapheme()</a> </dt>   <dt class="summary-signature"> <a href="#t:pattern/0">pattern()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#at/2">at(string, position)</a> </dt> <dd class="summary-synopsis">
<p>Returns the grapheme at the <code class="inline">position</code> of the given utf8 <code class="inline">string</code>. If <code class="inline">position</code> is greater than <code class="inline">string</code> length, then it returns <code class="inline">nil</code></p> </dd>   <dt class="summary-signature"> <a href="#capitalize/1">capitalize(string)</a> </dt> <dd class="summary-synopsis">
<p>Converts the first character in the given string to uppercase and the remainder to lowercase</p> </dd>   <dt class="summary-signature"> <a href="#chunk/2">chunk(string, trait)</a> </dt> <dd class="summary-synopsis">
<p>Splits the string into chunks of characters that share a common trait</p> </dd>   <dt class="summary-signature"> <a href="#codepoints/1">codepoints(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns all codepoints in the string</p> </dd>   <dt class="summary-signature"> <a href="#contains?/2">contains?(string, contents)</a> </dt> <dd class="summary-synopsis">
<p>Checks if <code class="inline">string</code> contains any of the given <code class="inline">contents</code></p> </dd>   <dt class="summary-signature"> <a href="#downcase/1">downcase(binary)</a> </dt> <dd class="summary-synopsis">
<p>Converts all characters in the given string to lowercase</p> </dd>   <dt class="summary-signature"> <a href="#duplicate/2">duplicate(subject, n)</a> </dt> <dd class="summary-synopsis">
<p>Returns a string <code class="inline">subject</code> duplicated <code class="inline">n</code> times</p> </dd>   <dt class="summary-signature"> <a href="#ends_with?/2">ends_with?(string, suffixes)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">string</code> ends with any of the suffixes given</p> </dd>   <dt class="summary-signature"> <a href="#equivalent?/2">equivalent?(string1, string2)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">string1</code> is canonically equivalent to ‘string2’</p> </dd>   <dt class="summary-signature"> <a href="#first/1">first(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns the first grapheme from a utf8 string, <code class="inline">nil</code> if the string is empty</p> </dd>   <dt class="summary-signature"> <a href="#graphemes/1">graphemes(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm</p> </dd>   <dt class="summary-signature"> <a href="#jaro_distance/2">jaro_distance(string1, string2)</a> </dt> <dd class="summary-synopsis">
<p>Returns a float value between 0 (equates to no similarity) and 1 (is an exact match) representing <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance" target="_blank">Jaro</a> distance between <code class="inline">string1</code> and <code class="inline">string2</code></p> </dd>   <dt class="summary-signature"> <a href="#last/1">last(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns the last grapheme from a utf8 string, <code class="inline">nil</code> if the string is empty</p> </dd>   <dt class="summary-signature"> <a href="#length/1">length(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns the number of Unicode graphemes in a utf8 string</p> </dd>   <dt class="summary-signature"> <a href="#match?/2">match?(string, regex)</a> </dt> <dd class="summary-synopsis">
<p>Checks if <code class="inline">string</code> matches the given regular expression</p> </dd>   <dt class="summary-signature"> <a href="#myers_difference/2">myers_difference(str1, str2)</a> </dt> <dd class="summary-synopsis">
<p>Returns a keyword list that represents an edit script</p> </dd>   <dt class="summary-signature"> <a href="#next_codepoint/1">next_codepoint(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns the next codepoint in a string</p> </dd>   <dt class="summary-signature"> <a href="#next_grapheme/1">next_grapheme(binary)</a> </dt> <dd class="summary-synopsis">
<p>Returns the next grapheme in a string</p> </dd>   <dt class="summary-signature"> <a href="#next_grapheme_size/1">next_grapheme_size(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns the size of the next grapheme</p> </dd>   <dt class="summary-signature"> <a href="#normalize/2">normalize(string, form)</a> </dt> <dd class="summary-synopsis">
<p>Converts all characters in <code class="inline">string</code> to Unicode normalization form identified by <code class="inline">form</code></p> </dd>   <dt class="summary-signature"> <a href="#pad_leading/3">pad_leading(string, count, padding \\ [" "])</a> </dt> <dd class="summary-synopsis">
<p>Returns a new string padded with a leading filler which is made of elements from the <code class="inline">padding</code></p> </dd>   <dt class="summary-signature"> <a href="#pad_trailing/3">pad_trailing(string, count, padding \\ [" "])</a> </dt> <dd class="summary-synopsis">
<p>Returns a new string padded with a trailing filler which is made of elements from the <code class="inline">padding</code></p> </dd>   <dt class="summary-signature"> <a href="#printable?/1">printable?(string)</a> </dt> <dd class="summary-synopsis">
<p>Checks if a string contains only printable characters</p> </dd>   <dt class="summary-signature"> <a href="#replace/4">replace(subject, pattern, replacement, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a new string created by replacing occurrences of <code class="inline">pattern</code> in <code class="inline">subject</code> with <code class="inline">replacement</code></p> </dd>   <dt class="summary-signature"> <a href="#replace_leading/3">replace_leading(string, match, replacement)</a> </dt> <dd class="summary-synopsis">
<p>Replaces all leading occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> of <code class="inline">match</code> in <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#replace_prefix/3">replace_prefix(string, match, replacement)</a> </dt> <dd class="summary-synopsis">
<p>Replaces prefix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code></p> </dd>   <dt class="summary-signature"> <a href="#replace_suffix/3">replace_suffix(string, match, replacement)</a> </dt> <dd class="summary-synopsis">
<p>Replaces suffix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code></p> </dd>   <dt class="summary-signature"> <a href="#replace_trailing/3">replace_trailing(string, match, replacement)</a> </dt> <dd class="summary-synopsis">
<p>Replaces all trailing occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> in <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#reverse/1">reverse(string)</a> </dt> <dd class="summary-synopsis">
<p>Reverses the graphemes in given string</p> </dd>   <dt class="summary-signature"> <a href="#slice/2">slice(string, range)</a> </dt> <dd class="summary-synopsis">
<p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range</p> </dd>   <dt class="summary-signature"> <a href="#slice/3">slice(string, start, len)</a> </dt> <dd class="summary-synopsis">
<p>Returns a substring starting at the offset <code class="inline">start</code>, and of length <code class="inline">len</code></p> </dd>   <dt class="summary-signature"> <a href="#split/1">split(binary)</a> </dt> <dd class="summary-synopsis">
<p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace</p> </dd>   <dt class="summary-signature"> <a href="#split/3">split(string, pattern, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Divides a string into substrings based on a pattern</p> </dd>   <dt class="summary-signature"> <a href="#split_at/2">split_at(string, position)</a> </dt> <dd class="summary-synopsis">
<p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string</p> </dd>   <dt class="summary-signature"> <a href="#splitter/3">splitter(string, pattern, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns an enumerable that splits a string on demand</p> </dd>   <dt class="summary-signature"> <a href="#starts_with?/2">starts_with?(string, prefix)</a> </dt> <dd class="summary-synopsis">
<p>Returns <code class="inline">true</code> if <code class="inline">string</code> starts with any of the prefixes given</p> </dd>   <dt class="summary-signature"> <a href="#to_atom/1">to_atom(string)</a> </dt> <dd class="summary-synopsis">
<p>Converts a string to an atom</p> </dd>   <dt class="summary-signature"> <a href="#to_charlist/1">to_charlist(string)</a> </dt> <dd class="summary-synopsis">
<p>Converts a string into a charlist</p> </dd>   <dt class="summary-signature"> <a href="#to_existing_atom/1">to_existing_atom(string)</a> </dt> <dd class="summary-synopsis">
<p>Converts a string to an existing atom</p> </dd>   <dt class="summary-signature"> <a href="#to_float/1">to_float(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns a float whose text representation is <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#to_integer/1">to_integer(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns an integer whose text representation is <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#to_integer/2">to_integer(string, base)</a> </dt> <dd class="summary-synopsis">
<p>Returns an integer whose text representation is <code class="inline">string</code> in base <code class="inline">base</code></p> </dd>   <dt class="summary-signature"> <a href="#trim/1">trim(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns a string where all leading and trailing Unicode whitespaces have been removed</p> </dd>   <dt class="summary-signature"> <a href="#trim/2">trim(string, to_trim)</a> </dt> <dd class="summary-synopsis">
<p>Returns a string where all leading and trailing <code class="inline">to_trim</code>s have been removed</p> </dd>   <dt class="summary-signature"> <a href="#trim_leading/1">trim_leading(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns a string where all leading Unicode whitespaces have been removed</p> </dd>   <dt class="summary-signature"> <a href="#trim_leading/2">trim_leading(string, to_trim)</a> </dt> <dd class="summary-synopsis">
<p>Returns a string where all leading <code class="inline">to_trim</code>s have been removed</p> </dd>   <dt class="summary-signature"> <a href="#trim_trailing/1">trim_trailing(string)</a> </dt> <dd class="summary-synopsis">
<p>Returns a string where all trailing Unicode whitespaces has been removed</p> </dd>   <dt class="summary-signature"> <a href="#trim_trailing/2">trim_trailing(string, to_trim)</a> </dt> <dd class="summary-synopsis">
<p>Returns a string where all trailing <code class="inline">to_trim</code>s have been removed</p> </dd>   <dt class="summary-signature"> <a href="#upcase/1">upcase(binary)</a> </dt> <dd class="summary-synopsis">
<p>Converts all characters in the given string to uppercase</p> </dd>   <dt class="summary-signature"> <a href="#valid?/1">valid?(string)</a> </dt> <dd class="summary-synopsis">
<p>Checks whether <code class="inline">string</code> contains only valid characters</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:codepoint/0">  <span class="signature">codepoint()</span>     </h3>
<pre data-language="elixir">codepoint() :: <a href="#t:t/0">t</a></pre>     <h3 class="detail-header type" id="t:grapheme/0">  <span class="signature">grapheme()</span>     </h3>
<pre data-language="elixir">grapheme() :: <a href="#t:t/0">t</a></pre>     <h3 class="detail-header type" id="t:pattern/0">  <span class="signature">pattern()</span>     </h3>
<pre data-language="elixir">pattern() :: <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>] | :binary.cp</pre>     <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: binary</pre>       <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="at/2">  <span class="signature">at(string, position)</span>     </h3>
<pre data-language="elixir">at(<a href="#t:t/0">t</a>, integer) :: <a href="#t:grapheme/0">grapheme</a> | nil</pre>  <p>Returns the grapheme at the <code class="inline">position</code> of the given utf8 <code class="inline">string</code>. If <code class="inline">position</code> is greater than <code class="inline">string</code> length, then it returns <code class="inline">nil</code>.</p> <h4 id="at/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.at("elixir", 0)
"e"

iex&gt; String.at("elixir", 1)
"l"

iex&gt; String.at("elixir", 10)
nil

iex&gt; String.at("elixir", -1)
"r"

iex&gt; String.at("elixir", -10)
nil</code></pre>    <h3 class="detail-header function" id="capitalize/1">  <span class="signature">capitalize(string)</span>     </h3>
<pre data-language="elixir">capitalize(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Converts the first character in the given string to uppercase and the remainder to lowercase.</p> <p>This relies on the titlecase information provided by the Unicode Standard. Note this function makes no attempt to capitalize all words in the string (usually known as titlecase).</p> <h4 id="capitalize/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.capitalize("abcd")
"Abcd"

iex&gt; String.capitalize("ﬁn")
"Fin"

iex&gt; String.capitalize("olá")
"Olá"</code></pre>    <h3 class="detail-header function" id="chunk/2">  <span class="signature">chunk(string, trait)</span>     </h3>
<pre data-language="elixir">chunk(<a href="#t:t/0">t</a>, :valid | :printable) :: [<a href="#t:t/0">t</a>]</pre>  <p>Splits the string into chunks of characters that share a common trait.</p> <p>The trait can be one of two options:</p> <ul> <li>
<p><code class="inline">:valid</code> - the string is split into chunks of valid and invalid character sequences</p> </li> <li>
<code class="inline">:printable</code> - the string is split into chunks of printable and non-printable character sequences </li> </ul> <p>Returns a list of binaries each of which contains only one kind of characters.</p> <p>If the given string is empty, an empty list is returned.</p> <h4 id="chunk/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0&gt;&gt;, :valid)
["abc\0"]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0FFFF::utf8&gt;&gt;, :valid)
["abc\0", &lt;&lt;0x0FFFF::utf8&gt;&gt;]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0FFFF::utf8&gt;&gt;, :printable)
["abc", &lt;&lt;0, 0x0FFFF::utf8&gt;&gt;]</code></pre>    <h3 class="detail-header function" id="codepoints/1">  <span class="signature">codepoints(string)</span>     </h3>
<pre data-language="elixir">codepoints(<a href="#t:t/0">t</a>) :: [<a href="#t:codepoint/0">codepoint</a>]</pre>  <p>Returns all codepoints in the string.</p> <p>For details about codepoints and graphemes, see the <a href="../string/#content"><code class="inline">String</code></a> module documentation.</p> <h4 id="codepoints/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.codepoints("olá")
["o", "l", "á"]

iex&gt; String.codepoints("оптими зации")
["о", "п", "т", "и", "м", "и", " ", "з", "а", "ц", "и", "и"]

iex&gt; String.codepoints("ἅἪῼ")
["ἅ", "Ἢ", "ῼ"]

iex&gt; String.codepoints("é")
["é"]

iex&gt; String.codepoints("é")
["e", "́"]</code></pre>    <h3 class="detail-header function" id="contains?/2">  <span class="signature">contains?(string, contents)</span>     </h3>
<pre data-language="elixir">contains?(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a>) :: boolean</pre>  <p>Checks if <code class="inline">string</code> contains any of the given <code class="inline">contents</code>.</p> <p><code class="inline">contents</code> can be either a single string or a list of strings.</p> <h4 id="contains?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.contains? "elixir of life", "of"
true
iex&gt; String.contains? "elixir of life", ["life", "death"]
true
iex&gt; String.contains? "elixir of life", ["death", "mercury"]
false</code></pre> <p>An empty string will always match:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.contains? "elixir of life", ""
true
iex&gt; String.contains? "elixir of life", ["", "other"]
true</code></pre> <p>The argument can also be a precompiled pattern:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; pattern = :binary.compile_pattern(["life", "death"])
iex&gt; String.contains? "elixir of life", pattern
true</code></pre>    <h3 class="detail-header function" id="downcase/1">  <span class="signature">downcase(binary)</span>     </h3>
<pre data-language="elixir">downcase(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Converts all characters in the given string to lowercase.</p> <h4 id="downcase/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.downcase("ABCD")
"abcd"

iex&gt; String.downcase("AB 123 XPTO")
"ab 123 xpto"

iex&gt; String.downcase("OLÁ")
"olá"</code></pre>    <h3 class="detail-header function" id="duplicate/2">  <span class="signature">duplicate(subject, n)</span>     </h3>
<pre data-language="elixir">duplicate(<a href="#t:t/0">t</a>, non_neg_integer) :: <a href="#t:t/0">t</a></pre>  <p>Returns a string <code class="inline">subject</code> duplicated <code class="inline">n</code> times.</p> <h4 id="duplicate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.duplicate("abc", 0)
""

iex&gt; String.duplicate("abc", 1)
"abc"

iex&gt; String.duplicate("abc", 2)
"abcabc"</code></pre>    <h3 class="detail-header function" id="ends_with?/2">  <span class="signature">ends_with?(string, suffixes)</span>     </h3>
<pre data-language="elixir">ends_with?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">string</code> ends with any of the suffixes given.</p> <p><code class="inline">suffixes</code> can be either a single suffix or a list of suffixes.</p> <h4 id="ends_with?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.ends_with? "language", "age"
true
iex&gt; String.ends_with? "language", ["youth", "age"]
true
iex&gt; String.ends_with? "language", ["youth", "elixir"]
false</code></pre> <p>An empty string will always match:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.ends_with? "language", ""
true
iex&gt; String.ends_with? "language", ["", "other"]
true</code></pre>    <h3 class="detail-header function" id="equivalent?/2">  <span class="signature">equivalent?(string1, string2)</span>     </h3>
<pre data-language="elixir">equivalent?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">string1</code> is canonically equivalent to ‘string2’.</p> <p>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</p> <pre data-language="elixir"><code class="elixir">String.normalize(string1, :nfd) == String.normalize(string2, :nfd)</code></pre> <p>Therefore, if you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</p> <h4 id="equivalent?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.equivalent?("abc", "abc")
true

iex&gt; String.equivalent?("man\u0303ana", "mañana")
true

iex&gt; String.equivalent?("abc", "ABC")
false

iex&gt; String.equivalent?("nø", "nó")
false</code></pre>    <h3 class="detail-header function" id="first/1">  <span class="signature">first(string)</span>     </h3>
<pre data-language="elixir">first(<a href="#t:t/0">t</a>) :: <a href="#t:grapheme/0">grapheme</a> | nil</pre>  <p>Returns the first grapheme from a utf8 string, <code class="inline">nil</code> if the string is empty.</p> <h4 id="first/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.first("elixir")
"e"

iex&gt; String.first("եոգլի")
"ե"</code></pre>    <h3 class="detail-header function" id="graphemes/1">  <span class="signature">graphemes(string)</span>     </h3>
<pre data-language="elixir">graphemes(<a href="#t:t/0">t</a>) :: [<a href="#t:grapheme/0">grapheme</a>]</pre>  <p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</p> <p>The algorithm is outlined in the <a href="http://www.unicode.org/reports/tr29/" target="_blank">Unicode Standard Annex #29, Unicode Text Segmentation</a>.</p> <p>For details about codepoints and graphemes, see the <a href="../string/#content"><code class="inline">String</code></a> module documentation.</p> <h4 id="graphemes/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.graphemes("Ńaïve")
["Ń", "a", "ï", "v", "e"]

iex&gt; String.graphemes("é")
["é"]

iex&gt; String.graphemes("é")
["é"]</code></pre>    <h3 class="detail-header function" id="jaro_distance/2">  <span class="signature">jaro_distance(string1, string2)</span>     </h3>
<pre data-language="elixir">jaro_distance(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: float</pre>  <p>Returns a float value between 0 (equates to no similarity) and 1 (is an exact match) representing <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance" target="_blank">Jaro</a> distance between <code class="inline">string1</code> and <code class="inline">string2</code>.</p> <p>The Jaro distance metric is designed and best suited for short strings such as person names.</p> <h4 id="jaro_distance/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.jaro_distance("dwayne", "duane")
0.8222222222222223
iex&gt; String.jaro_distance("even", "odd")
0.0</code></pre>    <h3 class="detail-header function" id="last/1">  <span class="signature">last(string)</span>     </h3>
<pre data-language="elixir">last(<a href="#t:t/0">t</a>) :: <a href="#t:grapheme/0">grapheme</a> | nil</pre>  <p>Returns the last grapheme from a utf8 string, <code class="inline">nil</code> if the string is empty.</p> <h4 id="last/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.last("elixir")
"r"

iex&gt; String.last("եոգլի")
"ի"</code></pre>    <h3 class="detail-header function" id="length/1">  <span class="signature">length(string)</span>     </h3>
<pre data-language="elixir">length(<a href="#t:t/0">t</a>) :: non_neg_integer</pre>  <p>Returns the number of Unicode graphemes in a utf8 string.</p> <h4 id="length/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.length("elixir")
6

iex&gt; String.length("եոգլի")
5</code></pre>    <h3 class="detail-header function" id="match?/2">  <span class="signature">match?(string, regex)</span>     </h3>
<pre data-language="elixir">match?(<a href="#t:t/0">t</a>, <a href="../regex/#t:t/0">Regex.t</a>) :: boolean</pre>  <p>Checks if <code class="inline">string</code> matches the given regular expression.</p> <h4 id="match?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.match?("foo", ~r/foo/)
true

iex&gt; String.match?("bar", ~r/foo/)
false</code></pre>    <h3 class="detail-header function" id="myers_difference/2">  <span class="signature">myers_difference(str1, str2)</span>     </h3>
<pre data-language="elixir">myers_difference(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: [{:eq | :ins | :del, <a href="#t:t/0">t</a>}] | nil</pre>  <p>Returns a keyword list that represents an edit script.</p> <p>The algorithm is outlined in the “An O(ND) Difference Algorithm and Its Variations” paper by E. Myers.</p> <h4 id="myers_difference/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; string1 = "fox hops over the dog"
iex&gt; string2 = "fox jumps over the lazy cat"
iex&gt; String.myers_difference(string1, string2)
[eq: "fox ", del: "ho", ins: "jum", eq: "ps over the ", del: "dog", ins: "lazy cat"]</code></pre>    <h3 class="detail-header function" id="next_codepoint/1">  <span class="signature">next_codepoint(string)</span>     </h3>
<pre data-language="elixir">next_codepoint(<a href="#t:t/0">t</a>) :: {<a href="#t:codepoint/0">codepoint</a>, <a href="#t:t/0">t</a>} | nil</pre>  <p>Returns the next codepoint in a string.</p> <p>The result is a tuple with the codepoint and the remainder of the string or <code class="inline">nil</code> in case the string reached its end.</p> <p>As with other functions in the String module, this function does not check for the validity of the codepoint. That said, if an invalid codepoint is found, it will be returned by this function.</p> <h4 id="next_codepoint/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.next_codepoint("olá")
{"o", "lá"}</code></pre>    <h3 class="detail-header function" id="next_grapheme/1">  <span class="signature">next_grapheme(binary)</span>     </h3>
<pre data-language="elixir">next_grapheme(<a href="#t:t/0">t</a>) :: {<a href="#t:grapheme/0">grapheme</a>, <a href="#t:t/0">t</a>} | nil</pre>  <p>Returns the next grapheme in a string.</p> <p>The result is a tuple with the grapheme and the remainder of the string or <code class="inline">nil</code> in case the String reached its end.</p> <h4 id="next_grapheme/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.next_grapheme("olá")
{"o", "lá"}</code></pre>    <h3 class="detail-header function" id="next_grapheme_size/1">  <span class="signature">next_grapheme_size(string)</span>     </h3>
<pre data-language="elixir">next_grapheme_size(<a href="#t:t/0">t</a>) :: {pos_integer, <a href="#t:t/0">t</a>} | nil</pre>  <p>Returns the size of the next grapheme.</p> <p>The result is a tuple with the next grapheme size and the remainder of the string or <code class="inline">nil</code> in case the string reached its end.</p> <h4 id="next_grapheme_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.next_grapheme_size("olá")
{1, "lá"}</code></pre>    <h3 class="detail-header function" id="normalize/2">  <span class="signature">normalize(string, form)</span>     </h3>
<pre data-language="elixir">normalize(<a href="#t:t/0">t</a>, atom) :: <a href="#t:t/0">t</a></pre>  <p>Converts all characters in <code class="inline">string</code> to Unicode normalization form identified by <code class="inline">form</code>.</p> <h4 id="normalize/2-forms" class="section-heading">  Forms </h4> <p>The supported forms are:</p> <ul> <li>
<p><code class="inline">:nfd</code> - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.</p> </li> <li>
<code class="inline">:nfc</code> - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence. </li> </ul> <h4 id="normalize/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.normalize("yêṩ", :nfd)
"yêṩ"

iex&gt; String.normalize("leña", :nfc)
"leña"</code></pre>     <h3 class="detail-header function" id="pad_leading/3">  <span class="signature">pad_leading(string, count, padding \\ [" "])</span>     </h3>
<pre data-language="elixir">pad_leading(<a href="#t:t/0">t</a>, non_neg_integer, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: <a href="#t:t/0">t</a></pre>  <p>Returns a new string padded with a leading filler which is made of elements from the <code class="inline">padding</code>.</p> <p>Passing a list of strings as <code class="inline">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class="inline">padding</code> is equivalent to passing the list of graphemes in it. If no <code class="inline">padding</code> is given, it defaults to whitespace.</p> <p>When <code class="inline">count</code> is less than or equal to the length of <code class="inline">string</code>, given <code class="inline">string</code> is returned.</p> <p>Raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the given <code class="inline">padding</code> contains non-string element.</p> <h4 id="pad_leading/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.pad_leading("abc", 5)
"  abc"

iex&gt; String.pad_leading("abc", 4, "12")
"1abc"

iex&gt; String.pad_leading("abc", 6, "12")
"121abc"

iex&gt; String.pad_leading("abc", 5, ["1", "23"])
"123abc"</code></pre>     <h3 class="detail-header function" id="pad_trailing/3">  <span class="signature">pad_trailing(string, count, padding \\ [" "])</span>     </h3>
<pre data-language="elixir">pad_trailing(<a href="#t:t/0">t</a>, non_neg_integer, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: <a href="#t:t/0">t</a></pre>  <p>Returns a new string padded with a trailing filler which is made of elements from the <code class="inline">padding</code>.</p> <p>Passing a list of strings as <code class="inline">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class="inline">padding</code> is equivalent to passing the list of graphemes in it. If no <code class="inline">padding</code> is given, it defaults to whitespace.</p> <p>When <code class="inline">count</code> is less than or equal to the length of <code class="inline">string</code>, given <code class="inline">string</code> is returned.</p> <p>Raises <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the given <code class="inline">padding</code> contains non-string element.</p> <h4 id="pad_trailing/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.pad_trailing("abc", 5)
"abc  "

iex&gt; String.pad_trailing("abc", 4, "12")
"abc1"

iex&gt; String.pad_trailing("abc", 6, "12")
"abc121"

iex&gt; String.pad_trailing("abc", 5, ["1", "23"])
"abc123"</code></pre>    <h3 class="detail-header function" id="printable?/1">  <span class="signature">printable?(string)</span>     </h3>
<pre data-language="elixir">printable?(<a href="#t:t/0">t</a>) :: boolean</pre>  <p>Checks if a string contains only printable characters.</p> <h4 id="printable?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.printable?("abc")
true</code></pre>     <h3 class="detail-header function" id="replace/4">  <span class="signature">replace(subject, pattern, replacement, options \\ [])</span>     </h3>
<pre data-language="elixir">replace(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a> | <a href="../regex/#t:t/0">Regex.t</a>, <a href="#t:t/0">t</a>, <a href="../keyword/#t:t/0">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a new string created by replacing occurrences of <code class="inline">pattern</code> in <code class="inline">subject</code> with <code class="inline">replacement</code>.</p> <p>By default, it replaces all occurrences, unless the <code class="inline">global</code> option is set to <code class="inline">false</code>, where it will only replace the first one</p> <p>The <code class="inline">pattern</code> may be a string or a regular expression.</p> <h4 id="replace/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.replace("a,b,c", ",", "-")
"a-b-c"

iex&gt; String.replace("a,b,c", ",", "-", global: false)
"a-b,c"</code></pre> <p>When the pattern is a regular expression, one can give <code class="inline">\N</code> or <code class="inline">\g{N}</code> in the <code class="inline">replacement</code> string to access a specific capture in the regular expression:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.replace("a,b,c", ~r/,(.)/, ",\\1\\g{1}")
"a,bb,cc"</code></pre> <p>Notice we had to escape the escape character <code class="inline">\</code>. By giving <code class="inline">\0</code>, one can inject the whole matched pattern in the replacement string. When the pattern is a string, a developer can use the replaced part inside the <code class="inline">replacement</code> by using the <code class="inline">:insert_replace</code> option and specifying the position(s) inside the <code class="inline">replacement</code> where the string pattern will be inserted: iex&gt; String.replace(“a,b,c”, “b”, “[]“, insert_replaced: 1) “a,[b],c” iex&gt; String.replace(“a,b,c”, “,”, “[]“, insert_replaced: 2) “a[],b[],c” iex&gt; String.replace(“a,b,c”, “,”, “[]“, insert_replaced: [1, 1]) “a[,,]b[,,]c” If any position given in the <code class="inline">:insert_replace</code> option is larger than the replacement string, or is negative, an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> is raised.</p>    <h3 class="detail-header function" id="replace_leading/3">  <span class="signature">replace_leading(string, match, replacement)</span>  </h3>  <p>Replaces all leading occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> of <code class="inline">match</code> in <code class="inline">string</code>.</p> <p>Returns the string untouched if there are no occurrences.</p> <h4 id="replace_leading/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.replace_leading("hello world", "hello ", "")
"world"
iex&gt; String.replace_leading("hello hello world", "hello ", "")
"world"

iex&gt; String.replace_leading("hello world", "hello ", "ola ")
"ola world"
iex&gt; String.replace_leading("hello hello world", "hello ", "ola ")
"ola ola world"</code></pre>    <h3 class="detail-header function" id="replace_prefix/3">  <span class="signature">replace_prefix(string, match, replacement)</span>  </h3>  <p>Replaces prefix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p> <p>Returns the string untouched if there is no match.</p> <h4 id="replace_prefix/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.replace_prefix("world", "hello ", "")
"world"
iex&gt; String.replace_prefix("hello world", "hello ", "")
"world"
iex&gt; String.replace_prefix("hello hello world", "hello ", "")
"hello world"

iex&gt; String.replace_prefix("world", "hello ", "ola ")
"world"
iex&gt; String.replace_prefix("hello world", "hello ", "ola ")
"ola world"
iex&gt; String.replace_prefix("hello hello world", "hello ", "ola ")
"ola hello world"</code></pre>    <h3 class="detail-header function" id="replace_suffix/3">  <span class="signature">replace_suffix(string, match, replacement)</span>  </h3>  <p>Replaces suffix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p> <p>Returns the string untouched if there is no match.</p> <h4 id="replace_suffix/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.replace_suffix("hello", " world", "")
"hello"
iex&gt; String.replace_suffix("hello world", " world", "")
"hello"
iex&gt; String.replace_suffix("hello world world", " world", "")
"hello world"

iex&gt; String.replace_suffix("hello", " world", " mundo")
"hello"
iex&gt; String.replace_suffix("hello world", " world", " mundo")
"hello mundo"
iex&gt; String.replace_suffix("hello world world", " world", " mundo")
"hello world mundo"</code></pre>    <h3 class="detail-header function" id="replace_trailing/3">  <span class="signature">replace_trailing(string, match, replacement)</span>  </h3>  <p>Replaces all trailing occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> in <code class="inline">string</code>.</p> <p>Returns the string untouched if there are no occurrences.</p> <h4 id="replace_trailing/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.replace_trailing("hello world", " world", "")
"hello"
iex&gt; String.replace_trailing("hello world world", " world", "")
"hello"

iex&gt; String.replace_trailing("hello world", " world", " mundo")
"hello mundo"
iex&gt; String.replace_trailing("hello world world", " world", " mundo")
"hello mundo mundo"</code></pre>    <h3 class="detail-header function" id="reverse/1">  <span class="signature">reverse(string)</span>     </h3>
<pre data-language="elixir">reverse(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Reverses the graphemes in given string.</p> <h4 id="reverse/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.reverse("abcd")
"dcba"

iex&gt; String.reverse("hello world")
"dlrow olleh"

iex&gt; String.reverse("hello ∂og")
"go∂ olleh"</code></pre> <p>Keep in mind reversing the same string twice does not necessarily yield the original string:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; "̀e"
"̀e"
iex&gt; String.reverse("̀e")
"è"
iex&gt; String.reverse String.reverse("̀e")
"è"</code></pre> <p>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</p>    <h3 class="detail-header function" id="slice/2">  <span class="signature">slice(string, range)</span>     </h3>
<pre data-language="elixir">slice(<a href="#t:t/0">t</a>, <a href="../range/#t:t/0">Range.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</p> <p>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns <code class="inline">""</code>.</p> <p>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</p> <p>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check <a href="../kernel/#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> instead.</p> <h4 id="slice/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.slice("elixir", 1..3)
"lix"

iex&gt; String.slice("elixir", 1..10)
"lixir"

iex&gt; String.slice("elixir", 10..3)
""

iex&gt; String.slice("elixir", -4..-1)
"ixir"

iex&gt; String.slice("elixir", 2..-1)
"ixir"

iex&gt; String.slice("elixir", -4..6)
"ixir"

iex&gt; String.slice("elixir", -1..-4)
""

iex&gt; String.slice("elixir", -10..-7)
""

iex&gt; String.slice("a", 0..1500)
"a"

iex&gt; String.slice("a", 1..1500)
""</code></pre>    <h3 class="detail-header function" id="slice/3">  <span class="signature">slice(string, start, len)</span>     </h3>
<pre data-language="elixir">slice(<a href="#t:t/0">t</a>, integer, integer) :: <a href="#t:grapheme/0">grapheme</a></pre>  <p>Returns a substring starting at the offset <code class="inline">start</code>, and of length <code class="inline">len</code>.</p> <p>If the offset is greater than string length, then it returns <code class="inline">""</code>.</p> <p>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check <a href="../kernel/#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> instead.</p> <h4 id="slice/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.slice("elixir", 1, 3)
"lix"

iex&gt; String.slice("elixir", 1, 10)
"lixir"

iex&gt; String.slice("elixir", 10, 3)
""

iex&gt; String.slice("elixir", -4, 4)
"ixir"

iex&gt; String.slice("elixir", -10, 3)
""

iex&gt; String.slice("a", 0, 1500)
"a"

iex&gt; String.slice("a", 1, 1500)
""

iex&gt; String.slice("a", 2, 1500)
""</code></pre>    <h3 class="detail-header function" id="split/1">  <span class="signature">split(binary)</span>     </h3>
<pre data-language="elixir">split(<a href="#t:t/0">t</a>) :: [<a href="#t:t/0">t</a>]</pre>  <p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</p> <h4 id="split/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.split("foo bar")
["foo", "bar"]

iex&gt; String.split("foo" &lt;&gt; &lt;&lt;194, 133&gt;&gt; &lt;&gt; "bar")
["foo", "bar"]

iex&gt; String.split(" foo   bar ")
["foo", "bar"]

iex&gt; String.split("no\u00a0break")
["no\u00a0break"]</code></pre>     <h3 class="detail-header function" id="split/3">  <span class="signature">split(string, pattern, options \\ [])</span>     </h3>
<pre data-language="elixir">split(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a> | <a href="../regex/#t:t/0">Regex.t</a>, <a href="../keyword/#t:t/0">Keyword.t</a>) :: [<a href="#t:t/0">t</a>]</pre>  <p>Divides a string into substrings based on a pattern.</p> <p>Returns a list of these substrings. The pattern can be a string, a list of strings or a regular expression.</p> <p>The string is split into as many parts as possible by default, but can be controlled via the <code class="inline">parts: pos_integer</code> option. If you pass <code class="inline">parts: :infinity</code>, it will return all possible parts (<code class="inline">:infinity</code> is the default).</p> <p>Empty strings are only removed from the result if the <code class="inline">trim</code> option is set to <code class="inline">true</code> (default is <code class="inline">false</code>).</p> <h4 id="split/3-examples" class="section-heading">  Examples </h4> <p>Splitting with a string pattern:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.split("a,b,c", ",")
["a", "b", "c"]

iex&gt; String.split("a,b,c", ",", parts: 2)
["a", "b,c"]

iex&gt; String.split(" a b c ", " ", trim: true)
["a", "b", "c"]</code></pre> <p>A list of patterns:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.split("1,2 3,4", [" ", ","])
["1", "2", "3", "4"]</code></pre> <p>A regular expression:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.split("a,b,c", ~r{,})
["a", "b", "c"]

iex&gt; String.split("a,b,c", ~r{,}, parts: 2)
["a", "b,c"]

iex&gt; String.split(" a b c ", ~r{\s}, trim: true)
["a", "b", "c"]</code></pre> <p>Splitting on empty patterns returns graphemes:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.split("abc", ~r{})
["a", "b", "c", ""]

iex&gt; String.split("abc", "")
["a", "b", "c", ""]

iex&gt; String.split("abc", "", trim: true)
["a", "b", "c"]

iex&gt; String.split("abc", "", parts: 2)
["a", "bc"]</code></pre> <p>A precompiled pattern can also be given:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; pattern = :binary.compile_pattern([" ", ","])
iex&gt; String.split("1,2 3,4", pattern)
["1", "2", "3", "4"]</code></pre>    <h3 class="detail-header function" id="split_at/2">  <span class="signature">split_at(string, position)</span>     </h3>
<pre data-language="elixir">split_at(<a href="#t:t/0">t</a>, integer) :: {<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>}</pre>  <p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string.</p> <p>The offset is capped to the length of the string. Returns a tuple with two elements.</p> <p>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use <a href="../kernel/#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> instead.</p> <h4 id="split_at/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.split_at "sweetelixir", 5
{"sweet", "elixir"}

iex&gt; String.split_at "sweetelixir", -6
{"sweet", "elixir"}

iex&gt; String.split_at "abc", 0
{"", "abc"}

iex&gt; String.split_at "abc", 1000
{"abc", ""}

iex&gt; String.split_at "abc", -1000
{"", "abc"}</code></pre>     <h3 class="detail-header function" id="splitter/3">  <span class="signature">splitter(string, pattern, options \\ [])</span>     </h3>
<pre data-language="elixir">splitter(<a href="#t:t/0">t</a>, <a href="#t:pattern/0">pattern</a>, <a href="../keyword/#t:t/0">Keyword.t</a>) :: <a href="../enumerable/#t:t/0">Enumerable.t</a></pre>  <p>Returns an enumerable that splits a string on demand.</p> <p>This is in contrast to <a href="#split/3"><code class="inline">split/3</code></a> which splits all the string upfront.</p> <p>Note splitter does not support regular expressions (as it is often more efficient to have the regular expressions traverse the string at once than in multiple passes).</p> <h4 id="splitter/3-options" class="section-heading">  Options </h4> <ul> <li>:trim - when <code class="inline">true</code>, does not emit empty patterns </li> </ul>    <h3 class="detail-header function" id="starts_with?/2">  <span class="signature">starts_with?(string, prefix)</span>     </h3>
<pre data-language="elixir">starts_with?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: boolean</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">string</code> starts with any of the prefixes given.</p> <p><code class="inline">prefix</code> can be either a single prefix or a list of prefixes.</p> <h4 id="starts_with?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.starts_with? "elixir", "eli"
true
iex&gt; String.starts_with? "elixir", ["erlang", "elixir"]
true
iex&gt; String.starts_with? "elixir", ["erlang", "ruby"]
false</code></pre> <p>An empty string will always match:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.starts_with? "elixir", ""
true
iex&gt; String.starts_with? "elixir", ["", "other"]
true</code></pre>    <h3 class="detail-header function" id="to_atom/1">  <span class="signature">to_atom(string)</span>     </h3>
<pre data-language="elixir">to_atom(<a href="../string/#t:t/0">String.t</a>) :: atom</pre>  <p>Converts a string to an atom.</p> <p>Currently Elixir does not support the conversion of strings that contain Unicode codepoints greater than 0xFF.</p> <p>Inlined by the compiler.</p> <h4 id="to_atom/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.to_atom("my_atom")
:my_atom</code></pre>    <h3 class="detail-header function" id="to_charlist/1">  <span class="signature">to_charlist(string)</span>     </h3>
<pre data-language="elixir">to_charlist(<a href="#t:t/0">t</a>) :: charlist</pre>  <p>Converts a string into a charlist.</p> <p>Specifically, this functions takes a UTF-8 encoded binary and returns a list of its integer codepoints. It is similar to <a href="#codepoints/1"><code class="inline">codepoints/1</code></a> except that the latter returns a list of codepoints as strings.</p> <p>In case you need to work with bytes, take a look at the <a href="http://www.erlang.org/doc/man/binary.html" target="_blank"><code class="inline">:binary</code> module</a>.</p> <h4 id="to_charlist/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.to_charlist("æß")
'æß'</code></pre>    <h3 class="detail-header function" id="to_existing_atom/1">  <span class="signature">to_existing_atom(string)</span>     </h3>
<pre data-language="elixir">to_existing_atom(<a href="../string/#t:t/0">String.t</a>) :: atom</pre>  <p>Converts a string to an existing atom.</p> <p>Currently Elixir does not support the conversion of strings that contain Unicode codepoints greater than 0xFF.</p> <p>Inlined by the compiler.</p> <h4 id="to_existing_atom/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; _ = :my_atom
iex&gt; String.to_existing_atom("my_atom")
:my_atom

iex&gt; String.to_existing_atom("this_atom_will_never_exist")
** (ArgumentError) argument error</code></pre>    <h3 class="detail-header function" id="to_float/1">  <span class="signature">to_float(string)</span>     </h3>
<pre data-language="elixir">to_float(<a href="../string/#t:t/0">String.t</a>) :: float</pre>  <p>Returns a float whose text representation is <code class="inline">string</code>.</p> <p><code class="inline">string</code> must be the string representation of a float. If a string representation of an integer wants to be used, then <a href="../float/#parse/1"><code class="inline">Float.parse/1</code></a> should be used instead, otherwise an argument error will be raised.</p> <p>Inlined by the compiler.</p> <h4 id="to_float/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.to_float("2.2017764e+0")
2.2017764

iex&gt; String.to_float("3.0")
3.0</code></pre>    <h3 class="detail-header function" id="to_integer/1">  <span class="signature">to_integer(string)</span>     </h3>
<pre data-language="elixir">to_integer(<a href="../string/#t:t/0">String.t</a>) :: integer</pre>  <p>Returns an integer whose text representation is <code class="inline">string</code>.</p> <p>Inlined by the compiler.</p> <h4 id="to_integer/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.to_integer("123")
123</code></pre>    <h3 class="detail-header function" id="to_integer/2">  <span class="signature">to_integer(string, base)</span>     </h3>
<pre data-language="elixir">to_integer(<a href="../string/#t:t/0">String.t</a>, 2..36) :: integer</pre>  <p>Returns an integer whose text representation is <code class="inline">string</code> in base <code class="inline">base</code>.</p> <p>Inlined by the compiler.</p> <h4 id="to_integer/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.to_integer("3FF", 16)
1023</code></pre>    <h3 class="detail-header function" id="trim/1">  <span class="signature">trim(string)</span>     </h3>
<pre data-language="elixir">trim(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a string where all leading and trailing Unicode whitespaces have been removed.</p> <h4 id="trim/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.trim("\n  abc\n  ")
"abc"</code></pre>    <h3 class="detail-header function" id="trim/2">  <span class="signature">trim(string, to_trim)</span>     </h3>
<pre data-language="elixir">trim(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a string where all leading and trailing <code class="inline">to_trim</code>s have been removed.</p> <h4 id="trim/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.trim("a  abc  a", "a")
"  abc  "</code></pre>    <h3 class="detail-header function" id="trim_leading/1">  <span class="signature">trim_leading(string)</span>     </h3>
<pre data-language="elixir">trim_leading(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a string where all leading Unicode whitespaces have been removed.</p> <h4 id="trim_leading/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.trim_leading("\n  abc   ")
"abc   "</code></pre>    <h3 class="detail-header function" id="trim_leading/2">  <span class="signature">trim_leading(string, to_trim)</span>     </h3>
<pre data-language="elixir">trim_leading(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a string where all leading <code class="inline">to_trim</code>s have been removed.</p> <h4 id="trim_leading/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.trim_leading("__ abc _", "_")
" abc _"

iex&gt; String.trim_leading("1 abc", "11")
"1 abc"</code></pre>    <h3 class="detail-header function" id="trim_trailing/1">  <span class="signature">trim_trailing(string)</span>     </h3>
<pre data-language="elixir">trim_trailing(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a string where all trailing Unicode whitespaces has been removed.</p> <h4 id="trim_trailing/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.trim_trailing("   abc\n  ")
"   abc"</code></pre>    <h3 class="detail-header function" id="trim_trailing/2">  <span class="signature">trim_trailing(string, to_trim)</span>     </h3>
<pre data-language="elixir">trim_trailing(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Returns a string where all trailing <code class="inline">to_trim</code>s have been removed.</p> <h4 id="trim_trailing/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.trim_trailing("_ abc __", "_")
"_ abc "

iex&gt; String.trim_trailing("abc 1", "11")
"abc 1"</code></pre>    <h3 class="detail-header function" id="upcase/1">  <span class="signature">upcase(binary)</span>     </h3>
<pre data-language="elixir">upcase(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Converts all characters in the given string to uppercase.</p> <h4 id="upcase/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.upcase("abcd")
"ABCD"

iex&gt; String.upcase("ab 123 xpto")
"AB 123 XPTO"

iex&gt; String.upcase("olá")
"OLÁ"</code></pre>    <h3 class="detail-header function" id="valid?/1">  <span class="signature">valid?(string)</span>     </h3>
<pre data-language="elixir">valid?(<a href="#t:t/0">t</a>) :: boolean</pre>  <p>Checks whether <code class="inline">string</code> contains only valid characters.</p> <h4 id="valid?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; String.valid?("a")
true

iex&gt; String.valid?("ø")
true

iex&gt; String.valid?(&lt;&lt;0xFFFF :: 16&gt;&gt;)
false

iex&gt; String.valid?("asd" &lt;&gt; &lt;&lt;0xFFFF :: 16&gt;&gt;)
false</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2017 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.3.3/String.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.3.3/String.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
