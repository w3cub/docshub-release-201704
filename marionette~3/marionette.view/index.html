
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>View - Marionette.js 3 - W3cubDocs</title>
  
  <meta name="description" content="A View is a view that represents an item to be displayed with a template. This is typically a Backbone.Model, Backbone.Collection, or nothing at all &hellip;">
  <meta name="keywords" content="marionette, view, -, js, marionette~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/marionette~3/marionette.view/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/marionette~3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/marionette~3/" class="_nav-link" title="" style="margin-left:0;">Marionette.js 3</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _marionette">
				
<h1>
Marionette.View</h1>
<p>A <code>View</code> is a view that represents an item to be displayed with a template. This is typically a <code>Backbone.Model</code>, <code>Backbone.Collection</code>, or nothing at all.</p> <p>Views are also used to build up your application hierarchy - you can easily nest multiple views through the <code>regions</code> attribute.</p> <p><strong><em>Note: From Marionette v3.x, <code>Marionette.View</code> replaces <code>Marionette.LayoutView</code> and <code>Marionette.ItemView</code>.</em></strong></p> <h2 id="documentation-index">
Documentation Index</h2>
<ul> <li>
<a href="#rendering-a-template">Rendering a Template</a><ul> <li><a href="#set-how-template-is-attached-to-the-el">Set How Template is Attached to the <code>el</code></a></li> </ul> </li> <li>
<a href="#managing-an-existing-page">Managing an Existing Page</a><ul> <li><a href="#setting-a-template-to-false">Setting a <code>template</code> to <code>false</code></a></li> </ul> </li> <li>
<a href="#laying-out-views-regions">Laying Out Views - Regions</a><ul> <li>
<a href="#managing-sub-views">Managing Sub-views</a><ul> <li><a href="#showing-a-view">Showing a View</a></li> <li><a href="#accessing-a-child-view">Accessing a Child View</a></li> <li><a href="#detaching-a-child-view">Detaching a Child View</a></li> </ul> </li> <li><a href="#region-availability">Region Availability</a></li> <li><a href="#efficient-nested-view-structures">Efficient Nested View Structures</a></li> <li><a href="#listening-to-events-on-children">Listening to Events on Children</a></li> </ul> </li> <li>
<a href="#organizing-your-view">Organizing Your View</a><ul> <li><a href="#defining-ui">Defining <code>ui</code></a></li> <li>
<a href="#accessing-ui-elements">Accessing UI Elements</a><ul> <li><a href="#referencing-ui-in-events-and-triggers">Referencing UI in <code>events</code> and <code>triggers</code></a></li> </ul> </li> </ul> </li> <li>
<a href="#events">Events</a><ul> <li><a href="#onevent-listeners">onEvent Listeners</a></li> <li><a href="#lifecycle-events">Lifecycle Events</a></li> <li>
<a href="#binding-to-user-input">Binding To User Input</a><ul> <li><a href="#event-and-trigger-mapping">Event and Trigger Mapping</a></li> <li><a href="#view-events">View <code>events</code></a></li> <li><a href="#view-triggers">View <code>triggers</code></a></li> <li><a href="#view-triggers-event-object">View <code>triggers</code> Event Object</a></li> </ul> </li> </ul> </li> <li>
<a href="#model-and-collection-events">Model and Collection Events</a><ul> <li>
<a href="#model-events">Model Events</a><ul> <li><a href="#function-callback">Function Callback</a></li> </ul> </li> <li><a href="#collection-events">Collection Events</a></li> <li><a href="#listening-to-both">Listening to Both</a></li> </ul> </li> </ul> <h2 id="rendering-a-template">
Rendering a Template</h2>
<p>The Marionette View implements a powerful render method which, given a template, will build your HTML from that template, mixing in model information and any extra template context.</p> <p><strong>Overriding <code>render</code></strong> If you want to add extra behavior to your view's render, you would be best off doing your logic in the <a href="#lifecycle-events"><code>onBeforeRender</code> or <code>onRender</code> handlers</a>.</p> <p>To render a template, set the <code>template</code> attribute on your view:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);
<span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">tagName</span>: <span class="hljs-string">'h1'</span>,
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'Contents'</span>)
});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();
myView.render();
</pre> <p><a href="https://jsfiddle.net/marionettejs/dhsjcka4/" target="_blank">Live example</a></p> <p>For more detail on how to render templates, see the <a href="../template/">Template documentation</a>.</p> <h3 id="set-how-template-is-attached-to-the-el">
Set How Template is Attached to the <code>el</code>
</h3>
<p>Override the view's <code>attachElContent</code> method to change how the a rendered template is attached to the view's <code>el</code>. This method receives one parameter - the rendered html.</p> <p>The default implementation of <code>attachElContent</code> is:</p> <pre data-language="javascript">attachElContent(html) {
  <span class="hljs-keyword">this</span>.$el.html(html);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
},
</pre> <h2 id="managing-an-existing-page">
Managing an Existing Page</h2>
<p>Marionette is able to manage pre-generated pages - either static or server-generated - and treat them as though they were generated from Marionette.</p> <p>To use the existing page, set the <code>el</code> to match the existing DOM element:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View({
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#base-element'</span>
});

<span class="hljs-keyword">new</span> myView();
myView.isRendered(); <span class="hljs-comment">// true if '#base-element` exists</span>
myView.isAttached(); <span class="hljs-comment">// true if '#base-element` is in the DOM</span>
</pre> <p><a href="https://jsfiddle.net/marionettejs/b2yz38gj/" target="_blank">Live example</a></p> <p>Marionette will <a href="../viewlifecycle/#views-associated-with-previously-rendered-or-attached-dom">set the appropriate state of the view</a>.</p> <h3 id="setting-a-template-to-false">
Setting a <code>template</code> to <code>false</code>
</h3>
<p>Setting the <code>template</code> to <code>false</code> allows for the view to create all of the bindings and trigger all view events without re-rendering the el of the view. <em>Any other falsy value will throw an exception.</em></p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View({
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#base-element'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-literal">false</span>
});

<span class="hljs-keyword">new</span> myView();
myView.render();
</pre> <h2 id="laying-out-views-regions">
Laying Out Views - Regions</h2>
<p>The <code>Marionette.View</code> class lets us manage a hierarchy of views using <code>regions</code>. Regions are a hook point that lets us show views inside views, manage the show/hide lifecycles, and act on events inside the children.</p> <p><strong>This Section only covers the basics. For more information on regions, see the <a href="../marionette.region/">Regions Documentation.</a></strong></p> <p>Regions are ideal for rendering application layouts by isolating concerns inside another view. This is especially useful for independently re-rendering chunks of your application without having to completely re-draw the entire screen every time some data is updated.</p> <p>Regions can be added to a View at class definition, with <code>regions</code>, or at runtime using <code>addRegion</code>.</p> <p>When you extend <code>View</code>, we use the <code>regions</code> attribute to point to the selector where the new view will be displayed:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#tpl-view-with-regions'</span>,

  <span class="hljs-attr">regions</span>: {
    <span class="hljs-attr">firstRegion</span>: <span class="hljs-string">'#first-region'</span>,
    <span class="hljs-attr">secondRegion</span>: <span class="hljs-string">'#second-region'</span>
  }
});
</pre> <p>If we have the following template:</p> <pre data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"x-template/underscore"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tpl-view-with-regions"</span>&gt;</span><span class="javascript">
  &lt;div id=<span class="hljs-string">"first-region"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"second-region"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"third-region"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</pre> <p><a href="https://jsfiddle.net/marionettejs/4e3qdgwr/" target="_blank">Live example</a></p> <p>When we show views in the region, the contents of <code>#first-region</code> and <code>#second-region</code> will be replaced with the contents of the view we show. The value in the <code>regions</code> hash is just a jQuery selector, and any valid jQuery syntax will suffice.</p> <h3 id="managing-sub-views">
Managing Sub-views</h3>
<p><code>View</code> provides a simple interface for managing sub-views with <code>showChildView</code> and <code>getChildView</code>:</p> <h4>
Showing a View</h4>
<p>To show a view inside a region, simply call <code>showChildView(region, view)</code>. This will handle rendering the view's HTML and attaching it to the DOM for you:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);
<span class="hljs-keyword">var</span> SubView = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./subview'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#tpl-view-with-regions'</span>,

  <span class="hljs-attr">regions</span>: {
    <span class="hljs-attr">firstRegion</span>: <span class="hljs-string">'#first-region'</span>
  },

  <span class="hljs-attr">onRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.showChildView(<span class="hljs-string">'firstRegion'</span>, <span class="hljs-keyword">new</span> SubView());
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/98u073m0/" target="_blank">Live example</a></p> <h4>
Accessing a Child View</h4>
<p>To access the child view of a <code>View</code> - use the <code>getChildView(region)</code> method. This will return the view instance that is current being displayed at that region, or <code>null</code>:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);
<span class="hljs-keyword">var</span> SubView = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./subview'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#tpl-view-with-regions'</span>,

  <span class="hljs-attr">regions</span>: {
    <span class="hljs-attr">firstRegion</span>: <span class="hljs-string">'#first-region'</span>
  },

  <span class="hljs-attr">onRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.showChildView(<span class="hljs-string">'firstRegion'</span>, <span class="hljs-keyword">new</span> SubView());
  },

  <span class="hljs-attr">onSomeEvent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">var</span> first = <span class="hljs-keyword">this</span>.getChildView(<span class="hljs-string">'firstRegion'</span>);
    first.doSomething();
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/b12kgq3t/" target="_blank">Live example</a></p> <p>If no view is available, <code>getChildView</code> returns <code>null</code>.</p> <h4>
Detaching a Child View</h4>
<p>You can detach a child view from a region through <code>detachChildView(region)</code></p> <pre data-language="javascript">
<span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);
<span class="hljs-keyword">var</span> SubView = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./subview'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#tpl-view-with-regions'</span>,

  <span class="hljs-attr">regions</span>: {
    <span class="hljs-attr">firstRegion</span>: <span class="hljs-string">'#first-region'</span>,
    <span class="hljs-attr">secondRegion</span>: <span class="hljs-string">'#second-region'</span>
  },

  <span class="hljs-attr">onRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.showChildView(<span class="hljs-string">'firstRegion'</span>, <span class="hljs-keyword">new</span> SubView());
  },

  <span class="hljs-attr">onMoveView</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">this</span>.detachChildView(<span class="hljs-string">'firstRegion'</span>);
    <span class="hljs-keyword">this</span>.showChildView(<span class="hljs-string">'secondRegion'</span>, view);
  }
});
</pre> <p>This is a proxy for <a href="../marionette.region/#detaching-existing-views">region.detachView()</a></p> <h3 id="region-availability">
Region Availability</h3>
<p>Any defined regions within a <code>View</code> will be available to the <code>View</code> or any calling code immediately after instantiating the <code>View</code>. This allows a View to be attached to an existing DOM element in an HTML page, without the need to call a render method or anything else, to create the regions.</p> <p>However, a region will only be able to populate itself if the <code>View</code> has access to the elements specified within the region definitions. That is, if your view has not yet rendered, your regions may not be able to find the element that you've specified for them to manage. In that scenario, using the region will result in no changes to the DOM.</p> <h3 id="efficient-nested-view-structures">
Efficient Nested View Structures</h3>
<p>When your views get some more regions, you may want to think of the most efficient way to render your views. Since manipulating the DOM is performance heavy, it's best practice to render most of your views at once.</p> <p>Marionette provides a simple mechanism to infinitely nest views in a single paint: just render all of the children in the onRender callback.</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> ParentView = Mn.View.extend({
  <span class="hljs-attr">onRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.showChildView(<span class="hljs-string">'header'</span>, <span class="hljs-keyword">new</span> HeaderView());
    <span class="hljs-keyword">this</span>.showChildView(<span class="hljs-string">'footer'</span>, <span class="hljs-keyword">new</span> FooterView());
  }
});

myRegion.show(<span class="hljs-keyword">new</span> ParentView(), options);
</pre> <p>In this example, the doubly-nested view structure will be rendered in a single paint.</p> <p>This system is recursive, so it works for any deeply nested structure. The child views you show can render their own child views within their onRender callbacks!</p> <h3 id="listening-to-events-on-children">
Listening to Events on Children</h3>
<p>Using regions lets you listen to the events that fire on child views - views attached inside a region. This lets a parent view take action depending on what is happening in views it directly owns.</p> <p><strong>To see more information about events, see the <a href="../events/#child-view-events">events documentation</a></strong></p> <h2 id="organizing-your-view">
Organizing Your View</h2>
<p>The <code>View</code> provides a mechanism to name parts of your template to be used throughout the view with the <code>ui</code> attribute. This provides a number of benefits:</p> <ol> <li>Provide a reference to commonly used UI elements</li> <li>Cache the jQuery selector</li> <li>Change the selector later in only one place in your view</li> </ol> <h3 id="defining-ui">
Defining <code>ui</code>
</h3>
<p>To define your <code>ui</code> hash, just set an object of key to jQuery selectors to the <code>ui</code> attribute of your View:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#my-template'</span>,
  <span class="hljs-attr">ui</span>: {
    <span class="hljs-attr">save</span>: <span class="hljs-string">'#save-button'</span>,
    <span class="hljs-attr">close</span>: <span class="hljs-string">'.close-button'</span>
  }
});
</pre> <p>Inside your view, the <code>save</code> and <code>close</code> references will point to the jQuery selectors <code>#save-button</code> and <code>.close-button</code> respectively.</p> <h3 id="accessing-ui-elements">
Accessing UI Elements</h3>
<p>To get the handles to your UI elements, use the <code>getUI(ui)</code> method:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#my-template'</span>,
  <span class="hljs-attr">ui</span>: {
    <span class="hljs-attr">save</span>: <span class="hljs-string">'#save-button'</span>,
    <span class="hljs-attr">close</span>: <span class="hljs-string">'.close-button'</span>
  },

  <span class="hljs-attr">onDoSomething</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">var</span> saveButton = <span class="hljs-keyword">this</span>.getUI(<span class="hljs-string">'save'</span>);
    saveButton.addClass(<span class="hljs-string">'disabled'</span>);
    saveButton.attr(<span class="hljs-string">'disabled'</span>, <span class="hljs-string">'disabled'</span>);
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/rpa58v0g/" target="_blank">Live example</a></p> <p>As <code>saveButton</code> here is a jQuery selector, you can call any jQuery methods on it, according to the jQuery documentation.</p> <h4>
Referencing UI in <code>events</code> and <code>triggers</code>
</h4>
<p>The UI attribute is especially useful when setting handlers in the <a href="#view-events"><code>events</code></a> and <a href="#view-triggers"><code>triggers</code></a> objects - simply use the <code>@ui.</code> prefix:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#my-template'</span>,
  <span class="hljs-attr">ui</span>: {
    <span class="hljs-attr">save</span>: <span class="hljs-string">'#save-button'</span>,
    <span class="hljs-attr">close</span>: <span class="hljs-string">'.close-button'</span>
  },

  <span class="hljs-attr">events</span>: {
    <span class="hljs-string">'click @ui.save'</span>: <span class="hljs-string">'handleSave'</span>
  },

  <span class="hljs-attr">triggers</span>: {
    <span class="hljs-string">'click @ui.close'</span>: <span class="hljs-string">'close:view'</span>
  },

  <span class="hljs-attr">handleSave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-keyword">this</span>.model.save();
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/f2k0wu05/" target="_blank">Live example</a></p> <p>In this example, when the user clicks on <code>#save-button</code>, <code>handleSave</code> will be called. If the user clicks on <code>.close-button</code>, then the event <code>close:view</code> will be fired on <code>MyView</code>.</p> <p>By prefixing with <code>@ui</code>, we can change the underlying template without having to hunt through our view for every place where that selector is referenced - just update the <code>ui</code> object.</p> <h2 id="events">
Events</h2>
<p>Firing events on views allows you to communicate that something has happened on that view and allowing it to decide whether to act on it or not.</p> <p>During the create/destroy lifecycle for a <code>View</code>, Marionette will call a number of events on the view being created and attached. You can listen to these events and act on them in two ways:</p> <ol> <li>The typical Backbone manner: <code>view.on('render', function() {})</code>
</li> <li>Overriding the onEvent listener methods: <code>onRender: function() {}</code>
</li> </ol> <h3 id="onevent-listeners">
onEvent Listeners</h3>
<p>Marionette creates onEvent listeners for all events fired using <code>view.triggerMethod('event')</code> - if there is an <code>onEvent</code> method, Marionette will call it for you. An example:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">onRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Fired whenever view.triggerMethod('render') is called."</span>);
  },

  <span class="hljs-attr">onOtherEvent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">argument</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Fired other:event with '"</span> + argument + <span class="hljs-string">"' as an argument"</span>);
  }
});

<span class="hljs-keyword">var</span> view = <span class="hljs-keyword">new</span> MyView();

view.triggerMethod(<span class="hljs-string">'other:event'</span>, <span class="hljs-string">'test argument'</span>);
</pre> <p><a href="https://jsfiddle.net/marionettejs/wb95xd3m/" target="_blank">Live example</a></p> <p>This will display in the console: <code>Fired other:event with 'test argument' as an argument</code></p> <p>To set up handlers for events, see the rules in the <a href="../events/#magic-method-binding">Documentation for Events</a>.</p> <h3 id="lifecycle-events">
Lifecycle Events</h3>
<p>When rendering and showing a <code>View</code>, a number of events will be fired to denote certain stages of the creation, or destruction, lifecycle have been reached. For a full list of events, and how to use them, see the <a href="../viewlifecycle/#view-lifecycle">documentation for <code>View</code> lifecycle events</a>.</p> <h3 id="binding-to-user-input">
Binding To User Input</h3>
<p>Views can bind custom events whenever users perform some interaction with the DOM. Using the view <code>events</code> and <code>triggers</code> handlers lets us either bind user input directly to an action or fire a generic trigger that may or may not be handled.</p> <h4>
Event and Trigger Mapping</h4>
<p>The <code>events</code> and <code>triggers</code> attributes bind DOM events to actions to perform on the view. They each take a DOM event key and a mapping to the handler.</p> <p>We'll cover a simple example:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">events</span>: {
    <span class="hljs-string">'click a'</span>: <span class="hljs-string">'showModal'</span>,
    <span class="hljs-string">'click @ui.save'</span>: <span class="hljs-string">'saveForm'</span>
  },

  <span class="hljs-attr">triggers</span>: {
    <span class="hljs-string">'click @ui.close'</span>: <span class="hljs-string">'cancel:entry'</span>
  },

  <span class="hljs-attr">ui</span>: {
    <span class="hljs-attr">save</span>: <span class="hljs-string">'.btn-save'</span>,
    <span class="hljs-attr">close</span>: <span class="hljs-string">'.btn-cancel'</span>
  },

  <span class="hljs-attr">showModal</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Show the modal'</span>);
  },

  <span class="hljs-attr">saveForm</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Save the form'</span>);
  }
});
</pre> <p>Event listeners are constructed by:</p> <pre data-language="javascript"><span class="hljs-string">'&lt;dom event&gt; &lt;dom node&gt;'</span>: <span class="hljs-string">'listener'</span>
</pre> <p>The <code>dom event</code> can be a jQuery DOM event - such as <code>click</code> - or another custom event, such as Bootstrap's <code>show.bs.modal</code>.</p> <p>The <code>dom node</code> represents a jQuery selector or a <code>ui</code> key prefixed by <code>@.</code>. This must exist inside the view once it has completed rendering. For more information about the <code>ui</code> object, and how it works, see <a href="#organizing-your-view">the documentation on ui</a>.</p> <h4>
View <code>events</code>
</h4>
<p>The view <code>events</code> attribute binds DOM events to functions or methods on the view. The simplest form is to reference a method on the view:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">events</span>: {
    <span class="hljs-string">'click a'</span>: <span class="hljs-string">'showModal'</span>
  },

  <span class="hljs-attr">showModal</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Show the modal'</span>);
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/jfxwtmxj/" target="_blank">Live example</a></p> <p>The DOM event gets passed in as the first argument, allowing you to see any information passed as part of the event.</p> <p><strong>When passing a method reference, the method must exist on the View.</strong></p> <p>The <code>events</code> attribute can also directly bind functions:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">events</span>: {
    <span class="hljs-string">'click a'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Show the modal'</span>);
    }
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/obt5vt09/" target="_blank">Live example</a></p> <p>As when passing a string reference to a view method, the <code>events</code> attribute passes in the <code>event</code> as the argument to the function called.</p> <h4>
View <code>triggers</code>
</h4>
<p>The view <code>triggers</code> attribute binds DOM events to Marionette View events that can be responded to at the view or parent level. For more information on events, see the <a href="../events/">events documentation</a>. This section will just cover how to bind these events to views.</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">triggers</span>: {
    <span class="hljs-string">'click a'</span>: <span class="hljs-string">'link:clicked'</span>
  },

  <span class="hljs-attr">onLinkClicked</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view, event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Show the modal'</span>);
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/exu2s3tL/" target="_blank">Live example</a></p> <p>When the <code>a</code> tag is clicked here, the <code>link:click</code> event is fired. This event can be listened to using the <a href="../events/#onevent-binding"><code>onEvent</code> Binding</a> technique discussed in the <a href="../events/">events documentation</a>.</p> <p>The major benefit of the <code>triggers</code> attribute over <code>events</code> is that triggered events can bubble up to any parent views. For a full explanation of bubbling events and listening to child events, see the <a href="../events/#child-view-events">event bubbling documentation</a>.</p> <h4>
View <code>triggers</code> Event Object</h4>
<p>Event handlers will receive the triggering view as the first argument and the DOM Event object as the second. It is <em>strongly recommended</em> that View's handle their own DOM event objects. It should be considered a best practice to not utilize the DOM event in external listeners.</p> <p>By default all trigger events are stopped with <code>preventDefault</code> and <code>stopPropagation</code> methods, but you can manually configure the triggers using a hash instead of event name. The example below triggers an event and prevents default browser behaviour using <code>preventDefault</code> method.</p> <pre data-language="js"><span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">triggers</span>: {
    <span class="hljs-string">'click a'</span>: {
      <span class="hljs-attr">event</span>: <span class="hljs-string">'link:clicked'</span>,
      <span class="hljs-attr">preventDefault</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// this param is optional and will default to true</span>
      stopPropagation: <span class="hljs-literal">false</span>
    }
  }
});
</pre> <p>The default behavior for calling <code>preventDefault</code> can be changed with the feature flag <a href="../marionette.features/#triggerspreventdefault"><code>triggersPreventDefault</code></a>, and <code>stopPropagation</code> can be changed with the feature flag <a href="../marionette.features/#triggersstoppropagation"><code>triggersStopPropagation</code></a>.</p> <h2 id="model-and-collection-events">
Model and Collection events</h2>
<p>The Marionette View can bind to events that occur on attached models and collections - this includes both <a href="http://backbonejs.org/#Events-catalog" target="_blank">standard backbone-events</a> and custom events.</p> <h3 id="model-events">
Model Events</h3>
<p>For example, to listen to a model's events:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">modelEvents</span>: {
    <span class="hljs-string">'change:attribute'</span>: <span class="hljs-string">'actOnChange'</span>
  },

  <span class="hljs-attr">actOnChange</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'New value: '</span> + value);
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/auvk4hps/" target="_blank">Live example</a></p> <p>The <code>modelEvents</code> attribute passes through all the arguments that are passed to <code>model.trigger('event', arguments)</code>.</p> <p>The <code>modelEvents</code> attribute can also take a <a href="../basics/#functions-returning-values">function returning an object</a>.</p> <h4>
Function Callback</h4>
<p>You can also bind a function callback directly in the <code>modelEvents</code> attribute:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">modelEvents</span>: {
    <span class="hljs-string">'change:attribute'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'attribute was changed'</span>);
    }
  }
})
</pre> <p><a href="https://jsfiddle.net/marionettejs/zaxLe6au/" target="_blank">Live example</a></p> <h3 id="collection-events">
Collection Events</h3>
<p>Collection events work exactly the same way as <a href="#model-events"><code>modelEvents</code></a> with their own <code>collectionEvents</code> key:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">collectionEvents</span>: {
    <span class="hljs-attr">sync</span>: <span class="hljs-string">'actOnSync'</span>
  },

  <span class="hljs-attr">actOnSync</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Collection was synchronised with the server'</span>);
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/7qyfeh9r/" target="_blank">Live example</a></p> <p>The <code>collectionEvents</code> attribute can also take a <a href="../basics/#functions-returning-values">function returning an object</a>.</p> <p>Just as in <code>modelEvents</code>, you can bind function callbacks directly inside the <code>collectionEvents</code> object:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">collectionEvents</span>: {
    <span class="hljs-string">'update'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'the collection was updated'</span>);
    }
  }
})
</pre> <p><a href="https://jsfiddle.net/marionettejs/ze8po0x5/" target="_blank">Live example</a></p> <h3 id="listening-to-both">
Listening to Both</h3>
<p>If your view has a <code>model</code> and <code>collection</code> attached, it will listen for events on both:</p> <pre data-language="javascript"><span class="hljs-keyword">var</span> Mn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone.marionette'</span>);

<span class="hljs-keyword">var</span> MyView = Mn.View.extend({
  <span class="hljs-attr">modelEvents</span>: {
    <span class="hljs-string">'change:someattribute'</span>: <span class="hljs-string">'changeMyAttribute'</span>
  },

  <span class="hljs-attr">collectionEvents</span>: {
    <span class="hljs-attr">update</span>: <span class="hljs-string">'modelsChanged'</span>
  },

  <span class="hljs-attr">changeMyAttribute</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'someattribute was changed'</span>);
  },

  <span class="hljs-attr">modelsChanged</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>() </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'models were added or removed in the collection'</span>);
  }
})
</pre> <p><a href="https://jsfiddle.net/marionettejs/h9ub5hp3/" target="_blank">Live example</a></p> <p>In this case, Marionette will bind event handlers to both.</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2017 Muted Solutions, LLC<br>Licensed under the MIT License.<br>
    <a href="https://marionettejs.com/docs/v3.2.0/marionette.view.html" class="_attribution-link" target="_blank">https://marionettejs.com/docs/v3.2.0/marionette.view.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
