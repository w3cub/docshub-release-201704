
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Alternative Method for Log Shipping - PostgreSQL 9.5 - W3cubDocs</title>
  
  <meta name="description" content="An alternative to the built-in standby mode described in the previous sections is to use a restore_command that polls the archive location. This was &hellip;">
  <meta name="keywords" content="alternative, method, for, log, shipping, -, postgresql, postgresql~9.5">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~9.5/log-shipping-alternative/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/postgresql~9.5.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~9.5/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 9.5</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				
<h1 class="SECT1" id="LOG-SHIPPING-ALTERNATIVE">25.4. Alternative Method for Log Shipping</h1> <p>An alternative to the built-in standby mode described in the previous sections is to use a <code class="VARNAME">restore_command</code> that polls the archive location. This was the only option available in versions 8.4 and below. In this setup, set <code class="VARNAME">standby_mode</code> off, because you are implementing the polling required for standby operation yourself. See the <a href="https://www.postgresql.org/docs/9.5/static/pgstandby.html" target="_blank"><span class="APPLICATION">pg_standby</span></a> module for a reference implementation of this.</p> <p>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding the time it takes to fill up the WAL file. <code class="VARNAME">archive_timeout</code> can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</p> <p>The operations that occur on both primary and standby servers are normal continuous archiving and recovery tasks. The only point of contact between the two database servers is the archive of WAL files that both share: primary writing to the archive, standby reading from the archive. Care must be taken to ensure that WAL archives from separate primary servers do not become mixed together or confused. The archive need not be large if it is only required for standby operation.</p> <p>The magic that makes the two loosely coupled servers work together is simply a <code class="VARNAME">restore_command</code> used on the standby that, when asked for the next WAL file, waits for it to become available from the primary. The <code class="VARNAME">restore_command</code> is specified in the <code class="FILENAME">recovery.conf</code> file on the standby server. Normal recovery processing would request a file from the WAL archive, reporting failure if the file was unavailable. For standby processing it is normal for the next WAL file to be unavailable, so the standby must wait for it to appear. For files ending in <code class="LITERAL">.backup</code> or <code class="LITERAL">.history</code> there is no need to wait, and a non-zero return code must be returned. A waiting <code class="VARNAME">restore_command</code> can be written as a custom script that loops after polling for the existence of the next WAL file. There must also be some way to trigger failover, which should interrupt the <code class="VARNAME">restore_command</code>, break the loop and return a file-not-found error to the standby server. This ends recovery and the standby will then come up as a normal server.</p> <p>Pseudocode for a suitable <code class="VARNAME">restore_command</code> is:</p> <pre class="PROGRAMLISTING" data-language="sql">
triggered = false;
while (!NextWALFileReady() &amp;&amp; !triggered)
{
    sleep(100000L);         /* wait for ~0.1 sec */
    if (CheckForExternalTrigger())
        triggered = true;
}
if (!triggered)
        CopyWALFileForRecovery();
</pre> <p>A working example of a waiting <code class="VARNAME">restore_command</code> is provided in the <a href="https://www.postgresql.org/docs/9.5/static/pgstandby.html" target="_blank"><span class="APPLICATION">pg_standby</span></a> module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</p> <p>The method for triggering failover is an important part of planning and design. One potential option is the <code class="VARNAME">restore_command</code> command. It is executed once for each WAL file, but the process running the <code class="VARNAME">restore_command</code> is created and dies for each file, so there is no daemon or server process, and signals or a signal handler cannot be used. Therefore, the <code class="VARNAME">restore_command</code> is not suitable to trigger failover. It is possible to use a simple timeout facility, especially if used in conjunction with a known <code class="VARNAME">archive_timeout</code> setting on the primary. However, this is somewhat error prone since a network problem or busy primary server might be sufficient to initiate failover. A notification mechanism such as the explicit creation of a trigger file is ideal, if this can be arranged.</p> <div class="SECT2"> <h2 class="SECT2" id="WARM-STANDBY-CONFIG">25.4.1. Implementation</h2> <p>The short procedure for configuring a standby server using this alternative method is as follows. For full details of each step, refer to previous sections as noted.</p> <ol type="1"> <li> <p>Set up primary and standby systems as nearly identical as possible, including two identical copies of <span class="PRODUCTNAME">PostgreSQL</span> at the same release level.</p> </li> <li> <p>Set up continuous archiving from the primary to a WAL archive directory on the standby server. Ensure that <a href="../runtime-config-wal/#GUC-ARCHIVE-MODE">archive_mode</a>, <a href="../runtime-config-wal/#GUC-ARCHIVE-COMMAND">archive_command</a> and <a href="../runtime-config-wal/#GUC-ARCHIVE-TIMEOUT">archive_timeout</a> are set appropriately on the primary (see <a href="../continuous-archiving/#BACKUP-ARCHIVING-WAL">Section 24.3.1</a>).</p> </li> <li> <p>Make a base backup of the primary server (see <a href="../continuous-archiving/#BACKUP-BASE-BACKUP">Section 24.3.2</a>), and load this data onto the standby.</p> </li> <li> <p>Begin recovery on the standby server from the local WAL archive, using a <code class="FILENAME">recovery.conf</code> that specifies a <code class="VARNAME">restore_command</code> that waits as described previously (see <a href="../continuous-archiving/#BACKUP-PITR-RECOVERY">Section 24.3.4</a>).</p> </li> </ol> <p>Recovery treats the WAL archive as read-only, so once a WAL file has been copied to the standby system it can be copied to tape at the same time as it is being read by the standby database server. Thus, running a standby server for high availability can be performed at the same time as files are stored for longer term disaster recovery purposes.</p> <p>For testing purposes, it is possible to run both primary and standby servers on the same system. This does not provide any worthwhile improvement in server robustness, nor would it be described as HA.</p> </div> <div class="SECT2"> <h2 class="SECT2" id="WARM-STANDBY-RECORD">25.4.2. Record-based Log Shipping</h2> <p>It is also possible to implement record-based log shipping using this alternative method, though this requires custom development, and changes will still only become visible to hot standby queries after a full WAL file has been shipped.</p> <p>An external program can call the <code class="FUNCTION">pg_xlogfile_name_offset()</code> function (see <a href="../functions-admin/">Section 9.26</a>) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' <code class="VARNAME">restore_command</code> scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies — then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the <code class="VARNAME">restore_command</code> script with the data copying program.</p> <p>Starting with <span class="PRODUCTNAME">PostgreSQL</span> version 9.0, you can use streaming replication (see <a href="../warm-standby/#STREAMING-REPLICATION">Section 25.2.5</a>) to achieve the same benefits with less effort.</p> </div>  <div class="NAVFOOTER">  <table summary="Footer navigation table"> <tr> <td width="33%" align="left"><a href="../warm-standby-failover/" accesskey="P">Prev</a></td> <td width="34%" align="center"></td> <td width="33%" align="right"><a href="../hot-standby/" accesskey="N">Next</a></td> </tr> <tr> <td width="33%" align="left">Failover</td> <td width="34%" align="center"><a href="https://www.postgresql.org/docs/9.5/static/high-availability.html" accesskey="U" target="_blank">Up</a></td> <td width="33%" align="right">Hot Standby</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2017 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/9.5/static/log-shipping-alternative.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/9.5/static/log-shipping-alternative.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
