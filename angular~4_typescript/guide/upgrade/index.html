
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Upgrading From AngularJS - Angular 4 TypeScript - W3cubDocs</title>
  
  <meta name="description" content=" Incrementally upgrade an AngularJS application to Angular. ">
  <meta name="keywords" content="upgrading, from, angularjs, -, angular, typescript, angular~4_typescript">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/angular~4_typescript/guide/upgrade/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/angular~4_typescript.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/angular~4_typescript/" class="_nav-link" title="" style="margin-left:0;">Angular 4 TypeScript</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _angular">
				
<h1 class="hero-title ">Upgrading from AngularJS </h1>

<div class="banner"><p class="text-body">Incrementally upgrade an AngularJS application to Angular.</p></div>
<p><em>Angular</em> is the name for the Angular of today and tomorrow. <em>AngularJS</em> is the name for all v1.x versions of Angular.</p> <p>AngularJS apps are great. Always consider the business case before moving to Angular. An important part of that case is the time and effort to get there. This guide describes the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, a piece at a time.</p> <p>Some applications will be easier to upgrade than others, and there are ways in which we can make it easier for ourselves. It is possible to prepare and align AngularJS applications with Angular even before beginning the upgrade process. These preparation steps are all about making the code more decoupled, more maintainable, and up to speed with modern development tools. That means the preparation work will not only make the eventual upgrade easier, but will also generally improve our AngularJS applications.</p> <p>One of the keys to a successful upgrade is to do it incrementally, by running the two frameworks side by side in the same application, and porting AngularJS components to Angular one by one. This makes it possible to upgrade even large and complex applications without disrupting other business, because the work can be done collaboratively and spread over a period of time. The <code>upgrade</code> module in Angular has been designed to make incremental upgrading seamless.</p> <ol> <li>
<a href="#preparation">Preparation</a><ol> <li><a href="#follow-the-angular-style-guide">Follow the Angular Style Guide</a></li> <li><a href="#using-a-module-loader">Using a Module Loader</a></li> <li><a href="#migrating-to-typescript">Migrating to TypeScript</a></li> <li><a href="#using-component-directives">Using Component Directives</a></li> </ol> </li> <li>
<a href="#upgrading-with-the-upgrade-module">Upgrading with The Upgrade Module</a><ol> <li><a href="#how-the-upgrade-module-works">How The Upgrade Module Works</a></li> <li><a href="#bootstrapping-hybrid-applications">Bootstrapping hybrid</a></li> <li><a href="#using-angular-components-from-angularjs-code">Using Angular Components from AngularJS Code</a></li> <li><a href="#using-angularjs-component-directives-from-angular-code">Using AngularJS Component Directives from Angular Code</a></li> <li><a href="#projecting-angularjs-content-into-angular-components">Projecting AngularJS Content into Angular Components</a></li> <li><a href="#transcluding-angular-content-into-angularjs-component-directives">Transcluding Angular Content into AngularJS Component Directives</a></li> <li><a href="#making-angularjs-dependencies-injectable-to-angular">Making AngularJS Dependencies Injectable to Angular</a></li> <li><a href="#making-angular-dependencies-injectable-to-angularjs">Making Angular Dependencies Injectable to AngularJS</a></li> <li><a href="#using-ahead-of-time-compilation-with-hybrid-apps">Using Ahead-of-time compilation with hybrid apps</a></li> <li><a href="#dividing-routes-between-angular-and-angularjs">Dividing routes between Angular and AngularJS</a></li> </ol> </li> <li>
<a href="#phonecat-upgrade-tutorial">PhoneCat Upgrade Tutorial</a><ol> <li><a href="#switching-to-typescript">Switching to TypeScript</a></li> <li><a href="#installing-angular">Installing Angular</a></li> <li><a href="#bootstrapping-a-hybrid-phonecat">Bootstrapping a hybrid PhoneCat</a></li> <li><a href="#upgrading-the-phone-service">Upgrading the Phone service</a></li> <li><a href="#upgrading-components">Upgrading Components</a></li> <li><a href="#aot-compile-the-hybrid-app">AoT compile the hybrid app</a></li> <li><a href="#adding-the-angular-router-and-bootstrap">Adding The Angular Router And Bootstrap</a></li> <li><a href="#say-goodbye-to-angularjs">Say Goodbye to AngularJS</a></li> </ol> </li> <li><a href="#appendix-upgrading-phonecat-tests">Appendix: Upgrading PhoneCat Tests</a></li> </ol> <h2 id="preparation">Preparation</h2> <p>There are many ways to structure AngularJS applications. When we begin to upgrade these applications to Angular, some will turn out to be much more easy to work with than others. There are a few key techniques and patterns that we can apply to future proof our apps even before we begin the migration.</p> <h3 id="follow-the-angular-style-guide">Follow the Angular Style Guide</h3> <p>The <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility" target="_blank">AngularJS Style Guide</a> collects patterns and practices that have been proven to result in cleaner and more maintainable AngularJS applications. It contains a wealth of information about how to write and organize Angular code - and equally importantly - how <strong>not</strong> to write and organize Angular code.</p> <p>Angular is a reimagined version of the best parts of AngularJS. In that sense, its goals are the same as the Angular Style Guide's: To preserve the good parts of AngularJS, and to avoid the bad parts. There's a lot more to Angular than just that of course, but this does mean that <em>following the style guide helps make your AngularJS app more closely aligned with Angular</em>.</p> <p>There are a few rules in particular that will make it much easier to do <em>an incremental upgrade</em> using the Angular <code>upgrade</code> module:</p> <ul> <li>
<p>The <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility" target="_blank">Rule of 1</a> states that there should be one component per file. This not only makes components easy to navigate and find, but will also allow us to migrate them between languages and frameworks one at a time. In this example application, each controller, component, service, and filter is in its own source file.</p> </li> <li>
<p>The <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure" target="_blank">Folders-by-Feature Structure</a> and <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity" target="_blank">Modularity</a> rules define similar principles on a higher level of abstraction: Different parts of the application should reside in different directories and Angular modules.</p> </li> </ul> <p>When an application is laid out feature per feature in this way, it can also be migrated one feature at a time. For applications that don't already look like this, applying the rules in the Angular style guide is a highly recommended preparation step. And this is not just for the sake of the upgrade - it is just solid advice in general!</p> <h3 id="using-a-module-loader">Using a Module Loader</h3> <p>When we break application code down into one component per file, we often end up with a project structure with a large number of relatively small files. This is a much neater way to organize things than a small number of large files, but it doesn't work that well if you have to load all those files to the HTML page with &lt;script&gt; tags. Especially when you also have to maintain those tags in the correct order. That's why it's a good idea to start using a <em>module loader</em>.</p> <p>Using a module loader such as <a href="https://github.com/systemjs/systemjs" target="_blank">SystemJS</a>, <a href="http://webpack.github.io/" target="_blank">Webpack</a>, or <a href="http://browserify.org/" target="_blank">Browserify</a> allows us to use the built-in module systems of the TypeScript or ES2015 languages in our apps. We can use the <code>import</code> and <code>export</code> features that explicitly specify what code can and will be shared between different parts of the application. For ES5 applications we can use CommonJS style <code>require</code> and <code>module.exports</code> features. In both cases, the module loader will then take care of loading all the code the application needs in the correct order.</p> <p>When we then take our applications into production, module loaders also make it easier to package them all up into production bundles with batteries included.</p> <h3 id="migrating-to-typescript">Migrating to TypeScript</h3> <p>If part of our Angular upgrade plan is to also take TypeScript into use, it makes sense to bring in the TypeScript compiler even before the upgrade itself begins. This means there's one less thing to learn and think about during the actual upgrade. It also means we can start using TypeScript features in our AngularJS code.</p> <p>Since TypeScript is a superset of ECMAScript 2015, which in turn is a superset of ECMAScript 5, "switching" to TypeScript doesn't necessarily require anything more than installing the TypeScript compiler and switching renaming files from <code>*.js</code> to <code>*.ts</code>. But just doing that is not hugely useful or exciting, of course. Additional steps like the following can give us much more bang for the buck:</p> <ul> <li>For applications that use a module loader, TypeScript imports and exports (which are really ECMAScript 2015 imports and exports) can be used to organize code into modules.</li> <li>Type annotations can be gradually added to existing functions and variables to pin down their types and get benefits like build-time error checking, great autocompletion support and inline documentation.</li> <li>JavaScript features new to ES2015, like arrow functions, <code>let</code>s and <code>const</code>s, default function parameters, and destructuring assignments can also be gradually added to make the code more expressive.</li> <li>Services and controllers can be turned into <em>classes</em>. That way they'll be a step closer to becoming Angular service and component classes, which will make our life easier once we do the upgrade.</li> </ul> <h3 id="using-component-directives">Using Component Directives</h3> <p>In Angular, components are the main primitive from which user interfaces are built. We define the different parts of our UIs as components, and then compose the UI by using components in our templates.</p> <p>You can also do this in AngularJS, using <em>component directives</em>. These are directives that define their own templates, controllers, and input/output bindings - the same things that Angular components define. Applications built with component directives are much easier to migrate to Angular than applications built with lower-level features like <code>ng-controller</code>, <code>ng-include</code>, and scope inheritance.</p> <p>To be Angular compatible, an AngularJS component directive should configure these attributes:</p> <ul> <li>
<code>restrict: 'E'</code>. Components are usually used as elements.</li> <li>
<code>scope: {}</code> - an isolate scope. In Angular, components are always isolated from their surroundings, and we should do this in AngularJS too.</li> <li>
<code>bindToController: {}</code>. Component inputs and outputs should be bound to the controller instead of using the <code>$scope</code>.</li> <li>
<code>controller</code> and <code>controllerAs</code>. Components have their own controllers.</li> <li>
<code>template</code> or <code>templateUrl</code>. Components have their own templates.</li> </ul> <p>Component directives may also use the following attributes:</p> <ul> <li>
<code>transclude: true</code>, if the component needs to transclude content from elsewhere.</li> <li>
<code>require</code>, if the component needs to communicate with some parent component's controller.</li> </ul> <p>Component directives <strong>may not</strong> use the following attributes:</p> <ul> <li>
<code>compile</code>. This will not be supported in Angular.</li> <li>
<code>replace: true</code>. Angular never replaces a component element with the component template. This attribute is also deprecated in AngularJS.</li> <li>
<code>priority</code> and <code>terminal</code>. While AngularJS components may use these, they are not used in Angular and it is better not to write code that relies on them.</li> </ul> <p>An AngularJS component directive that is fully aligned with the Angular architecture may look something like this:</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">export function heroDetailDirective() {
  return {
    restrict: 'E',
    scope: {},
    bindToController: {
      hero: '=',
      deleted: '&amp;'
    },
    template: `
      &lt;h2&gt;{{ctrl.hero.name}} details!&lt;/h2&gt;
      &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{ctrl.hero.id}}&lt;/div&gt;
      &lt;button ng-click="ctrl.onDelete()"&gt;Delete&lt;/button&gt;
    `,
    controller: function() {
      this.onDelete = () =&gt; {
        this.deleted({hero: this.hero});
      };
    },
    controllerAs: 'ctrl'
  };
}
</pre></div>
<p>AngularJS 1.5 introduces the <a href="https://docs.angularjs.org/api/ng/type/angular.Module" target="_blank">component API</a> that makes it easier to define directives like these. It is a good idea to use this API for component directives for several reasons:</p> <ul> <li>It requires less boilerplate code.</li> <li>It enforces the use of component best practices like <code>controllerAs</code>.</li> <li>It has good default values for directive attributes like <code>scope</code> and <code>restrict</code>.</li> </ul> <p>The component directive example from above looks like this when expressed using the component API:</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">export const heroDetail = {
  bindings: {
    hero: '&lt;',
    deleted: '&amp;'
  },
  template: `
    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;
    &lt;button ng-click="$ctrl.onDelete()"&gt;Delete&lt;/button&gt;
  `,
  controller: function() {
    this.onDelete = () =&gt; {
      this.deleted(this.hero);
    };
  }
};

import { Directive, ElementRef, Injector, Input, Output, EventEmitter } from '@angular/core';
import { UpgradeComponent } from '@angular/upgrade/static';
import { Hero } from '../hero';

@Directive({
  selector: 'hero-detail'
})
export class HeroDetailDirective extends UpgradeComponent {
  @Input() hero: Hero;
  @Output() deleted: EventEmitter&lt;Hero&gt;;

  constructor(elementRef: ElementRef, injector: Injector) {
    super('heroDetail', elementRef, injector);
  }
}
</pre></div>
<p>Controller lifecycle hook methods <code>$onInit()</code>, <code>$onDestroy()</code>, and <code>$onChanges()</code> are another convenient feature that AngularJS 1.5 introduces. They all have nearly exact <a href="../lifecycle-hooks/">equivalents in Angular</a>, so organizing component lifecycle logic around them will ease the eventual Angular upgrade process.</p> <h2 id="upgrading-with-the-upgrade-module">Upgrading with The Upgrade Module</h2> <p>The <code>upgrade</code> module in Angular is a very useful tool for upgrading anything but the smallest of applications. With it we can mix and match AngularJS and Angular components in the same application and have them interoperate seamlessly. That means we don't have to do the upgrade work all at once, since there's a natural coexistence between the two frameworks during the transition period.</p> <h3 id="how-the-upgrade-module-works">How The Upgrade Module Works</h3> <p>The primary tool provided by the upgrade module is called the <code>UpgradeModule</code>. This is a service that can bootstrap and manage hybrid applications that support both Angular and AngularJS code.</p> <p>When we use <code>UpgradeModule</code>, what we're really doing is <em>running both versions of Angular at the same time</em>. All Angular code is running in the Angular framework, and AngularJS code in the AngularJS framework. Both of these are the actual, fully featured versions of the frameworks. There is no emulation going on, so we can expect to have all the features and natural behavior of both frameworks.</p> <p>What happens on top of this is that components and services managed by one framework can interoperate with those from the other framework. This happens in three main areas: Dependency injection, the DOM, and change detection.</p> <h4 id="dependency-injection">Dependency Injection</h4> <p>Dependency injection is front and center in both AngularJS and Angular, but there are some key differences between the two frameworks in how it actually works.</p> <table>
<tr>
<th>AngularJS</th>
<th>Angular</th>
</tr>
<tr>
<td>
<p>Dependency injection tokens are always strings</p> </td>
<td>
<p>Tokens <a href="../dependency-injection/">can have different types</a>. They are often classes. They may also be strings.</p> </td>
</tr>
<tr>
<td>
<p>There is exactly one injector. Even in multi-module applications, everything is poured into one big namespace.</p> </td>
<td>
<p>There is a <a href="../hierarchical-dependency-injection/">tree hierarchy of injectors</a>, with a root injector and an additional injector for each component.</p> </td>
</tr>
</table>
<p>Even accounting for these differences we can still have dependency injection interoperability. The <code>UpgradeModule</code> resolves the differences and makes everything work seamlessly:</p> <ul> <li>We can make AngularJS services available for injection to Angular code by <em>upgrading</em> them. The same singleton instance of each service is shared between the frameworks. In Angular these services will always be in the <em>root injector</em> and available to all components.</li> <li>We can also make Angular services available for injection to AngularJS code by <em>downgrading</em> them. Only services from the Angular root injector can be downgraded. Again, the same singleton instances are shared between the frameworks. When we register a downgrade, we explicitly specify a <em>string token</em> that we want to use in AngularJS.</li> </ul> <img src="https://angular.io/resources/images/devguide/upgrade/injectors.png" alt="The two injectors in a hybrid application" width="700"><h4 id="components-and-the-dom">Components and the DOM</h4> <p>What we'll find in the DOM of a hybrid application are components and directives from both AngularJS and Angular. These components communicate with each other by using the input and output bindings of their respective frameworks, which the <code>UpgradeModule</code> bridges together. They may also communicate through shared injected dependencies, as described above.</p> <p>There are two key things to understand about what happens in the DOM of a hybrid application:</p> <ol> <li>Every element in the DOM is owned by exactly one of the two frameworks. The other framework ignores it. If an element is owned by AngularJS, Angular treats it as if it didn't exist, and vice versa.</li> <li>The root of the application <em>is always an AngularJS template</em>.</li> </ol> <p>So a hybrid application begins life as an AngularJS application, and it is AngularJS that processes its root template. Angular then steps into the picture when an Angular component is used somewhere in the application templates. That component's view will then be managed by Angular, and it may use any number of Angular components and directives.</p> <p>Beyond that, we may interleave the two frameworks as much as we need to. We always cross the boundary between the two frameworks by one of two ways:</p> <ol> <li>By using a component from the other framework: An AngularJS template using an Angular component, or an Angular template using an AngularJS component.</li> <li>By transcluding or projecting content from the other framework. The <code>UpgradeModule</code> bridges the related concepts of AngularJS transclusion and Angular content projection together.</li> </ol> <img src="https://angular.io/resources/images/devguide/upgrade/dom.png" alt="DOM element ownership in a hybrid application" width="500"><p>Whenever we use a component that belongs to the other framework, a switch between framework boundaries occurs. However, that switch only happens to the <em>children</em> of the component element. Consider a situation where we use an Angular component from AngularJS like this:</p> <pre language="html" escape="html" data-language="html"><a-component></a-component>
</pre>
<p>The DOM element <code>&lt;a-component&gt;</code> will remain to be an AngularJS managed element, because it's defined in an AngularJS template. That also means you can apply additional AngularJS directives to it, but <em>not</em> Angular directives. It is only in the template of the <code>&lt;a-component&gt;</code> where Angular steps in. This same rule also applies when you use AngularJS component directives from Angular.</p> <h4 id="change-detection">Change Detection</h4> <p>Change detection in AngularJS is all about <code>scope.$apply()</code>. After every event that occurs, <code>scope.$apply()</code> gets called. This is done either automatically by the framework, or in some cases manually by our own code. It is the point in time when change detection occurs and data bindings get updated.</p> <p>In Angular things are different. While change detection still occurs after every event, no one needs to call <code>scope.$apply()</code> for that to happen. This is because all Angular code runs inside something called the <a href="../../api/core/index/ngzone-class/">Angular zone</a>. Angular always knows when the code finishes, so it also knows when it should kick off change detection. The code itself doesn't have to call <code>scope.$apply()</code> or anything like it.</p> <p>In the case of hybrid applications, the <code>UpgradeModule</code> bridges the AngularJS and Angular approaches. Here's what happens:</p> <ul> <li>Everything that happens in the application runs inside the Angular zone. This is true whether the event originated in AngularJS or Angular code. The zone triggers Angular change detection after every event.</li> <li>The <code>UpgradeModule</code> will invoke the AngularJS <code>$rootScope.$apply()</code> after every turn of the Angular zone. This also triggers AngularJS change detection after every event.</li> </ul> <img src="https://angular.io/resources/images/devguide/upgrade/change_detection.png" alt="Change detection in a hybrid application" width="600"><p>What this means in practice is that we do not need to call <code>$apply()</code> in our code, regardless of whether it is in AngularJS on Angular. The <code>UpgradeModule</code> does it for us. We <em>can</em> still call <code>$apply()</code> so there is no need to remove such calls from existing code. Those calls just don't have any effect in a hybrid application.</p> <p>When we downgrade an Angular component and then use it from AngularJS, the component's inputs will be watched using AngularJS change detection. When those inputs change, the corresponding properties in the component are set. We can also hook into the changes by implementing the <a href="../../api/core/index/onchanges-class/">OnChanges</a> interface in the component, just like we could if it hadn't been downgraded.</p> <p>Correspondingly, when we upgrade an AngularJS component and use it from Angular, all the bindings defined for the component directive's <code>scope</code> (or <code>bindToController</code>) will be hooked into Angular change detection. They will be treated as regular Angular inputs and set onto the scope (or controller) when they change.</p> <h3 id="using-upgrademodule-with-angular-_ngmodules_">Using UpgradeModule with Angular <em>NgModules</em>
</h3> <p>Both AngularJS and Angular have their own concept of modules to help organize an application into cohesive blocks of functionality.</p> <p>Their details are quite different in architecture and implementation. In AngularJS, you add Angular assets to the <code>angular.module</code> property. In Angular, you create one or more classes adorned with an <code>NgModule</code> decorator that describes Angular assets in metadata. The differences blossom from there.</p> <p>In a hybrid application we run both versions of Angular at the same time. That means that we need at least one module each from both AngularJS and Angular. We will import <code>UpgradeModule</code> inside our Angular module, and then use it for bootstrapping our AngularJS module. Let's see how.</p> <div class="l-sub-section">
<p>Learn more about Angular modules at the <a href="../ngmodule/">NgModule guide</a>.</p> </div>
<h3 id="bootstrapping-hybrid-applications">Bootstrapping hybrid applications</h3> <p>The first step to upgrading an application using the <code>UpgradeModule</code> is always to bootstrap it as a hybrid that supports both AngularJS and Angular, but still is an AngularJS app at top level.</p> <p>Pure AngularJS applications can be bootstrapped in two ways: By using an <code>ng-app</code> directive somewhere on the HTML page, or by calling <a href="https://docs.angularjs.org/api/ng/function/angular.bootstrap" target="_blank">angular.bootstrap</a> from JavaScript. In Angular, only the second method is possible - there is no <code>ng-app</code> in Angular. This is also the case for hybrid applications. Therefore, it is a good preliminary step to switch AngularJS applications to use the JavaScript bootstrap method even before switching them to hybrid mode.</p> <p>Say we have an <code>ng-app</code> driven bootstrap such as this one:</p> <div class="code-example"><pre language="html" format="linenums" data-language="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;base href="/"&gt;
    &lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js"&gt;&lt;/script&gt;
    &lt;script src="app/ajs-ng-app/app.module.js"&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body <span class="otl">ng-app="heroApp" ng-strict-di</span>&gt;
    &lt;div id="message" ng-controller="MainCtrl as mainCtrl"&gt;
      {{ mainCtrl.message }}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre></div>
<p>We can remove the <code>ng-app</code> and <code>ng-strict-di</code> directives from the HTML and instead switch to calling <code>angular.bootstrap</code> from JavaScript, which will result in the same thing:</p> <div class="code-example"><pre language="ts" format="" data-language="typescript">angular.bootstrap(document.body, ['heroApp'], {strictDi: true});
</pre></div>
<p>Now introduce Angular to the project. Inspired by instructions in <a href="../setup/">the Setup</a>, you can selectively copy in material from the <a href="https://github.com/angular/quickstart" target="_blank">QuickStart github repository</a>.</p> <p>Next, create an <code>app.module.ts</code> file and add the following <code>NgModule</code> class:</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { UpgradeModule } from '@angular/upgrade/static';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule
  ]
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre></div>
<p>This bare minimum <code>NgModule</code> imports <code>BrowserModule</code>, the module every Angular browser-based app must have.</p> <p>It also imports <code>UpgradeModule</code> from <code>@angular/upgrade/static</code>, and adds an override to prevent Angular from bootstrapping itself in the form of the <code>ngDoBootstrap</code> empty class method.</p> <p>Now we bootstrap <code>AppModule</code> using <code>platformBrowserDynamic</code>'s <code>bootstrapModule</code> method. Then we use dependency injection to get a hold of the <code>UpgradeModule</code> instance in <code>AppModule</code>, and use it to bootstrap our AngularJS app. The <code>upgrade.bootstrap</code> method takes the exact same arguments as <a href="https://docs.angularjs.org/api/ng/function/angular.bootstrap" target="_blank">angular.bootstrap</a>:</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

platformBrowserDynamic().bootstrapModule(AppModule).then(platformRef =&gt; {
  const upgrade = platformRef.injector.get(UpgradeModule) as UpgradeModule;
  upgrade.bootstrap(document.body, ['heroApp'], {strictDi: true});
});
</pre></div>
<p>We also need to install the <code>@angular/upgrade</code> package via <code>npm install @angular/upgrade --save</code> and add a mapping for the <code>@angular/upgrade/static</code> package: </p> <div class="code-example">
<h4>systemjs.config.js (map)</h4>
<pre language="js" format="" data-language="js">'@angular/upgrade/static': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',
</pre>
</div>
<p>Congratulations! You're running a hybrid application! The existing AngularJS code works as before <em>and</em> you're ready to run Angular code.</p> <h3 id="using-angular-components-from-angularjs-code">Using Angular Components from AngularJS Code</h3> <img src="https://angular.io/resources/images/devguide/upgrade/ajs-to-a.png" alt="Using an Angular component from AngularJS code" align="left" style="width:250px"><p>Once we're running a hybrid app, we can start the gradual process of upgrading code. One of the more common patterns for doing that is to use an Angular component in an AngularJS context. This could be a completely new component or one that was previously AngularJS but has been rewritten for Angular.</p> <p>Say we have a simple Angular component that shows information about a hero:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component } from '@angular/core';

@Component({
  selector: 'hero-detail',
  template: `
    &lt;h2&gt;Windstorm details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;
  `
})
export class HeroDetailComponent { }
</pre>
</div>
<p>If we want to use this component from AngularJS, we need to <em>downgrade</em> it using the <code>downgradeComponent()</code> method. What we get when we do that is an AngularJS <em>directive</em>, which we can then register into our AngularJS module:</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">import { HeroDetailComponent } from './hero-detail.component';

/* . . . */

import { downgradeComponent } from '@angular/upgrade/static';

angular.module('heroApp', [])
  .directive(
    'heroDetail',
    downgradeComponent({component: HeroDetailComponent}) as angular.IDirectiveFactory
  );
</pre></div>
<p>Because <code>HeroDetailComponent</code> is an Angular component, we must also add it to the <code>declarations</code> in the <code>AppModule</code>.</p> <p>And because this component is being used from the AngularJS module, and is an entry point into our Angular application, we also need to add it to the <code>entryComponents</code> for our Angular module.</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">import { HeroDetailComponent } from './hero-detail.component';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule
  ],
  declarations: [
    HeroDetailComponent
  ],
  entryComponents: [
    HeroDetailComponent
  ]
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre></div>
<div class="l-sub-section">
<p>All Angular components, directives and pipes must be declared in an NgModule.</p> </div>
<p>The net result is an AngularJS directive called <code>heroDetail</code>, that we can use like any other directive in our AngularJS templates.</p> <div class="code-example"><pre language="html" format="" data-language="html">&lt;hero-detail&gt;&lt;/hero-detail&gt;
</pre></div>
<div class="alert is-helpful">
<p>Note that this AngularJS is an element directive (<code>restrict: 'E'</code>) called <code>heroDetail</code>. An AngularJS element directive is matched based on its <em>name</em>. <em>The <code>selector</code> metadata of the downgraded Angular component is ignored.</em></p> </div>
<p>Most components are not quite this simple, of course. Many of them have <em>inputs and outputs</em> that connect them to the outside world. An Angular hero detail component with inputs and outputs might look like this:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component, EventEmitter, Input, Output } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'hero-detail',
  template: `
    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
    &lt;button (click)="onDelete()"&gt;Delete&lt;/button&gt;
  `
})
export class HeroDetailComponent {
  @Input() hero: Hero;
  @Output() deleted = new EventEmitter&lt;Hero&gt;();
  onDelete() {
    this.deleted.emit(this.hero);
  }
}
</pre>
</div>
<p>These inputs and outputs can be supplied from the AngularJS template, and the <code>downgradeComponent()</code> method takes care of bridging them over via the <code>inputs</code> and <code>outputs</code> arrays:</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">import { HeroDetailComponent } from './hero-detail.component';

/* . . . */

angular.module('heroApp', [])
  .controller('MainController', MainController)
  .directive('heroDetail', downgradeComponent({
    component: HeroDetailComponent,
    inputs: ['hero'],
    outputs: ['deleted']
  }) as angular.IDirectiveFactory);
</pre></div>
<div class="code-example"><pre language="html" format="linenums" data-language="html">&lt;div ng-controller="MainController as mainCtrl"&gt;
  &lt;hero-detail [hero]="mainCtrl.hero"
               (deleted)="mainCtrl.onDelete($event)"&gt;
  &lt;/hero-detail&gt;
&lt;/div&gt;
</pre></div>
<p>Note that even though we are in an AngularJS template, <strong>we're using Angular attribute syntax to bind the inputs and outputs</strong>. This is a requirement for downgraded components. The expressions themselves are still regular AngularJS expressions.</p> <div class="callout is-important">
<header>Use kebab-case for downgraded component attributes</header><p>There's one notable exception to the rule of using Angular attribute syntax for downgraded components. It has to do with input or output names that consist of multiple words. In Angular we would bind these attributes using camelCase:</p> <pre format="">[myHero]="hero"</pre>
<p>But when using them from AngularJS templates, we need to use kebab-case:</p> <pre format="">[my-hero]="hero"
</pre>
</div>
<p>The <code>$event</code> variable can be used in outputs to gain access to the object that was emitted. In this case it will be the <code>Hero</code> object, because that is what was passed to <code>this.deleted.emit()</code>.</p> <p>Since this is an AngularJS template, we can still use other AngularJS directives on the element, even though it has Angular binding attributes on it. For example, we can easily make multiple copies of the component using <code>ng-repeat</code>:</p> <div class="code-example"><pre language="html" format="linenums" data-language="html">&lt;div ng-controller="MainController as mainCtrl"&gt;
  &lt;hero-detail [hero]="hero"
               (deleted)="mainCtrl.onDelete($event)"
               ng-repeat="hero in mainCtrl.heroes"&gt;
  &lt;/hero-detail&gt;
&lt;/div&gt;
</pre></div>
<h3 id="using-angularjs-component-directives-from-angular-code">Using AngularJS Component Directives from Angular Code</h3> <img src="https://angular.io/resources/images/devguide/upgrade/a-to-ajs.png" alt="Using an AngularJS component from Angular code" align="left" style="width:250px"><p>So, we can write an Angular component and then use it from AngularJS code. This is very useful when we start our migration from lower-level components and work our way up. But in some cases it is more convenient to do things in the opposite order: To start with higher-level components and work our way down. This too can be done using the <code>UpgradeModule</code>. We can <em>upgrade</em> AngularJS component directives and then use them from Angular.</p> <p>Not all kinds of AngularJS directives can be upgraded. The directive really has to be a <em>component directive</em>, with the characteristics <a href="#using-component-directives">described in the preparation guide above</a>. Our safest bet for ensuring compatibility is using the <a href="https://docs.angularjs.org/api/ng/type/angular.Module" target="_blank">component API</a> introduced in AngularJS 1.5.</p> <p>A simple example of an upgradable component is one that just has a template and a controller:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">export const heroDetail = {
  template: `
    &lt;h2&gt;Windstorm details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;
  `,
  controller: function() {
  }
};
</pre>
</div>
<p>We can <em>upgrade</em> this component to Angular using the <code>UpgradeComponent</code> class. By creating a new Angular <strong>directive</strong> that extends <code>UpgradeComponent</code> and doing a <code>super</code> call inside it's constructor, we have a fully upgrade AngularJS component to be used inside Angular. All that is left is to add it to <code>AppModule</code>'s <code>declarations</code> array.</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Directive, ElementRef, Injector } from '@angular/core';
import { UpgradeComponent } from '@angular/upgrade/static';

@Directive({
  selector: 'hero-detail'
})
export class HeroDetailDirective extends UpgradeComponent {
  constructor(elementRef: ElementRef, injector: Injector) {
    super('heroDetail', elementRef, injector);
  }
}
</pre>
</div>
<div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule
  ],
  declarations: [
    HeroDetailDirective,
    /* . . . */
  ]
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<div class="alert is-helpful">
<p>Upgraded components are Angular <strong>directives</strong>, instead of <strong>components</strong>, because Angular is unaware that AngularJS will create elements under it. As far as Angular knows, the upgraded component is just a directive - a tag - and Angular doesn't have to concern itself with it's children. </p> </div>
<p>An upgraded component may also have inputs and outputs, as defined by the scope/controller bindings of the original AngularJS component directive. When we use the component from an Angular template, we provide the inputs and outputs using <strong>Angular template syntax</strong>, with the following rules:</p> <table>
<tr>
<th></th>
<th>Binding definition</th>
<th>Template syntax</th>
</tr>
<tr>
<th>Attribute binding</th>
<td>
<p><code>myAttribute: '@myAttribute'</code></p> </td>
<td>
<p><code>&lt;my-component myAttribute="value"&gt;</code></p> </td>
</tr>
<tr>
<th>Expression binding</th>
<td>
<p><code>myOutput: '&amp;myOutput'</code></p> </td>
<td>
<p><code>&lt;my-component (myOutput)="action()"&gt;</code></p> </td>
</tr>
<tr>
<th>One-way binding</th>
<td>
<p><code>myValue: '&lt;myValue'</code></p> </td>
<td>
<p><code>&lt;my-component [myValue]="anExpression"&gt;</code></p> </td>
</tr>
<tr>
<th>Two-way binding</th>
<td>
<p><code>myValue: '=myValue'</code></p> </td>
<td>
<p>As a two-way binding: <code>&lt;my-component [(myValue)]="anExpression"&gt;</code>. Since most AngularJS two-way bindings actually only need a one-way binding in practice, <code>&lt;my-component [myValue]="anExpression"&gt;</code> is often enough.</p> </td>
</tr>
</table>
<p>As an example, say we have a hero detail AngularJS component directive with one input and one output:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">export const heroDetail = {
  bindings: {
    hero: '&lt;',
    deleted: '&amp;'
  },
  template: `
    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;
    &lt;button ng-click="$ctrl.onDelete()"&gt;Delete&lt;/button&gt;
  `,
  controller: function() {
    this.onDelete = () =&gt; {
      this.deleted(this.hero);
    };
  }
};
</pre>
</div>
<p>We can upgrade this component to Angular, annotate inputs and outputs in the upgrade directive, and then provide the input and output using Angular template syntax:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Directive, ElementRef, Injector, Input, Output, EventEmitter } from '@angular/core';
import { UpgradeComponent } from '@angular/upgrade/static';
import { Hero } from '../hero';

@Directive({
  selector: 'hero-detail'
})
export class HeroDetailDirective extends UpgradeComponent {
  @Input() hero: Hero;
  @Output() deleted: EventEmitter&lt;Hero&gt;;

  constructor(elementRef: ElementRef, injector: Injector) {
    super('heroDetail', elementRef, injector);
  }
}
</pre>
</div>
<div class="code-example">
<h4>container.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'my-container',
  template: `
    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;
    &lt;hero-detail [hero]="hero"
                 (deleted)="heroDeleted($event)"&gt;
    &lt;/hero-detail&gt;
  `
})
export class ContainerComponent {
  hero = new Hero(1, 'Windstorm');
  heroDeleted(hero: Hero) {
    hero.name = 'Ex-' + hero.name;
  }
}
</pre>
</div>
<h3 id="projecting-angularjs-content-into-angular-components">Projecting AngularJS Content into Angular Components</h3> <img src="https://angular.io/resources/images/devguide/upgrade/ajs-to-a-with-projection.png" alt="Projecting AngularJS content into Angular" align="left" style="width:250px"><p>When we are using a downgraded Angular component from an AngularJS template, the need may arise to <em>transclude</em> some content into it. This is also possible. While there is no such thing as transclusion in Angular, there is a very similar concept called <em>content projection</em>. The <code>UpgradeModule</code> is able to make these two features interoperate.</p> <p>Angular components that support content projection make use of an <code>&lt;ng-content&gt;</code> tag within them. Here's an example of such a component:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component, Input } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'hero-detail',
  template: `
    &lt;h2&gt;{{hero.name}}&lt;/h2&gt;
    &lt;div&gt;
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/div&gt;
  `
})
export class HeroDetailComponent {
  @Input() hero: Hero;
}
</pre>
</div>
<p>When using the component from AngularJS, we can supply contents for it. Just like they would be transcluded in AngularJS, they get projected to the location of the <code>&lt;ng-content&gt;</code> tag in Angular:</p> <div class="code-example"><pre language="html" format="linenums" data-language="html">&lt;div ng-controller="MainController as mainCtrl"&gt;
  &lt;hero-detail [hero]="mainCtrl.hero"&gt;
    &lt;!-- Everything here will get projected --&gt;
    &lt;p&gt;{{mainCtrl.hero.description}}&lt;/p&gt;
  &lt;/hero-detail&gt;
&lt;/div&gt;
</pre></div>
<div class="alert is-helpful">
<p>When AngularJS content gets projected inside an Angular component, it still remains in "AngularJS land" and is managed by the AngularJS framework.</p> </div>
<h3 id="transcluding-angular-content-into-angularjs-component-directives">Transcluding Angular Content into AngularJS Component Directives</h3> <img src="https://angular.io/resources/images/devguide/upgrade/a-to-ajs-with-transclusion.png" alt="Projecting Angular content into AngularJS" align="left" style="width:250px"><p>Just like we can project AngularJS content into Angular components, we can <em>transclude</em> Angular content into AngularJS components, whenever we are using upgraded versions from them.</p> <p>When an AngularJS component directive supports transclusion, it may use the <code>ng-transclude</code> directive in its template to mark the transclusion point:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">export const heroDetail = {
  bindings: {
    hero: '='
  },
  template: `
    &lt;h2&gt;{{$ctrl.hero.name}}&lt;/h2&gt;
    &lt;div&gt;
      &lt;ng-transclude&gt;&lt;/ng-transclude&gt;
    &lt;/div&gt;
  `
};
</pre>
</div>
<div class="alert is-helpful">
<p>The directive also needs to have the <code>transclude: true</code> option enabled. It is on by default for component directives defined with the 1.5 component API.</p> </div>
<p>If we upgrade this component and use it from Angular, we can populate the component tag with contents that will then get transcluded:</p> <div class="code-example">
<h4>container.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component } from '@angular/core';
import { Hero } from '../hero';

@Component({
  selector: 'my-container',
  template: `
    &lt;hero-detail [hero]="hero"&gt;
      &lt;!-- Everything here will get transcluded --&gt;
      &lt;p&gt;{{hero.description}}&lt;/p&gt;
    &lt;/hero-detail&gt;
  `
})
export class ContainerComponent {
  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');
}
</pre>
</div>
<h3 id="making-angularjs-dependencies-injectable-to-angular">Making AngularJS Dependencies Injectable to Angular</h3> <p>When running a hybrid app, we may bump into situations where we need to have some AngularJS dependencies to be injected to Angular code. This may be because we have some business logic still in AngularJS services, or because we need some of AngularJS's built-in services like <code>$location</code> or <code>$timeout</code>.</p> <p>In these situations, it is possible to <em>upgrade</em> an AngularJS provider to Angular. This makes it possible to then inject it somewhere in Angular code. For example, we might have a service called <code>HeroesService</code> in AngularJS:</p> <div class="code-example">
<h4>heroes.service.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Hero } from '../hero';

export class HeroesService {
  get() {
    return [
      new Hero(1, 'Windstorm'),
      new Hero(2, 'Spiderman')
    ];
  }
}
</pre>
</div>
<p>We can upgrade the service using a Angular <a href="../dependency-injection/#factory-providers">Factory provider</a> that requests the service from the AngularJS <code>$injector</code>. </p> <p>We recommend declaring the Factory Provider in a separate <code>ajs-upgraded-providers.ts</code> file so that they are all together, making it easier to reference them, create new ones and delete them once the upgrade is over. </p> <p>It's also recommended to export the <code>heroesServiceFactory</code> function so that Ahead-of-Time compilation can pick it up. </p> <div class="code-example">
<h4>ajs-upgraded-providers.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { HeroesService } from './heroes.service';

export function heroesServiceFactory(i: any) {
  return i.get('heroes');
}

export const heroesServiceProvider = {
  provide: HeroesService,
  useFactory: heroesServiceFactory,
  deps: ['$injector']
};
</pre>
</div>
<div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { heroesServiceProvider } from './ajs-upgraded-providers';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule
  ],
  providers: [
    heroesServiceProvider
  ],
  /* . . . */
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<p>We can then inject it in Angular using it's class as a type annotation:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component } from '@angular/core';
import { HeroesService } from './heroes.service';
import { Hero } from '../hero';

@Component({
  selector: 'hero-detail',
  template: `
    &lt;h2&gt;{{hero.id}}: {{hero.name}}&lt;/h2&gt;
  `
})
export class HeroDetailComponent {
  hero: Hero;
  constructor(heroes: HeroesService) {
    this.hero = heroes.get()[0];
  }
}
</pre>
</div>
<div class="alert is-helpful">
<p>In this example we upgraded a service class, which has the added benefit that we can use a TypeScript type annotation when we inject it. While it doesn't affect how the dependency is handled, it enables the benefits of static type checking. This is not required though, and any AngularJS service, factory, or provider can be upgraded.</p> </div>
<h3 id="making-angular-dependencies-injectable-to-angularjs">Making Angular Dependencies Injectable to AngularJS</h3> <p>In addition to upgrading AngularJS dependencies, we can also <em>downgrade</em> Angular dependencies, so that we can use them from AngularJS. This can be useful when we start migrating services to Angular or creating new services in Angular while we still have components written in AngularJS.</p> <p>For example, we might have an Angular service called <code>Heroes</code>:</p> <div class="code-example">
<h4>heroes.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Injectable } from '@angular/core';
import { Hero } from '../hero';

@Injectable()
export class Heroes {
  get() {
    return [
      new Hero(1, 'Windstorm'),
      new Hero(2, 'Spiderman')
    ];
  }
}
</pre>
</div>
<p>Again, as with Angular components, register the provider with the <code>NgModule</code> by adding it to the module's <code>providers</code> list.</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Heroes } from './heroes';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule
  ],
  providers: [ Heroes ]
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<p>Now wrap the Angular <code>Heroes</code> in an <em>AngularJS factory function</em> using <code>downgradeInjectable()</code>. and plug the factory into an AngularJS module. The name of the AngularJS dependency is up to you:</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { downgradeInjectable } from '@angular/upgrade/static';

angular.module('heroApp', [])
  .factory('heroes', downgradeInjectable(Heroes))
  .component('heroDetail', heroDetailComponent);
</pre>
</div>
<p>After this, the service is injectable anywhere in our AngularJS code:</p> <div class="code-example">
<h4>hero-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">export const heroDetailComponent = {
  template: `
    &lt;h2&gt;{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&lt;/h2&gt;
  `,
  controller: ['heroes', function(heroes: Heroes) {
    this.hero = heroes.get()[0];
  }]
};
</pre>
</div>
<h2 id="using-ahead-of-time-compilation-with-hybrid-apps">Using Ahead-of-time compilation with hybrid apps</h2> <p>We can take advantage of Ahead-of-time (AoT) compilation on hybrid apps just like on any other Angular application. The setup for an hybrid app is mostly the same as described in <a href="../../cookbook/aot-compiler/">the Ahead-of-time Compilation chapter</a> save for differences in <code>index.html</code> and <code>main-aot.ts</code></p> <p>Our <code>index.html</code> will likely have script tags loading AngularJS files, so the <code>index.html</code> we use for AoT must also load those files. An easy way to copy them is by adding each to the <code>copy-dist-files.js</code> file.</p> <p>We also need to use <code>UpgradeModule</code> to bootstrap a hybrid app after bootstrapping the Module Factory:</p> <div class="code-example">
<h4>app/main-aot.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { platformBrowser } from '@angular/platform-browser';
import { UpgradeModule } from '@angular/upgrade/static';

import { AppModuleNgFactory } from '../aot/app/app.module.ngfactory';

platformBrowser().bootstrapModuleFactory(AppModuleNgFactory).then(platformRef =&gt; {
  const upgrade = platformRef.injector.get(UpgradeModule) as UpgradeModule;
  upgrade.bootstrap(document.documentElement, ['phonecatApp']);
});
</pre>
</div>
<p>And that's all we need to get the full benefit of AoT for Angular apps!</p> <div class="alert is-helpful">
<p>The AoT metadata collector will not detect lifecycle hook methods on a parent class' prototype, so in order for upgraded components to work we needs to implement the lifecycle hooks on the upgraded component class and forward them to the <code>UpgradeComponent</code> parent. </p> </div>
<h2 id="dividing-routes-between-angular-and-angularjs">Dividing routes between Angular and AngularJS</h2> <p>Another important part of upgrading is upgrading routes. We could upgrade our whole app while still using the AngularJS router and then migrate all the routes in one fell swoop. But it would be much better to migrate routes one by one as they become upgraded.</p> <p>The first step to have a dual router setup is to add an Angular root component containing one outlet for each router. AngularJS will use <code>ng-view</code>, and Angular will use <code>router-outlet</code>. When one is using it's router, the other outlet will be empty. </p> <div class="code-example">
<h4>app.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component } from '@angular/core';

@Component({
  selector: 'my-app',
  template: `
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
    &lt;div ng-view&gt;&lt;/div&gt;
  `,
})
export class AppComponent { }
</pre>
</div>
<p>We want to use this component in the body of our <code>index.html</code> instead of an AngularJS component: </p> <div class="code-example">
<h4>app.component.ts (body)</h4>
<pre language="html" format="linenums" data-language="html">&lt;body&gt;
  &lt;my-app&gt;Loading...&lt;/my-app&gt;
&lt;/body&gt;
</pre>
</div>
<p>Next we declare both AngularJS and Angular routes as normal:</p> <div class="code-example">
<h4>app.module.ts (AngularJS route)</h4>
<pre language="ts" format="linenums" data-language="typescript">$routeProvider
  .when('/villain', { template: '&lt;villain-detail&gt;&lt;/villain-detail&gt;' });
</pre>
</div>
<div class="code-example">
<h4>hero.module.ts (Angular route)</h4>
<pre language="ts" format="linenums" data-language="typescript">RouterModule.forChild([
  { path: 'hero', children: [
    { path: '', component: HeroDetailComponent },
  ] },
])
</pre>
</div>
<p>In our <code>app.module.ts</code> we need to add <code>AppComponent</code> to the declarations and boostrap array.</p> <p>Next we configure the router itself. We want to use <a href="../router/#-hashlocationstrategy-">hash navigation</a> in Angular because that's what we're also using in AngularJS. </p> <p>Lastly, and most importantly, we want to use a custom <code>UrlHandlingStrategy</code> that will tell the Angular router which routes it should render - and only those.</p> <div class="code-example">
<h4>app.module.ts (router config)</h4>
<pre language="ts" format="linenums" data-language="typescript">import { HashLocationStrategy, LocationStrategy } from '@angular/common';
import { RouterModule, UrlHandlingStrategy, UrlTree } from '@angular/router';
import { AppComponent } from './app.component';

class HybridUrlHandlingStrategy implements UrlHandlingStrategy {
  // use only process the `/hero` url
  shouldProcessUrl(url: UrlTree) { return url.toString().startsWith('/hero'); }
  extract(url: UrlTree) { return url; }
  merge(url: UrlTree, whole: UrlTree) { return url; }
}

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
    HeroModule,
    RouterModule.forRoot([])
  ],
  providers: [
    // use hash location strategy
    { provide: LocationStrategy, useClass: HashLocationStrategy },
    // use custom url handling strategy
    { provide: UrlHandlingStrategy, useClass: HybridUrlHandlingStrategy }
  ],
  declarations: [ AppComponent ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</pre>
</div>
<p>That's it! Now we're running both routers at the same time.</p> <h2 id="phonecat-upgrade-tutorial">PhoneCat Upgrade Tutorial</h2> <p>In this section and we will look at a complete example of preparing and upgrading an application using the <code>upgrade</code> module. The app we're going to work on is <a href="https://github.com/angular/angular-phonecat" target="_blank">Angular PhoneCat</a> from <a href="https://docs.angularjs.org/tutorial" target="_blank">the original AngularJS tutorial</a>, which is where many of us began our Angular adventures. Now we'll see how to bring that application to the brave new world of Angular.</p> <p>During the process we'll learn how to apply the steps outlined in the <a href="#preparation">preparation guide</a> in practice: We'll align the application with Angular and also take TypeScript into use.</p> <p>To follow along with the tutorial, clone the <a href="https://github.com/angular/angular-phonecat" target="_blank">angular-phonecat</a> repository and apply the steps as we go.</p> <p>In terms of project structure, this is where our work begins:</p> <div class="filetree">
<div class="file">angular-phonecat</div>
<div class="children">
<div class="file">bower.json</div>
<div class="file">karma.conf.js</div>
<div class="file">package.json</div>
<div class="file">app</div>
<div class="children">
<div class="file">core</div>
<div class="children">
<div class="file">checkmark</div>
<div class="children">
<div class="file">checkmark.filter.js</div>
<div class="file">checkmark.filter.spec.js</div>
</div>
<div class="file">phone</div>
<div class="children">
<div class="file">phone.module.js</div>
<div class="file">phone.service.js</div>
<div class="file">phone.service.spec.js</div>
</div>
<div class="file">core.module.js</div>
</div>
<div class="file">phone-detail</div>
<div class="children">
<div class="file">phone-detail.component.js</div>
<div class="file">phone-detail.component.spec.js</div>
<div class="file">phone-detail.module.js</div>
<div class="file">phone-detail.template.html</div>
</div>
<div class="file">phone-list</div>
<div class="children">
<div class="file">phone-list.component.js</div>
<div class="file">phone-list.component.spec.js</div>
<div class="file">phone-list.module.js</div>
<div class="file">phone-list.template.html</div>
</div>
<div class="file">img</div>
<div class="children"><div class="file"> ...</div></div>
<div class="file">phones</div>
<div class="children"><div class="file"> ...</div></div>
<div class="file">app.animations.js</div>
<div class="file">app.config.js</div>
<div class="file">app.css</div>
<div class="file">app.module.js</div>
<div class="file">index.html</div>
</div>
<div class="file">e2e-tests</div>
<div class="children">
<div class="file">protractor-conf.js</div>
<div class="file">scenarios.js</div>
</div>
</div>
</div>
<p>This is actually a pretty good starting point. The code uses the AngularJS 1.5 component API and the organization follows the <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md" target="_blank">AngularJS Style Guide</a>, which is an important <a href="#following-the-angular-style-guide">preparation step</a> before a successful upgrade.</p> <ul> <li>Each component, service, and filter is in its own source file, as per the <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility" target="_blank">Rule of 1</a>.</li> <li>The <code>core</code>, <code>phone-detail</code>, and <code>phone-list</code> modules are each in their own subdirectory. Those subdirectories contain the JavaScript code as well as the HTML templates that go with each particular feature. This is in line with the <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#style-y152" target="_blank">Folders-by-Feature Structure</a> and <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity" target="_blank">Modularity</a> rules.</li> <li>Unit tests are located side-by-side with application code where they are easily found, as described in the rules for <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#style-y197" target="_blank">Organizing Tests</a>.</li> </ul> <h3 id="switching-to-typescript">Switching to TypeScript</h3> <p>Since we're going to be writing our Angular code in TypeScript, it makes sense to bring in the TypeScript compiler even before we begin upgrading.</p> <p>We will also start to gradually phase out the Bower package manager in favor of NPM. We'll install all new dependencies using NPM, and will eventually be able to remove Bower from the project.</p> <p>Let's begin by installing TypeScript to the project.</p> <pre format="">npm i typescript --save-dev
</pre>
<p>Let's also add run scripts for the <code>tsc</code> TypeScript compiler to <code>package.json</code>:</p> <div class="code-example">
<h4>package.json</h4>
<pre language="json" format="linenums" data-language="json">{
  "scripts": {}
}</pre>
</div>
<p>We can now install type definitions for the existing libraries that we're using but that don't come with prepackaged types: AngularJS and the Jasmine unit test framework.</p> <pre format="">npm install @types/jasmine @types/angular  @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev
</pre>
<p>We should also configure the TypeScript compiler so that it can understand our project. We'll add a <code>tsconfig.json</code> file to the project directory, just like we do in the documentation <a href="../setup/">setup</a>. It instructs the TypeScript compiler how to interpret our source files.</p> <div class="code-example">
<h4>tsconfig.json</h4>
<pre language="json" format="linenums" data-language="json">{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "moduleResolution": "node",
    "sourceMap": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "removeComments": false,
    "noImplicitAny": false,
    "suppressImplicitAnyIndexErrors": true
  }
}
</pre>
</div>
<p>We are telling the TypeScript compiler to turn our TypeScript files to ES5 code bundled into CommonJS modules.</p> <p>We can now launch the TypeScript compiler from the command line. It will watch our <code>.ts</code> source files and compile them to JavaScript on the fly. Those compiled <code>.js</code> files are then loaded into the browser by SystemJS. This is a process we'll want to have continuously running in the background as we go along.</p> <pre format="">npm run tsc:w
</pre>
<p>The next thing we'll do is convert our JavaScript files to TypeScript. Since TypeScript is a superset of ECMAScript 2015, which in turn is a superset of ECMAScript 5, we can simply switch the file extensions from <code>.js</code> to <code>.ts</code> and everything will work just like it did before. As the TypeScript compiler runs, it emits the corresponding <code>.js</code> file for every <code>.ts</code> file and the compiled JavaScript is what actually gets executed. If you start the project HTTP server with <code>npm start</code>, you should see the fully functional application in your browser.</p> <p>Now that we have TypeScript though, we can start benefiting from some of its features. There's a lot of value the language can provide to AngularJS applications.</p> <p>For one thing, TypeScript is a superset of ES2015. Any app that has previously been written in ES5 - like the PhoneCat example has - can with TypeScript start incorporating all of the JavaScript features that are new to ES2015. These include things like <code>let</code>s and <code>const</code>s, arrow functions, default function parameters, and destructuring assignments.</p> <p>Another thing we can do is start adding <em>type safety</em> to our code. This has actually partially already happened because of the AngularJS typings we installed. TypeScript are checking that we are calling AngularJS APIs correctly when we do things like register components to Angular modules.</p> <p>But we can also start adding <em>type annotations</em> for our own code to get even more out of TypeScript's type system. For instance, we can annotate the checkmark filter so that it explicitly expects booleans as arguments. This makes it clearer what the filter is supposed to do.</p> <div class="code-example">
<h4>app/core/checkmark/checkmark.filter.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">angular.
  module('core').
  filter('checkmark', function() {
    return function(input: boolean) {
      return input ? '\u2713' : '\u2718';
    };
  });
</pre>
</div>
<p>In the <code>Phone</code> service we can explicitly annotate the <code>$resource</code> service dependency as an <code>angular.resource.IResourceService</code> - a type defined by the AngularJS typings.</p> <div class="code-example">
<h4>app/core/phone/phone.service.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">angular.
  module('core.phone').
  factory('Phone', ['$resource',
    function($resource: angular.resource.IResourceService) {
      return $resource('phones/:phoneId.json', {}, {
        query: {
          method: 'GET',
          params: {phoneId: 'phones'},
          isArray: true
        }
      });
    }
  ]);
</pre>
</div>
<p>We can apply the same trick to the application's route configuration file in <code>app.config.ts</code>, where we are using the location and route services. By annotating them accordingly TypeScript can verify we're calling their APIs with the correct kinds of arguments.</p> <div class="code-example">
<h4>app/app.config.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">angular.
  module('phonecatApp').
  config(['$locationProvider', '$routeProvider',
    function config($locationProvider: angular.ILocationProvider,
                    $routeProvider: angular.route.IRouteProvider) {
      $locationProvider.hashPrefix('!');

      $routeProvider.
        when('/phones', {
          template: '&lt;phone-list&gt;&lt;/phone-list&gt;'
        }).
        when('/phones/:phoneId', {
          template: '&lt;phone-detail&gt;&lt;/phone-detail&gt;'
        }).
        otherwise('/phones');
    }
  ]);
</pre>
</div>
<div class="l-sub-section">
<p>The <a href="https://www.npmjs.com/package/@types/angular" target="_blank">AngularJS 1.x type definitions</a> we installed are not officially maintained by the Angular team, but are quite comprehensive. It is possible to make an AngularJS 1.x application fully type-annotated with the help of these definitions.</p> <p>If this is something we wanted to do, it would be a good idea to enable the <code>noImplicitAny</code> configuration option in <code>tsconfig.json</code>. This would cause the TypeScript compiler to display a warning when there's any code that does not yet have type annotations. We could use it as a guide to inform us about how close we are to having a fully annotated project.</p> </div>
<p>Another TypeScript feature we can make use of is <em>classes</em>. In particular, we can turn our component controllers into classes. That way they'll be a step closer to becoming Angular component classes, which will make our life easier once we do the upgrade.</p> <p>AngularJS expects controllers to be constructor functions. That's exactly what ES2015/TypeScript classes are under the hood, so that means we can just plug in a class as a component controller and AngularJS will happily use it.</p> <p>Here's what our new class for the phone list component controller looks like:</p> <div class="code-example">
<h4>app/phone-list/phone-list.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">class PhoneListController {
  phones: any[];
  orderProp: string;
  query: string;

  static $inject = ['Phone'];
  constructor(Phone: any) {
    this.phones = Phone.query();
    this.orderProp = 'age';
  }

}

angular.
  module('phoneList').
  component('phoneList', {
    templateUrl: 'phone-list/phone-list.template.html',
    controller: PhoneListController
  });
</pre>
</div>
<p>What was previously done in the controller function is now done in the class constructor function. The dependency injection annotations are attached to the class using a static property <code>$inject</code>. At runtime this becomes the <code>PhoneListController.$inject</code> property.</p> <p>The class additionally declares three members: The array of phones, the name of the current sort key, and the search query. These are all things we have already been attaching to the controller but that weren't explicitly declared anywhere. The last one of these isn't actually used in the TypeScript code since it's only referred to in the template, but for the sake of clarity we want to define all the members our controller will have.</p> <p>In the Phone detail controller we'll have two members: One for the phone that the user is looking at and another for the URL of the currently displayed image:</p> <div class="code-example">
<h4>app/phone-detail/phone-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">class PhoneDetailController {
  phone: any;
  mainImageUrl: string;

  static $inject = ['$routeParams', 'Phone'];
  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {
    let phoneId = $routeParams['phoneId'];
    this.phone = Phone.get({phoneId}, (phone: any) =&gt; {
      this.setImage(phone.images[0]);
    });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}

angular.
  module('phoneDetail').
  component('phoneDetail', {
    templateUrl: 'phone-detail/phone-detail.template.html',
    controller: PhoneDetailController
  });
</pre>
</div>
<p>This makes our controller code look a lot more like Angular already. We're all set to actually introduce Angular into the project.</p> <p>If we had any AngularJS services in the project, those would also be a good candidate for converting to classes, since like controllers, they're also constructor functions. But we only have the <code>Phone</code> factory in this project, and that's a bit special since it's an <code>ngResource</code> factory. So we won't be doing anything to it in the preparation stage. We'll instead turn it directly into an Angular service.</p> <h3 id="installing-angular">Installing Angular</h3> <p>Having completed our preparation work, let's get going with the Angular upgrade of PhoneCat. We'll do this incrementally with the help of the <a href="#upgrading-with-the-upgrade-module">upgrade module</a> that comes with Angular. By the time we're done, we'll be able to remove AngularJS from the project completely, but the key is to do this piece by piece without breaking the application.</p> <div class="alert is-important">The project also contains some animations, which we are not yet upgrading in this version of the guide. This will change in a later release.</div>
<p>Let's install Angular into the project, along with the SystemJS module loader. Take a look at the results of the <a href="../setup/">Setup</a> instructions and get the following configurations from there:</p> <ul> <li>Add Angular and the other new dependencies to <code>package.json</code>
</li> <li>The SystemJS configuration file <code>systemjs.config.js</code> to the project root directory.</li> </ul> <p>Once these are done, run:</p> <pre format="">npm install
</pre>
<p>We can soon load Angular dependencies into the application via <code>index.html</code>, but first we need to do some directory path adjustments. This is because we're going to need to load files from <code>node_modules</code> and the project root, whereas so far in this project everything has been loaded from the <code>/app</code> directory.</p> <p>Move the <code>app/index.html</code> file to the project root directory. Then change the development server root path in <code>package.json</code> to also point to the project root instead of <code>app</code>:</p> <div class="code-example">
<h4>package.json (start script)</h4>
<pre language="json" format="linenums" data-language="json">{
  "scripts": {
    "start": "http-server -a localhost -p 8000 -c-1 ./"
  }
}</pre>
</div>
<p>Now we're able to serve everything from the project root to the web browser. But we do <em>not</em> want to have to change all the image and data paths used in the application code to match our development setup. For that reason, we'll add a <code>&lt;base&gt;</code> tag to <code>index.html</code>, which will cause relative URLs to be resolved back to the <code>/app</code> directory:</p> <div class="code-example">
<h4>index.html</h4>
<pre language="html" format="" data-language="html">&lt;base href="/app/"&gt;
</pre>
</div>
<p>Now we can load Angular via SystemJS. We'll add the Angular polyfills and the SystemJS config to the end of the <code>&lt;head&gt;</code> section, and then we'll use <code>System.import</code> to load the actual application:</p> <div class="code-example">
<h4>index.html</h4>
<pre language="html" format="linenums" data-language="html">&lt;script src="/node_modules/core-js/client/shim.min.js"&gt;&lt;/script&gt;
&lt;script src="/node_modules/zone.js/dist/zone.js"&gt;&lt;/script&gt;
&lt;script src="/node_modules/systemjs/dist/system.src.js"&gt;&lt;/script&gt;
&lt;script src="/systemjs.config.js"&gt;&lt;/script&gt;
&lt;script&gt;
  System.import('/app');
&lt;/script&gt;
</pre>
</div>
<p>We also need to make a couple of adjustments to the <code>systemjs.config.js</code> file installed during <a href="../setup/">setup</a>. </p> <p>We want to point the browser to the project root when loading things through SystemJS, instead of using the <code>&lt;base&gt;</code> URL.</p> <p>We also need to install the <code>upgrade</code> package via <code>npm install @angular/upgrade --save</code> and add a mapping for the <code>@angular/upgrade/static</code> package. </p> <div class="code-example">
<h4>systemjs.config.js</h4>
<pre language="js" format="linenums" data-language="js">System.config({
  paths: {
    // paths serve as alias
    'npm:': '/node_modules/'
  },
  map: {
    app: '/app',
    /* . . . */
    '@angular/upgrade/static': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',
    /* . . . */
  },
</pre>
</div>
<h3 id="creating-the-_appmodule_">Creating the <em>AppModule</em>
</h3> <p>Now create the root <code>NgModule</code> class called <code>AppModule</code>. There is already a file named <code>app.module.ts</code> that holds the AngularJS module. Rename it to <code>app.module.ajs.ts</code> and update the corresponding script name in the <code>index.html</code> as well. The file contents remain:</p> <div class="code-example">
<h4>app.module.ajs.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">'use strict';

// Define the `phonecatApp` AngularJS module
angular.module('phonecatApp', [
  'ngAnimate',
  'ngRoute',
  'core',
  'phoneDetail',
  'phoneList',
]);
</pre>
</div>
<p>Now create a new <code>app.module.ts</code> with the minimum <code>NgModule</code> class:</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

@NgModule({
  imports: [
    BrowserModule,
  ],
})
export class AppModule {
}
</pre>
</div>
<h3 id="bootstrapping-a-hybrid-phonecat">Bootstrapping a hybrid PhoneCat</h3> <p>What we'll do next is bootstrap the application as a <em>hybrid application</em> that supports both AngularJS and Angular components. Once we've done that we can start converting the individual pieces to Angular.</p> <p>To <a href="#bootstrapping-hybrid-applications">bootstrap a hybrid application</a>, we first need to import <code>UpgradeModule</code> in our <code>AppModule</code>, and override it's bootstrap method:</p> <div class="code-example">
<h4>app/app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { UpgradeModule } from '@angular/upgrade/static';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
  ],
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<p>Our application is currently bootstrapped using the AngularJS <code>ng-app</code> directive attached to the <code>&lt;html&gt;</code> element of the host page. This will no longer work with Angular. We should switch to a JavaScript-driven bootstrap instead. </p> <p>So, remove the <code>ng-app</code> attribute from <code>index.html</code>, and instead bootstrap via <code>src/main.ts</code>. This file has been configured as the application entrypoint in <code>systemjs.config.js</code>, so it is already being loaded by the browser.</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { UpgradeModule } from '@angular/upgrade/static';

import { AppModule } from './app.module';

platformBrowserDynamic().bootstrapModule(AppModule).then(platformRef =&gt; {
  const upgrade = platformRef.injector.get(UpgradeModule) as UpgradeModule;
  upgrade.bootstrap(document.documentElement, ['phonecatApp']);
});
</pre></div>
<p>The arguments used here are the root element of the application (which is the same element we had <code>ng-app</code> on earlier), and the AngularJS 1.x modules that we want to load. Since we're bootstrapping the app through an <code>UpgradeModule</code>, we're actually now running the app as a <strong>hybrid app</strong>.</p> <p>This means we are now running both AngularJS and Angular at the same time. That's pretty exciting! We're not running any actual Angular components yet though, so let's do that next.</p> <div class="l-sub-section">
<h4 id="why-declare-_angular_-as-_angular-iangularstatic_-">Why declare <em>angular</em> as <em>angular.IAngularStatic</em>?</h4> <p><code>@types/angular</code> is declared as a UMD module, and due to the way <a href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions" target="_blank">UMD typings</a> work, once you have an ES6 <code>import</code> statement in a file all UMD typed modules must also be imported via <code>import</code> statements instead of being globally available.</p> <p>AngularJS is currently loaded by a script tag in <code>index.html</code>, which means that the whole app has access to it as a global and uses the same instance of the <code>angular</code> variable. If we used <code>import * as angular from 'angular'</code> instead we would also need to overhaul how we load every file in our AngularJS app to use ES6 modules in order to ensure AngularJS was being loaded correctly.</p> <p>This is a considerable effort and it often isn't worth it, especially since we are in the process of moving our our to Angular already. Instead we declare <code>angular</code> as <code>angular.IAngularStatic</code> to indicate it is a global variable and still have full typing support.</p> </div>
<h3 id="upgrading-the-phone-service">Upgrading the Phone service</h3> <p>The first piece we'll port over to Angular is the <code>Phone</code> service, which resides in <code>app/core/phone/phone.service.ts</code> and makes it possible for components to load phone information from the server. Right now it's implemented with ngResource and we're using it for two things:</p> <ul> <li>For loading the list of all phones into the phone list component</li> <li>For loading the details of a single phone into the phone detail component.</li> </ul> <p>We can replace this implementation with an Angular service class, while keeping our controllers in AngularJS land. </p> <p>In the new version, we import the Angular HTTP module and call its <code>Http</code> service instead of <code>ngResource</code>.</p> <p>Re-open the <code>app.module.ts</code> file, import and add <code>HttpModule</code> to the <code>imports</code> array of the <code>AppModule</code>:</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { HttpModule } from '@angular/http';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
    HttpModule,
  ],
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<p>Now we're ready to upgrade the Phone service itself. We replace the ngResource-based service in <code>phone.service.ts</code> with a TypeScript class decorated as <code>@Injectable</code>:</p> <div class="code-example">
<h4>app/core/phone/phone.service.ts (skeleton)</h4>
<pre language="ts" format="" data-language="typescript">@Injectable()
export class Phone {
/* . . . */
}
</pre>
</div>
<p>The <code>@Injectable</code> decorator will attach some dependency injection metadata to the class, letting Angular know about its dependencies. As described by our <a href="../dependency-injection/">Dependency Injection Guide</a>, this is a marker decorator we need to use for classes that have no other Angular decorators but still need to have their dependencies injected.</p> <p>In its constructor the class expects to get the <code>Http</code> service. It will be injected to it and it is stored as a private field. The service is then used in the two instance methods, one of which loads the list of all phones, and the other the details of a particular phone:</p> <div class="code-example"><pre language="ts" format="linenums" data-language="typescript">@Injectable()
export class Phone {
  constructor(private http: Http) { }
  query(): Observable&lt;PhoneData[]&gt; {
    return this.http.get(`phones/phones.json`)
      .map((res: Response) =&gt; res.json());
  }
  get(id: string): Observable&lt;PhoneData&gt; {
    return this.http.get(`phones/${id}.json`)
      .map((res: Response) =&gt; res.json());
  }
}
</pre></div>
<p>The methods now return Observables of type <code>PhoneData</code> and <code>PhoneData[]</code>. This is a type we don't have yet, so let's add a simple interface for it:</p> <div class="code-example">
<h4>app/core/phone/phone.service.ts (interface)</h4>
<pre language="ts" format="" data-language="typescript">export interface PhoneData {
  name: string;
  snippet: string;
  images: string[];
}
</pre>
</div>
<p><code>@angular/upgrade/static</code> has a <code>downgradeInjectable</code> method for the purpose of making Angular services available to AngularJS code. Use it to plug in the <code>Phone</code> service:</p> <div class="code-example">
<h4>app/core/phone/phone.service.ts (downgrade)</h4>
<pre language="ts" format="" data-language="typescript">declare var angular: angular.IAngularStatic;
import { downgradeInjectable } from '@angular/upgrade/static';
/* . . . */
@Injectable()
export class Phone {
/* . . . */
}

angular.module('core.phone')
  .factory('phone', downgradeInjectable(Phone));
</pre>
</div>
<p>Here's the full, final code for the service:</p> <div class="code-example">
<h4>app/core/phone/phone.service.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Injectable } from '@angular/core';
import { Http, Response } from '@angular/http';
import { Observable } from 'rxjs/Rx';

declare var angular: angular.IAngularStatic;
import { downgradeInjectable } from '@angular/upgrade/static';

import 'rxjs/add/operator/map';

export interface PhoneData {
  name: string;
  snippet: string;
  images: string[];
}

@Injectable()
export class Phone {
  constructor(private http: Http) { }
  query(): Observable&lt;PhoneData[]&gt; {
    return this.http.get(`phones/phones.json`)
      .map((res: Response) =&gt; res.json());
  }
  get(id: string): Observable&lt;PhoneData&gt; {
    return this.http.get(`phones/${id}.json`)
      .map((res: Response) =&gt; res.json());
  }
}

angular.module('core.phone')
  .factory('phone', downgradeInjectable(Phone));
</pre>
</div>
<p>Notice that we're importing the <code>map</code> operator of the RxJS <code>Observable</code> separately. We need to do this for all RxJS operators that we want to use, since Angular does not load all of them by default.</p> <p>The new <code>Phone</code> service has the same features as the original, <code>ngResource</code>-based service. Because it's an Angular service, we register it with the <code>NgModule</code> providers:</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Phone } from './core/phone/phone.service';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
    HttpModule,
  ],
  providers: [
    Phone,
  ]
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<p>Now that we are loading <code>phone.service.ts</code> through an import that is resolved by SystemJS, we should <strong>remove the &lt;script&gt; tag</strong> for the service from <code>index.html</code>. This is something we'll do to all our components as we upgrade them. Simultaneously with the AngularJS to Angular upgrade we're also migrating our code from scripts to modules.</p> <p>At this point we can switch our two components to use the new service instead of the old one. We <code>$inject</code> it as the downgraded <code>phone</code> factory, but it's really an instance of the <code>Phone</code> class and we can annotate its type accordingly:</p> <div class="code-example">
<h4>app/phone-list/phone-list.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">declare var angular: angular.IAngularStatic;
import { Phone, PhoneData } from '../core/phone/phone.service';

class PhoneListController {
  phones: PhoneData[];
  orderProp: string;

  static $inject = ['phone'];
  constructor(phone: Phone) {
    phone.query().subscribe(phones =&gt; {
      this.phones = phones;
    });
    this.orderProp = 'age';
  }

}

angular.
  module('phoneList').
  component('phoneList', {
    templateUrl: 'app/phone-list/phone-list.template.html',
    controller: PhoneListController
  });
</pre>
</div>
<div class="code-example">
<h4>app/phone-detail/phone-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">declare var angular: angular.IAngularStatic;
import { Phone, PhoneData } from '../core/phone/phone.service';

class PhoneDetailController {
  phone: PhoneData;
  mainImageUrl: string;

  static $inject = ['$routeParams', 'phone'];
  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {
    let phoneId = $routeParams['phoneId'];
    phone.get(phoneId).subscribe(data =&gt; {
      this.phone = data;
      this.setImage(data.images[0]);
    });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}

angular.
  module('phoneDetail').
  component('phoneDetail', {
    templateUrl: 'phone-detail/phone-detail.template.html',
    controller: PhoneDetailController
  });
</pre>
</div>
<p>What we have here are two AngularJS components using an Angular service! The components don't need to be aware of this, though the fact that the service returns Observables and not Promises is a bit of a giveaway. In any case, what we've achieved is a migration of a service to Angular without having to yet migrate the components that use it.</p> <div class="alert is-helpful">
<p>We could also use the <code>toPromise</code> method of <code>Observable</code> to turn those Observables into Promises in the service. This can in many cases further reduce the amount of changes needed in the component controllers.</p> </div>
<h3 id="upgrading-components">Upgrading Components</h3> <p>Next, let's upgrade our AngularJS components to Angular components. We'll do it one at a time, while still keeping the application in hybrid mode. As we make these conversions, we'll also be defining our first Angular <em>pipes</em>.</p> <p>Let's look at the phone list component first. Right now it contains a TypeScript controller class and a component definition object. We can morph this into an Angular component by just renaming the controller class and turning the AngularJS component definition object into an Angular <code>@Component</code> decorator. We can then also remove the static <code>$inject</code> property from the class:</p> <div class="code-example">
<h4>app/phone-list/phone-list.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component } from '@angular/core';
import { Phone, PhoneData } from '../core/phone/phone.service';

@Component({
  selector: 'phone-list',
  templateUrl: 'phone-list.template.html'
})
export class PhoneListComponent {
  phones: PhoneData[];
  query: string;
  orderProp: string;

  constructor(phone: Phone) {
    phone.query().subscribe(phones =&gt; {
      this.phones = phones;
    });
    this.orderProp = 'age';
  }
  /* . . . */
}
</pre>
</div>
<p>The <code>selector</code> attribute is a CSS selector that defines where on the page the component should go. In AngularJS we do matching based on component names, but in Angular we have these explicit selectors. This one will match elements with the name <code>phone-list</code>, just like the AngularJS version did.</p> <p>We now also need to convert the template of this component into Angular syntax. The search controls replace the AngularJS <code>$ctrl</code> expressions with Angular's two-way <code>[(ngModel)]</code> binding syntax:</p> <div class="code-example">
<h4>app/phone-list/phone-list.template.html (search controls)</h4>
<pre language="html" format="" data-language="html">&lt;p&gt;
  Search:
  &lt;input [(ngModel)]="query" /&gt;
&lt;/p&gt;

&lt;p&gt;
  Sort by:
  &lt;select [(ngModel)]="orderProp"&gt;
    &lt;option value="name"&gt;Alphabetical&lt;/option&gt;
    &lt;option value="age"&gt;Newest&lt;/option&gt;
  &lt;/select&gt;
&lt;/p&gt;
</pre>
</div>
<p>Replace the list's <code>ng-repeat</code> with an <code>*ngFor</code> as <a href="../template-syntax/#directives">described in the Template Syntax page</a>. Replace the image tag's <code>ng-src</code> with a binding to the native <code>src</code> property.</p> <div class="code-example">
<h4>app/phone-list/phone-list.template.html (phones)</h4>
<pre language="html" format="" data-language="html">&lt;ul class="phones"&gt;
  &lt;li *ngFor="let phone of getPhones()"
      class="thumbnail phone-list-item"&gt;
    &lt;a href="/#!/phones/{{phone.id}}" class="thumb"&gt;
      &lt;img [src]="phone.imageUrl" [alt]="phone.name" /&gt;
    &lt;/a&gt;
    &lt;a href="/#!/phones/{{phone.id}}" class="name"&gt;{{phone.name}}&lt;/a&gt;
    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</pre>
</div>
<h4 id="no-angular-_filter_-or-_orderby_-filters">No Angular <em>filter</em> or <em>orderBy</em> filters</h4> <p>The built-in AngularJS <code>filter</code> and <code>orderBy</code> filters do not exist in Angular, so we need to do the filtering and sorting ourselves. </p> <p>We replaced the <code>filter</code> and <code>orderBy</code> filters with bindings to the <code>getPhones()</code> controller method, which implements the filtering and ordering logic inside the component itself. </p> <div class="code-example">
<h4>app/phone-list/phone-list.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">getPhones(): PhoneData[] {
  return this.sortPhones(this.filterPhones(this.phones));
}

private filterPhones(phones: PhoneData[]) {
  if (phones &amp;&amp; this.query) {
    return phones.filter(phone =&gt; {
      let name = phone.name.toLowerCase();
      let snippet = phone.snippet.toLowerCase();
      return name.indexOf(this.query) &gt;= 0 || snippet.indexOf(this.query) &gt;= 0;
    });
  }
  return phones;
}

private sortPhones(phones: PhoneData[]) {
  if (phones &amp;&amp; this.orderProp) {
    return phones
      .slice(0) // Make a copy
      .sort((a, b) =&gt; {
        if (a[this.orderProp] &lt; b[this.orderProp]) {
          return -1;
        } else if ([b[this.orderProp] &lt; a[this.orderProp]]) {
          return 1;
        } else {
          return 0;
        }
      });
  }
  return phones;
}
</pre>
</div>
<p>Now we need to downgrade our Angular component so we can use it in AngularJS. Instead of registering a component, we register a <code>phoneList</code> <em>directive</em>, a downgraded version of the Angular component.</p> <p>The <code>as angular.IDirectiveFactory</code> cast tells the TypeScript compiler that the return value of the <code>downgradeComponent</code> method is a directive factory.</p> <div class="code-example">
<h4>app/phone-list/phone-list.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">declare var angular: angular.IAngularStatic;
import { downgradeComponent } from '@angular/upgrade/static';

/* . . . */
@Component({
  selector: 'phone-list',
  templateUrl: 'phone-list.template.html'
})
export class PhoneListComponent {
/* . . . */
}

angular.module('phoneList')
  .directive(
    'phoneList',
    downgradeComponent({component: PhoneListComponent}) as angular.IDirectiveFactory
  );
</pre>
</div>
<p>The new <code>PhoneListComponent</code> uses the Angular <code>ngModel</code> directive, located in the <code>FormsModule</code>. Add the <code>FormsModule</code> to <code>NgModule</code> imports, declare the new <code>PhoneListComponent</code> and finally add it to <code>entryComponents</code> since we downgraded it:</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { FormsModule } from '@angular/forms';
import { PhoneListComponent } from './phone-list/phone-list.component';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
    HttpModule,
    FormsModule,
  ],
  declarations: [
    PhoneListComponent,
  ],
  entryComponents: [
    PhoneListComponent,
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<p>Remove the &lt;script&gt; tag for the phone list component from <code>index.html</code>.</p> <p>Now set the remaining <code>phone-detail.component.ts</code> as follows:</p> <div class="code-example">
<h4>app/phone-detail/phone-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">declare var angular: angular.IAngularStatic;
import { downgradeComponent } from '@angular/upgrade/static';

import { Component } from '@angular/core';

import { Phone, PhoneData } from '../core/phone/phone.service';
import { RouteParams } from '../ajs-upgraded-providers';

@Component({
  selector: 'phone-detail',
  templateUrl: './phone-detail.template.html',
})
export class PhoneDetailComponent {
  phone: PhoneData;
  mainImageUrl: string;

  constructor(routeParams: RouteParams, phone: Phone) {
    phone.get(routeParams['phoneId']).subscribe(phone =&gt; {
      this.phone = phone;
      this.setImage(phone.images[0]);
    });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}

angular.module('phoneDetail')
  .directive(
    'phoneDetail',
    downgradeComponent({component: PhoneDetailComponent}) as angular.IDirectiveFactory
  );
</pre>
</div>
<p>This is similar to the phone list component. The new wrinkle is the <code>RouteParams</code> type annotation that identifies the <code>routeParams</code> dependency. </p> <p>The AngularJS injector has an AngularJS router dependency called <code>$routeParams</code>, which was injected into <code>PhoneDetails</code> when it was still an AngularJS controller. We intend to inject it into the new <code>PhoneDetailsComponent</code>.</p> <p>Unfortunately, AngularJS dependencies are not automatically available to Angular components. We must use a <a href="#making-angularjs-dependencies-injectable-to-angular">Factory provider</a> to make <code>$routeParams</code> an Angular provider. Do that in a new file called <code>ajs-upgraded-providers.ts</code> and import it in <code>app.module.ts</code>:</p> <div class="code-example">
<h4>app/ajs-upgraded-providers.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">export abstract class RouteParams {
  [key: string]: string;
}

export function routeParamsFactory(i: any) {
  return i.get('$routeParams');
}

export const routeParamsProvider = {
  provide: RouteParams,
  useFactory: routeParamsFactory,
  deps: ['$injector']
};
</pre>
</div>
<div class="code-example">
<h4>app/app.module.ts ($routeParams)</h4>
<pre language="ts" format="" data-language="typescript">import { routeParamsProvider } from './ajs-upgraded-providers';
  providers: [
    Phone,
    routeParamsProvider
  ]
</pre>
</div>
<p>Convert the phone detail component template into Angular syntax as follows:</p> <div class="code-example">
<h4>app/phone-detail/phone-detail.template.html</h4>
<pre language="html" format="linenums" data-language="html">&lt;div *ngIf="phone"&gt;
  &lt;div class="phone-images"&gt;
    &lt;img [src]="img" class="phone"
        [ngClass]="{selected: img === mainImageUrl}"
        *ngFor="let img of phone.images" /&gt;
  &lt;/div&gt;

  &lt;h1&gt;{{phone.name}}&lt;/h1&gt;

  &lt;p&gt;{{phone.description}}&lt;/p&gt;

  &lt;ul class="phone-thumbs"&gt;
    &lt;li *ngFor="let img of phone.images"&gt;
      &lt;img [src]="img" (click)="setImage(img)" /&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;ul class="specs"&gt;
    &lt;li&gt;
      &lt;span&gt;Availability and Networks&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Availability&lt;/dt&gt;
        &lt;dd *ngFor="let availability of phone.availability"&gt;{{availability}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Battery&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Type&lt;/dt&gt;
        &lt;dd&gt;{{phone.battery?.type}}&lt;/dd&gt;
        &lt;dt&gt;Talk Time&lt;/dt&gt;
        &lt;dd&gt;{{phone.battery?.talkTime}}&lt;/dd&gt;
        &lt;dt&gt;Standby time (max)&lt;/dt&gt;
        &lt;dd&gt;{{phone.battery?.standbyTime}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Storage and Memory&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;RAM&lt;/dt&gt;
        &lt;dd&gt;{{phone.storage?.ram}}&lt;/dd&gt;
        &lt;dt&gt;Internal Storage&lt;/dt&gt;
        &lt;dd&gt;{{phone.storage?.flash}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Connectivity&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Network Support&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.cell}}&lt;/dd&gt;
        &lt;dt&gt;WiFi&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.wifi}}&lt;/dd&gt;
        &lt;dt&gt;Bluetooth&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.bluetooth}}&lt;/dd&gt;
        &lt;dt&gt;Infrared&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.infrared | checkmark}}&lt;/dd&gt;
        &lt;dt&gt;GPS&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.gps | checkmark}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Android&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;OS Version&lt;/dt&gt;
        &lt;dd&gt;{{phone.android?.os}}&lt;/dd&gt;
        &lt;dt&gt;UI&lt;/dt&gt;
        &lt;dd&gt;{{phone.android?.ui}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Size and Weight&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Dimensions&lt;/dt&gt;
        &lt;dd *ngFor="let dim of phone.sizeAndWeight?.dimensions"&gt;{{dim}}&lt;/dd&gt;
        &lt;dt&gt;Weight&lt;/dt&gt;
        &lt;dd&gt;{{phone.sizeAndWeight?.weight}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Display&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Screen size&lt;/dt&gt;
        &lt;dd&gt;{{phone.display?.screenSize}}&lt;/dd&gt;
        &lt;dt&gt;Screen resolution&lt;/dt&gt;
        &lt;dd&gt;{{phone.display?.screenResolution}}&lt;/dd&gt;
        &lt;dt&gt;Touch screen&lt;/dt&gt;
        &lt;dd&gt;{{phone.display?.touchScreen | checkmark}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Hardware&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;CPU&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.cpu}}&lt;/dd&gt;
        &lt;dt&gt;USB&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.usb}}&lt;/dd&gt;
        &lt;dt&gt;Audio / headphone jack&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.audioJack}}&lt;/dd&gt;
        &lt;dt&gt;FM Radio&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.fmRadio | checkmark}}&lt;/dd&gt;
        &lt;dt&gt;Accelerometer&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.accelerometer | checkmark}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Camera&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Primary&lt;/dt&gt;
        &lt;dd&gt;{{phone.camera?.primary}}&lt;/dd&gt;
        &lt;dt&gt;Features&lt;/dt&gt;
        &lt;dd&gt;{{phone.camera?.features?.join(', ')}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Additional Features&lt;/span&gt;
      &lt;dd&gt;{{phone.additionalFeatures}}&lt;/dd&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</pre>
</div>
<p>There are several notable changes here:</p> <ul> <li>We've removed the <code>$ctrl.</code> prefix from all expressions.</li> <li>Just like we did in the phone list, we've replaced <code>ng-src</code> with property bindings for the standard <code>src</code> property.</li> <li>We're using the property binding syntax around <code>ng-class</code>. Though Angular does have <a href="../template-syntax/#directives">a very similar <code>ngClass</code></a> as AngularJS does, its value is not magically evaluated as an expression. In Angular we always specify in the template when an attribute's value is a property expression, as opposed to a literal string.</li> <li>We've replaced <code>ng-repeat</code>s with <code>*ngFor</code>s.</li> <li>We've replaced <code>ng-click</code> with an event binding for the standard <code>click</code>.</li> <li>We've wrapped the whole template in an <code>ngIf</code> that causes it only to be rendered when there is a phone present. We need this because when the component first loads, we don't have <code>phone</code> yet and the expressions will refer to a non-existing value. Unlike in AngularJS, Angular expressions do not fail silently when we try to refer to properties on undefined objects. We need to be explicit about cases where this is expected.</li> </ul> <p>Add <code>PhoneDetailComponent</code> component to the <code>NgModule</code> <em>declarations</em> and <em>entryComponents</em>:</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { PhoneDetailComponent } from './phone-detail/phone-detail.component';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
    HttpModule,
    FormsModule,
  ],
  declarations: [
    PhoneListComponent,
    PhoneDetailComponent,
  ],
  entryComponents: [
    PhoneListComponent,
    PhoneDetailComponent
  ],
  providers: [
    Phone,
    routeParamsProvider
  ]
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<p>We should now also remove the phone detail component &lt;script&gt; tag from <code>index.html</code>.</p> <h4 id="add-the-_checkmarkpipe_">Add the <em>CheckmarkPipe</em>
</h4> <p>The AngularJS directive had a <code>checkmark</code> <em>filter</em>. Let's turn that into an Angular <strong>pipe</strong>.</p> <p>There is no upgrade method to convert filters into pipes. You won't miss it. It's easy to turn the filter function into an equivalent Pipe class. The implementation is the same as before, repackaged in the <code>transform</code> method. Rename the file to <code>checkmark.pipe.ts</code> to conform with Angular conventions:</p> <div class="code-example">
<h4>app/core/checkmark/checkmark.pipe.ts</h4>
<pre language="ts" format="" data-language="typescript">import { Pipe, PipeTransform } from '@angular/core';

@Pipe({name: 'checkmark'})
export class CheckmarkPipe implements PipeTransform {
  transform(input: boolean) {
    return input ? '\u2713' : '\u2718';
  }
}
</pre>
</div>
<p>Now import and declare the newly created pipe and remove the filter &lt;script&gt; tag from <code>index.html</code>:</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { CheckmarkPipe } from './core/checkmark/checkmark.pipe';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
    HttpModule,
    FormsModule,
  ],
  declarations: [
    PhoneListComponent,
    PhoneDetailComponent,
    CheckmarkPipe
  ],
  entryComponents: [
    PhoneListComponent,
    PhoneDetailComponent
  ],
  providers: [
    Phone,
    routeParamsProvider
  ]
})
export class AppModule {
  ngDoBootstrap() {}
}
</pre>
</div>
<h2 id="aot-compile-the-hybrid-app">AoT compile the hybrid app</h2> <p>To use AoT with our hybrid app we have to first set it up like any other Angular application, as shown in <a href="../../cookbook/aot-compiler/">the Ahead-of-time Compilation chapter</a>.</p> <p>Then we have to change <code>main-aot.ts</code> bootstrap also bootstrap the AngularJS app via <code>UpgradeModule</code>:</p> <div class="code-example">
<h4>app/main-aot.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { platformBrowser } from '@angular/platform-browser';
import { UpgradeModule } from '@angular/upgrade/static';

import { AppModuleNgFactory } from '../aot/app/app.module.ngfactory';

platformBrowser().bootstrapModuleFactory(AppModuleNgFactory).then(platformRef =&gt; {
  const upgrade = platformRef.injector.get(UpgradeModule) as UpgradeModule;
  upgrade.bootstrap(document.documentElement, ['phonecatApp']);
});
</pre>
</div>
<p>We need to load all the AngularJS files we already use in <code>index.html</code> in <code>aot/index.html</code> as well:</p> <div class="code-example">
<h4>aot/index.html</h4>
<pre language="html" format="linenums" data-language="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;

    &lt;base href="/app/"&gt;

    &lt;title&gt;Google Phone Gallery&lt;/title&gt;
    &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" /&gt;
    &lt;link rel="stylesheet" href="app.css" /&gt;
    &lt;link rel="stylesheet" href="app.animations.css" /&gt;

    &lt;script src="https://code.jquery.com/jquery-2.2.4.js"&gt;&lt;/script&gt;
    &lt;script src="https://code.angularjs.org/1.5.5/angular.js"&gt;&lt;/script&gt;
    &lt;script src="https://code.angularjs.org/1.5.5/angular-animate.js"&gt;&lt;/script&gt;
    &lt;script src="https://code.angularjs.org/1.5.5/angular-resource.js"&gt;&lt;/script&gt;
    &lt;script src="https://code.angularjs.org/1.5.5/angular-route.js"&gt;&lt;/script&gt;

    &lt;script src="app.module.ajs.js"&gt;&lt;/script&gt;
    &lt;script src="app.config.js"&gt;&lt;/script&gt;
    &lt;script src="app.animations.js"&gt;&lt;/script&gt;
    &lt;script src="core/core.module.js"&gt;&lt;/script&gt;
    &lt;script src="core/phone/phone.module.js"&gt;&lt;/script&gt;
    &lt;script src="phone-list/phone-list.module.js"&gt;&lt;/script&gt;
    &lt;script src="phone-detail/phone-detail.module.js"&gt;&lt;/script&gt;

    &lt;script src="/node_modules/core-js/client/shim.min.js"&gt;&lt;/script&gt;
    &lt;script src="/node_modules/zone.js/dist/zone.min.js"&gt;&lt;/script&gt;

    &lt;script&gt;window.module = 'aot';&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class="view-container"&gt;
      &lt;div ng-view class="view-frame"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
  &lt;script src="/dist/build.js"&gt;&lt;/script&gt;
&lt;/html&gt;
</pre>
</div>
<p>These files need to be copied together with the polyfills. Files our application needs at runtime, like the <code>.json</code> phone lists and images, also need to be copied.</p> <p>Install <code>fs-extra</code> via <code>npm install fs-extra --save-dev</code> for better file copying, and change <code>copy-dist-files.js</code> to the following:</p> <div class="code-example">
<h4>copy-dist-files.js</h4>
<pre language="js" format="linenums" data-language="js">var fsExtra = require('fs-extra');
var resources = [
  // polyfills
  'node_modules/core-js/client/shim.min.js',
  'node_modules/zone.js/dist/zone.min.js',
  // css
  'app/app.css',
  'app/app.animations.css',
  // images and json files
  'app/img/',
  'app/phones/',
  // app files
  'app/app.module.ajs.js',
  'app/app.config.js',
  'app/app.animations.js',
  'app/core/core.module.js',
  'app/core/phone/phone.module.js',
  'app/phone-list/phone-list.module.js',
  'app/phone-detail/phone-detail.module.js'
];
resources.map(function(sourcePath) {
  var destPath = `aot/${sourcePath}`;
  fsExtra.copySync(sourcePath, destPath);
});
</pre>
</div>
<p>And that's all you need to use AoT while upgrading your app!</p> <h3 id="adding-the-angular-router-and-bootstrap">Adding The Angular Router And Bootstrap</h3> <p>At this point we've replaced all AngularJS application components with their Angular counterparts, even though we're still serving them from the AngularJS router.</p> <p>Most AngularJS apps have more than a couple of routes though, and it's very helpful to migrate one route at a time.</p> <p>Let's start by migrating the initial <code>/</code> and <code>/phones</code> routes to Angular, while keeping <code>/phones/:phoneId</code> in the AngularJS router.</p> <h4 id="add-the-angular-router">Add the Angular router</h4> <p>Angular has an <a href="../router/">all-new router</a>.</p> <p>Like all routers, it needs a place in the UI to display routed views. For Angular that's the <code>&lt;router-outlet&gt;</code> and it belongs in a <em>root component</em> at the top of the applications component tree. </p> <p>We don't yet have such a root component, because the app is still managed as an AngularJS app. Create a new <code>app.component.ts</code> file with the following <code>AppComponent</code> class:</p> <div class="code-example">
<h4>app/app.component.ts</h4>
<pre language="ts" format="" data-language="typescript">import { Component } from '@angular/core';

@Component({
  selector: 'phonecat-app',
  template: `
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
    &lt;div class="view-container"&gt;
      &lt;div ng-view class="view-frame"&gt;&lt;/div&gt;
    &lt;/div&gt;
  `
})
export class AppComponent { }
</pre>
</div>
<p>It has a simple template that only includes the <code>&lt;router-outlet&gt;</code> for Angular routes and <code>ng-view</code> for AngularJS routes. This component just renders the contents of the active route and nothing else.</p> <p>The selector tells Angular to plug this root component into the <code>&lt;phonecat-app&gt;</code> element on the host web page when the application launches.</p> <p>Add this <code>&lt;phonecat-app&gt;</code> element to the <code>index.html</code>. It replaces the old AngularJS <code>ng-view</code> directive:</p> <div class="code-example">
<h4>index.html (body)</h4>
<pre language="html" format="" data-language="html">&lt;body&gt;
  &lt;phonecat-app&gt;&lt;/phonecat-app&gt;
&lt;/body&gt;
</pre>
</div>
<h4 id="create-the-_routing-module_">Create the <em>Routing Module</em>
</h4> <p>A router needs configuration whether it's the AngularJS or Angular or any other router.</p> <p>The details of Angular router configuration are best left to the <a href="../router/">Routing documentation</a> which recommends that you create a <code>NgModule</code> dedicated to router configuration (called a <em>Routing Module</em>).</p> <div class="code-example">
<h4>app/app-routing.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { NgModule } from '@angular/core';
import { Routes, RouterModule, UrlHandlingStrategy, UrlTree } from '@angular/router';
import { APP_BASE_HREF, HashLocationStrategy, LocationStrategy } from '@angular/common';

import { PhoneListComponent }   from './phone-list/phone-list.component';

export class Ng1Ng2UrlHandlingStrategy implements UrlHandlingStrategy {
  shouldProcessUrl(url: UrlTree) {
    return url.toString() === '/' || url.toString() === '/phones';
  }
  extract(url: UrlTree) { return url; }
  merge(url: UrlTree, whole: UrlTree) { return url; }
}

const routes: Routes = [
  { path: '', redirectTo: 'phones', pathMatch: 'full' },
  { path: 'phones', component: PhoneListComponent }
];

@NgModule({
  imports: [ RouterModule.forRoot(routes) ],
  exports: [ RouterModule ],
  providers: [
    { provide: APP_BASE_HREF, useValue: '!' },
    { provide: LocationStrategy, useClass: HashLocationStrategy },
    { provide: UrlHandlingStrategy, useClass: Ng1Ng2UrlHandlingStrategy }
  ]
})
export class AppRoutingModule { }
</pre>
</div>
<p>This module defines a <code>routes</code> object with one route to the phone list component and a default route for the empty path. It passes the <code>routes</code> to the <code>RouterModule.forRoot</code> method which does the rest.</p> <p>A couple of extra providers enable routing with "hash" URLs such as <code>#!/phones</code> instead of the default "push state" strategy.</p> <p>There's a twist to our Routing Module though: we're also adding a custom <code>UrlHandlingStrategy</code> that tells the Angular router to only process the <code>/</code> and <code>/phones</code> routes.</p> <p>Now update the <code>AppModule</code> to import this <code>AppRoutingModule</code> and also the declare the root <code>AppComponent</code> as the bootstrap component. That tells Angular that it should bootstrap the app with the <em>root</em> <code>AppComponent</code> and insert it's view into the host web page.</p> <p>We can also remove the <code>ngDoBootstrap()</code> override from <code>app.module.ts</code> since we are now bootstrapping from Angular.</p> <p>And since <code>PhoneListComponent</code> isn't being rendered from a <code>&lt;phone-list&gt;</code> tag anymore, but rather routed to, we can do away with it's Angular selector as well.</p> <div class="code-example">
<h4>app/app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { UpgradeModule } from '@angular/upgrade/static';
import { HttpModule } from '@angular/http';
import { FormsModule } from '@angular/forms';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent }     from './app.component';
import { Phone } from './core/phone/phone.service';
import { CheckmarkPipe } from './core/checkmark/checkmark.pipe';
import { PhoneListComponent } from './phone-list/phone-list.component';
import { PhoneDetailComponent } from './phone-detail/phone-detail.component';
import { routeParamsProvider } from './ajs-upgraded-providers';

@NgModule({
  imports: [
    BrowserModule,
    UpgradeModule,
    HttpModule,
    FormsModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    PhoneListComponent,
    PhoneDetailComponent,
    CheckmarkPipe
  ],
  entryComponents: [
    PhoneListComponent,
    PhoneDetailComponent
  ],
  providers: [
    Phone,
    routeParamsProvider
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</pre>
</div>
<p>Now we need to tell the AngularJS router to only process the <code>/phones/:phoneId</code> route:</p> <div class="code-example">
<h4>app/app.config.ts (route config)</h4>
<pre language="ts" format="linenums" data-language="typescript">$routeProvider
  .when('/phones/:phoneId', {
    template: '&lt;phone-detail&gt;&lt;/phone-detail&gt;'
  });
</pre>
</div>
<h4 id="generate-links-for-each-phone">Generate links for each phone</h4> <p>We no longer have to hardcode the links to phone details in the phone list. We can generate data bindings for each phone's <code>id</code> to the <code>routerLink</code> directive and let that directive construct the appropriate URL to the <code>PhoneDetailComponent</code>:</p> <div class="code-example">
<h4>app/phone-list/phone-list.template.html (list with links)</h4>
<pre language="html" format="" data-language="html">&lt;ul class="phones"&gt;
  &lt;li *ngFor="let phone of getPhones()"
      class="thumbnail phone-list-item"&gt;
    &lt;a [routerLink]="['/phones', phone.id]" class="thumb"&gt;
      &lt;img [src]="phone.imageUrl" [alt]="phone.name" /&gt;
    &lt;/a&gt;
    &lt;a [routerLink]="['/phones', phone.id]" class="name"&gt;{{phone.name}}&lt;/a&gt;
    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</pre>
</div>
<div class="l-sub-section">
<p>See the <a href="../router/">Routing</a> page for details.</p> </div>
<p>We are now running both routers at the same time! Angular is handling the initial <code>/</code> url, redirecting to <code>/phones</code>. Meanwhile when we click a link to the phone detail, AngularJS takes over.</p> <p>This way we can incrementally upgrade our app, reducing the risk of a massive one step router swap.</p> <p>The next step is to migrate the <code>/phones/:phoneId</code> route.</p> <p>The Angular router passes route parameters differently. Correct the <code>PhoneDetail</code> component constructor to expect an injected <code>ActivatedRoute</code> object. Extract the <code>phoneId</code> from the <code>ActivatedRoute.snapshot.params</code> and fetch the phone data as before:</p> <div class="code-example">
<h4>app/phone-detail/phone-detail.component.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { Component }      from '@angular/core';
import { ActivatedRoute } from '@angular/router';

import { Phone, PhoneData } from '../core/phone/phone.service';

@Component({
  selector: 'phone-detail',
  templateUrl: './phone-detail.template.html'
})
export class PhoneDetailComponent {
  phone: PhoneData;
  mainImageUrl: string;

  constructor(activatedRoute: ActivatedRoute, phone: Phone) {
    phone.get(activatedRoute.snapshot.params['phoneId'])
      .subscribe((p: PhoneData) =&gt; {
        this.phone = p;
        this.setImage(p.images[0]);
      });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}
</pre>
</div>
<p>Since this was the last route we want to migrate over, we can also now delete the last route config from <code>app/app.config.ts</code>, and add it to the Angular router configuration.</p> <p>We don't need our <code>UrlHandlingStrategy</code> anymore either, since now Angular is processing all routes. </p> <div class="code-example">
<h4>app/app-routing.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { APP_BASE_HREF, HashLocationStrategy, LocationStrategy } from '@angular/common';

import { PhoneDetailComponent } from './phone-detail/phone-detail.component';
import { PhoneListComponent }   from './phone-list/phone-list.component';

const routes: Routes = [
  { path: '', redirectTo: 'phones', pathMatch: 'full' },
  { path: 'phones',          component: PhoneListComponent },
  { path: 'phones/:phoneId', component: PhoneDetailComponent }
];

@NgModule({
  imports: [ RouterModule.forRoot(routes) ],
  exports: [ RouterModule ],
  providers: [
    { provide: APP_BASE_HREF, useValue: '!' },
    { provide: LocationStrategy, useClass: HashLocationStrategy },
  ]
})
export class AppRoutingModule { }
</pre>
</div>
<p>You are now running a pure Angular application!</p> <h3 id="say-goodbye-to-angularjs">Say Goodbye to AngularJS</h3> <p>It is time to take off the training wheels and let our application begin its new life as a pure, shiny Angular app. The remaining tasks all have to do with removing code - which of course is every programmer's favorite task!</p> <p>The application is still bootstrapped as a hybrid app. There's no need for that anymore.</p> <p>Switch the bootstrap method of the application from the <code>UpgradeAdapter</code> to the Angular way. </p> <div class="code-example">
<h4>main.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app.module';

platformBrowserDynamic().bootstrapModule(AppModule);
</pre>
</div>
<p>If you haven't already, remove all references to the <code>UpgradeModule</code> from <code>app.module.ts</code>, as well as any <a href="#making-angularjs-dependencies-injectable-to-angular">Factory provider</a> for AngularJS services, and the <code>app/ajs-upgraded-providers.ts</code> file.</p> <p>Also remove any <code>downgradeInjectable()</code> or <code>downgradeComponent()</code> you find, together with the associated AngularJS factory or directive declarations. Since we have no downgraded components anymore, we also don't need to have them listed in <code>entryComponents</code> either.</p> <div class="code-example">
<h4>app.module.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent }     from './app.component';
import { CheckmarkPipe }    from './core/checkmark/checkmark.pipe';
import { Phone }            from './core/phone/phone.service';
import { PhoneDetailComponent } from './phone-detail/phone-detail.component';
import { PhoneListComponent }   from './phone-list/phone-list.component';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AppRoutingModule
  ],
  declarations: [
    AppComponent,
    PhoneListComponent,
    CheckmarkPipe,
    PhoneDetailComponent
  ],
  providers: [
    Phone
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {}
</pre>
</div>
<p>You may also completely remove the following files. They are AngularJS module configuration files and not needed in Angular:</p> <ul> <li><code>app/app.module.ajs.ts</code></li> <li><code>app/app.config.ts</code></li> <li><code>app/core/core.module.ts</code></li> <li><code>app/core/phone/phone.module.ts</code></li> <li><code>app/phone-detail/phone-detail.module.ts</code></li> <li><code>app/phone-list/phone-list.module.ts</code></li> </ul> <p>The external typings for AngularJS may be uninstalled as well. The only ones we still need are for Jasmine and Angular polyfills. The <code>@angular/upgrade</code> package and it's mapping in <code>systemjs.config.js</code> can also go.</p> <pre format="">npm uninstall @angular/upgrade --save
npm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev
</pre>
<p>Finally, from <code>index.html</code>, remove all references to AngularJS scripts, the Angular upgrade module, and jQuery. When we're done, this is what it should look like:</p> <div class="code-example">
<h4>index.html</h4>
<pre language="html" format="linenums" data-language="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;base href="/app/"&gt;
    &lt;title&gt;Google Phone Gallery&lt;/title&gt;
    &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" /&gt;
    &lt;link rel="stylesheet" href="app.css" /&gt;

    &lt;script src="/node_modules/core-js/client/shim.min.js"&gt;&lt;/script&gt;
    &lt;script src="/node_modules/zone.js/dist/zone.js"&gt;&lt;/script&gt;
    &lt;script src="/node_modules/systemjs/dist/system.src.js"&gt;&lt;/script&gt;
    &lt;script src="/systemjs.config.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      System.import('/app');
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;phonecat-app&gt;&lt;/phonecat-app&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<p>That is the last we'll see of AngularJS! It has served us well but now it's time to say goodbye.</p> <h2 id="appendix-upgrading-phonecat-tests">Appendix: Upgrading PhoneCat Tests</h2> <p>Tests can not only be retained through an upgrade process, but they can also be used as a valuable safety measure when ensuring that the application does not break during the upgrade. E2E tests are especially useful for this purpose.</p> <h3 id="e2e-tests">E2E Tests</h3> <p>The PhoneCat project has both E2E Protractor tests and some Karma unit tests in it. Of these two, E2E tests can be dealt with much more easily: By definition, E2E tests access our application from the <em>outside</em> by interacting with the various UI elements the app puts on the screen. E2E tests aren't really that concerned with the internal structure of the application components. That also means that although we modify our project quite a bit during the upgrade, the E2E test suite should keep passing with just minor modifications. This is because we don't change how the application behaves from the user's point of view.</p> <p>During TypeScript conversion, there is nothing we have to do to keep E2E tests working. It is only when we change our bootstrap to that of a Hybrid app that we need to make some changes.</p> <p>The following change is needed in <code>protractor-conf.js</code> to sync with hybrid apps:</p> <pre format="">ng12Hybrid: true
</pre>
<p>The next set of changes is when we start to upgrade components and their template to Angular. This is because the E2E tests have matchers that are specific to AngularJS. For PhoneCat we need to make the following changes in order to make things work with Angular:</p> <table>
<tr>
<th>Previous code</th>
<th>New code</th>
<th>Notes</th>
</tr>
<tr>
<td>
<p><code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></p> </td>
<td>
<p><code>by.css('.phones .name')</code></p> </td>
<td>
<p>The repeater matcher relies on AngularJS <code>ng-repeat</code></p> </td>
</tr>
<tr>
<td>
<p><code>by.repeater('phone in $ctrl.phones')</code></p> </td>
<td>
<p><code>by.css('.phones li')</code></p> </td>
<td>
<p>The repeater matcher relies on AngularJS <code>ng-repeat</code></p> </td>
</tr>
<tr>
<td>
<p><code>by.model('$ctrl.query')</code></p> </td>
<td>
<p><code>by.css('input')</code></p> </td>
<td>
<p>The model matcher relies on AngularJS <code>ng-model</code></p> </td>
</tr>
<tr>
<td>
<p><code>by.model('$ctrl.orderProp')</code></p> </td>
<td>
<p><code>by.css('select')</code></p> </td>
<td>
<p>The model matcher relies on AngularJS <code>ng-model</code></p> </td>
</tr>
<tr>
<td>
<p><code>by.binding('$ctrl.phone.name')</code></p> </td>
<td>
<p><code>by.css('h1')</code></p> </td>
<td>
<p>The binding matcher relies on AngularJS data binding</p> </td>
</tr>
</table>
<p>When the bootstrap method is switched from that of <code>UpgradeModule</code> to pure Angular, AngularJS ceases to exist on the page completely. At this point we need to tell Protractor that it should not be looking for an AngularJS app anymore, but instead it should find <em>Angular apps</em> from the page. </p> <p>Replace the <code>ng12Hybrid</code> previously added with the following in <code>protractor-conf.js</code>:</p> <pre format="">useAllAngular2AppRoots: true,
</pre>
<p>Also, there are a couple of Protractor API calls in the PhoneCat test code that are using the AngularJS <code>$location</code> service under the hood. As that service is no longer there after the upgrade, we need to replace those calls with ones that use WebDriver's generic URL APIs instead. The first of these is the redirection spec:</p> <div class="code-example">
<h4>e2e-tests/scenarios.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">it('should redirect `index.html` to `index.html#!/phones', function() {
  browser.get('index.html');
  browser.waitForAngular();
  browser.getCurrentUrl().then(function(url: string) {
    expect(url.endsWith('/phones')).toBe(true);
  });
});
</pre>
</div>
<p>And the second is the phone links spec:</p> <div class="code-example">
<h4>e2e-tests/scenarios.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">it('should render phone specific links', function() {
  let query = element(by.css('input'));
  query.sendKeys('nexus');
  element.all(by.css('.phones li a')).first().click();
  browser.getCurrentUrl().then(function(url: string) {
    expect(url.endsWith('/phones/nexus-s')).toBe(true);
  });
});
</pre>
</div>
<h3 id="unit-tests">Unit Tests</h3> <p>For unit tests, on the other hand, more conversion work is needed. Effectively they need to be <em>upgraded</em> along with the production code.</p> <p>During TypeScript conversion no changes are strictly necessary. But it may be a good idea to convert the unit test code into TypeScript as well, as the same benefits we from TypeScript in production code also applies to tests.</p> <p>For instance, in the phone detail component spec we can use not only ES2015 features like arrow functions and block-scoped variables, but also type definitions for some of the AngularJS services we're consuming:</p> <div class="code-example">
<h4>app/phone-detail/phone-detail.component.spec.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">describe('phoneDetail', () =&gt; {

  // Load the module that contains the `phoneDetail` component before each test
  beforeEach(angular.mock.module('phoneDetail'));

  // Test the controller
  describe('PhoneDetailController', () =&gt; {
    let $httpBackend: angular.IHttpBackendService;
    let ctrl: any;
    let xyzPhoneData = {
      name: 'phone xyz',
      images: ['image/url1.png', 'image/url2.png']
    };

    beforeEach(inject(($componentController: any,
                       _$httpBackend_: angular.IHttpBackendService,
                       $routeParams: angular.route.IRouteParamsService) =&gt; {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData);

      $routeParams['phoneId'] = 'xyz';

      ctrl = $componentController('phoneDetail');
    }));

    it('should fetch the phone details', () =&gt; {
      jasmine.addCustomEqualityTester(angular.equals);

      expect(ctrl.phone).toEqual({});

      $httpBackend.flush();
      expect(ctrl.phone).toEqual(xyzPhoneData);
    });

  });

});
</pre>
</div>
<p>Once we start the upgrade process and bring in SystemJS, configuration changes are needed for Karma. We need to let SystemJS load all the new Angular code, which can be done with the following kind of shim file:</p> <div class="code-example">
<h4>karma-test-shim.js</h4>
<pre language="js" format="linenums" data-language="js">// /*global jasmine, __karma__, window*/
Error.stackTraceLimit = 0; // "No stacktrace"" is usually best for app testing.

// Uncomment to get full stacktrace output. Sometimes helpful, usually not.
// Error.stackTraceLimit = Infinity; //

jasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;

var builtPath = '/base/app/';

__karma__.loaded = function () { };

function isJsFile(path) {
  return path.slice(-3) == '.js';
}

function isSpecFile(path) {
  return /\.spec\.(.*\.)?js$/.test(path);
}

function isBuiltFile(path) {
  return isJsFile(path) &amp;&amp; (path.substr(0, builtPath.length) == builtPath);
}

var allSpecFiles = Object.keys(window.__karma__.files)
  .filter(isSpecFile)
  .filter(isBuiltFile);

System.config({
  baseURL: '/base',
  // Extend usual application package list with test folder
  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },

  // Assume npm: is set in `paths` in systemjs.config
  // Map the angular testing umd bundles
  map: {
    '@angular/core/testing': 'npm:@angular/core/bundles/core-testing.umd.js',
    '@angular/common/testing': 'npm:@angular/common/bundles/common-testing.umd.js',
    '@angular/compiler/testing': 'npm:@angular/compiler/bundles/compiler-testing.umd.js',
    '@angular/platform-browser/testing': 'npm:@angular/platform-browser/bundles/platform-browser-testing.umd.js',
    '@angular/platform-browser-dynamic/testing': 'npm:@angular/platform-browser-dynamic/bundles/platform-browser-dynamic-testing.umd.js',
    '@angular/http/testing': 'npm:@angular/http/bundles/http-testing.umd.js',
    '@angular/router/testing': 'npm:@angular/router/bundles/router-testing.umd.js',
    '@angular/forms/testing': 'npm:@angular/forms/bundles/forms-testing.umd.js',
  },
});

System.import('systemjs.config.js')
  .then(importSystemJsExtras)
  .then(initTestBed)
  .then(initTesting);

/** Optional SystemJS configuration extras. Keep going w/o it */
function importSystemJsExtras(){
  return System.import('systemjs.config.extras.js')
  .catch(function(reason) {
    console.log(
      'Warning: System.import could not load the optional "systemjs.config.extras.js". Did you omit it by accident? Continuing without it.'
    );
    console.log(reason);
  });
}

function initTestBed(){
  return Promise.all([
    System.import('@angular/core/testing'),
    System.import('@angular/platform-browser-dynamic/testing')
  ])

  .then(function (providers) {
    var coreTesting    = providers[0];
    var browserTesting = providers[1];

    coreTesting.TestBed.initTestEnvironment(
      browserTesting.BrowserDynamicTestingModule,
      browserTesting.platformBrowserDynamicTesting());
  })
}

// Import all spec files and start karma
function initTesting () {
  return Promise.all(
    allSpecFiles.map(function (moduleName) {
      return System.import(moduleName);
    })
  )
  .then(__karma__.start, __karma__.error);
}
</pre>
</div>
<p>The shim first loads the SystemJS configuration, then Angular's test support libraries, and then the application's spec files themselves.</p> <p>Karma configuration should then be changed so that it uses the application root dir as the base directory, instead of <code>app</code>.</p> <div class="code-example">
<h4>karma.conf.js</h4>
<pre language="js" format="" data-language="js">basePath: './',
</pre>
</div>
<p>Once this is done, we can load SystemJS and other dependencies, and also switch the configuration for loading application files so that they are <em>not</em> included to the page by Karma. We'll let the shim and SystemJS load them.</p> <div class="code-example">
<h4>karma.conf.js</h4>
<pre language="js" format="linenums" data-language="js">// System.js for module loading
'node_modules/systemjs/dist/system.src.js',

// Polyfills
'node_modules/core-js/client/shim.js',

// zone.js
'node_modules/zone.js/dist/zone.js',
'node_modules/zone.js/dist/long-stack-trace-zone.js',
'node_modules/zone.js/dist/proxy.js',
'node_modules/zone.js/dist/sync-test.js',
'node_modules/zone.js/dist/jasmine-patch.js',
'node_modules/zone.js/dist/async-test.js',
'node_modules/zone.js/dist/fake-async-test.js',

// RxJs.
{ pattern: 'node_modules/rxjs/**/*.js', included: false, watched: false },
{ pattern: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },

// Angular itself and the testing library
{pattern: 'node_modules/@angular/**/*.js', included: false, watched: false},
{pattern: 'node_modules/@angular/**/*.js.map', included: false, watched: false},

{pattern: 'systemjs.config.js', included: false, watched: false},
'karma-test-shim.js',

{pattern: 'app/**/*.module.js', included: false, watched: true},
{pattern: 'app/*!(.module|.spec).js', included: false, watched: true},
{pattern: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},
{pattern: 'app/**/*.spec.js', included: false, watched: true},

{pattern: '**/*.html', included: false, watched: true},
</pre>
</div>
<p>Since the HTML templates of Angular components will be loaded as well, we need to help Karma out a bit so that it can route them to the right paths:</p> <div class="code-example">
<h4>karma.conf.js</h4>
<pre language="js" format="linenums" data-language="js">// proxied base paths for loading assets
proxies: {
  // required for component assets fetched by Angular's compiler
  "/phone-detail": '/base/app/phone-detail',
  "/phone-list": '/base/app/phone-list'
},
</pre>
</div>
<p>The unit test files themselves also need to be switched to Angular when their production counterparts are switched. The specs for the checkmark pipe are probably the most straightforward, as the pipe has no dependencies:</p> <div class="code-example">
<h4>app/core/checkmark/checkmark.pipe.spec.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { CheckmarkPipe } from './checkmark.pipe';

describe('CheckmarkPipe', function() {

  it('should convert boolean values to unicode checkmark or cross', function () {
    const checkmarkPipe = new CheckmarkPipe();
    expect(checkmarkPipe.transform(true)).toBe('\u2713');
    expect(checkmarkPipe.transform(false)).toBe('\u2718');
  });
});
</pre>
</div>
<p>The unit test for the phone service is a bit more involved. We need to switch from the mocked-out AngularJS <code>$httpBackend</code> to a mocked-out Angular Http backend.</p> <div class="code-example">
<h4>app/core/phone/phone.service.spec.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { inject, TestBed } from '@angular/core/testing';
import {
  Http,
  BaseRequestOptions,
  ResponseOptions,
  Response
} from '@angular/http';
import { MockBackend, MockConnection } from '@angular/http/testing';
import { Phone, PhoneData } from './phone.service';

describe('Phone', function() {
  let phone: Phone;
  let phonesData: PhoneData[] = [
    {name: 'Phone X', snippet: '', images: []},
    {name: 'Phone Y', snippet: '', images: []},
    {name: 'Phone Z', snippet: '', images: []}
  ];
  let mockBackend: MockBackend;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      providers: [
        Phone,
        MockBackend,
        BaseRequestOptions,
        { provide: Http,
          useFactory: (backend: MockBackend, options: BaseRequestOptions) =&gt; new Http(backend, options),
          deps: [MockBackend, BaseRequestOptions]
        }
      ]
    });
  });

  beforeEach(inject([MockBackend, Phone], (_mockBackend_: MockBackend, _phone_: Phone) =&gt; {
    mockBackend = _mockBackend_;
    phone = _phone_;
  }));

  it('should fetch the phones data from `/phones/phones.json`', (done: () =&gt; void) =&gt; {
    mockBackend.connections.subscribe((conn: MockConnection) =&gt; {
      conn.mockRespond(new Response(new ResponseOptions({body: JSON.stringify(phonesData)})));
    });
    phone.query().subscribe(result =&gt; {
      expect(result).toEqual(phonesData);
      done();
    });
  });

});
</pre>
</div>
<p>For the component specs we can mock out the <code>Phone</code> service itself, and have it provide canned phone data. We use Angular's component unit testing APIs for both components.</p> <div class="code-example">
<h4>app/phone-detail/phone-detail.component.spec.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { ActivatedRoute } from '@angular/router';

import { Observable } from 'rxjs/Rx';

import { async, TestBed } from '@angular/core/testing';

import { PhoneDetailComponent } from './phone-detail.component';
import { Phone, PhoneData } from '../core/phone/phone.service';
import { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';

function xyzPhoneData(): PhoneData {
  return {
    name: 'phone xyz',
    snippet: '',
    images: ['image/url1.png', 'image/url2.png']
  };
}

class MockPhone {
  get(id: string): Observable&lt;PhoneData&gt; {
    return Observable.of(xyzPhoneData());
  }
}


class ActivatedRouteMock {
  constructor(public snapshot: any) {}
}


describe('PhoneDetailComponent', () =&gt; {


  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ CheckmarkPipe, PhoneDetailComponent ],
      providers: [
        { provide: Phone, useClass: MockPhone },
        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) }
      ]
    })
    .compileComponents();
  }));

  it('should fetch phone detail', () =&gt; {
    const fixture = TestBed.createComponent(PhoneDetailComponent);
    fixture.detectChanges();
    let compiled = fixture.debugElement.nativeElement;
    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);
  });

});
</pre>
</div>
<div class="code-example">
<h4>app/phone-list/phone-list.component.spec.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { NO_ERRORS_SCHEMA } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Observable } from 'rxjs/Rx';
import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import { SpyLocation } from '@angular/common/testing';

import { PhoneListComponent } from './phone-list.component';
import { Phone, PhoneData } from '../core/phone/phone.service';

class ActivatedRouteMock {
  constructor(public snapshot: any) {}
}

class MockPhone {
  query(): Observable&lt;PhoneData[]&gt; {
    return Observable.of([
      {name: 'Nexus S', snippet: '', images: []},
      {name: 'Motorola DROID', snippet: '', images: []}
    ]);
  }
}

let fixture: ComponentFixture&lt;PhoneListComponent&gt;;

describe('PhoneList', () =&gt; {

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ PhoneListComponent ],
      providers: [
        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) },
        { provide: Location, useClass: SpyLocation },
        { provide: Phone, useClass: MockPhone },
      ],
      schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
  }));

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(PhoneListComponent);
  });

  it('should create "phones" model with 2 phones fetched from xhr', () =&gt; {
    fixture.detectChanges();
    let compiled = fixture.debugElement.nativeElement;
    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);
    expect(
      compiled.querySelector('.phone-list-item:nth-child(1)').textContent
    ).toContain('Motorola DROID');
    expect(
      compiled.querySelector('.phone-list-item:nth-child(2)').textContent
    ).toContain('Nexus S');
  });

  xit('should set the default value of orderProp model', () =&gt; {
    fixture.detectChanges();
    let compiled = fixture.debugElement.nativeElement;
    expect(
      compiled.querySelector('select option:last-child').selected
    ).toBe(true);
  });

});
</pre>
</div>
<p>Finally, we need to revisit both of the component tests when we switch to the Angular router. For the details component we need to provide a mock of Angular <code>ActivatedRoute</code> object instead of using the AngularJS <code>$routeParams</code>.</p> <div class="code-example">
<h4>app/phone-detail/phone-detail.component.spec.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { ActivatedRoute } from '@angular/router';

/* . . . */

class ActivatedRouteMock {
  constructor(public snapshot: any) {}
}

/* . . . */

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ CheckmarkPipe, PhoneDetailComponent ],
      providers: [
        { provide: Phone, useClass: MockPhone },
        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) }
      ]
    })
    .compileComponents();
  }));
</pre>
</div>
<p>And for the phone list component we need to set up a few things for the router itself so that the route link directive will work.</p> <div class="code-example">
<h4>app/phone-list/phone-list.component.spec.ts</h4>
<pre language="ts" format="linenums" data-language="typescript">import { NO_ERRORS_SCHEMA } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Observable } from 'rxjs/Rx';
import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import { SpyLocation } from '@angular/common/testing';

import { PhoneListComponent } from './phone-list.component';
import { Phone, PhoneData } from '../core/phone/phone.service';

/* . . . */

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ PhoneListComponent ],
      providers: [
        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) },
        { provide: Location, useClass: SpyLocation },
        { provide: Phone, useClass: MockPhone },
      ],
      schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
  }));

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(PhoneListComponent);
  });
</pre>
</div>
<div class="_attribution">
  <p class="_attribution-p">
     20102017 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/docs/ts/latest/guide/upgrade.html" class="_attribution-link" target="_blank">https://angular.io/docs/ts/latest/guide/upgrade.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
