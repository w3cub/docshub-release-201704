
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>ActiveRecord&#58;&#58;ConnectionAdapters&#58;&#58;SchemaStatements - Ruby on Rails 4.2 - W3cubDocs</title>
  
  <meta name="description" content="Adds a new column to the named table. See ActiveRecord&#58;&#58;ConnectionAdapters&#58;&#58;TableDefinition#column for details of the options you &hellip;">
  <meta name="keywords" content="module, activerecord, connectionadapters, schemastatements, -, ruby, on, rails, rails~4.2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rails~4.2/activerecord/connectionadapters/schemastatements/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/rails~4.2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~4.2/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 4.2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
<h1 id="module-ActiveRecord::ConnectionAdapters::SchemaStatements" class="module"> module ActiveRecord::ConnectionAdapters::SchemaStatements </h1>  <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-add_belongs_to"> <span class="method-name">add_belongs_to</span><span class="method-args">(table_name, ref_name, options = {})</span> </div>  <div class="aliases"> Alias for: <a href="../schemastatements/#method-i-add_reference">add_reference</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_column"> <span class="method-name">add_column</span><span class="method-args">(table_name, column_name, type, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds a new column to the named table. See <a href="../tabledefinition/#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a> for details of the options you can use.</p> <div class="method-source-code" id="add_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 404
def add_column(table_name, column_name, type, options = {})
  at = create_alter_table table_name
  at.add_column(column_name, type, options)
  execute schema_creation.accept at
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_foreign_key"> <span class="method-name">add_foreign_key</span><span class="method-args">(from_table, to_table, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds a new foreign key. <code>from_table</code> is the table with the key column, <code>to_table</code> contains the referenced primary key.</p> <p>The foreign key will be named after the following pattern: <code>fk_rails_&lt;identifier&gt;</code>. <code>identifier</code> is a 10 character long string which is deterministically generated from the <code>from_table</code> and <code>column</code>. A custom name can be specified with the <code>:name</code> option.</p> <h6 id="method-i-add_foreign_key-label-Creating+a+simple+foreign+key">Creating a simple foreign key</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :authors
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT articles_author_id_fk FOREIGN KEY ("author_id") REFERENCES "authors" ("id")</pre> <h6 id="method-i-add_foreign_key-label-Creating+a+foreign+key+on+a+specific+column">Creating a foreign key on a specific column</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :users, column: :author_id, primary_key: :lng_id
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY ("author_id") REFERENCES "users" ("lng_id")</pre> <h6 id="method-i-add_foreign_key-label-Creating+a+cascading+foreign+key">Creating a cascading foreign key</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :authors, on_delete: :cascade
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT articles_author_id_fk FOREIGN KEY ("author_id") REFERENCES "authors" ("id") ON DELETE CASCADE</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:column</code> </dt>
<dd> <p>The foreign key column name on <code>from_table</code>. Defaults to <code>to_table.singularize + "_id"</code></p> </dd>
<dt>
<code>:primary_key</code> </dt>
<dd> <p>The primary key column name on <code>to_table</code>. Defaults to <code>id</code>.</p> </dd>
<dt>
<code>:name</code> </dt>
<dd> <p>The constraint name. Defaults to <code>fk_rails_&lt;identifier&gt;</code>.</p> </dd>
<dt>
<code>:on_delete</code> </dt>
<dd> <p>Action that happens <code>ON DELETE</code>. Valid values are <code>:nullify</code>, <code>:cascade:</code> and <code>:restrict</code></p> </dd>
<dt>
<code>:on_update</code> </dt>
<dd> <p>Action that happens <code>ON UPDATE</code>. Valid values are <code>:nullify</code>, <code>:cascade:</code> and <code>:restrict</code></p> </dd>
</dl> <div class="method-source-code" id="add_foreign_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 761
def add_foreign_key(from_table, to_table, options = {})
  return unless supports_foreign_keys?

  options[:column] ||= foreign_key_column_for(to_table)

  options = {
    column: options[:column],
    primary_key: options[:primary_key],
    name: foreign_key_name(from_table, options),
    on_delete: options[:on_delete],
    on_update: options[:on_update]
  }
  at = create_alter_table from_table
  at.add_foreign_key to_table, options

  execute schema_creation.accept(at)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_index"> <span class="method-name">add_index</span><span class="method-args">(table_name, column_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds a new index to the table. <code>column_name</code> can be a single <a href="../../../symbol/">Symbol</a>, or an <a href="../../../array/">Array</a> of Symbols.</p> <p>The index will be named after the table and the column name(s), unless you pass <code>:name</code> as an option.</p> <h6 id="method-i-add_index-label-Creating+a+simple+index">Creating a simple index</h6> <pre class="ruby" data-language="ruby">add_index(:suppliers, :name)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX suppliers_name_index ON suppliers(name)
</pre> <h6 id="method-i-add_index-label-Creating+a+unique+index">Creating a unique index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE UNIQUE INDEX accounts_branch_id_party_id_index ON accounts(branch_id, party_id)
</pre> <h6 id="method-i-add_index-label-Creating+a+named+index">Creating a named index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)
</pre> <h6 id="method-i-add_index-label-Creating+an+index+with+specific+key+length">Creating an index with specific key length</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, :name, name: 'by_name', length: 10)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX by_name ON accounts(name(10))

add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX by_name_surname ON accounts(name(10), surname(15))
</pre> <p>Note: SQLite doesn't support index length.</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+sort+order+-28desc+or+asc-2C+asc+is+the+default-29">Creating an index with a sort order (desc or asc, asc is the default)</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id, :surname], order: {branch_id: :desc, party_id: :asc})
</pre> <p>generates:</p> <pre>CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)</pre> <p>Note: MySQL doesn't yet support index order (it accepts the syntax but ignores it).</p> <h6 id="method-i-add_index-label-Creating+a+partial+index">Creating a partial index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true, where: "active")
</pre> <p>generates:</p> <pre>CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active</pre> <p>Note: Partial indexes are only supported for <span>PostgreSQL</span> and SQLite 3.8.0+.</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+method">Creating an index with a specific method</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, using: 'btree')
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL
CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL
</pre> <p>Note: only supported by <span>PostgreSQL</span> and MySQL</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+type">Creating an index with a specific type</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, type: :fulltext)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL
</pre> <p>Note: only supported by MySQL. Supported: <code>:fulltext</code> and <code>:spatial</code> on MyISAM tables.</p> <div class="method-source-code" id="add_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 569
def add_index(table_name, column_name, options = {})
  index_name, index_type, index_columns, index_options = add_index_options(table_name, column_name, options)
  execute "CREATE #{index_type} INDEX #{quote_column_name(index_name)} ON #{quote_table_name(table_name)} (#{index_columns})#{index_options}"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_reference"> <span class="method-name">add_reference</span><span class="method-args">(table_name, ref_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds a reference. The reference column is an integer by default, the <code>:type</code> option can be used to specify a different type. Optionally adds a <code>_type</code> column, if <code>:polymorphic</code> option is provided. <code>add_reference</code> and <code>add_belongs_to</code> are acceptable.</p> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:type</code> </dt>
<dd> <p>The reference column type. Defaults to <code>:integer</code>.</p> </dd>
<dt>
<code>:index</code> </dt>
<dd> <p>Add an appropriate index. Defaults to false.</p> </dd>
<dt>
<code>:foreign_key</code> </dt>
<dd> <p>Add an appropriate foreign key. Defaults to false.</p> </dd>
<dt>
<code>:polymorphic</code> </dt>
<dd> <p>Wether an additional <code>_type</code> column should be added. Defaults to false.</p> </dd>
</dl> <h6 id="method-i-add_reference-label-Create+a+user_id+integer+column">Create a user_id integer column</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :user)
</pre> <h6 id="method-i-add_reference-label-Create+a+user_id+string+column">Create a user_id string column</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :user, type: :string)
</pre> <h6 id="method-i-add_reference-label-Create+supplier_id-2C+supplier_type+columns+and+appropriate+index">Create supplier_id, supplier_type columns and appropriate index</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, polymorphic: true, index: true)
</pre> <div class="method-source-code" id="add_reference-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 667
def add_reference(table_name, ref_name, options = {})
  polymorphic = options.delete(:polymorphic)
  index_options = options.delete(:index)
  type = options.delete(:type) || :integer
  foreign_key_options = options.delete(:foreign_key)

  if polymorphic &amp;&amp; foreign_key_options
    raise ArgumentError, "Cannot add a foreign key to a polymorphic relation"
  end

  add_column(table_name, "#{ref_name}_id", type, options)
  add_column(table_name, "#{ref_name}_type", :string, polymorphic.is_a?(Hash) ? polymorphic : options) if polymorphic
  add_index(table_name, polymorphic ? %w[type id].map{ |t| "#{ref_name}_#{t}" } : "#{ref_name}_id", index_options.is_a?(Hash) ? index_options : {}) if index_options
  if foreign_key_options
    to_table = Base.pluralize_table_names ? ref_name.to_s.pluralize : ref_name
    add_foreign_key(table_name, to_table, foreign_key_options.is_a?(Hash) ? foreign_key_options : {})
  end
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../schemastatements/#method-i-add_belongs_to">add_belongs_to</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_timestamps"> <span class="method-name">add_timestamps</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds timestamps (<code>created_at</code> and <code>updated_at</code>) columns to <code>table_name</code>. Additional options (like <code>null:
false</code>) are forwarded to <a href="../schemastatements/#method-i-add_column">add_column</a>.</p> <pre class="ruby" data-language="ruby">add_timestamps(:suppliers, null: false)
</pre> <div class="method-source-code" id="add_timestamps-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 908
def add_timestamps(table_name, options = {})
  emit_warning_if_null_unspecified(:add_timestamps, options)
  add_column table_name, :created_at, :datetime, options
  add_column table_name, :updated_at, :datetime, options
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-assume_migrated_upto_version"> <span class="method-name">assume_migrated_upto_version</span><span class="method-args">(version, migrations_paths = ActiveRecord::Migrator.migrations_paths)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="assume_migrated_upto_version-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 839
def assume_migrated_upto_version(version, migrations_paths = ActiveRecord::Migrator.migrations_paths)
  migrations_paths = Array(migrations_paths)
  version = version.to_i
  sm_table = quote_table_name(ActiveRecord::Migrator.schema_migrations_table_name)

  migrated = select_values("SELECT version FROM #{sm_table}").map { |v| v.to_i }
  paths = migrations_paths.map {|p| "#{p}/[0-9]*_*.rb" }
  versions = Dir[*paths].map do |filename|
    filename.split('/').last.split('_').first.to_i
  end

  unless migrated.include?(version)
    execute "INSERT INTO #{sm_table} (version) VALUES ('#{version}')"
  end

  inserted = Set.new
  (versions - migrated).each do |v|
    if inserted.include?(v)
      raise "Duplicate migration #{v}. Please renumber your migrations to resolve the conflict."
    elsif v &lt; version
      execute "INSERT INTO #{sm_table} (version) VALUES ('#{v}')"
      inserted &lt;&lt; v
    end
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column"> <span class="method-name">change_column</span><span class="method-args">(table_name, column_name, type, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Changes the column's definition according to the new options. See <a href="../tabledefinition/#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a> for details of the options you can use.</p> <pre class="ruby" data-language="ruby">change_column(:suppliers, :name, :string, limit: 80)
change_column(:accounts, :description, :text)
</pre> <div class="method-source-code" id="change_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 438
def change_column(table_name, column_name, type, options = {})
  raise NotImplementedError, "change_column is not implemented"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_default"> <span class="method-name">change_column_default</span><span class="method-args">(table_name, column_name, default)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Sets a new default value for a column:</p> <pre class="ruby" data-language="ruby">change_column_default(:suppliers, :qualification, 'new')
change_column_default(:accounts, :authorized, 1)
</pre> <p>Setting the default to <code>nil</code> effectively drops the default:</p> <pre class="ruby" data-language="ruby">change_column_default(:users, :email, nil)
</pre> <div class="method-source-code" id="change_column_default-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 451
def change_column_default(table_name, column_name, default)
  raise NotImplementedError, "change_column_default is not implemented"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_null"> <span class="method-name">change_column_null</span><span class="method-args">(table_name, column_name, null, default = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Sets or removes a +NOT NULL+ constraint on a column. The <code>null</code> flag indicates whether the value can be <code>NULL</code>. For example</p> <pre class="ruby" data-language="ruby">change_column_null(:users, :nickname, false)
</pre> <p>says nicknames cannot be <code>NULL</code> (adds the constraint), whereas</p> <pre class="ruby" data-language="ruby">change_column_null(:users, :nickname, true)
</pre> <p>allows them to be <code>NULL</code> (drops the constraint).</p> <p>The method accepts an optional fourth argument to replace existing +NULL+s with some other value. Use that one when enabling the constraint if needed, since otherwise those rows would not be valid.</p> <p>Please note the fourth argument does not set a column's default.</p> <div class="method-source-code" id="change_column_null-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 471
def change_column_null(table_name, column_name, null, default = nil)
  raise NotImplementedError, "change_column_null is not implemented"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_table"> <span class="method-name">change_table</span><span class="method-args">(table_name, options = {}) { |update_table_definition(table_name, recorder)| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>A block for changing columns in <code>table</code>.</p> <pre class="ruby" data-language="ruby"># change_table() yields a Table instance
change_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other column alterations here
end
</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:bulk</code> </dt>
<dd> <p>Set this to true to make this a bulk alter query, such as</p> <pre>ALTER TABLE `users` ADD COLUMN age INT(11), ADD COLUMN birthdate DATETIME ...</pre> <p>Defaults to false.</p> </dd>
</dl> <h6 id="method-i-change_table-label-Add+a+column">Add a column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
end
</pre> <h6 id="method-i-change_table-label-Add+2+integer+columns">Add 2 integer columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.integer :width, :height, null: false, default: 0
end
</pre> <h6 id="method-i-change_table-label-Add+created_at-2Fupdated_at+columns">Add created_at/updated_at columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.timestamps
end
</pre> <h6 id="method-i-change_table-label-Add+a+foreign+key+column">Add a foreign key column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.references :company
end
</pre> <p>Creates a <code>company_id(integer)</code> column.</p> <h6 id="method-i-change_table-label-Add+a+polymorphic+foreign+key+column">Add a polymorphic foreign key column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.belongs_to :company, polymorphic: true
end
</pre> <p>Creates <code>company_type(varchar)</code> and <code>company_id(integer)</code> columns.</p> <h6 id="method-i-change_table-label-Remove+a+column">Remove a column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove :company
end
</pre> <h6 id="method-i-change_table-label-Remove+several+columns">Remove several columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove :company_id
  t.remove :width, :height
end
</pre> <h6 id="method-i-change_table-label-Remove+an+index">Remove an index</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove_index :company_id
end
</pre> <p>See also <a href="../table/">Table</a> for details on all of the various column transformation.</p> <div class="method-source-code" id="change_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 371
def change_table(table_name, options = {})
  if supports_bulk_alter? &amp;&amp; options[:bulk]
    recorder = ActiveRecord::Migration::CommandRecorder.new(self)
    yield update_table_definition(table_name, recorder)
    bulk_change_table(table_name, recorder.commands)
  else
    yield update_table_definition(table_name, self)
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-column_exists-3F"> <span class="method-name">column_exists?</span><span class="method-args">(table_name, column_name, type = nil, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Checks to see if a column exists in a given table.</p> <pre class="ruby" data-language="ruby"># Check a column exists
column_exists?(:suppliers, :name)

# Check a column exists of a particular type
column_exists?(:suppliers, :name, :string)

# Check a column exists with a specific definition
column_exists?(:suppliers, :name, :string, limit: 100)
column_exists?(:suppliers, :name, :string, default: 'default')
column_exists?(:suppliers, :name, :string, null: false)
column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2)
</pre> <div class="method-source-code" id="column_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 90
def column_exists?(table_name, column_name, type = nil, options = {})
  column_name = column_name.to_s
  columns(table_name).any?{ |c| c.name == column_name &amp;&amp;
                                (!type                     || c.type == type) &amp;&amp;
                                (!options.key?(:limit)     || c.limit == options[:limit]) &amp;&amp;
                                (!options.key?(:precision) || c.precision == options[:precision]) &amp;&amp;
                                (!options.key?(:scale)     || c.scale == options[:scale]) &amp;&amp;
                                (!options.key?(:default)   || c.default == options[:default]) &amp;&amp;
                                (!options.key?(:null)      || c.null == options[:null]) }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-columns"> <span class="method-name">columns</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns an array of Column objects for the table specified by <code>table_name</code>. See the concrete implementation for details on the expected parameter values.</p> <div class="method-source-code" id="columns-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 74
def columns(table_name) end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_join_table"> <span class="method-name">create_join_table</span><span class="method-args">(table_1, table_2, options = {}) { |td| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Creates a new join table with the name created using the lexical order of the first two arguments. These arguments can be a <a href="../../../string/">String</a> or a <a href="../../../symbol/">Symbol</a>.</p> <pre class="ruby" data-language="ruby"># Creates a table called 'assemblies_parts' with no id.
create_join_table(:assemblies, :parts)
</pre> <p>You can pass a <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:table_name</code> </dt>
<dd> <p>Sets the table name overriding the default</p> </dd>
<dt>
<code>:column_options</code> </dt>
<dd> <p>Any extra options you want appended to the columns definition.</p> </dd>
<dt>
<code>:options</code> </dt>
<dd> <p>Any extra options you want appended to the table definition.</p> </dd>
<dt>
<code>:temporary</code> </dt>
<dd> <p>Make a temporary table.</p> </dd>
<dt>
<code>:force</code> </dt>
<dd> <p>Set to true to drop the table before creating it. Defaults to false.</p> </dd>
</dl> <p>Note that <code>create_join_table</code> does not create any indices by default; you can use its block form to do so yourself:</p> <pre class="ruby" data-language="ruby">create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
</pre> <h6 id="method-i-create_join_table-label-Add+a+backend+specific+option+to+the+generated+SQL+-28MySQL-29">Add a backend specific option to the generated SQL (MySQL)</h6> <pre class="ruby" data-language="ruby">create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
</pre> <p>generates:</p> <pre>CREATE TABLE assemblies_parts (
  assembly_id int NOT NULL,
  part_id int NOT NULL,
) ENGINE=InnoDB DEFAULT CHARSET=utf8</pre> <div class="method-source-code" id="create_join_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 275
def create_join_table(table_1, table_2, options = {})
  join_table_name = find_join_table_name(table_1, table_2, options)

  column_options = options.delete(:column_options) || {}
  column_options.reverse_merge!(null: false)

  t1_column, t2_column = [table_1, table_2].map{ |t| t.to_s.singularize.foreign_key }

  create_table(join_table_name, options.merge!(id: false)) do |td|
    td.integer t1_column, column_options
    td.integer t2_column, column_options
    yield td if block_given?
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_table"> <span class="method-name">create_table</span><span class="method-args">(table_name, options = {}) { |td| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Creates a new table with the name <code>table_name</code>. <code>table_name</code> may either be a <a href="../../../string/">String</a> or a <a href="../../../symbol/">Symbol</a>.</p> <p>There are two ways to work with <code>create_table</code>. You can use the block form or the regular form, like this:</p> <h3 id="method-i-create_table-label-Block+form">Block form</h3> <pre class="ruby" data-language="ruby"># create_table() passes a TableDefinition object to the block.
# This form will not only create the table, but also columns for the
# table.

create_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other fields here
end
</pre> <h3 id="method-i-create_table-label-Block+form-2C+with+shorthand">Block form, with shorthand</h3> <pre class="ruby" data-language="ruby"># You can also use the column types as method calls, rather than calling the column method.
create_table(:suppliers) do |t|
  t.string :name, limit: 60
  # Other fields here
end
</pre> <h3 id="method-i-create_table-label-Regular+form">Regular form</h3> <pre class="ruby" data-language="ruby"># Creates a table called 'suppliers' with no columns.
create_table(:suppliers)
# Add a column to 'suppliers'.
add_column(:suppliers, :name, :string, {limit: 60})
</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:id</code> </dt>
<dd> <p>Whether to automatically add a primary key column. Defaults to true. Join tables for <code>has_and_belongs_to_many</code> should set it to false.</p> </dd>
<dt>
<code>:primary_key</code> </dt>
<dd> <p>The name of the primary key, if one is to be added automatically. Defaults to <code>id</code>. If <code>:id</code> is false this option is ignored.</p> <p>Note that Active Record models will automatically detect their primary key. This can be avoided by using <code>self.primary_key=</code> on the model to define the key explicitly.</p> </dd>
<dt>
<code>:options</code> </dt>
<dd> <p>Any extra options you want appended to the table definition.</p> </dd>
<dt>
<code>:temporary</code> </dt>
<dd> <p>Make a temporary table.</p> </dd>
<dt>
<code>:force</code> </dt>
<dd> <p>Set to true to drop the table before creating it. Set to <code>:cascade</code> to drop dependent objects as well. Defaults to false.</p> </dd>
<dt>
<code>:as</code> </dt>
<dd> <p>SQL to use to generate the table. When this option is used, the block is ignored, as are the <code>:id</code> and <code>:primary_key</code> options.</p> </dd>
</dl> <h6 id="method-i-create_table-label-Add+a+backend+specific+option+to+the+generated+SQL+-28MySQL-29">Add a backend specific option to the generated SQL (MySQL)</h6> <pre class="ruby" data-language="ruby">create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
</pre> <p>generates:</p> <pre>CREATE TABLE suppliers (
  id int(11) DEFAULT NULL auto_increment PRIMARY KEY
) ENGINE=InnoDB DEFAULT CHARSET=utf8</pre> <h6 id="method-i-create_table-label-Rename+the+primary+key+column">Rename the primary key column</h6> <pre class="ruby" data-language="ruby">create_table(:objects, primary_key: 'guid') do |t|
  t.column :name, :string, limit: 80
end
</pre> <p>generates:</p> <pre>CREATE TABLE objects (
  guid int(11) DEFAULT NULL auto_increment PRIMARY KEY,
  name varchar(80)
)</pre> <h6 id="method-i-create_table-label-Do+not+add+a+primary+key+column">Do not add a primary key column</h6> <pre class="ruby" data-language="ruby">create_table(:categories_suppliers, id: false) do |t|
  t.column :category_id, :integer
  t.column :supplier_id, :integer
end
</pre> <p>generates:</p> <pre>CREATE TABLE categories_suppliers (
  category_id int,
  supplier_id int
)</pre> <h6 id="method-i-create_table-label-Create+a+temporary+table+based+on+a+query">Create a temporary table based on a query</h6> <pre class="ruby" data-language="ruby">create_table(:long_query, temporary: true,
  as: "SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id")
</pre> <p>generates:</p> <pre>CREATE TEMPORARY TABLE long_query AS
  SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id</pre> <p>See also <a href="../tabledefinition/#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a> for details on how to create columns.</p> <div class="method-source-code" id="create_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 205
def create_table(table_name, options = {})
  td = create_table_definition table_name, options[:temporary], options[:options], options[:as]

  if options[:id] != false &amp;&amp; !options[:as]
    pk = options.fetch(:primary_key) do
      Base.get_primary_key table_name.to_s.singularize
    end

    td.primary_key pk, options.fetch(:id, :primary_key), options
  end

  yield td if block_given?

  if options[:force] &amp;&amp; table_exists?(table_name)
    drop_table(table_name, options)
  end

  result = execute schema_creation.accept td

  unless supports_indexes_in_create?
    td.indexes.each_pair do |column_name, index_options|
      add_index(table_name, column_name, index_options)
    end
  end

  td.foreign_keys.each do |other_table_name, foreign_key_options|
    add_foreign_key(table_name, other_table_name, foreign_key_options)
  end

  result
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-data_source_exists-3F"> <span class="method-name">data_source_exists?</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Checks to see if the data source <code>name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">data_source_exists?(:ebooks)
</pre> <div class="method-source-code" id="data_source_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 32
def data_source_exists?(name)
  data_sources.include?(name.to_s)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-data_sources"> <span class="method-name">data_sources</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the relation names useable to back Active Record models. For most adapters this means all tables and views.</p> <div class="method-source-code" id="data_sources-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 24
def data_sources
  tables
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop_join_table"> <span class="method-name">drop_join_table</span><span class="method-args">(table_1, table_2, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Drops the join table specified by the given arguments. See <code>create_join_table</code> for details.</p> <p>Although this command ignores the block if one is given, it can be helpful to provide one in a migration's <code>change</code> method so it can be reverted. In that case, the block will be used by create_join_table.</p> <div class="method-source-code" id="drop_join_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 296
def drop_join_table(table_1, table_2, options = {})
  join_table_name = find_join_table_name(table_1, table_2, options)
  drop_table(join_table_name)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop_table"> <span class="method-name">drop_table</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Drops a table from the database.</p> <dl class="rdoc-list label-list">
<dt>
<code>:force</code> </dt>
<dd> <p>Set to <code>:cascade</code> to drop dependent objects as well. Defaults to false.</p> </dd>
</dl> <p>Although this command ignores most <code>options</code> and the block if one is given, it can be helpful to provide these in a migration's <code>change</code> method so it can be reverted. In that case, <code>options</code> and the block will be used by create_table.</p> <div class="method-source-code" id="drop_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 398
def drop_table(table_name, options = {})
  execute "DROP TABLE #{quote_table_name(table_name)}"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-foreign_keys"> <span class="method-name">foreign_keys</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns an array of foreign keys for the given table. The foreign keys are represented as <code>ForeignKeyDefinition</code> objects.</p> <div class="method-source-code" id="foreign_keys-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 715
def foreign_keys(table_name)
  raise NotImplementedError, "foreign_keys is not implemented"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index_exists-3F"> <span class="method-name">index_exists?</span><span class="method-args">(table_name, column_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Checks to see if an index exists on a table for a given index definition.</p> <pre class="ruby" data-language="ruby"># Check an index exists
index_exists?(:suppliers, :company_id)

# Check an index on multiple columns exists
index_exists?(:suppliers, [:company_id, :company_type])

# Check a unique index exists
index_exists?(:suppliers, :company_id, unique: true)

# Check an index with a custom name exists
index_exists?(:suppliers, :company_id, name: "idx_company_id")
</pre> <div class="method-source-code" id="index_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 61
def index_exists?(table_name, column_name, options = {})
  column_names = Array(column_name).map(&amp;:to_s)
  index_name = options.key?(:name) ? options[:name].to_s : index_name(table_name, column: column_names)
  checks = []
  checks &lt;&lt; lambda { |i| i.name == index_name }
  checks &lt;&lt; lambda { |i| i.columns == column_names }
  checks &lt;&lt; lambda { |i| i.unique } if options[:unique]

  indexes(table_name).any? { |i| checks.all? { |check| check[i] } }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index_name_exists-3F"> <span class="method-name">index_name_exists?</span><span class="method-args">(table_name, index_name, default)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Verifies the existence of an index with a given name.</p> <p>The default argument is returned if the underlying implementation does not define the indexes method, as there's no way to determine the correct answer in that case.</p> <div class="method-source-code" id="index_name_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 634
def index_name_exists?(table_name, index_name, default)
  return default unless respond_to?(:indexes)
  index_name = index_name.to_s
  indexes(table_name).detect { |i| i.name == index_name }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-initialize_schema_migrations_table"> <span class="method-name">initialize_schema_migrations_table</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Should not be called normally, but this operation is non-destructive. The migrations module handles this automatically.</p> <div class="method-source-code" id="initialize_schema_migrations_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 835
def initialize_schema_migrations_table
  ActiveRecord::SchemaMigration.create_table
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-native_database_types"> <span class="method-name">native_database_types</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a hash of mappings from the abstract data types to the native database types. See <a href="../tabledefinition/#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a> for details on the recognized abstract data types.</p> <div class="method-source-code" id="native_database_types-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 13
def native_database_types
  {}
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-remove_belongs_to"> <span class="method-name">remove_belongs_to</span><span class="method-args">(table_name, ref_name, options = {})</span> </div>  <div class="aliases"> Alias for: <a href="../schemastatements/#method-i-remove_reference">remove_reference</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_column"> <span class="method-name">remove_column</span><span class="method-args">(table_name, column_name, type = nil, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes the column from the table definition.</p> <pre class="ruby" data-language="ruby">remove_column(:suppliers, :qualification)
</pre> <p>The <code>type</code> and <code>options</code> parameters will be ignored if present. It can be helpful to provide these in a migration's <code>change</code> method so it can be reverted. In that case, <code>type</code> and <code>options</code> will be used by add_column.</p> <div class="method-source-code" id="remove_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 428
def remove_column(table_name, column_name, type = nil, options = {})
  execute "ALTER TABLE #{quote_table_name(table_name)} DROP #{quote_column_name(column_name)}"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_columns"> <span class="method-name">remove_columns</span><span class="method-args">(table_name, *column_names)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes the given columns from the table definition.</p> <pre class="ruby" data-language="ruby">remove_columns(:suppliers, :qualification, :experience)
</pre> <div class="method-source-code" id="remove_columns-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 414
def remove_columns(table_name, *column_names)
  raise ArgumentError.new("You must specify at least one column name. Example: remove_columns(:people, :first_name)") if column_names.empty?
  column_names.each do |column_name|
    remove_column(table_name, column_name)
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_foreign_key"> <span class="method-name">remove_foreign_key</span><span class="method-args">(from_table, options_or_to_table = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes the given foreign key from the table.</p> <p>Removes the foreign key on <code>accounts.branch_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, :branches
</pre> <p>Removes the foreign key on <code>accounts.owner_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, column: :owner_id
</pre> <p>Removes the foreign key named <code>special_fk_name</code> on the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, name: :special_fk_name
</pre> <div class="method-source-code" id="remove_foreign_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 793
def remove_foreign_key(from_table, options_or_to_table = {})
  return unless supports_foreign_keys?

  if options_or_to_table.is_a?(Hash)
    options = options_or_to_table
  else
    options = { column: foreign_key_column_for(options_or_to_table) }
  end

  fk_name_to_delete = options.fetch(:name) do
    fk_to_delete = foreign_keys(from_table).detect {|fk| fk.column == options[:column].to_s }

    if fk_to_delete
      fk_to_delete.name
    else
      raise ArgumentError, "Table '#{from_table}' has no foreign key on column '#{options[:column]}'"
    end
  end

  at = create_alter_table from_table
  at.drop_foreign_key fk_name_to_delete

  execute schema_creation.accept(at)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_index"> <span class="method-name">remove_index</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes the given index from the table.</p> <p>Removes the <code>index_accounts_on_column</code> in the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, :column
</pre> <p>Removes the index named <code>index_accounts_on_branch_id</code> in the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, column: :branch_id
</pre> <p>Removes the index named <code>index_accounts_on_branch_id_and_party_id</code> in the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, column: [:branch_id, :party_id]
</pre> <p>Removes the index named <code>by_branch_party</code> in the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, name: :by_branch_party
</pre> <div class="method-source-code" id="remove_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 592
def remove_index(table_name, options = {})
  remove_index!(table_name, index_name_for_remove(table_name, options))
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_reference"> <span class="method-name">remove_reference</span><span class="method-args">(table_name, ref_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes the reference(s). Also removes a <code>type</code> column if one exists. <code>remove_reference</code>, <code>remove_references</code> and <code>remove_belongs_to</code> are acceptable.</p> <h6 id="method-i-remove_reference-label-Remove+the+reference">Remove the reference</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :user, index: true)
</pre> <h6 id="method-i-remove_reference-label-Remove+polymorphic+reference">Remove polymorphic reference</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :supplier, polymorphic: true)
</pre> <h6 id="method-i-remove_reference-label-Remove+the+reference+with+a+foreign+key">Remove the reference with a foreign key</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :user, index: true, foreign_key: true)
</pre> <div class="method-source-code" id="remove_reference-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 702
def remove_reference(table_name, ref_name, options = {})
  if options[:foreign_key]
    to_table = Base.pluralize_table_names ? ref_name.to_s.pluralize : ref_name
    remove_foreign_key(table_name, to_table)
  end

  remove_column(table_name, "#{ref_name}_id")
  remove_column(table_name, "#{ref_name}_type") if options[:polymorphic]
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../schemastatements/#method-i-remove_belongs_to">remove_belongs_to</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_timestamps"> <span class="method-name">remove_timestamps</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Removes the timestamp columns (<code>created_at</code> and <code>updated_at</code>) from the table definition.</p> <pre class="ruby" data-language="ruby">remove_timestamps(:suppliers)
</pre> <div class="method-source-code" id="remove_timestamps-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 918
def remove_timestamps(table_name, options = {})
  remove_column table_name, :updated_at
  remove_column table_name, :created_at
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_column"> <span class="method-name">rename_column</span><span class="method-args">(table_name, column_name, new_column_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Renames a column.</p> <pre class="ruby" data-language="ruby">rename_column(:suppliers, :description, :name)
</pre> <div class="method-source-code" id="rename_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 479
def rename_column(table_name, column_name, new_column_name)
  raise NotImplementedError, "rename_column is not implemented"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_index"> <span class="method-name">rename_index</span><span class="method-args">(table_name, old_name, new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Renames an index.</p> <p>Rename the <code>index_people_on_last_name</code> index to <code>index_users_on_last_name</code>:</p> <pre class="ruby" data-language="ruby">rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name'
</pre> <div class="method-source-code" id="rename_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 606
def rename_index(table_name, old_name, new_name)
  validate_index_length!(table_name, new_name)

  # this is a naive implementation; some DBs may support this more efficiently (Postgres, for instance)
  old_index_def = indexes(table_name).detect { |i| i.name == old_name }
  return unless old_index_def
  add_index(table_name, old_index_def.columns, name: new_name, unique: old_index_def.unique)
  remove_index(table_name, name: old_name)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_table"> <span class="method-name">rename_table</span><span class="method-args">(table_name, new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Renames a table.</p> <pre class="ruby" data-language="ruby">rename_table('octopuses', 'octopi')
</pre> <div class="method-source-code" id="rename_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 385
def rename_table(table_name, new_name)
  raise NotImplementedError, "rename_table is not implemented"
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_alias_for"> <span class="method-name">table_alias_for</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Truncates a table alias according to the limits of the current adapter.</p> <div class="method-source-code" id="table_alias_for-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 18
def table_alias_for(table_name)
  table_name[0...table_alias_length].tr('.', '_')
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_exists-3F"> <span class="method-name">table_exists?</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Checks to see if the table <code>table_name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">table_exists?(:developers)
</pre> <div class="method-source-code" id="table_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 40
def table_exists?(table_name)
  tables.include?(table_name.to_s)
end</pre> </div> </div> </div> </section> <section id="protected-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Protected Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-add_index_sort_order"> <span class="method-name">add_index_sort_order</span><span class="method-args">(option_strings, column_names, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="add_index_sort_order-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 962
def add_index_sort_order(option_strings, column_names, options = {})
  if options.is_a?(Hash) &amp;&amp; order = options[:order]
    case order
    when Hash
      column_names.each {|name| option_strings[name] += " #{order[name].upcase}" if order.has_key?(name)}
    when String
      column_names.each {|name| option_strings[name] += " #{order.upcase}"}
    end
  end

  return option_strings
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index_name_for_remove"> <span class="method-name">index_name_for_remove</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="index_name_for_remove-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 991
def index_name_for_remove(table_name, options = {})
  index_name = index_name(table_name, options)

  unless index_name_exists?(table_name, index_name, true)
    if options.is_a?(Hash) &amp;&amp; options.has_key?(:name)
      options_without_column = options.dup
      options_without_column.delete :column
      index_name_without_column = index_name(table_name, options_without_column)

      return index_name_without_column if index_name_exists?(table_name, index_name_without_column, false)
    end

    raise ArgumentError, "Index name '#{index_name}' on table '#{table_name}' does not exist"
  end

  index_name
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-options_include_default-3F"> <span class="method-name">options_include_default?</span><span class="method-args">(options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="options_include_default-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 987
def options_include_default?(options)
  options.include?(:default) &amp;&amp; !(options[:null] == false &amp;&amp; options[:default].nil?)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-quoted_columns_for_index"> <span class="method-name">quoted_columns_for_index</span><span class="method-args">(column_names, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Overridden by the MySQL adapter for supporting index lengths</p> <div class="method-source-code" id="quoted_columns_for_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 976
def quoted_columns_for_index(column_names, options = {})
  option_strings = Hash[column_names.map {|name| [name, '']}]

  # add index sort order if supported
  if supports_index_sort_order?
    option_strings = add_index_sort_order(option_strings, column_names, options)
  end

  column_names.map {|name| quote_column_name(name) + option_strings[name]}
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_column_indexes"> <span class="method-name">rename_column_indexes</span><span class="method-args">(table_name, column_name, new_column_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="rename_column_indexes-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1018
def rename_column_indexes(table_name, column_name, new_column_name)
  column_name, new_column_name = column_name.to_s, new_column_name.to_s
  indexes(table_name).each do |index|
    next unless index.columns.include?(new_column_name)
    old_columns = index.columns.dup
    old_columns[old_columns.index(new_column_name)] = column_name
    generated_index_name = index_name(table_name, column: old_columns)
    if generated_index_name == index.name
      rename_index table_name, generated_index_name, index_name(table_name, column: index.columns)
    end
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_table_indexes"> <span class="method-name">rename_table_indexes</span><span class="method-args">(table_name, new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="rename_table_indexes-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1009
def rename_table_indexes(table_name, new_name)
  indexes(new_name).each do |index|
    generated_index_name = index_name(table_name, column: index.columns)
    if generated_index_name == index.name
      rename_index new_name, generated_index_name, index_name(new_name, column: index.columns)
    end
  end
end</pre> </div> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
     20042017 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
