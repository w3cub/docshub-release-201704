
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Complex - Ruby 2.2 - W3cubDocs</title>
  
  <meta name="description" content="A complex number can be represented as a paired real number with imaginary unit; a+bi. Where a is real part, b is imaginary part and i is imaginary &hellip;">
  <meta name="keywords" content="class, complex, -, ruby, ruby~2.2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.2/complex/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/ruby~2.2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.2/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
<h1 id="class-Complex" class="class"> class Complex </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../numeric/">Numeric</a></dd>
</dl> <section class="description"> <p>A complex number can be represented as a paired real number with imaginary unit; a+bi. Where a is real part, b is imaginary part and i is imaginary unit. Real a equals complex a+0i mathematically.</p> <p>In ruby, you can create complex object with <a href="../complex/">Complex</a>, <a href="../complex/#method-c-rect">::rect</a>, <a href="../complex/#method-c-polar">::polar</a> or <a href="../complex/#method-i-to_c">#to_c</a> method.</p> <pre class="ruby">Complex(1)           #=&gt; (1+0i)
Complex(2, 3)        #=&gt; (2+3i)
Complex.polar(2, 3)  #=&gt; (-1.9799849932008908+0.2822400161197344i)
3.to_c               #=&gt; (3+0i)
</pre> <p>You can also create complex object from floating-point numbers or strings.</p> <pre class="ruby">Complex(0.3)         #=&gt; (0.3+0i)
Complex('0.3-0.5i')  #=&gt; (0.3-0.5i)
Complex('2/3+3/4i')  #=&gt; ((2/3)+(3/4)*i)
Complex('1@2')       #=&gt; (-0.4161468365471424+0.9092974268256817i)

0.3.to_c             #=&gt; (0.3+0i)
'0.3-0.5i'.to_c      #=&gt; (0.3-0.5i)
'2/3+3/4i'.to_c      #=&gt; ((2/3)+(3/4)*i)
'1@2'.to_c           #=&gt; (-0.4161468365471424+0.9092974268256817i)
</pre> <p>A complex object is either an exact or an inexact number.</p> <pre class="ruby">Complex(1, 1) / 2    #=&gt; ((1/2)+(1/2)*i)
Complex(1, 1) / 2.0  #=&gt; (0.5+0.5i)
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="I">I </dt>
<dd>
<p>The imaginary unit.</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(object)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="json_create-source"> <pre class="ruby"># File ext/json/lib/json/add/complex.rb, line 7
def self.json_create(object)
  Complex(object['r'], object['i'])
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-polar"> <span class="method-callseq"> polar(abs[, arg]) → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a complex object which denotes the given polar form.</p> <pre class="ruby">Complex.polar(3, 0)            #=&gt; (3.0+0.0i)
Complex.polar(3, Math::PI/2)   #=&gt; (1.836909530733566e-16+3.0i)
Complex.polar(3, Math::PI)     #=&gt; (-3.0+3.673819061467132e-16i)
Complex.polar(3, -Math::PI/2)  #=&gt; (1.836909530733566e-16-3.0i)
</pre> <div class="method-source-code" id="polar-source"> <pre class="c">static VALUE
nucomp_s_polar(int argc, VALUE *argv, VALUE klass)
{
    VALUE abs, arg;

    switch (rb_scan_args(argc, argv, "11", &amp;abs, &amp;arg)) {
      case 1:
        nucomp_real_check(abs);
        arg = ZERO;
        break;
      default:
        nucomp_real_check(abs);
        nucomp_real_check(arg);
        break;
    }
    return f_complex_polar(klass, abs, arg);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rect"> <span class="method-callseq"> rect(real[, imag]) → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> rectangular(real[, imag]) → complex </span> </div> <div class="method-description"> <p>Returns a complex object which denotes the given rectangular form.</p> <pre class="ruby">Complex.rectangular(1, 2)  #=&gt; (1+2i)
</pre> <div class="method-source-code" id="rect-source"> <pre class="c">static VALUE
nucomp_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE real, imag;

    switch (rb_scan_args(argc, argv, "11", &amp;real, &amp;imag)) {
      case 1:
        nucomp_real_check(real);
        imag = ZERO;
        break;
      default:
        nucomp_real_check(real);
        nucomp_real_check(imag);
        break;
    }

    return nucomp_s_canonicalize_internal(klass, real, imag);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rectangular"> <span class="method-callseq"> rectangular(real[, imag]) → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a complex object which denotes the given rectangular form.</p> <pre class="ruby">Complex.rectangular(1, 2)  #=&gt; (1+2i)
</pre> <div class="method-source-code" id="rectangular-source"> <pre class="c">static VALUE
nucomp_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE real, imag;

    switch (rb_scan_args(argc, argv, "11", &amp;real, &amp;imag)) {
      case 1:
        nucomp_real_check(real);
        imag = ZERO;
        break;
      default:
        nucomp_real_check(real);
        nucomp_real_check(imag);
        break;
    }

    return nucomp_s_canonicalize_internal(klass, real, imag);
}</pre> </div> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-2A"> <span class="method-callseq"> cmp * numeric → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Performs multiplication.</p> <pre class="ruby">Complex(2, 3)  * Complex(2, 3)   #=&gt; (-5+12i)
Complex(900)   * Complex(1)      #=&gt; (900+0i)
Complex(-2, 9) * Complex(-9, 2)  #=&gt; (0-85i)
Complex(9, 8)  * 4               #=&gt; (36+32i)
Complex(20, 9) * 9.8             #=&gt; (196.0+88.2i)
</pre> <div class="method-source-code" id="2A-source"> <pre class="c">static VALUE
nucomp_mul(VALUE self, VALUE other)
{
    if (k_complex_p(other)) {
        VALUE real, imag;

        get_dat2(self, other);

        real = f_sub(f_mul(adat-&gt;real, bdat-&gt;real),
                     f_mul(adat-&gt;imag, bdat-&gt;imag));
        imag = f_add(f_mul(adat-&gt;real, bdat-&gt;imag),
                     f_mul(adat-&gt;imag, bdat-&gt;real));

        return f_complex_new2(CLASS_OF(self), real, imag);
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        get_dat1(self);

        return f_complex_new2(CLASS_OF(self),
                              f_mul(dat-&gt;real, other),
                              f_mul(dat-&gt;imag, other));
    }
    return rb_num_coerce_bin(self, other, '*');
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2A-2A"> <span class="method-callseq"> cmp ** numeric → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Performs exponentiation.</p> <pre class="ruby">Complex('i') ** 2              #=&gt; (-1+0i)
Complex(-8) ** Rational(1, 3)  #=&gt; (1.0000000000000002+1.7320508075688772i)
</pre> <div class="method-source-code" id="2A-2A-source"> <pre class="c">static VALUE
nucomp_expt(VALUE self, VALUE other)
{
    if (k_numeric_p(other) &amp;&amp; k_exact_zero_p(other))
        return f_complex_new_bang1(CLASS_OF(self), ONE);

    if (k_rational_p(other) &amp;&amp; f_one_p(f_denominator(other)))
        other = f_numerator(other); /* c14n */

    if (k_complex_p(other)) {
        get_dat1(other);

        if (k_exact_zero_p(dat-&gt;imag))
            other = dat-&gt;real; /* c14n */
    }

    if (k_complex_p(other)) {
        VALUE r, theta, nr, ntheta;

        get_dat1(other);

        r = f_abs(self);
        theta = f_arg(self);

        nr = m_exp_bang(f_sub(f_mul(dat-&gt;real, m_log_bang(r)),
                              f_mul(dat-&gt;imag, theta)));
        ntheta = f_add(f_mul(theta, dat-&gt;real),
                       f_mul(dat-&gt;imag, m_log_bang(r)));
        return f_complex_polar(CLASS_OF(self), nr, ntheta);
    }
    if (k_fixnum_p(other)) {
        if (f_gt_p(other, ZERO)) {
            VALUE x, z;
            long n;

            x = self;
            z = x;
            n = FIX2LONG(other) - 1;

            while (n) {
                long q, r;

                while (1) {
                    get_dat1(x);

                    q = n / 2;
                    r = n % 2;

                    if (r)
                        break;

                    x = nucomp_s_new_internal(CLASS_OF(self),
                                       f_sub(f_mul(dat-&gt;real, dat-&gt;real),
                                             f_mul(dat-&gt;imag, dat-&gt;imag)),
                                       f_mul(f_mul(TWO, dat-&gt;real), dat-&gt;imag));
                    n = q;
                }
                z = f_mul(z, x);
                n--;
            }
            return z;
        }
        return f_expt(f_reciprocal(self), f_negate(other));
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        VALUE r, theta;

        if (k_bignum_p(other))
            rb_warn("in a**b, b may be too big");

        r = f_abs(self);
        theta = f_arg(self);

        return f_complex_polar(CLASS_OF(self), f_expt(r, other),
                               f_mul(theta, other));
    }
    return rb_num_coerce_bin(self, other, id_expt);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2B"> <span class="method-callseq"> cmp + numeric → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Performs addition.</p> <pre class="ruby">Complex(2, 3)  + Complex(2, 3)   #=&gt; (4+6i)
Complex(900)   + Complex(1)      #=&gt; (901+0i)
Complex(-2, 9) + Complex(-9, 2)  #=&gt; (-11+11i)
Complex(9, 8)  + 4               #=&gt; (13+8i)
Complex(20, 9) + 9.8             #=&gt; (29.8+9i)
</pre> <div class="method-source-code" id="2B-source"> <pre class="c">static VALUE
nucomp_add(VALUE self, VALUE other)
{
    return f_addsub(self, other, f_add, '+');
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2D"> <span class="method-callseq"> cmp - numeric → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Performs subtraction.</p> <pre class="ruby">Complex(2, 3)  - Complex(2, 3)   #=&gt; (0+0i)
Complex(900)   - Complex(1)      #=&gt; (899+0i)
Complex(-2, 9) - Complex(-9, 2)  #=&gt; (7+7i)
Complex(9, 8)  - 4               #=&gt; (5+8i)
Complex(20, 9) - 9.8             #=&gt; (10.2+9i)
</pre> <div class="method-source-code" id="2D-source"> <pre class="c">static VALUE
nucomp_sub(VALUE self, VALUE other)
{
    return f_addsub(self, other, f_sub, '-');
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2D-40"> <span class="method-callseq"> -cmp → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns negation of the value.</p> <pre class="ruby">-Complex(1, 2)  #=&gt; (-1-2i)
</pre> <div class="method-source-code" id="2D-40-source"> <pre class="c">static VALUE
nucomp_negate(VALUE self)
{
  get_dat1(self);
  return f_complex_new2(CLASS_OF(self),
                        f_negate(dat-&gt;real), f_negate(dat-&gt;imag));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-2F"> <span class="method-callseq"> cmp / numeric → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> quo(numeric) → complex </span> </div> <div class="method-description"> <p>Performs division.</p> <pre class="ruby">Complex(2, 3)  / Complex(2, 3)   #=&gt; ((1/1)+(0/1)*i)
Complex(900)   / Complex(1)      #=&gt; ((900/1)+(0/1)*i)
Complex(-2, 9) / Complex(-9, 2)  #=&gt; ((36/85)-(77/85)*i)
Complex(9, 8)  / 4               #=&gt; ((9/4)+(2/1)*i)
Complex(20, 9) / 9.8             #=&gt; (2.0408163265306123+0.9183673469387754i)
</pre> <div class="method-source-code" id="2F-source"> <pre class="c">static VALUE
nucomp_div(VALUE self, VALUE other)
{
    return f_divide(self, other, f_quo, id_quo);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> cmp == object → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if cmp equals object numerically.</p> <pre class="ruby">Complex(2, 3)  == Complex(2, 3)   #=&gt; true
Complex(5)     == 5               #=&gt; true
Complex(0)     == 0.0             #=&gt; true
Complex('1/3') == 0.33            #=&gt; false
Complex('1/2') == '1/2'           #=&gt; false
</pre> <div class="method-source-code" id="3D-3D-source"> <pre class="c">static VALUE
nucomp_eqeq_p(VALUE self, VALUE other)
{
    if (k_complex_p(other)) {
        get_dat2(self, other);

        return f_boolcast(f_eqeq_p(adat-&gt;real, bdat-&gt;real) &amp;&amp;
                          f_eqeq_p(adat-&gt;imag, bdat-&gt;imag));
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        get_dat1(self);

        return f_boolcast(f_eqeq_p(dat-&gt;real, other) &amp;&amp; f_zero_p(dat-&gt;imag));
    }
    return f_eqeq_p(other, self);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-abs"> <span class="method-callseq"> abs → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the absolute part of its polar form.</p> <pre class="ruby">Complex(-1).abs         #=&gt; 1
Complex(3.0, -4.0).abs  #=&gt; 5.0
</pre> <div class="method-source-code" id="abs-source"> <pre class="c">static VALUE
nucomp_abs(VALUE self)
{
    get_dat1(self);

    if (f_zero_p(dat-&gt;real)) {
        VALUE a = f_abs(dat-&gt;imag);
        if (k_float_p(dat-&gt;real) &amp;&amp; !k_float_p(dat-&gt;imag))
            a = f_to_f(a);
        return a;
    }
    if (f_zero_p(dat-&gt;imag)) {
        VALUE a = f_abs(dat-&gt;real);
        if (!k_float_p(dat-&gt;real) &amp;&amp; k_float_p(dat-&gt;imag))
            a = f_to_f(a);
        return a;
    }
    return m_hypot(dat-&gt;real, dat-&gt;imag);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-abs2"> <span class="method-callseq"> abs2 → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns square of the absolute value.</p> <pre class="ruby">Complex(-1).abs2         #=&gt; 1
Complex(3.0, -4.0).abs2  #=&gt; 25.0
</pre> <div class="method-source-code" id="abs2-source"> <pre class="c">static VALUE
nucomp_abs2(VALUE self)
{
    get_dat1(self);
    return f_add(f_mul(dat-&gt;real, dat-&gt;real),
                 f_mul(dat-&gt;imag, dat-&gt;imag));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-angle"> <span class="method-callseq"> angle → float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the angle part of its polar form.</p> <pre class="ruby">Complex.polar(3, Math::PI/2).arg  #=&gt; 1.5707963267948966
</pre> <div class="method-source-code" id="angle-source"> <pre class="c">static VALUE
nucomp_arg(VALUE self)
{
    get_dat1(self);
    return m_atan2_bang(dat-&gt;imag, dat-&gt;real);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-arg"> <span class="method-callseq"> arg → float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the angle part of its polar form.</p> <pre class="ruby">Complex.polar(3, Math::PI/2).arg  #=&gt; 1.5707963267948966
</pre> <div class="method-source-code" id="arg-source"> <pre class="c">static VALUE
nucomp_arg(VALUE self)
{
    get_dat1(self);
    return m_atan2_bang(dat-&gt;imag, dat-&gt;real);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="as_json-source"> <pre class="ruby"># File ext/json/lib/json/add/complex.rb, line 11
def as_json(*)
  {
    JSON.create_id =&gt; self.class.name,
    'r'            =&gt; real,
    'i'            =&gt; imag,
  }
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-conj"> <span class="method-callseq"> conj → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> conjugate → complex </span> </div> <div class="method-description"> <p>Returns the complex conjugate.</p> <pre class="ruby">Complex(1, 2).conjugate  #=&gt; (1-2i)
</pre> <div class="method-source-code" id="conj-source"> <pre class="c">static VALUE
nucomp_conj(VALUE self)
{
    get_dat1(self);
    return f_complex_new2(CLASS_OF(self), dat-&gt;real, f_negate(dat-&gt;imag));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-conjugate"> <span class="method-callseq"> conjugate → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the complex conjugate.</p> <pre class="ruby">Complex(1, 2).conjugate  #=&gt; (1-2i)
</pre> <div class="method-source-code" id="conjugate-source"> <pre class="c">static VALUE
nucomp_conj(VALUE self)
{
    get_dat1(self);
    return f_complex_new2(CLASS_OF(self), dat-&gt;real, f_negate(dat-&gt;imag));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-denominator"> <span class="method-callseq"> denominator → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the denominator (lcm of both denominator - real and imag).</p> <p>See numerator.</p> <div class="method-source-code" id="denominator-source"> <pre class="c">static VALUE
nucomp_denominator(VALUE self)
{
    get_dat1(self);
    return rb_lcm(f_denominator(dat-&gt;real), f_denominator(dat-&gt;imag));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fdiv"> <span class="method-callseq"> fdiv(numeric) → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Performs division as each part is a float, never returns a float.</p> <pre class="ruby">Complex(11, 22).fdiv(3)  #=&gt; (3.6666666666666665+7.333333333333333i)
</pre> <div class="method-source-code" id="fdiv-source"> <pre class="c">static VALUE
nucomp_fdiv(VALUE self, VALUE other)
{
    return f_divide(self, other, f_fdiv, id_fdiv);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-imag"> <span class="method-callseq"> imag → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> imaginary → real </span> </div> <div class="method-description"> <p>Returns the imaginary part.</p> <pre class="ruby">Complex(7).imaginary      #=&gt; 0
Complex(9, -4).imaginary  #=&gt; -4
</pre> <div class="method-source-code" id="imag-source"> <pre class="c">static VALUE
nucomp_imag(VALUE self)
{
    get_dat1(self);
    return dat-&gt;imag;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-imaginary"> <span class="method-callseq"> imaginary → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the imaginary part.</p> <pre class="ruby">Complex(7).imaginary      #=&gt; 0
Complex(9, -4).imaginary  #=&gt; -4
</pre> <div class="method-source-code" id="imaginary-source"> <pre class="c">static VALUE
nucomp_imag(VALUE self)
{
    get_dat1(self);
    return dat-&gt;imag;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the value as a string for inspection.</p> <pre class="ruby">Complex(2).inspect                       #=&gt; "(2+0i)"
Complex('-8/6').inspect                  #=&gt; "((-4/3)+0i)"
Complex('1/2i').inspect                  #=&gt; "(0+(1/2)*i)"
Complex(0, Float::INFINITY).inspect      #=&gt; "(0+Infinity*i)"
Complex(Float::NAN, Float::NAN).inspect  #=&gt; "(NaN+NaN*i)"
</pre> <div class="method-source-code" id="inspect-source"> <pre class="c">static VALUE
nucomp_inspect(VALUE self)
{
    VALUE s;

    s = rb_usascii_str_new2("(");
    rb_str_concat(s, f_format(self, rb_inspect));
    rb_str_cat2(s, ")");

    return s;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-magnitude"> <span class="method-callseq"> magnitude → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the absolute part of its polar form.</p> <pre class="ruby">Complex(-1).abs         #=&gt; 1
Complex(3.0, -4.0).abs  #=&gt; 5.0
</pre> <div class="method-source-code" id="magnitude-source"> <pre class="c">static VALUE
nucomp_abs(VALUE self)
{
    get_dat1(self);

    if (f_zero_p(dat-&gt;real)) {
        VALUE a = f_abs(dat-&gt;imag);
        if (k_float_p(dat-&gt;real) &amp;&amp; !k_float_p(dat-&gt;imag))
            a = f_to_f(a);
        return a;
    }
    if (f_zero_p(dat-&gt;imag)) {
        VALUE a = f_abs(dat-&gt;real);
        if (!k_float_p(dat-&gt;real) &amp;&amp; k_float_p(dat-&gt;imag))
            a = f_to_f(a);
        return a;
    }
    return m_hypot(dat-&gt;real, dat-&gt;imag);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-numerator"> <span class="method-callseq"> numerator → numeric </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the numerator.</p> <pre>    1   2       3+4i  &lt;-  numerator
    - + -i  -&gt;  ----
    2   3        6    &lt;-  denominator

c = Complex('1/2+2/3i')  #=&gt; ((1/2)+(2/3)*i)
n = c.numerator          #=&gt; (3+4i)
d = c.denominator        #=&gt; 6
n / d                    #=&gt; ((1/2)+(2/3)*i)
Complex(Rational(n.real, d), Rational(n.imag, d))
                         #=&gt; ((1/2)+(2/3)*i)</pre> <p>See denominator.</p> <div class="method-source-code" id="numerator-source"> <pre class="c">static VALUE
nucomp_numerator(VALUE self)
{
    VALUE cd;

    get_dat1(self);

    cd = f_denominator(self);
    return f_complex_new2(CLASS_OF(self),
                          f_mul(f_numerator(dat-&gt;real),
                                f_div(cd, f_denominator(dat-&gt;real))),
                          f_mul(f_numerator(dat-&gt;imag),
                                f_div(cd, f_denominator(dat-&gt;imag))));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-phase"> <span class="method-callseq"> phase → float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the angle part of its polar form.</p> <pre class="ruby">Complex.polar(3, Math::PI/2).arg  #=&gt; 1.5707963267948966
</pre> <div class="method-source-code" id="phase-source"> <pre class="c">static VALUE
nucomp_arg(VALUE self)
{
    get_dat1(self);
    return m_atan2_bang(dat-&gt;imag, dat-&gt;real);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-polar"> <span class="method-callseq"> polar → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns an array; [cmp.abs, cmp.arg].</p> <pre class="ruby">Complex(1, 2).polar  #=&gt; [2.23606797749979, 1.1071487177940904]
</pre> <div class="method-source-code" id="polar-source"> <pre class="c">static VALUE
nucomp_polar(VALUE self)
{
    return rb_assoc_new(f_abs(self), f_arg(self));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-quo"> <span class="method-callseq"> cmp / numeric → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> quo(numeric) → complex </span> </div> <div class="method-description"> <p>Performs division.</p> <pre class="ruby">Complex(2, 3)  / Complex(2, 3)   #=&gt; ((1/1)+(0/1)*i)
Complex(900)   / Complex(1)      #=&gt; ((900/1)+(0/1)*i)
Complex(-2, 9) / Complex(-9, 2)  #=&gt; ((36/85)-(77/85)*i)
Complex(9, 8)  / 4               #=&gt; ((9/4)+(2/1)*i)
Complex(20, 9) / 9.8             #=&gt; (2.0408163265306123+0.9183673469387754i)
</pre> <div class="method-source-code" id="quo-source"> <pre class="c">static VALUE
nucomp_div(VALUE self, VALUE other)
{
    return f_divide(self, other, f_quo, id_quo);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rationalize"> <span class="method-callseq"> rationalize([eps]) → rational </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the value as a rational if possible (the imaginary part should be exactly zero).</p> <pre class="ruby">Complex(1.0/3, 0).rationalize  #=&gt; (1/3)
Complex(1, 0.0).rationalize    # RangeError
Complex(1, 2).rationalize      # RangeError
</pre> <p>See to_r.</p> <div class="method-source-code" id="rationalize-source"> <pre class="c">static VALUE
nucomp_rationalize(int argc, VALUE *argv, VALUE self)
{
    get_dat1(self);

    rb_scan_args(argc, argv, "01", NULL);

    if (k_inexact_p(dat-&gt;imag) || f_nonzero_p(dat-&gt;imag)) {
       rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Rational",
                self);
    }
    return rb_funcall2(dat-&gt;real, rb_intern("rationalize"), argc, argv);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-real"> <span class="method-callseq"> real → real </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the real part.</p> <pre class="ruby">Complex(7).real      #=&gt; 7
Complex(9, -4).real  #=&gt; 9
</pre> <div class="method-source-code" id="real-source"> <pre class="c">static VALUE
nucomp_real(VALUE self)
{
    get_dat1(self);
    return dat-&gt;real;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-real-3F"> <span class="method-callseq"> real? → false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns false.</p> <div class="method-source-code" id="real-3F-source"> <pre class="c">static VALUE
nucomp_false(VALUE self)
{
    return Qfalse;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rect"> <span class="method-callseq"> rect → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> rectangular → array </span> </div> <div class="method-description"> <p>Returns an array; [cmp.real, cmp.imag].</p> <pre class="ruby">Complex(1, 2).rectangular  #=&gt; [1, 2]
</pre> <div class="method-source-code" id="rect-source"> <pre class="c">static VALUE
nucomp_rect(VALUE self)
{
    get_dat1(self);
    return rb_assoc_new(dat-&gt;real, dat-&gt;imag);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rectangular"> <span class="method-callseq"> rect → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> rectangular → array </span> </div> <div class="method-description"> <p>Returns an array; [cmp.real, cmp.imag].</p> <pre class="ruby">Complex(1, 2).rectangular  #=&gt; [1, 2]
</pre> <div class="method-source-code" id="rectangular-source"> <pre class="c">static VALUE
nucomp_rect(VALUE self)
{
    get_dat1(self);
    return rb_assoc_new(dat-&gt;real, dat-&gt;imag);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_c"> <span class="method-callseq"> to_c → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns self.</p> <pre class="ruby">Complex(2).to_c      #=&gt; (2+0i)
Complex(-8, 6).to_c  #=&gt; (-8+6i)
</pre> <div class="method-source-code" id="to_c-source"> <pre class="c">static VALUE
nucomp_to_c(VALUE self)
{
    return self;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_f"> <span class="method-callseq"> to_f → float </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the value as a float if possible (the imaginary part should be exactly zero).</p> <pre class="ruby">Complex(1, 0).to_f    #=&gt; 1.0
Complex(1, 0.0).to_f  # RangeError
Complex(1, 2).to_f    # RangeError
</pre> <div class="method-source-code" id="to_f-source"> <pre class="c">static VALUE
nucomp_to_f(VALUE self)
{
    get_dat1(self);

    if (k_inexact_p(dat-&gt;imag) || f_nonzero_p(dat-&gt;imag)) {
        rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Float",
                 self);
    }
    return f_to_f(dat-&gt;real);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_i"> <span class="method-callseq"> to_i → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the value as an integer if possible (the imaginary part should be exactly zero).</p> <pre class="ruby">Complex(1, 0).to_i    #=&gt; 1
Complex(1, 0.0).to_i  # RangeError
Complex(1, 2).to_i    # RangeError
</pre> <div class="method-source-code" id="to_i-source"> <pre class="c">static VALUE
nucomp_to_i(VALUE self)
{
    get_dat1(self);

    if (k_inexact_p(dat-&gt;imag) || f_nonzero_p(dat-&gt;imag)) {
        rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Integer",
                 self);
    }
    return f_to_i(dat-&gt;real);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="to_json-source"> <pre class="ruby"># File ext/json/lib/json/add/complex.rb, line 19
def to_json(*)
  as_json.to_json
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_r"> <span class="method-callseq"> to_r → rational </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the value as a rational if possible (the imaginary part should be exactly zero).</p> <pre class="ruby">Complex(1, 0).to_r    #=&gt; (1/1)
Complex(1, 0.0).to_r  # RangeError
Complex(1, 2).to_r    # RangeError
</pre> <p>See rationalize.</p> <div class="method-source-code" id="to_r-source"> <pre class="c">static VALUE
nucomp_to_r(VALUE self)
{
    get_dat1(self);

    if (k_inexact_p(dat-&gt;imag) || f_nonzero_p(dat-&gt;imag)) {
        rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Rational",
                 self);
    }
    return f_to_r(dat-&gt;real);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the value as a string.</p> <pre class="ruby">Complex(2).to_s                       #=&gt; "2+0i"
Complex('-8/6').to_s                  #=&gt; "-4/3+0i"
Complex('1/2i').to_s                  #=&gt; "0+1/2i"
Complex(0, Float::INFINITY).to_s      #=&gt; "0+Infinity*i"
Complex(Float::NAN, Float::NAN).to_s  #=&gt; "NaN+NaN*i"
</pre> <div class="method-source-code" id="to_s-source"> <pre class="c">static VALUE
nucomp_to_s(VALUE self)
{
    return f_format(self, rb_String);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-7E"> <span class="method-callseq"> conj → complex </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> conjugate → complex </span> </div> <div class="method-description"> <p>Returns the complex conjugate.</p> <pre class="ruby">Complex(1, 2).conjugate  #=&gt; (1-2i)
</pre> <div class="method-source-code" id="7E-source"> <pre class="c">static VALUE
nucomp_conj(VALUE self)
{
    get_dat1(self);
    return f_complex_new2(CLASS_OF(self), dat-&gt;real, f_negate(dat-&gt;imag));
}</pre> </div> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2016 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
