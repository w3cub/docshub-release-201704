
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ftp - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" ftp ">
  <meta name="keywords" content="ftp, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/inets-6.2/doc/html/ftp/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>ftp</h1> <h2>Module</h2> <p class="REFBODY">ftp</p> <h2>Module summary</h2> <p class="REFBODY">A File Transfer Protocol client.</p> <h2>Description</h2> 
<p>This module implements a client for file transfer according to a subset of the File Transfer Protocol (FTP), see <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc959.txt" target="_blank">RFC 959</a></code>.</p> <p>As from <code class="code">Inets</code> 4.4.1, the FTP client always tries to use passive FTP mode and only resort to active FTP mode if this fails. This default behavior can be changed by start option <code class="bold_code"><a href="#mode">mode</a></code>.</p>  <p>An FTP client can be started in two ways. One is using the <code class="bold_code"><a href="#service_start">Inets service framework</a></code>, the other is to start it directly as a standalone process using function <code class="bold_code"><a href="#open">open</a></code>.</p> <p>For a simple example of an FTP session, see <code class="bold_code"><a href="../ftp_client/">Inets User's Guide</a></code>.</p> <p>In addition to the ordinary functions for receiving and sending files (see <code class="code">recv/2</code>, <code class="code">recv/3</code>, <code class="code">send/2</code>, and <code class="code">send/3</code>) there are functions for receiving remote files as binaries (see <code class="code">recv_bin/2</code>) and for sending binaries to be stored as remote files (see <code class="code">send_bin/3</code>).</p> <p>A set of functions is provvided for sending and receiving contiguous parts of a file to be stored in a remote file. For send, see <code class="code">send_chunk_start/2</code>, <code class="code">send_chunk/2</code>, and <code class="code">send_chunk_end/1</code>. For receive, see <code class="code">recv_chunk_start/2</code> and <code class="code">recv_chunk/</code>).</p> <p>The return values of the following functions depend much on the implementation of the FTP server at the remote host. In particular, the results from <code class="code">ls</code> and <code class="code">nlist</code> varies. Often real errors are not reported as errors by <code class="code">ls</code>, even if, for example, a file or directory does not exist. <code class="code">nlist</code> is usually more strict, but some implementations have the peculiar behaviour of responding with an error if the request is a listing of the contents of a directory that exists but is empty.</p>   <h2 id="id58664">Ftp client service start/stop</h2>  <p>The FTP client can be started and stopped dynamically in runtime by calling the <code class="code">Inets</code> application API <code class="code">inets:start(ftpc, ServiceConfig)</code>, or <code class="code">inets:start(ftpc, ServiceConfig, How)</code>, and <code class="code">inets:stop(ftpc, Pid)</code>. For details, see <code class="bold_code"><a href="../inets/">inets(3)</a></code>.</p> <p>The available configuration options are as follows:</p> <dl> <dt><strong>{host, Host}</strong></dt> <dd id="host">  <p>Host = <code class="code">string() | ip_address()</code></p> </dd> <dt><strong>{port, Port}</strong></dt> <dd id="port">  <p>Port = <code class="code">integer() &gt; 0</code></p> <p>Default is <code class="code">21</code>.</p> </dd> <dt><strong>{mode, Mode}</strong></dt> <dd id="mode">  <p>Mode = <code class="code">active | passive</code></p> <p>Default is <code class="code">passive</code>.</p> </dd> <dt><strong>{verbose, Verbose}</strong></dt> <dd id="verbose">  <p>Verbose = <code class="code">boolean()</code> </p> <p>Determines if the FTP communication is to be verbose or not.</p> <p>Default is <code class="code">false</code>.</p> </dd> <dt><strong>{debug, Debug}</strong></dt> <dd id="debug">  <p>Debug = <code class="code">trace | debug | disable</code> </p> <p>Debugging using the dbg toolkit. </p> <p>Default is <code class="code">disable</code>.</p> </dd> <dt><strong>{ipfamily, IpFamily}</strong></dt> <dd id="ipfamily">  <p>IpFamily = <code class="code">inet | inet6 | inet6fb4</code> </p> <p>With <code class="code">inet6fb4</code> the client behaves as before, that is, tries to use IPv6, and only if that does not work it uses IPv4).</p> <p>Default is <code class="code">inet</code> (IPv4).</p> </dd> <dt><strong>{timeout, Timeout}</strong></dt> <dd id="timeout">  <p>Timeout = <code class="code">non_neg_integer()</code></p> <p>Connection time-out.</p> <p>Default is <code class="code">60000</code> (milliseconds).</p> </dd> <dt><strong>{dtimeout, DTimeout}</strong></dt> <dd id="dtimeout">  <p>DTimeout = <code class="code">non_neg_integer() | infinity</code> </p> <p>Data connect time-out. The time the client waits for the server to connect to the data socket.</p> <p>Default is <code class="code">infinity</code>. </p> </dd> <dt><strong>{progress, Progress}</strong></dt> <dd id="progress">  <p>Progress = <code class="code">ignore | {CBModule, CBFunction, InitProgress}</code></p> <p><code class="code">CBModule = atom()</code>, <code class="code">CBFunction = atom()</code></p> <p><code class="code">InitProgress = term()</code></p> <p>Default is <code class="code">ignore</code>.</p> </dd> </dl> <p>Option <code class="code">progress</code> is intended to be used by applications that want to create some type of progress report, such as a progress bar in a GUI. Default for the progress option is <code class="code">ignore</code>, that is, the option is not used. When the progress option is specified, the following happens when <code class="code">ftp:send/[3,4]</code> or <code class="code">ftp:recv/[3,4]</code> are called:</p> <ul> <li> <p>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the <code class="code">UserProgressTerm</code> that will be used as input the next time the callback function is called.</p> <p><code class="code">CBModule:CBFunction(InitProgress, File, {file_size, FileSize})</code></p> </li> <li> <p>Every time a chunk of bytes is transferred the following call is made:</p> <p><code class="code">CBModule:CBFunction(UserProgressTerm, File, {transfer_size, TransferSize})</code></p> </li> <li> <p>At the end of the file the following call is made to indicate the end of the transfer:</p> <p><code class="code">CBModule:CBFunction(UserProgressTerm, File, {transfer_size, 0})</code></p> </li> </ul> <p>The callback function is to be defined as follows:</p> <p><code class="code">CBModule:CBFunction(UserProgressTerm, File, Size) -&gt; UserProgressTerm</code></p> <p><code class="code">CBModule = CBFunction = atom()</code></p> <p><code class="code">UserProgressTerm = term()</code></p> <p><code class="code">File = string()</code></p> <p><code class="code">Size = {transfer_size, integer()} | {file_size, integer()} | {file_size, unknown}</code></p> <p>For remote files, <code class="code">ftp</code> cannot determine the file size in a platform independent way. In this case the size becomes <code class="code">unknown</code> and it is left to the application to determine the size.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The callback is made by a middleman process, hence the file transfer is not affected by the code in the progress callback function. If the callback crashes, this is detected by the FTP connection process, which then prints an info-report and goes on as if the progress option was set to <code class="code">ignore</code>.</p> </div> </div> <p>The file transfer type is set to the default of the FTP server when the session is opened. This is usually ASCCI mode. </p> <p>The current local working directory (compare <code class="code">lpwd/1</code>) is set to the value reported by <code class="code">file:get_cwd/1</code>, the wanted local directory. </p> <p>The return value <code class="code">Pid</code> is used as a reference to the newly created FTP client in all other functions, and they are to be called by the process that created the connection. The FTP client process monitors the process that created it and terminates if that process terminates.</p>  <h2 id="id78009">Data types</h2>  <p>The following type definitions are used by more than one function in the FTP client API:</p> <p><code class="code">pid()</code> = identifier of an FTP connection</p> <p><code class="code">string()</code> = list of ASCII characters</p> <p><code class="code">shortage_reason()</code> = <code class="code">etnospc | epnospc</code></p> <p><code class="code">restriction_reason()</code> = <code class="code">epath | efnamena | elogin | enotbinary</code> - all restrictions are not always relevant to all functions </p> <p><code class="code">common_reason()</code> = <code class="code">econn | eclosed | term()</code> - some explanation of what went wrong</p>   <h2>Exports</h2> <h3 id="account-2" class="code">account(Pid, Account) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Account = string()
Reason = eacct | common_reason()</pre>

<p>Sets the account for an operation, if needed.</p>     <h3 id="append-3" class="code">append(Pid, LocalFile) -&gt;<br>append(Pid, LocalFile, RemoteFile) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
LocalFile = RemoteFile = string()
Reason = epath | elogin | etnospc | epnospc | efnamena | common_reason</pre>

<p>Transfers the file <code class="code">LocalFile</code> to the remote server. If <code class="code">RemoteFile</code> is specified, the name of the remote file that the file is appended to is set to <code class="code">RemoteFile</code>, otherwise to <code class="code">LocalFile</code>. If the file does not exists, it is created.</p>   <h3 id="append_bin-3" class="code">append_bin(Pid, Bin, RemoteFile) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>      <pre>Pid = pid()
Bin = binary()()
RemoteFile = string()
Reason = restriction_reason()| shortage_reason() | common_reason()</pre>

<p>Transfers the binary <code class="code">Bin</code> to the remote server and appends it to the file <code class="code">RemoteFile</code>. If the file does not exist, it is created.</p>   <h3 id="append_chunk-2" class="code">append_chunk(Pid, Bin) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Bin = binary()
Reason = echunk | restriction_reason() | common_reason()</pre>

<p>Transfers the chunk <code class="code">Bin</code> to the remote server, which appends it to the file specified in the call to <code class="code">append_chunk_start/2</code>.</p> <p>For some errors, for example, file system full, it is necessary to call <code class="code">append_chunk_end</code> to get the proper reason.</p>   <h3 id="append_chunk_start-2" class="code">append_chunk_start(Pid, File) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
File = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Starts the transfer of chunks for appending to the file <code class="code">File</code> at the remote server. If the file does not exist, it is created.</p>   <h3 id="append_chunk_end-1" class="code">append_chunk_end(Pid) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>    <pre>Pid = pid()
Reason = echunk | restriction_reason() | shortage_reason()</pre>

<p>Stops transfer of chunks for appending to the remote server. The file at the remote server, specified in the call to <code class="code">append_chunk_start/2</code>, is closed by the server.</p>   <h3 id="cd-2" class="code">cd(Pid, Dir) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Dir = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Changes the working directory at the remote server to <code class="code">Dir</code>.</p>   <h3 id="close-1" class="code">close(Pid) -&gt; ok</h3>  <p>Types:</p>   <pre>Pid = pid()</pre>

<p>Ends an FTP session, created using function <code class="bold_code"><a href="#open">open</a></code>.</p>   <h3 id="delete-2" class="code">delete(Pid, File) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
File = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Deletes the file <code class="code">File</code> at the remote server.</p>   <h3 id="formaterror-1" class="code">formaterror(Tag) -&gt; string()</h3>  <p>Types:</p>   <pre>Tag = {error, atom()} | atom()</pre>

<p>Given an error return value <code class="code">{error, AtomReason}</code>, this function returns a readable string describing the error.</p>   <h3 id="lcd-2" class="code">lcd(Pid, Dir) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Dir = string()
Reason = restriction_reason()</pre>

<p>Changes the working directory to <code class="code">Dir</code> for the local client.</p>   <h3 id="lpwd-1" class="code">lpwd(Pid) -&gt; {ok, Dir}</h3>  <p>Types:</p>   <pre>Pid = pid()</pre>

<p>Returns the current working directory at the local client.</p>     <h3 id="ls-2" class="code">ls(Pid) -&gt;<br>ls(Pid, Pathname) -&gt; {ok, Listing} | {error, Reason}</h3>  <p>Types:</p>      <pre>Pid = pid()
Pathname = string()
Listing = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Returns a list of files in long format.</p> <p><code class="code">Pathname</code> can be a directory, a group of files, or a file. The <code class="code">Pathname</code> string can contain wildcards.</p> <p><code class="code">ls/1</code> implies the current remote directory of the user.</p> <p>The format of <code class="code">Listing</code> depends on the operating system. On UNIX, it is typically produced from the output of the <code class="code">ls -l</code> shell command.</p>   <h3 id="mkdir-2" class="code">mkdir(Pid, Dir) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Dir = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Creates the directory <code class="code">Dir</code> at the remote server.</p>     <h3 id="nlist-2" class="code">nlist(Pid) -&gt;<br>nlist(Pid, Pathname) -&gt; {ok, Listing} | {error, Reason}</h3>  <p>Types:</p>      <pre>Pid = pid()
Pathname = string()
Listing = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Returns a list of files in short format.</p> <p><code class="code">Pathname</code> can be a directory, a group of files, or a file. The <code class="code">Pathname</code> string can contain wildcards.</p> <p><code class="code">nlist/1</code> implies the current remote directory of the user.</p> <p>The format of <code class="code">Listing</code> is a stream of filenames where each filename is separated by &lt;CRLF&gt; or &lt;NL&gt;. Contrary to function <code class="code">ls</code>, the purpose of <code class="code">nlist</code> is to enable a program to process filename information automatically.</p>   <h3 id="open-2" class="code">open(Host) -&gt; {ok, Pid} | {error, Reason}<br>open(Host, Opts) -&gt; {ok, Pid} | {error, Reason}</h3>  <p>Types:</p>                     <pre>Host = string() | ip_address()
Opts = options()
options() = [option()]
option() = start_option() | open_option()
start_option() = {verbose, verbose()} | {debug, debug()}
verbose() = boolean() (default is false)
debug() = disable | debug | trace (default is disable)
open_option() = {ipfamily, ipfamily()} | {port, port()} | {mode, mode()} | {tls, tls_options()} | {timeout, timeout()} | {dtimeout, dtimeout()} | {progress, progress()}
ipfamily() = inet | inet6 | inet6fb4 (default is inet)
port() = integer() &gt; 0 (default is 21)
mode() = active | passive (default is passive)
tls_options() = [ssl:ssloption()]
timeout() = integer() &gt; 0 (default is 60000 milliseconds)
dtimeout() = integer() &gt; 0 | infinity (default is infinity)
pogress() = ignore | {module(), function(), initial_data()} (default is ignore)
module() = atom()
function() = atom()
initial_data() = term()
Reason = ehost | term()</pre>

<p>Starts a standalone FTP client process (without the <code class="code">Inets</code> service framework) and opens a session with the FTP server at <code class="code">Host</code>. </p> <p>If option <code class="code">{tls, tls_options()}</code> is present, the FTP session is transported over <code class="code">tls</code> (<code class="code">ftps</code>, see <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc4217.txt" target="_blank">RFC 4217</a></code>). The list <code class="code">tls_options()</code> can be empty. The function <code class="bold_code"><span class="code">ssl:connect/3</span></code> is used for securing both the control connection and the data sessions. </p> <p>A session opened in this way is closed using function <code class="bold_code"><a href="#close">close</a></code>.</p>   <h3 id="pwd-1" class="code">pwd(Pid) -&gt; {ok, Dir} | {error, Reason}</h3>  <p>Types:</p>    <pre>Pid = pid()
Reason = restriction_reason() | common_reason()</pre>

<p>Returns the current working directory at the remote server.</p>     <h3 id="recv-3" class="code">recv(Pid, RemoteFile) -&gt;<br>recv(Pid, RemoteFile, LocalFile) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>      <pre>Pid = pid()
RemoteFile = LocalFile = string()
Reason = restriction_reason() | common_reason() | file_write_error_reason()
file_write_error_reason() = see file:write/2</pre>

<p>Transfers the file <code class="code">RemoteFile</code> from the remote server to the file system of the local client. If <code class="code">LocalFile</code> is specified, the local file will be <code class="code">LocalFile</code>, otherwise <code class="code">RemoteFile</code>.</p> <p>If the file write fails (for example, <code class="code">enospc</code>), the command is aborted and <code class="code">{error, file_write_error_reason()}</code> is returned. However, the file is <strong>not</strong> removed.</p>   <h3 id="recv_bin-2" class="code">recv_bin(Pid, RemoteFile) -&gt; {ok, Bin} | {error, Reason}</h3>  <p>Types:</p>      <pre>Pid = pid()
Bin = binary()
RemoteFile = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Transfers the file <code class="code">RemoteFile</code> from the remote server and receives it as a binary.</p>   <h3 id="recv_chunk_start-2" class="code">recv_chunk_start(Pid, RemoteFile) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
RemoteFile = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Starts transfer of the file <code class="code">RemoteFile</code> from the remote server.</p>   <h3 id="recv_chunk-1" class="code">recv_chunk(Pid) -&gt; ok | {ok, Bin} | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Bin = binary()
Reason = restriction_reason() | common_reason()</pre>

<p>Receives a chunk of the remote file (<code class="code">RemoteFile</code> of <code class="code">recv_chunk_start</code>). The return values have the following meaning:</p> <ul> <li> <code class="code">ok</code> = the transfer is complete.</li> <li> <code class="code">{ok, Bin}</code> = just another chunk of the file.</li> <li> <code class="code">{error, Reason}</code> = transfer failed.</li> </ul>   <h3 id="rename-3" class="code">rename(Pid, Old, New) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
CurrFile = NewFile = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Renames <code class="code">Old</code> to <code class="code">New</code> at the remote server.</p>   <h3 id="rmdir-2" class="code">rmdir(Pid, Dir) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Dir = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Removes directory <code class="code">Dir</code> at the remote server.</p>     <h3 id="send-3" class="code">send(Pid, LocalFile) -&gt;<br>send(Pid, LocalFile, RemoteFile) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
LocalFile = RemoteFile = string()
Reason = restriction_reason() | common_reason() | shortage_reason()</pre>

<p>Transfers the file <code class="code">LocalFile</code> to the remote server. If <code class="code">RemoteFile</code> is specified, the name of the remote file is set to <code class="code">RemoteFile</code>, otherwise to <code class="code">LocalFile</code>.</p>   <h3 id="send_bin-3" class="code">send_bin(Pid, Bin, RemoteFile) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>      <pre>Pid = pid()
Bin = binary()()
RemoteFile = string()
Reason = restriction_reason() | common_reason() | shortage_reason()</pre>

<p>Transfers the binary <code class="code">Bin</code> into the file <code class="code">RemoteFile</code> at the remote server.</p>   <h3 id="send_chunk-2" class="code">send_chunk(Pid, Bin) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Bin = binary()
Reason = echunk | restriction_reason() | common_reason()</pre>

<p>Transfers the chunk <code class="code">Bin</code> to the remote server, which writes it into the file specified in the call to <code class="code">send_chunk_start/2</code>.</p> <p>For some errors, for example, file system full, it is necessary to to call <code class="code">send_chunk_end</code> to get the proper reason.</p>   <h3 id="send_chunk_start-2" class="code">send_chunk_start(Pid, File) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
File = string()
Reason = restriction_reason() | common_reason()</pre>

<p>Starts transfer of chunks into the file <code class="code">File</code> at the remote server.</p>   <h3 id="send_chunk_end-1" class="code">send_chunk_end(Pid) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>    <pre>Pid = pid()
Reason = restriction_reason() | common_reason() | shortage_reason()</pre>

<p>Stops transfer of chunks to the remote server. The file at the remote server, specified in the call to <code class="code">send_chunk_start/2</code> is closed by the server.</p>   <h3 id="type-2" class="code">type(Pid, Type) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
Type = ascii | binary
Reason = etype | restriction_reason() | common_reason()</pre>

<p>Sets the file transfer type to <code class="code">ascii</code> or <code class="code">binary</code>. When an FTP session is opened, the default transfer type of the server is used, most often <code class="code">ascii</code>, which is default according to <code class="bold_code"><a href="http://www.ietf.org/rfc/rfc959.txt" target="_blank">RFC 959</a></code>.</p>   <h3 id="user-3" class="code">user(Pid, User, Password) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
User = Password = string()
Reason = euser | common_reason()</pre>

<p>Performs login of <code class="code">User</code> with <code class="code">Password</code>.</p>   <h3 id="user-4" class="code">user(Pid, User, Password, Account) -&gt; ok | {error, Reason}</h3>  <p>Types:</p>     <pre>Pid = pid()
User = Password = string()
Reason = euser | common_reason()</pre>

<p>Performs login of <code class="code">User</code> with <code class="code">Password</code> to the account specified by <code class="code">Account</code>.</p>   <h3 id="quote-2" class="code">quote(Pid, Command) -&gt; [FTPLine]</h3>  <p>Types:</p>     <pre>Pid = pid()
Command = string()
FTPLine = string(</pre>

<div class="note"> <div class="label">Note</div> <div class="content">

<p>The telnet end of line characters, from the FTP protocol definition, CRLF, for example, "\\r\\n" has been removed.</p>
</div> </div> <p>Sends an arbitrary FTP command and returns verbatim a list of the lines sent back by the FTP server. This function is intended to give application accesses to FTP commands that are server-specific or that cannot be provided by this FTP client.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>FTP commands requiring a data connection cannot be successfully issued with this function.</p> </div> </div>  <h2 id="id79974">Errors</h2>  <p>The possible error reasons and the corresponding diagnostic strings returned by <code class="code">formaterror/1</code> are as follows: </p> <dl> <dt><strong><code class="code">echunk</code></strong></dt> <dd> <p>Synchronization error during chunk sending according to one of the following: </p> <ul> <li>A call is made to <code class="code">send_chunk/2</code> or <code class="code">send_chunk_end/1</code> before a call to <code class="code">send_chunk_start/2</code>.</li> <li>A call has been made to another transfer function during chunk sending, that is, before a call to <code class="code">send_chunk_end/1</code>.</li> </ul> </dd> <dt><strong><code class="code">eclosed</code></strong></dt> <dd> <p>The session is closed.</p> </dd> <dt><strong><code class="code">econn</code></strong></dt> <dd> <p>Connection to the remote server is prematurely closed.</p> </dd> <dt><strong><code class="code">ehost</code></strong></dt> <dd> <p>Host is not found, FTP server is not found, or connection is rejected by FTP server.</p> </dd> <dt><strong><code class="code">elogin</code></strong></dt> <dd> <p>User is not logged in.</p> </dd> <dt><strong><code class="code">enotbinary</code></strong></dt> <dd> <p>Term is not a binary.</p> </dd> <dt><strong><code class="code">epath</code></strong></dt> <dd> <p>No such file or directory, or directory already exists, or permission denied.</p> </dd> <dt><strong><code class="code">etype</code></strong></dt> <dd> <p>No such type.</p> </dd> <dt><strong><code class="code">euser</code></strong></dt> <dd> <p>Invalid username or password.</p> </dd> <dt><strong><code class="code">etnospc</code></strong></dt> <dd> <p>Insufficient storage space in system [452].</p> </dd> <dt><strong><code class="code">epnospc</code></strong></dt> <dd> <p>Exceeded storage allocation (for current directory or dataset) [552].</p> </dd> <dt><strong><code class="code">efnamena</code></strong></dt> <dd> <p>Filename not allowed [553].</p> </dd> </dl>  <h2 id="id80171">See also</h2>  <p><code class="bold_code">file(3)</code> <code class="bold_code">filename(3)</code> and J. Postel and J. Reynolds: File Transfer Protocol (<code class="bold_code"><a href="http://www.ietf.org/rfc/rfc959.txt" target="_blank">RFC 959</a></code>). </p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
