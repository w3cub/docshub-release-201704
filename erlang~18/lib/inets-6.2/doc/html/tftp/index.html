
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Tftp - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" tftp ">
  <meta name="keywords" content="tftp, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/inets-6.2/doc/html/tftp/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>tftp</h1> <h2>Module</h2> <p class="REFBODY">tftp</p> <h2>Module summary</h2> <p class="REFBODY">Trivial FTP.</p> <h2>Description</h2> 
<p>This is a complete implementation of the following IETF standards:</p> <ul> <li>RFC 1350, The TFTP Protocol (revision 2)</li> <li>RFC 2347, TFTP Option Extension</li> <li>RFC 2348, TFTP Blocksize Option</li> <li>RFC 2349, TFTP Timeout Interval and Transfer Size Options</li> </ul> <p>The only feature that not is implemented is the "netascii" transfer mode.</p> <p>The <code class="bold_code"><a href="#start-1">start/1</a></code> function starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the transfer.</p> <p>On the client side, function <code class="bold_code"><a href="#read_file-3">read_file/3</a></code> and <code class="bold_code"><a href="#write_file-3">write_file/3</a></code> spawn a temporary client process establishing contact with a TFTP daemon and perform the file transfer.</p> <p><code class="code">tftp</code> uses a callback module to handle the file transfer. Two such callback modules are provided, <code class="code">tftp_binary</code> and <code class="code">tftp_file</code>. See <code class="bold_code"><a href="#read_file-3">read_file/3</a></code> and <code class="bold_code"><a href="#write_file-3">write_file/3</a></code> for details. You can also implement your own callback modules, see <code class="bold_code"><a href="#tftp_callback">CALLBACK FUNCTIONS</a></code>. A callback module provided by the user is registered using option <code class="code">callback</code>, see <code class="bold_code"><a href="#options">DATA TYPES</a></code>.</p>  <h2 id="id80359">Tftp server service start/stop</h2>  <p>A TFTP server can be configured to start statically when starting the <code class="code">Inets</code> application. Alternatively, it can be started dynamically (when <code class="code">Inets</code> is already started) by calling the <code class="code">Inets</code> application API <code class="code">inets:start(tftpd, ServiceConfig)</code> or <code class="code">inets:start(tftpd, ServiceConfig, How)</code>, see <code class="bold_code"><a href="../inets/">inets(3)</a></code> for details. The <code class="code">ServiceConfig</code> for TFTP is described in the <code class="bold_code"><a href="#options">DATA TYPES</a></code> section.</p> <p>The TFTP server can be stopped using <code class="code">inets:stop(tftpd, Pid)</code>, see <code class="bold_code"><a href="../inets/">inets(3)</a></code> for details.</p> <p>The TPFT client is of such a temporary nature that it is not handled as a service in the <code class="code">Inets</code> service framework.</p>  <h2 id="id80433">Data types</h2>   <p><code class="code">ServiceConfig = Options</code></p> <p><code class="code">Options = [option()]</code></p> <p>Most of the options are common for both the client and the server side, but some of them differs a little. The available <code class="code">option()</code>s are as follows:</p> <dl> <dt><strong><code class="code">{debug, Level}</code></strong></dt> <dd> <p><code class="code">Level = none | error | warning | brief | normal | verbose | all</code></p> <p>Controls the level of debug printouts. Default is <code class="code">none</code>.</p> </dd> <dt><strong><code class="code">{host, Host}</code></strong></dt> <dd> <p><code class="code">Host = hostname()</code>, see <code class="bold_code">inet(3)</code>.</p> <p>The name or IP address of the host where the TFTP daemon resides. This option is only used by the client.</p> </dd> <dt><strong><code class="code">{port, Port}</code></strong></dt> <dd> <p><code class="code">Port = int()</code></p> <p>The TFTP port where the daemon listens. Defaults is the standardized number 69. On the server side, it can sometimes make sense to set it to 0, meaning that the daemon just picks a free port (which one is returned by function <code class="code">info/1</code>).</p> <p>If a socket is connected already, option <code class="code">{udp, [{fd, integer()}]}</code> can be used to pass the open file descriptor to <code class="code">gen_udp</code>. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by <code class="code">setuid_socket_wrap</code>, the command-line argument "-tftpd_69 22" triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option <code class="code">{udp, [{fd, 22}]}</code> is automatically added. See <code class="code">init:get_argument/</code> about command-line arguments and <code class="code">gen_udp:open/2</code> about UDP options.</p> </dd> <dt><strong><code class="code">{port_policy, Policy}</code></strong></dt> <dd> <p><code class="code">Policy = random | Port | {range, MinPort, MaxPort}</code></p> <p><code class="code">Port = MinPort = MaxPort = int()</code></p> <p>Policy for the selection of the temporary port that is used by the server/client during the file transfer. Default is <code class="code">random</code>, which is the standardized policy. With this policy a randomized free port is used. A single port or a range of ports can be useful if the protocol passes through a firewall.</p> </dd> <dt><strong><code class="code">{udp, Options}</code></strong></dt> <dd> <p><code class="code">Options = [Opt]</code>, see <code class="bold_code">gen_udp:open/2</code>.</p> </dd> <dt><strong><code class="code">{use_tsize, Bool}</code></strong></dt> <dd> <p><code class="code">Bool = bool()</code></p> <p>Flag for automated use of option <code class="code">tsize</code>. With this set to <code class="code">true</code>, the <code class="code">write_file/3</code> client determines the filesize and sends it to the server as the standardized <code class="code">tsize</code> option. A <code class="code">read_file/3</code> client acquires only a filesize from the server by sending a zero <code class="code">tsize</code>.</p> </dd> <dt><strong><code class="code">{max_tsize, MaxTsize}</code></strong></dt> <dd> <p><code class="code">MaxTsize = int() | infinity</code></p> <p>Threshold for the maximal filesize in bytes. The transfer is aborted if the limit is exceeded. Default is <code class="code">infinity</code>.</p> </dd> <dt><strong><code class="code">{max_conn, MaxConn}</code></strong></dt> <dd> <p><code class="code">MaxConn = int() | infinity</code></p> <p>Threshold for the maximal number of active connections. The daemon rejects the setup of new connections if the limit is exceeded. Default is <code class="code">infinity</code>.</p> </dd> <dt><strong><code class="code">{TftpKey, TftpVal}</code></strong></dt> <dd> <p><code class="code">TftpKey = string()</code> <br> <code class="code">TftpVal = string()</code></p> <p>Name and value of a TFTP option.</p> </dd> <dt><strong><code class="code">{reject, Feature}</code></strong></dt> <dd> <p><code class="code">Feature = Mode | TftpKey</code> <br> <code class="code"> Mode = read | write</code> <br> <code class="code"> TftpKey = string()</code></p> <p>Controls which features to reject. This is mostly useful for the server as it can restrict the use of certain TFTP options or read/write access.</p> </dd> <dt><strong><code class="code">{callback, {RegExp, Module, State}}</code></strong></dt> <dd> <p><code class="code">RegExp = string()</code> <br> <code class="code">Module = atom()</code> <br> <code class="code">State = term()</code></p> <p>Registration of a callback module. When a file is to be transferred, its local filename is matched to the regular expressions of the registered callbacks. The first matching callback is used during the transfer. See <code class="bold_code"><a href="#read_file-3">read_file/3</a></code> and <code class="bold_code"><a href="#write_file-3">write_file/3</a></code>. </p> <p>The callback module must implement the <code class="code">tftp</code> behavior, see <code class="bold_code"><a href="#tftp_callback">CALLBACK FUNCTIONS</a></code>.</p> </dd> <dt><strong><code class="code">{logger, Module}</code></strong></dt> <dd> <p><code class="code">Module = module()()</code></p> <p>Callback module for customized logging of errors, warnings, and info messages. The callback module must implement the <code class="code">tftp_logger</code> behavior, see <code class="bold_code"><a href="#tftp_logger">LOGGER FUNCTIONS</a></code>. The default module is <code class="code">tftp_logger</code>.</p> </dd> <dt><strong><code class="code">{max_retries, MaxRetries}</code></strong></dt> <dd> <p><code class="code">MaxRetries = int()</code></p> <p>Threshold for the maximal number of retries. By default the server/client tries to resend a message up to five times when the time-out expires.</p> </dd> </dl>  <h2>Exports</h2> <h3 id="change_config-2" class="code">change_config(daemons, Options) -&gt; [{Pid, Result}]</h3>  <p>Types:</p>      <pre>Options = [option()]
Pid = pid()
Result = ok | {error, Reason}
Reason = term()</pre>

<p>Changes configuration for all TFTP daemon processes. </p>  <h3 id="change_config-2" class="code">change_config(servers, Options) -&gt; [{Pid, Result}]</h3>  <p>Types:</p>      <pre>Options = [option()]
Pid = pid()
Result = ok | {error, Reason}
Reason = term()</pre>

<p>Changes configuration for all TFTP server processes.</p>  <h3 id="change_config-2" class="code">change_config(Pid, Options) -&gt; Result</h3>  <p>Types:</p>      <pre>Pid = pid()
Options = [option()]
Result = ok | {error, Reason}
Reason = term()</pre>

<p>Changes configuration for a TFTP daemon, server, or client process.</p>  <h3 id="info-1" class="code">info(daemons) -&gt; [{Pid, Options}]</h3>  <p>Types:</p>     <pre>Pid = [pid()()]
Options = [option()]
Reason = term()</pre>

<p>Returns information about all TFTP daemon processes.</p>  <h3 id="info-1" class="code">info(servers) -&gt; [{Pid, Options}]</h3>  <p>Types:</p>     <pre>Pid = [pid()()]
Options = [option()]
Reason = term()</pre>

<p>Returns information about all TFTP server processes. </p>  <h3 id="info-1" class="code">info(Pid) -&gt; {ok, Options} | {error, Reason}</h3>  <p>Types:</p>    <pre>Options = [option()]
Reason = term()</pre>

<p>Returns information about a TFTP daemon, server, or client process.</p>  <h3 id="read_file-3" class="code">read_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</h3>  <p>Types:</p>       <pre>RemoteFilename = string()
LocalFilename = binary | string()
Options = [option()]
LastCallbackState = term()
Reason = term()</pre>

<p>Reads a (virtual) file <code class="code">RemoteFilename</code> from a TFTP server.</p> <p>If <code class="code">LocalFilename</code> is the atom <code class="code">binary</code>, <code class="code">tftp_binary</code> is used as callback module. It concatenates all transferred blocks and returns them as one single binary in <code class="code">LastCallbackState</code>.</p> <p>If <code class="code">LocalFilename</code> is a string and there are no registered callback modules, <code class="code">tftp_file</code> is used as callback module. It writes each transferred block to the file named <code class="code">LocalFilename</code> and returns the number of transferred bytes in <code class="code">LastCallbackState</code>.</p> <p>If <code class="code">LocalFilename</code> is a string and there are registered callback modules, <code class="code">LocalFilename</code> is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</p>  <h3 id="start-1" class="code">start(Options) -&gt; {ok, Pid} | {error, Reason}</h3>  <p>Types:</p>     <pre>Options = [option()]
Pid = pid()
Reason = term()</pre>

<p>Starts a daemon process listening for UDP packets on a port. When it receives a request for read or write, it spawns a temporary server process handling the actual transfer of the (virtual) file.</p>  <h3 id="write_file-3" class="code">write_file(RemoteFilename, LocalFilename, Options) -&gt; {ok, LastCallbackState} | {error, Reason}</h3>  <p>Types:</p>       <pre>RemoteFilename = string()
LocalFilename = binary() | string()
Options = [option()]
LastCallbackState = term()
Reason = term()</pre>

<p>Writes a (virtual) file <code class="code">RemoteFilename</code> to a TFTP server.</p> <p>If <code class="code">LocalFilename</code> is a binary, <code class="code">tftp_binary</code> is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in <code class="code">LastCallbackState</code>.</p> <p>If <code class="code">LocalFilename</code> is a string and there are no registered callback modules, <code class="code">tftp_file</code> is used as callback module. It reads the file named <code class="code">LocalFilename</code> block by block and returns the number of transferred bytes in <code class="code">LastCallbackState</code>.</p> <p>If <code class="code">LocalFilename</code> is a string and there are registered callback modules, <code class="code">LocalFilename</code> is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</p>  <h2 id="id81310">Callback functions</h2>   <p>A <code class="code">tftp</code> callback module is to be implemented as a <code class="code">tftp</code> behavior and export the functions listed in the following.</p> <p>On the server side, the callback interaction starts with a call to <code class="code">open/5</code> with the registered initial callback state. <code class="code">open/5</code> is expected to open the (virtual) file. Then either function <code class="code">read/1</code> or <code class="code">write/2</code> is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function <code class="code">read/1</code> or <code class="code">write/2</code> is expected to close the (virtual) file and return its last state. Function <code class="code">abort/3</code> is only used in error situations. Function <code class="code">prepare/5</code> is not used on the server side.</p> <p>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to <code class="code">prepare/5</code> with the same arguments as <code class="code">open/5</code> takes. <code class="code">prepare/5</code> is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function <code class="code">open/5</code> on the client side. On the client side, function <code class="code">open/5</code> must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in <code class="code">read/1</code> or <code class="code">write/2</code>, the returned state is forwarded to the user and returned from <code class="code">read_file</code>/3 or <code class="code">write_file/3</code>.</p> <p> If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</p> <p>If the TFTP server receives yet another request from the same client (same host and port) while it already has an active connection to the client, it ignores the new request if the request is equal to the first one (same filename and options). This implies that the (new) client will be served by the already ongoing connection on the server side. By not setting up yet another connection, in parallel with the ongoing one, the server consumes less resources.</p>   <h2>Exports</h2> <h3 id="Module:abort-3" class="code">Module:abort(Code, Text, State) -&gt; ok</h3>  <p>Types:</p>       <pre>Code = undef | enoent | eacces | enospc
  | badop | eexist | baduser | badopt
  | int()
Text = string()
State = term()</pre>

<p>Invoked when the file transfer is aborted.</p> <p>The callback function is expected to clean up its used resources after the aborted file transfer, such as closing open file descriptors and so on. The function is not invoked if any of the other callback functions returns an error, as it is expected that they already have cleaned up the necessary resources. However, it is invoked if the functions fail (crash).</p>  <h3 id="Module:open-6" class="code">Module:open(Peer, Access, Filename, Mode, SuggestedOptions, State) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</h3>  <p>Types:</p>                  <pre>Peer = {PeerType, PeerHost, PeerPort}
PeerType = inet | inet6
PeerHost = ip_address()
PeerPort = integer()
Access = read | write
Filename = string()
Mode = string()
SuggestedOptions = AcceptedOptions = [{Key, Value}]
 Key = Value = string()
State = InitialState | term()
 InitialState = [] | [{root_dir, string()}]
NewState = term()
Code = undef | enoent | eacces | enospc
  | badop | eexist | baduser | badopt
  | int()
Text = string()</pre>

<p>Opens a file for read or write access.</p> <p>On the client side, where the <code class="code">open/5</code> call has been preceded by a call to <code class="code">prepare/5</code>, all options must be accepted or rejected.</p> <p>On the server side, where there is no preceding <code class="code">prepare/5</code> call, no new options can be added, but those present in <code class="code">SuggestedOptions</code> can be omitted or replaced with new values in <code class="code">AcceptedOptions</code>.</p>   <h3 id="Module:prepare-6" class="code">Module:prepare(Peer, Access, Filename, Mode, SuggestedOptions, InitialState) -&gt; {ok, AcceptedOptions, NewState} | {error, {Code, Text}}</h3>  <p>Types:</p>                 <pre>Peer = {PeerType, PeerHost, PeerPort}
PeerType = inet | inet6
PeerHost = ip_address()
PeerPort = integer()
Access = read | write
Filename = string()
Mode = string()
SuggestedOptions = AcceptedOptions = [{Key, Value}]
 Key = Value = string()
InitialState = [] | [{root_dir, string()}]
NewState = term()
Code = undef | enoent | eacces | enospc
  | badop | eexist | baduser | badopt
  | int()
Text = string()</pre>

<p>Prepares to open a file on the client side.</p> <p>No new options can be added, but those present in <code class="code">SuggestedOptions</code> can be omitted or replaced with new values in <code class="code">AcceptedOptions</code>.</p> <p>This is followed by a call to <code class="code">open/4</code> before any read/write access is performed. <code class="code">AcceptedOptions</code> is sent to the server, which replies with the options that it accepts. These are then forwarded to <code class="code">open/4</code> as <code class="code">SuggestedOptions</code>.</p>   <h3 id="Module:read-1" class="code">Module:read(State) -&gt; {more, Bin, NewState} | {last, Bin, FileSize} | {error, {Code, Text}}</h3>  <p>Types:</p>         <pre>State = NewState = term()
Bin = binary()
FileSize = int()
Code = undef | enoent | eacces | enospc
  | badop | eexist | baduser | badopt
  | int()
Text = string()</pre>

<p>Reads a chunk from the file.</p> <p>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</p>   <h3 id="Module:write-2" class="code">Module:write(Bin, State) -&gt; {more, NewState} | {last, FileSize} | {error, {Code, Text}}</h3>  <p>Types:</p>         <pre>Bin = binary()
State = NewState = term()
FileSize = int()
Code = undef | enoent | eacces | enospc
  | badop | eexist | baduser | badopt
  | int()
Text = string()</pre>

<p>Writes a chunk to the file.</p> <p>The callback function is expected to close the file when the last file chunk is encountered. When an error is encountered, the callback function is expected to clean up after the aborted file transfer, such as closing open file descriptors, and so on. In both cases there will be no more calls to any of the callback functions.</p>   <h2 id="id81841">Logger functions</h2>   <p>A <code class="code">tftp_logger</code> callback module is to be implemented as a <code class="code">tftp_logger</code> behavior and export the following functions:</p>   <h2>Exports</h2> <h3 id="Logger:error_msg-2" class="code">Logger:error_msg(Format, Data) -&gt; ok | exit(Reason)</h3>  <p>Types:</p>     <pre>Format = string()
Data = [term()]
Reason = term()</pre>

<p>Logs an error message. See <code class="code">error_logger:error_msg/2</code> for details.</p>   <h3 id="Logger:info_msg-2" class="code">Logger:info_msg(Format, Data) -&gt; ok | exit(Reason)</h3>  <p>Types:</p>     <pre>Format = string()
Data = [term()]
Reason = term()</pre>

<p>Logs an info message. See <code class="code">error_logger:info_msg/2</code> for details.</p>  <h3 id="Logger:warning_msg-2" class="code">Logger:warning_msg(Format, Data) -&gt; ok | exit(Reason)</h3>  <p>Types:</p>     <pre>Format = string()
Data = [term()]
Reason = term()</pre>

<p>Logs a warning message. See <code class="code">error_logger:warning_msg/2</code> for details.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
