
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>6 OMG IDL to Erlang Mapping - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content="The purpose of OMG IDL, Interface Definition Language, mapping is to act as translator between platforms and languages. An IDL specification is &hellip;">
  <meta name="keywords" content="omg, idl, erlang, mapping, -, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/orber-3.8.1/doc/html/ch_idl_to_erlang_mapping/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>6 OMG IDL to Erlang Mapping</h1> <h2 id="id77047">6.1 OMG IDL to Erlang Mapping - Overview</h2> <p>The purpose of OMG IDL, <strong>Interface Definition Language</strong>, mapping is to act as translator between platforms and languages. An IDL specification is supposed to describe data types, object types etc.</p> <p>CORBA is independent of the programming language used to construct clients or implementations. In order to use the ORB, it is necessary for programmers to know how to access ORB functionality from their programming languages. It translates different IDL constructs to a specific programming language. This chapter describes the mapping of OMG IDL constructs to the Erlang programming language.</p> <h2 id="id77071">6.2 OMG IDL Mapping Elements</h2> <p>A complete language mapping will allow the programmer to have access to all ORB functionality in a way that is convenient for a specified programming language. </p> <p>All mapping must define the following elements: </p> <ul> <li>All OMG IDL basic and constructed types</li> <li>References to constants defined in OMG IDL</li> <li>References to objects defined in OMG IDL</li> <li>Invocations of operations, including passing of parameters and receiving of results</li> <li>Exceptions, including what happens when an operation raises an exception and how the exception parameters are accessed</li> <li>Access to attributes</li> <li>Signatures for operations defined by the ORB, such as dynamic invocation interface, the object adapters etc.</li> <li>Scopes; OMG IDL has several levels of scopes, which are mapped to Erlang's two scopes.</li> </ul> <h2 id="id77127">6.3 Getting Started</h2> <p>To begin with, we should decide which type of objects (i.e. servers) we need and if two, or more, should export the same functionality. Let us assume that we want to create a system for DB (database) access for different kind of users. For example, anyone with a valid password may extract data, but only a few may update the DB. Usually, an application is defined within a <code class="code">module</code>, and all global datatypes are defined on the top-level. To begin with we create a module and the interfaces we need:</p> <div class="example"><pre>
// DB IDL
#ifndef _DB_IDL_
#define _DB_IDL_
// A module is simply a container
module DB {

  // An interface maps to a CORBA::Object.
  interface CommonUser {

  };

  // Inherit the Consumer interface
  interface Administrator : CommonUser {

  };

  interface Access {

  };

};
#endif    </pre></div> <p>Since the <code class="code">Administrator</code> should be able to do the same things as the <code class="code">CommonUser</code>, the previous inherits from the latter. The <code class="code">Access</code> interface will grant access to the DB. Now we are ready to define the functionality and data types we need. But, this requires that we know a little bit more about the OMG IDL.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The OMG defines a set of reserved case insensitive key-words, which may <strong>NOT</strong> be used as identifiers (e.g. module name). For more information, see <code class="bold_code"><a href="#key_words">Reserved Compiler Names and Keywords</a></code></p> </div> </div> <h2 id="id77189">6.4 Basic OMG IDL Types</h2> <p>The OMG IDL mapping is strongly typed and, even if you have a good knowledge of CORBA types, it is essential to read carefully the following mapping to Erlang types.</p> <p>The mapping of basic types is straightforward. Note that the OMG IDL double type is mapped to an Erlang float which does not support the full double value range.</p> <table> <tr> <td>OMG IDL type</td> <td>Erlang type</td> <td>Note</td> </tr> <tr> <td>float</td> <td>Erlang float</td> <td></td> </tr> <tr> <td>double</td> <td>Erlang float</td> <td>value range not supported</td> </tr> <tr> <td>short</td> <td>Erlang integer</td> <td>-2^15 .. 2^15-1</td> </tr> <tr> <td>unsigned short</td> <td>Erlang integer</td> <td>0 .. 2^16-1</td> </tr> <tr> <td>long</td> <td>Erlang integer</td> <td>-2^31 .. 2^31-1</td> </tr> <tr> <td>unsigned long</td> <td>Erlang integer</td> <td>0 .. 2^32-1</td> </tr> <tr> <td>long long</td> <td>Erlang integer</td> <td>-2^63 .. 2^63-1</td> </tr> <tr> <td>unsigned long long</td> <td>Erlang integer</td> <td>0 .. 2^64-1</td> </tr> <tr> <td>char</td> <td>Erlang integer</td> <td>ISO-8859-1</td> </tr> <tr> <td>wchar</td> <td>Erlang integer</td> <td>UTF-16 (ISO-10646-1:1993)</td> </tr> <tr> <td>boolean</td> <td>Erlang atom</td> <td>true/false</td> </tr> <tr> <td>octet</td> <td>Erlang integer</td> <td></td> </tr> <tr> <td>any</td> <td>Erlang record</td> <td>#any{typecode, value}</td> </tr> <tr> <td>long double</td> <td>Not supported</td> <td></td> </tr> <tr> <td>Object</td> <td>Orber object reference</td> <td>Internal Representation</td> </tr> <tr> <td>void</td> <td>Erlang atom</td> <td>ok</td> </tr> </table> <em>Table 6.1: OMG IDL basic types</em> <p>The <code class="code">any</code> value is written as a record with the field typecode which contains the Type Coderepresentation, <code class="bold_code"><a href="#tk_values">see also the Type Code table</a></code>, and the value field itself.</p> <p>Functions with return type <code class="code">void</code> will return the atom <code class="code">ok</code>.</p> <h2 id="id77730">6.5 Template OMG IDL Types and Complex Declarators</h2> <p>Constructed types all have native mappings as shown in the table below.</p> <table> <tr> <td><strong>Type</strong></td> <td><strong>IDL code</strong></td> <td><strong>Maps to</strong></td> <td><strong>Erlang code</strong></td> </tr> <tr> <td><strong>string</strong></td> <td>typedef string S; <br> void op(in S a);</td> <td>Erlang string</td> <td>ok = op(Obj, "Hello World"),</td> </tr> <tr> <td><strong>wstring</strong></td> <td>typedef wstring S; <br> void op(in S a);</td> <td>Erlang list of Integers</td> <td>ok = op(Obj, "Hello World"),</td> </tr> <tr> <td><strong>sequence</strong></td> <td>typedef sequence &lt;long, 3&gt; S; <br> void op(in S a);</td> <td>Erlang list</td> <td>ok = op(Obj, [1, 2, 3]),</td> </tr> <tr> <td><strong>array</strong></td> <td>typedef string S[2]; <br> void op(in S a);</td> <td>Erlang tuple</td> <td>ok = op(Obj, {"one", "two"}),</td> </tr> <tr> <td><strong>fixed</strong></td> <td>typedef fixed&lt;3,2&gt; myFixed; <br> void op(in myFixed a);</td> <td>Erlang tuple</td> <td>MF = fixed:create(3, 2, 314), <br> ok = op(Obj, MF),</td> </tr> </table> <em>Table 6.2: OMG IDL Template and Complex Declarators</em> <h4>String/WString Data Types</h4> <p>A <code class="code">string</code> consists of all possible 8-bit quantities except null. Most ORB:s uses, including Orber, the character set Latin-1 (ISO-8859-1). The <code class="code">wstring</code> type is represented as a list of integers, where each integer represents a wide character. In this case Orber uses, as most other ORB:s, the UTF-16 (ISO-10646-1:1993) character set.</p> <p>When defining a a string or wstring they can be of limited length or null terminated:</p> <div class="example"><pre>
// Null terminated
typedef string myString;
typedef wstring myWString;
// Maximum length 10 
typedef string&lt;10&gt; myString10;
typedef wstring&lt;10&gt; myWString10;
      </pre></div> <p>If we want to define a char/string or wchar/wstring constant, we can use octal (\OOO - one, two or three octal digits), hexadecimal (\xHH - one or two hexadecimal digits) and unicode (\uHHHH - one, two, three or four hexadecimal digits.) representation as well. For example:</p> <div class="example"><pre>
const string  SwedensBestSoccerTeam = "\101" "\x49" "\u004B";
const wstring SwedensBestHockeyTeam = L"\101\x49\u004B";
const char  aChar  = '\u004B';  
const wchar aWchar = L'\u004C';
      </pre></div> <p>Naturally, we can use <code class="code">"Erlang"</code>, <code class="code">L"Rocks"</code>, <code class="code">'A'</code> and <code class="code">L'A'</code> as well.</p> <h4>Sequence Data Type</h4> <p>A sequence can be defined to be of a maximum length or unbounded, and may contain Basic and Template types and scoped names:</p> <div class="example"><pre>
typedef sequence &lt;short, 1&gt; aShortSequence;
typedef sequence &lt;long&gt; aLongSequence;
typedef sequence &lt;aLongSequence&gt; anEvenLongerSequence;
      </pre></div> <h4>Array Data Type</h4> <p>Arrays are multidimensional, fixed-size arrays. The indices is language mapping specific, which is why one should not pass them as arguments to another ORB.</p> <div class="example"><pre>
typedef long myMatrix[2][3];
      </pre></div> <h4>Fixed Data Type</h4> <p>A Fixed Point literal consists of an integer part (decimal digits), decimal point and a fraction part (decimal digits), followed by a <code class="code">D</code> or <code class="code">d</code>. Either the integer part or the fraction part may be missing; the decimal point may be missing, but not d/D. The integer part must be a positive integer less than 32. The Fraction part must be a positive integer less than or equal to the Integer part.</p> <div class="example"><pre>
const fixed myFixed1 = 3.14D;
const fixed myFixed2 = .14D;
const fixed myFixed3 = 0.14D;
const fixed myFixed4 = 3.D;
const fixed myFixed5 = 3D;
      </pre></div> <p>It is also possible to use unary (+-) and binary (+-*/) operators:</p> <div class="example"><pre>
const fixed myFixed6 = 3D + 0.14D;
const fixed myFixed7 = -3.14D;
      </pre></div> <p>The Fixed Point examples above are, so called, <strong>anonymous</strong> definitions. In later CORBA specifications these have been deprecated as function parameters or return values. Hence, we strongly recommend that you do not use them. Instead, you should use:</p> <div class="example"><pre>
typedef fixed&lt;5,3&gt; myFixed53;
const myFixed53 myFixed53constant = 03.140d;
typedef fixed&lt;3,2&gt; myFixed32;
const myFixed32 myFixed32constant = 3.14d;

myFixed53 foo(in myFixed32 MF); // OK
void bar(in fixed&lt;5,3&gt; MF); // Illegal
      </pre></div> <p>For more information, see <code class="bold_code"><a href="../fixed/">Fixed</a></code> in Orber's Reference Manual.</p> <p>Now we continue to work on our IDL specification. To begin with, we want to limit the size of the logon parameters (Id and password). Since the <code class="code">UserID</code> and <code class="code">Password</code> parameters, only will be used when invoking operations on the <code class="code">Access</code> interface, we may choose to define them within the scope that interface. To keep it simple our DB will contain employee information. Hence, as the DB key we choose an integer (<code class="code">EmployeeNo</code>).</p> <div class="example"><pre>
// DB IDL
#ifndef _DB_IDL_
#define _DB_IDL_
module DB {

  typedef unsigned long EmployeeNo;

  interface CommonUser {

     any lookup(in EmployeeNo ENo);

  };

  interface Administrator : CommonUser {

     void delete(in EmployeeNo ENo);

  };

  interface Access {

      typedef string&lt;10&gt; UserID;
      typedef string&lt;10&gt; Password;

      CommonUser logon(in UserID ID, in Password PW);

  };

};
#endif    </pre></div> <p>But what should, for example, the <code class="code">lookup</code> operation return? One option is to use the <code class="code">any</code> data type. But, depending on what kind of data it encapsulates, this datatype can be rather expensive to use. We might find a solution to our problems among the <code class="code">Constructed</code> IDL types.</p> <h2 id="id78216">6.6 Constructed OMG IDL Types</h2> <p>Constructed types all have native mappings as shown in the table below.</p> <table> <tr> <td><strong>Type</strong></td> <td><strong>IDL code</strong></td> <td><strong>Maps to</strong></td> <td><strong>Erlang code</strong></td> </tr> <tr> <td><strong>struct</strong></td> <td>struct myStruct { <br> long a; <br> short b; <br> }; <br> void op(in myStruct a);</td> <td>Erlang record</td> <td>ok = op(Obj, #'myStruct'{a=300, b=127}),</td> </tr> <tr> <td><strong>union</strong></td> <td>union myUnion switch(long) { <br> case 1: long a; <br> }; <br> void op(in myUnion a);</td> <td>Erlang record</td> <td>ok = op(Obj, #'myUnion'{label=1, value=66}),</td> </tr> <tr> <td><strong>enum</strong></td> <td>enum myEnum {one, two}; <br> void op(in myEnum a);</td> <td>Erlang atom</td> <td>ok = op(Obj, one),</td> </tr> </table> <em>Table 6.3: OMG IDL constructed types</em> <h4>Struct Data Type</h4> <p>A <code class="code">struct</code> may have Basic, Template, Scoped Names and Constructed types as members. By using forward declaration we can define a recursive struct:</p> <div class="example"><pre>
struct myStruct; // Forward declaration
typedef sequence&lt;myStruct&gt; myStructSeq;
struct myStruct {
    myStructSeq chain;
};

// Deprecated definition (anonymous) not supported by IC
struct myStruct {
    sequence&lt;myStruct&gt; chain;
};
      </pre></div> <h4>Enum Data Type</h4> <p>The maximum number of identifiers which may defined in an enumeration is 2³². The order in which the identifiers are named in the specification of an enumeration defines the relative order of the identifiers.</p> <h4>Union Data Type</h4> <p>A <code class="code">union</code> may consist of:</p> <ul> <li>Identifier</li> <li>Switch - may be an integer, char, boolean, enum or scoped name.</li> <li>Body - with or without a <code class="code">default</code> case; may appear at most once.</li> </ul> <p>A case label must match the defined type of the discriminator, and may only contain a default case if the values given in the non-default labels do not cover the entire range of the union's discriminant type. For example:</p> <div class="example"><pre>
// Illegal default; all cases covered by 
// non-default cases.
union BooleanUnion switch(boolean) {
  case TRUE:  long TrueValue;
  case FALSE: long FalseValue;
  default: long DefaultValue; 
};
// OK
union BooleanUnion2 switch(boolean) {
  case TRUE:  long TrueValue;
  default: long DefaultValue; 
};
      </pre></div> <p>It is not necessary to list all possible values of the union discriminator in the body. Hence, the value of a union is the value of the discriminator and, in given order, one of the following:</p> <ul> <li>If the discriminator match a label, explicitly listed in a case statement, the value must be of the same type.</li> <li>If the union contains a default label, the value must match the type of the default label.</li> <li>No value. Orber then inserts the Erlang atom <code class="code">undefined</code> in the value field when receiving a union from an external ORB.</li> </ul> <p>The above can be summed up to:</p> <div class="example"><pre>
// If the discriminator equals 1 or 2 the value 
// is a long. Otherwise, the atom undefined.
union LongUnion switch(long) {
  case 1:
  case 2:  long TrueValue;
};
// If the discriminator equals 1 or 2 the value 
// is a long. Otherwise, a boolean.
union LongUnion2 switch(long) {
  case 1:
  case 2:  long TrueValue;
  default: boolean DefaultValue; 
};
      </pre></div> <p>In the same way as structs, unions can be recursive if forward declaration is used (anonymous types is deprecated and not supported):</p> <div class="example"><pre>
// Forward declaration
union myUnion;
typedef sequence&lt;myUnion&gt;myUnionSeq;
union myUnion switch (long) {
    case 1 : myUnionSeq chain;
    default: boolean DefaultValue;
};
      </pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Recursive types (union and struct) require Light IFR. I.e. the IC option {light_ifr, true} is used and that Orber is configured in such a way that Light IFR is activated. Recursive TypeCode is currently not supported, which is why these cannot be encapsulated in an any data type.</p> </div> </div> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Every field in, for example, a struct must be initiated. Otherwise it will be set to the atom <code class="code">undefined</code>, which Orber cannot encode when communicating via IIOP. In the example above, invoking the operation with #'myStruct'{a=300} will fail (equal to #'myStruct'{a=300, b=undefined})</p> </div> </div> <p>Now we can continue to work on our IDL specification. To begin with, we should determine the return value of the <code class="code">lookup</code> operation. Since the <code class="code">any</code> type can be rather expensive we can use a <code class="code">struct</code> or a <code class="code">union</code> instead. If we intend to return the same information about a employee every time we can use a struct. Let us assume that the DB contains the name, address, employee number and department.</p> <div class="example"><pre>
// DB IDL
#ifndef _DB_IDL_
#define _DB_IDL_
module DB {

  typedef unsigned long EmployeeNo;

  enum Department {Department1, Department2};

  struct employee {
        EmployeeNo No;
        string Name; 
        string Address; 
        Department Dpt;
  };

  typedef employee EmployeeData;

  interface CommonUser {

     EmployeeData lookup(in EmployeeNo ENo);

  };

  interface Administrator : CommonUser {

     void delete(in EmployeeNo ENo);

  };

  interface Access {

      typedef string&lt;10&gt; UserID;
      typedef string&lt;10&gt; Password;

      // Since Administrator inherits from CommonUser
      // the returned Object can be of either type.
      CommonUser logon(in UserID ID, in Password PW);

  };

};
#endif    </pre></div> <p>We can also define exceptions (i.e. not system exception) thrown by each interface. Since exceptions are thoroughly described in the chapter <code class="bold_code"><a href="../ch_exceptions/">System and User Defined Exceptions</a></code>, we choose not to. Hence, we are now ready to compile our IDL-file by invoking:</p> <div class="example"><pre>
$ erlc DB.idl
    </pre></div> <p>or:</p> <div class="example"><pre>
$ erl
Erlang (BEAM) emulator version 5.1.1 [threads:0]

Eshell V5.1.1  (abort with ^G)
1&gt; ic:gen('DB').
ok
2&gt; halt().
    </pre></div> <p>The next step is to implement our servers. But, to be able to do that, we need to know how we can access data type definitions. For example, since a struct is mapped to an Erlang record we must include an hrl-file in our callback module.</p> <h2 id="id78655">6.7 Scoped Names and Generated Files</h2> <h4>Scoped Names</h4> <p>Within a scope all identifiers must be unique. The following kinds of definitions form scopes in the OMG IDL:</p> <ul> <li><strong>module</strong></li> <li><strong>interface</strong></li> <li><strong>operation</strong></li> <li><strong>valuetype</strong></li> <li><strong>struct</strong></li> <li><strong>union</strong></li> <li><strong>exception</strong></li> </ul> <p>For example, since enumerants do not form a scope, the following IDL code is not valid:</p> <div class="example"><pre>
module MyModule {
     // 'two' is not unique
     enum MyEnum {one, two};
     enum MyOtherEnum {two, three};
};
      </pre></div> <p>But, since Erlang only has two levels of scope, <strong>module</strong> and <strong>function</strong>, the OMG IDL scope is mapped as follows:</p> <ul> <li> <strong>Function Scope</strong> - used for constants, operations and attributes.</li> <li> <strong>Erlang Module Scope</strong> - the Erlang module scope handles the remaining OMG IDL scopes.</li> </ul> <p>An Erlang module, corresponding to an IDL global name, is derived by converting occurrences of "::" to underscore, and eliminating the leading "::". Hence, accessing <code class="code">MyEnum</code> from another module, one use <code class="code">MyModule::MyEnum</code></p> <p>For example, an operation <code class="code">foo</code> defined in interface <code class="code">I</code>, which is defined in module <code class="code">M</code>, would be written in IDL as <code class="code">M::I::foo</code> and as <code class="code">'M_I':foo</code> in Erlang - <code class="code">foo</code> is the function name and <code class="code">'M_I'</code> is the name of the Erlang module. Applying this knowledge to a stripped version of the DB.idl gives:</p> <div class="example"><pre>
// DB IDL
#ifndef _DB_IDL_
#define _DB_IDL_
// ++ topmost scope ++ 
// IC generates oe_XX.erl and oe_XX.hrl.
// XX is equal to the name of the IDL-file.
// Tips: create one IDL-file for each top module
// and give the file the same name (DB.idl).
// The oe_XX.erl module is used to register data
// in the IFR.
module DB {

  // ++ Module scope ++
  // To access 'EmployeeNo' from another scope, use:
  // DB::EmployeeNo, DB::Access etc.
  typedef unsigned long EmployeeNo;

  enum Department {Department1, Department2};

  // Definitions of this struct is contained in:
  // DB.hrl
  // Access functions exported by:
  // DB_employee.erl
  struct employee {
     ... CUT ...
  };

  typedef employee EmployeeData;

  ... CUT ...

  // If this interface should inherit an interface
  // in another module (e.g. OtherModule) use:
  // interface Access : OtherModule::OtherInterface
  interface Access {

      // ++ interface scope ++
      // Types within this scope is accessible via:
      // DB::Access::UserID
      // The Stub/Skeleton for this interface is
      // placed in the module:
      // DB_Access.erl
      typedef string&lt;10&gt; UserID;
      typedef string&lt;10&gt; Password;

      // Since Administrator inherits from CommonUser
      // the returned Object can be of either type.
      // This operation is exported from:
      // DB_Access.erl
      CommonUser logon(in UserID ID, in Password PW);

  };

};
#endif      </pre></div> <p>Using underscores in IDL names can lead to ambiguities due to the name mapping described above. It is advisable to avoid the use of underscores in identifiers. For example, the following definition would generate two structures named <code class="code">x_y_z</code>.</p> <div class="example"><pre>
module x {

    struct y_z {
    ...
    };

    interface y {

    struct z {
        ...
    };
    };
};
      </pre></div> <h4>Generated Files</h4> <p>Several files can be generated for each scope.</p> <ul> <li>An Erlang source code file (<code class="code">.erl</code>) is generated for top level scope as well as the Erlang header file.</li> <li>An Erlang header file (<code class="code">.hrl</code>) will be generated for each scope. The header file will contain record definitions for all <code class="code">struct</code>, <code class="code">union</code> and <code class="code">exception</code> types in that scope.</li> <li>Modules that contain at least one constant definition, will produce Erlang source code files (<code class="code">.erl</code>). That Erlang file will contain constant functions for that scope. Modules that contain no constant definitions are considered empty and no code will be produced for them, but only for their included modules/interfaces.</li> <li>Interfaces will produce Erlang source code files (<code class="code">.erl</code>), this code will contain all operation stub code and implementation functions.</li> <li>In addition to the scope-related files, an Erlang source file will be generated for each definition of the types <code class="code">struct</code>, <code class="code">union</code> and <code class="code">exception</code> (these are the types that will be represented in Erlang as records). This file will contain special access functions for that record.</li> <li>The top level scope will produce two files, one header file (<code class="code">.hrl</code>) and one Erlang source file (<code class="code">.erl</code>). These files are named as the IDL file, prefixed with <code class="code">oe_</code>.</li> </ul> <p>After compiling DB.idl, the following files have been generated:</p> <ul> <li> <code class="code">oe_DB.hrl</code> and <code class="code">oe_DB.erl</code> for the top scope level.</li> <li> <code class="code">DB.hrl</code> for the module <code class="code">DB</code>.</li> <li> <code class="code">DB_Access.hrl</code> and <code class="code">DB_Access.erl</code> for the interface <code class="code">DB_Access</code>.</li> <li> <code class="code">DB_CommonUser.hrl</code> and <code class="code">DB_CommonUser.erl</code> for the interface <code class="code">DB_CommonUser</code>.</li> <li> <code class="code">DB_Administrator.hrl</code> and <code class="code">DB_Administrator.erl</code> for the interface <code class="code">DB_Administrator</code>.</li> <li> <code class="code">DB_employee.erl</code> for the structure <code class="code">employee</code> in module <code class="code">DB</code>.</li> </ul> <p>Since the <code class="code">employee</code> struct is defined in the top level scope, the Erlang record definition is found in <code class="code">DB.hrl</code>. IC also generates stubs/skeletons (e.g. <code class="code">DB_CommonUser.erl</code>) and access functions for some datatypes (e.g. <code class="code">DB_employee.erl</code>). How the stubs/skeletons are used is thoroughly described in <code class="bold_code"><a href="../ch_stubs/">Stubs/Skeletons</a></code> and <code class="bold_code"><a href="../module_interface/">Module_Interface</a></code>.</p> <h2 id="id79047">6.8 Typecode, Identity and Name Access Functions</h2> <p>As mentioned in a previous section, <code class="code">struct</code>, <code class="code">union</code> and <code class="code">exception</code> types yield record definitions and access code for that record. For <code class="code">struct</code>, <code class="code">union</code>, <code class="code">exception</code>, <code class="code">array</code> and <code class="code">sequence</code> types, a special file is generated that holds access functions for <code class="code">TypeCode</code>, <code class="code">Identity</code> and <code class="code">Name</code>. These functions are put in the file corresponding to the scope where they are defined. For example, the module <code class="code">DB_employee.erl</code>, representing the <code class="code">employee</code> struct, exports the following functions:</p> <ul> <li>tc/0 - returns the type code for the struct.</li> <li>id/0 - returns the IFR identity of the struct. In this case the returned value is <code class="code">"IDL:DB/employee:1.0"</code>, but if the struct was defined in the scope of <code class="code">CommonUser</code>, the result would be <code class="code">"IDL:DB/CommonUser/employee:1.0"</code>. However, the user usually do not need to know the Id, just which Erlang module contains the correct Id.</li> <li>name/0 - returns the scoped name of the struct. The <code class="code">employee</code> struct name is <code class="code">"DB_employee"</code>.</li> </ul> <p>Type Codesare, for example, used in <code class="bold_code"><a href="../any/">Any</a></code> values. Hence, we can encapsulate the <code class="code">employee</code> struct in an <code class="code">any</code> type by:</p> <div class="example"><pre>
%% Erlang code
....
AnEmployee = #'DB_employee'{'No'      = 1,
                            'Name'    = "Adam Ivan Kendall",
                            'Address' = "Rasunda, Solna",
                            'Dpt'     = 'Department1'},
EmployeeTC = 'DB_employee':tc(),
EmployeeAny = any:create(EmployeeTC, AnEmployee),
....
    </pre></div> <p>For more information, see the <code class="bold_code"><a href="#tk_values">Type Code listing</a></code>.</p> <h2 id="id79191">6.9 References to Constants</h2> <p>Constants are generated as Erlang functions, and are accessed by a single function call. The functions are put in the file corresponding to the scope where they are defined. There is no need for an object to be started to access a constant.</p> <p>Example:</p> <div class="example"><pre>
// m.idl
module m {
    const float pi = 3.14;

    interface i {
    const float pi = 3.1415;
    };
};
    </pre></div> <p>Since the two constants are defined in different scopes, the IDL code above is valid, but not necessarily a good approach. After compiling <code class="code">m.idl</code>, the constant definitions can be extracted by invoking:</p> <div class="example"><pre>
$ erlc m.idl
$ erlc m.erl
$ erl
Erlang (BEAM) emulator version 5.1.1 [threads:0]

Eshell V5.1.1  (abort with ^G)
1&gt; m:pi().
3.14
2&gt; m_i:pi().
3.1415
3&gt; halt().
    </pre></div> <h2 id="id79250">6.10 References to Objects Defined in OMG IDL</h2> <p>Objects are accessed by object references. An object reference is an opaque Erlang term created and maintained by the ORB.</p> <p>Objects are implemented by providing implementations for all operations and attributes of the Object, <code class="bold_code"><a href="#op_impl">see operation implementation</a></code>.</p> <h2 id="id79273">6.11 Exceptions</h2> <p>Exceptions are handled as Erlang catch and throws. Exceptions are translated to messages over an IIOP bridge but converted back to a throw on the receiving side. Object implementations that invoke operations on other objects must be aware of the possibility of a non-local return. This includes invocation of ORB and IFR services. See also the <code class="bold_code"><a href="../ch_exceptions/">Exceptions</a></code> section.</p> <p>Exception parameters are mapped as an Erlang record and accessed as such.</p> <p>An object implementation that raises an exception will use the <code class="code">corba:raise/1</code> function, passing the exception record as parameter.</p> <h2 id="id79306">6.12 Access to Attributes</h2> <p>Attributes are accessed through their access functions. An attribute implicitly defines the <code class="code">_get</code> and <code class="code">_set</code> operations. These operations are handled in the same way as normal operations. The <code class="code">_get</code> operation is defined as a <code class="code">readonly</code> attribute.</p> <div class="example"><pre>
readonly attribute long RAttribute;
attribute long RWAttribute;
    </pre></div> <p>The <code class="code">RAttribute</code> requires that you implement, in your call-back module, <code class="code">_get_RAttribute</code>. For the <code class="code">RWAttribute</code> it is necessary to implement <code class="code">_get_RWAttribute</code> and <code class="code">_set_RWAttribute</code>.</p> <h2 id="id79363">6.13 Invocations of Operations</h2>  <p>A standard Erlang <code class="code">gen_server</code> behavior is used for object implementation. The <code class="code">gen_server</code> state is then used as the object internal state. Implementation of the object function is achieved by implementing its methods and attribute operations. These functions will usually have the internal state as their first parameter, followed by any <code class="code">in</code> and <code class="code">inout</code> parameters. </p> <p>Do not confuse the object internal state with its object reference. The object internal state is an Erlang term which has a format defined by the user.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>It is not always the case that the internal state will be the first parameter, as stubs can use their own object reference as the first parameter (see the IC documentation).</p> </div> </div> <p>A function call will invoke an operation. The first parameter of the function should be the object reference and then all <code class="code">in</code> and <code class="code">inout</code> parameters follow in the same order as specified in the IDL specification. The result will be a return value unless the function has <code class="code">inout</code> or <code class="code">out</code> parameters specified; in which case, a tuple of the return value, followed by the parameters will be returned.</p> <p>Example:</p> <div class="example"><pre>
// IDL
module m {
  interface i {
      readonly attribute long RAttribute;
      attribute long RWAttribute;
      long foo(in short a);
      long bar(in char c, inout string s, out long count);
      void baz(out long Id);
  };
};
    </pre></div> <p>Is used in Erlang as :</p> <div class="example"><pre>
%% Erlang code
....
Obj = ...    %% get object reference
RAttr  = m_i:'_get_RAttribute'(Obj),
RWAttr = m_i:'_get_RWAttribute'(Obj),
ok = m_i:'_set_RWAttribute'(Obj, Long),
R1 = m_i:foo(Obj, 55),
{R2, S, Count} = m_i:bar(Obj, $a, "hello"),
....
    </pre></div> <p>Note how the <code class="code">inout</code> parameter is passed <strong>and</strong> returned. There is no way to use a single occurrence of a variable for this in Erlang. Also note, that <code class="code">ok</code>, Orber's representation of the IDL-type <code class="code">void</code>, must be returned by <code class="code">baz</code> and <code class="code">'_set_RWAttribute'</code>. These operations can be implemented in the call-back module as:</p> <div class="example"><pre>
'_set_RWAttribute'(State, Long) -&gt;
    {reply, ok, State}.

'_get_RWAttribute'(State) -&gt;
    {reply, Long, State}.

'_get_RAttribute'(State) -&gt;
    {reply, Long, State}.

foo(State, AShort) -&gt;
    {reply, ALong, State}.
 
bar(State, AShort, AString) -&gt;
    {reply, {ALong, "MyString", ALong}, State}.
 
baz(State) -&gt;
    {reply, {ok, AId}, State}.
    </pre></div> <p>The operations may require more arguments (depends on IC options used). For more information, see <code class="bold_code"><a href="../ch_stubs/">Stubs/Skeletons</a></code> and <code class="bold_code"><a href="../module_interface/">Module_Interface</a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>A function can also be defined to be <code class="code">oneway</code>, i.e. asynchronous. But, since the behavior of a oneway operation is not defined in the OMG specifications (i.e. the behavior can differ depending on which other ORB Orber is communicating with), one should avoid using it.</p> </div> </div> <h2 id="id79521">6.14 Implementing the DB Application</h2> <p>Now we are ready to implement the call-back modules. There are three modules we must create:</p> <ul> <li>DB_Access_impl.erl</li> <li>DB_CommonUser_impl.erl</li> <li>DB_Administrator_impl.erl</li> </ul> <p>An easy way to accomplish that, is to use the IC backend <code class="code">erl_template</code>, which will generate a complete call-back module. One should also add the same compile options, for example <code class="code">this</code> or <code class="code">from</code>, used when generating the stub/skeleton modules:</p> <div class="example"><pre>
$&gt; erlc +"{be,erl_template}" DB.idl
    </pre></div> <p>We begin with implementing the <code class="code">DB_Access_impl.erl</code> module, which, if we used <code class="code">erl_template</code>, will look like the following. All we need to do is to add the logic to the <code class="code">logon</code> operation.</p> <div class="example"><pre>
%%----------------------------------------------------------------------
%% &lt;LICENSE&gt;
%% 
%%     $Id$
%%
%%----------------------------------------------------------------------
%% Module       : DB_Access_impl.erl
%% 
%% Source       : /home/user/example/DB.idl
%% 
%% Description  : 
%% 
%% Creation date: 2005-05-20
%%
%%----------------------------------------------------------------------
-module('DB_Access_impl').

-export([logon/3]).

%%----------------------------------------------------------------------
%% Internal Exports
%%----------------------------------------------------------------------
-export([init/1,
         terminate/2,
         code_change/3,
         handle_info/2]).

%%----------------------------------------------------------------------
%% Include Files
%%----------------------------------------------------------------------


%%----------------------------------------------------------------------
%% Macros
%%----------------------------------------------------------------------


%%----------------------------------------------------------------------
%% Records
%%----------------------------------------------------------------------
-record(state, {}).

%%======================================================================
%% API Functions
%%======================================================================
%%----------------------------------------------------------------------
%% Function   : logon/3
%% Arguments  : State - term()
%%              ID = String()
%%              PW = String()
%% Returns    : ReturnValue = OE_Reply
%%              OE_Reply = Object_Ref()
%% Raises     : 
%% Description: 
%%----------------------------------------------------------------------
logon(State, ID, PW) -&gt;
    %% Check if the ID/PW is valid and what 
    %% type of user it is (Common or Administrator).
    OE_Reply
            = case check_user(ID, PW) of
             {ok, administrator} -&gt;
                'DB_Administrator':oe_create();
             {ok, common} -&gt;
                'DB_CommonUser':oe_create();
             error -&gt;
                %% Here we should throw an exception              
                corba:raise(....)
        end,
    {reply, OE_Reply, State}.

%%======================================================================
%% Internal Functions
%%======================================================================
%%----------------------------------------------------------------------
%% Function   : init/1
%% Arguments  : Env = term()
%% Returns    : {ok, State}          |
%%              {ok, State, Timeout} |
%%              ignore               |
%%              {stop, Reason}
%% Raises     : -
%% Description: Initiates the server
%%----------------------------------------------------------------------
init(_Env) -&gt;
    {ok, #state{}}.


%%----------------------------------------------------------------------
%% Function   : terminate/2
%% Arguments  : Reason = normal | shutdown | term()
%%              State = term()
%% Returns    : ok
%% Raises     : -
%% Description: Invoked when the object is terminating.
%%----------------------------------------------------------------------
terminate(_Reason, _State) -&gt;
    ok.


%%----------------------------------------------------------------------
%% Function   : code_change/3
%% Arguments  : OldVsn = undefined | term()
%%              State = NewState = term()
%%              Extra = term()
%% Returns    : {ok, NewState}
%% Raises     : -
%% Description: Invoked when the object should update its internal state
%%              due to code replacement.
%%----------------------------------------------------------------------
code_change(_OldVsn, State, _Extra) -&gt;
    {ok, State}.


%%----------------------------------------------------------------------
%% Function   : handle_info/2
%% Arguments  : Info = normal | shutdown | term()
%%              State = NewState = term()
%% Returns    : {noreply, NewState}          |
%%              {noreply, NewState, Timeout} |
%%              {stop, Reason, NewState}
%% Raises     : -
%% Description: Invoked when, for example, the server traps exits.
%%----------------------------------------------------------------------
handle_info(_Info, State) -&gt;
    {noreply, State}.
    </pre></div> <p>Since <code class="code">DB_Administrator</code> inherits from <code class="code">DB_CommonUser</code>, we must implement <code class="code">delete</code> in the <code class="code">DB_Administrator_impl.erl</code> module, and <code class="code">lookup</code> in <code class="code">DB_Administrator_impl.erl</code><strong>and</strong><code class="code">DB_CommonUser_impl.erl</code>. But wait, is that really necessary? Actually, it is not. We simple use the IC compile option <strong>impl</strong>:</p> <div class="example"><pre>
$ erlc +'{{impl, "DB::CommonUser"}, "DBUser_impl"}'\ +'{{impl, "DB::Administrator"}, "DBUser_impl"}' DB.idl
$ erlc *.erl
    </pre></div> <p>Instead of creating, and not the least, maintaining two call-back modules, we only have to deal with <code class="code">DBUser_impl.erl</code>. If we generated the templates, we simply rename <code class="code">DB_Administrator_impl.erl</code> to <code class="code">DBUser_impl.erl</code>. See also the <code class="bold_code"><a href="../ch_exceptions/">Exceptions</a></code> chapter. In the following example, only the implementation of the API functions are shown:</p> <div class="example"><pre>
%%======================================================================
%% API Functions
%%======================================================================
%%----------------------------------------------------------------------
%% Function   : delete/2
%% Arguments  : State - term()
%%              ENo = unsigned_Long()
%% Returns    : ReturnValue = ok
%% Raises     : 
%% Description: 
%%----------------------------------------------------------------------
delete(State, ENo) -&gt;
        %% How we access the DB, for example mnesia, is not shown here.
        case delete_employee(No) of
            ok -&gt;
                {reply, ok, State};
            error -&gt;
                %% Here we should throw an exception if
                %% there is no match.
                corba:raise(....)
        end.

%%----------------------------------------------------------------------
%% Function   : lookup/2
%% Arguments  : State - term()
%%              ENo = unsigned_Long()
%% Returns    : ReturnValue = OE_Reply
%%              OE_Reply = #'DB_employee'{No,Name,Address,Dpt}
%%              No = unsigned_Long()
%%              Name = String()
%%              Address = String()
%%              Dpt = Department
%%              Department = 'Department1' | 'Department2' 
%% Raises     : 
%% Description: 
%%----------------------------------------------------------------------
lookup(State, ENo) -&gt;
        %% How we access the DB, for example mnesia, is not shown here.
        case lookup_employee(ENo) of
            %% We assume that we receive a 'DB_employee' struct
            {ok, Employee} -&gt;
                OE_Reply = Employee,
                {reply, OE_Reply, State};
            error -&gt;
                %% Here we should throw an exception if
                %% there is no match.
                corba:raise(....)
        end.
    </pre></div> <p>After you have compiled both call-back modules, and implemented the missing functionality (e.g. lookup_employee/1), we can test our application:</p> <div class="example"><pre>
%% Erlang code
....
%% Create an Access object
Acc = 'DB_Access':oe_create(),

%% Login is Common user and Administrator
Adm = 'DB_Access':logon(A, "admin", "pw"),
Com = 'DB_Access':logon(A, "comm", "pw"),

%% Lookup existing employee
Employee = 'DB_Administrator':lookup(Adm, 1),
Employee = 'DB_CommonUser':lookup(Adm, 1),

%% If we try the same using the DB_CommonUser interface 
%% it result in an exit since that operation is not exported.
{'EXIT', _} = (catch 'DB_CommonUser':delete(Adm, 1)),

%% Try to delete the employee via the CommonUser Object
{'EXCEPTION', _} = (catch 'DB_Administrator':delete(Com, 1)),

%% Invoke delete operation on the Administrator object
ok = 'DB_Administrator':delete(Adm, 1),
....
    </pre></div> <h2 id="id79740">6.15 Reserved Compiler Names and Keywords</h2>  <p>The use of some names is strongly discouraged due to ambiguities. However, the use of some names is prohibited when using the Erlang mapping , as they are strictly reserved for IC.</p> <p>IC reserves all identifiers starting with <code class="code">OE_</code> and <code class="code">oe_</code> for internal use.</p> <p>Note also, that an identifier in IDL can contain alphabetic, digits and underscore characters, but the first character <strong>must</strong> be alphabetic. </p> <p>The OMG defines a set of reserved words, shown below, for use as keywords. These may <strong>not</strong> be used as, for example, identifiers. The keywords which are not in bold face was introduced in the OMG CORBA-3.0 specification.</p> <table> <tr> <td><strong>abstract</strong></td> <td><strong>exception</strong></td> <td><strong>inout</strong></td> <td>provides</td> <td><strong>truncatable</strong></td> </tr> <tr> <td><strong>any</strong></td> <td>emits</td> <td><strong>interface</strong></td> <td><strong>public</strong></td> <td><strong>typedef</strong></td> </tr> <tr> <td><strong>attribute</strong></td> <td><strong>enum</strong></td> <td><strong>local</strong></td> <td>publishes</td> <td>typeid</td> </tr> <tr> <td><strong>boolean</strong></td> <td>eventtype</td> <td><strong>long</strong></td> <td><strong>raises</strong></td> <td>typeprefix</td> </tr> <tr> <td><strong>case</strong></td> <td><strong>factory</strong></td> <td><strong>module</strong></td> <td><strong>readonly</strong></td> <td><strong>unsigned</strong></td> </tr> <tr> <td><strong>char</strong></td> <td><strong>FALSE</strong></td> <td>multiple</td> <td>setraises</td> <td><strong>union</strong></td> </tr> <tr> <td>component</td> <td>finder</td> <td><strong>native</strong></td> <td><strong>sequence</strong></td> <td>uses</td> </tr> <tr> <td><strong>const</strong></td> <td><strong>fixed</strong></td> <td><strong>Object</strong></td> <td><strong>short</strong></td> <td><strong>ValueBase</strong></td> </tr> <tr> <td>consumes</td> <td><strong>float</strong></td> <td><strong>octet</strong></td> <td><strong>string</strong></td> <td><strong>valuetype</strong></td> </tr> <tr> <td><strong>context</strong></td> <td>getraises</td> <td><strong>oneway</strong></td> <td><strong>struct</strong></td> <td><strong>void</strong></td> </tr> <tr> <td><strong>custom</strong></td> <td>home</td> <td><strong>out</strong></td> <td><strong>supports</strong></td> <td><strong>wchar</strong></td> </tr> <tr> <td><strong>default</strong></td> <td>import</td> <td>primarykey</td> <td><strong>switch</strong></td> <td><strong>wstring</strong></td> </tr> <tr> <td><strong>double</strong></td> <td><strong>in</strong></td> <td><strong>private</strong></td> <td><strong>TRUE</strong></td> <td></td> </tr> </table> <em>Table 6.4: OMG IDL keywords</em> <p>The keywords listed above must be written exactly as shown. Any usage of identifiers that collide with a keyword is illegal. For example, <strong>long</strong> is a valid keyword; <strong>Long</strong> and <strong>LONG</strong> are illegal as keywords and identifiers. But, since the OMG must be able to expand the IDL grammar, it is possible to use <strong>Escaped Identifiers</strong>. For example, it is not unlikely that <code class="code">native</code> have been used in IDL-specifications as identifiers. One option is to change all occurrences to <code class="code">myNative</code>. Usually, it is necessary to change programming language code that depends upon that IDL as well. Since Escaped Identifiers just disable type checking (i.e. if it is a reserved word or not) and leaves everything else unchanged, it is only necessary to update the IDL-specification. To escape an identifier, simply prefix it with <strong>_</strong>. The following IDL-code is illegal:</p> <div class="example"><pre>
typedef string native;
interface i {
   void foo(in native Arg);
   };
};
    </pre></div> <p>With Escaped Identifiers the code will look like:</p> <div class="example"><pre>
typedef string _native;
interface i {
   void foo(in _native Arg);
   };
};
    </pre></div> <h2 id="id80485">6.16 Type Code Representation</h2>  <p>Type Codes are used in <code class="code">any</code> values. To avoid mistakes, you should use access functions exported by the Data Types modules (e.g. struct, union etc) or the <code class="bold_code"><a href="../orber_tc/">orber_tc</a></code> module.</p> <table> <tr> <td><strong>Type Code</strong></td> <td><strong>Example</strong></td> </tr> <tr> <td>tk_null</td> <td></td> </tr> <tr> <td>tk_void</td> <td></td> </tr> <tr> <td>tk_short</td> <td></td> </tr> <tr> <td>tk_long</td> <td></td> </tr> <tr> <td>tk_longlong</td> <td></td> </tr> <tr> <td>tk_ushort</td> <td></td> </tr> <tr> <td>tk_ulong</td> <td></td> </tr> <tr> <td>tk_ulonglong</td> <td></td> </tr> <tr> <td>tk_float</td> <td></td> </tr> <tr> <td>tk_double</td> <td></td> </tr> <tr> <td>tk_boolean</td> <td></td> </tr> <tr> <td>tk_char</td> <td></td> </tr> <tr> <td>tk_wchar</td> <td></td> </tr> <tr> <td>tk_octet</td> <td></td> </tr> <tr> <td>tk_any</td> <td></td> </tr> <tr> <td>tk_TypeCode</td> <td></td> </tr> <tr> <td>tk_Principal</td> <td></td> </tr> <tr> <td>{tk_objref, IFRId, Name}</td> <td>{tk_objref, "IDL:M1\I1:1.0", "I1"}</td> </tr> <tr> <td>{tk_struct, IFRId, Name, [{ElemName, ElemTC}]}</td> <td>{tk_struct, "IDL:M1\S1:1.0", "S1", [{"a", tk_long}, {"b", tk_char}]}</td> </tr> <tr> <td>{tk_union, IFRId, Name, DiscrTC, DefaultNr, [{Label, ElemName, ElemTC}]} <br> Note: DefaultNr tells which of tuples in the case list that is default, or -1 if no default</td> <td>{tk_union, "IDL:U1:1.0", "U1", tk_long, 1, [{1, "a", tk_long}, {default, "b", tk_char}]}</td> </tr> <tr> <td>{tk_enum, IFRId, Name, [ElemName]}</td> <td>{tk_enum, "IDL:E1:1.0", "E1", ["a1", "a2"]}</td> </tr> <tr> <td>{tk_string, Length}</td> <td>{tk_string, 5}</td> </tr> <tr> <td>{tk_wstring, Length}</td> <td>{tk_wstring, 7}</td> </tr> <tr> <td>{tk_fixed, Digits, Scale}</td> <td>{tk_fixed, 3, 2}</td> </tr> <tr> <td>{tk_sequence, ElemTC, Length}</td> <td>{tk_sequence, tk_long, 4}</td> </tr> <tr> <td>{tk_array, ElemTC, Length}</td> <td>{tk_array, tk_char, 9}</td> </tr> <tr> <td>{tk_alias, IFRId, Name, TC}</td> <td>{tk_alias, "IDL:T1:1.0", "T1", tk_short}</td> </tr> <tr> <td>{tk_except, IFRId, Name, [{ElemName, ElemTC}]}</td> <td>{tk_except, "IDL:Exc1:1.0", "Exc1", [{"a", tk_long}, {"b", {tk_string, 0}}]}</td> </tr> </table> <em>Table 6.5: Type Code tuples</em><div class="_attribution">
  <p class="_attribution-p">
    © 1999–2016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
