
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Mnesia - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" mnesia ">
  <meta name="keywords" content="mnesia, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/lib/mnesia-4.13.3/doc/html/mnesia/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>mnesia</h1> <h2>Module</h2> <p class="REFBODY">mnesia</p> <h2>Module summary</h2> <p class="REFBODY">A distributed telecommunications DBMS</p> <h2>Description</h2> 
<p>The following are some of the most important and attractive capabilities provided by <code class="code">Mnesia</code>:</p> <ul> <li>A relational/object hybrid data model that is suitable for telecommunications applications. </li> <li>A DBMS query language, Query List Comprehension (QLC) as an add-on library. </li> <li>Persistence. Tables can be coherently kept on disc and in the main memory. </li> <li>Replication. Tables can be replicated at several nodes. </li> <li>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction. </li> <li>Location transparency. Programs can be written without knowledge of the actual data location. </li> <li>Extremely fast real-time data searches. </li> <li>Schema manipulation routines. The DBMS can be reconfigured at runtime without stopping the system. </li> </ul> <p>This Reference Manual describes the <code class="code">Mnesia</code> API. This includes functions that define and manipulate <code class="code">Mnesia</code> tables.</p> <p>All functions in this Reference Manual can be used in any combination with queries using the list comprehension notation. For information about the query notation, see the <code class="bold_code">qlc</code> manual page in <code class="code">STDLIB</code>.</p> <p>Data in <code class="code">Mnesia</code> is organized as a set of tables. Each table has a name that must be an atom. Each table is made up of Erlang records. The user is responsible for the record definitions. Each table also has a set of properties. The following are some of the properties that are associated with each table:</p> <ul> <li> <p><code class="code">type</code>. Each table can have <code class="code">set</code>, <code class="code">ordered_set</code>, or <code class="code">bag</code> semantics. Notice that currently <code class="code">ordered_set</code> is not supported for <code class="code">disc_only_copies</code>.</p> <p>If a table is of type <code class="code">set</code>, each key leads to either one or zero records.</p> <p>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type <code class="code">bag</code>, each key can map to several records. All records in type <code class="code">bag</code> tables are unique, only the keys can be duplicated.</p> </li> <li> <p><code class="code">record_name</code>. All records stored in a table must have the same name. The records must be instances of the same record type.</p> </li> <li> <p><code class="code">ram_copies</code>. A table can be replicated on a number of Erlang nodes. Property <code class="code">ram_copies</code> specifies a list of Erlang nodes where RAM copies are kept. These copies can be dumped to disc at regular intervals. However, updates to these copies are not written to disc on a transaction basis.</p> </li> <li> <p><code class="code">disc_copies</code>. This property specifies a list of Erlang nodes where the table is kept in RAM and on disc. All updates of the table are performed in the actual table and are also logged to disc. If a table is of type <code class="code">disc_copies</code> at a certain node, the entire table is resident in RAM memory and on disc. Each transaction performed on the table is appended to a <code class="code">LOG</code> file and written into the RAM table.</p> </li> <li> <p><code class="code">disc_only_copies</code>. Some, or all, table replicas can be kept on disc only. These replicas are considerably slower than the RAM-based replicas.</p> </li> <li> <p><code class="code">index</code>. This is a list of attribute names, or integers, which specify the tuple positions on which <code class="code">Mnesia</code> is to build and maintain an extra index table.</p> </li> <li> <p><code class="code">local_content</code>. When an application requires tables whose contents are local to each node, <code class="code">local_content</code> tables can be used. The table name is known to all <code class="code">Mnesia</code> nodes, but its content is unique on each node. This means that access to such a table must be done locally. Set field <code class="code">local_content</code> to <code class="code">true</code> to enable the <code class="code">local_content</code> behavior. Default is <code class="code">false</code>.</p> </li> <li> <p><code class="code">majority</code>. This attribute is <code class="code">true</code> or <code class="code">false</code>; default is <code class="code">false</code>. When <code class="code">true</code>, a majority of the table replicas must be available for an update to succeed. Majority checking can be enabled on tables with mission-critical data, where it is vital to avoid inconsistencies because of network splits.</p> </li> <li> <p><code class="code">snmp</code>. Each (set-based) <code class="code">Mnesia</code> table can be automatically turned into a Simple Network Management Protocol (SNMP) ordered table as well. This property specifies the types of the SNMP keys.</p> </li> <li> <p><code class="code">attributes</code>. The names of the attributes for the records that are inserted in the table.</p> </li> </ul> <p>For information about the complete set of table properties and their details, see <code class="code">mnesia:create_table/2</code>.</p> <p>This Reference Manual uses a table of persons to illustrate various examples. The following record definition is assumed:</p> <div class="example"><pre>
-record(person, {name,
                 age = 0,
                 address = unknown,
                 salary = 0,
                 children = []}),</pre></div> <p>The first record attribute is the primary key, or key for short.</p> <p>The function descriptions are sorted in alphabetical order. It is recommended to start to read about <code class="code">mnesia:create_table/2</code>, <code class="code">mnesia:lock/2</code>, and <code class="code">mnesia:activity/4</code> before you continue and learn about the rest.</p> <p>Writing or deleting in transaction-context creates a local copy of each modified record during the transaction. During iteration, that is, <code class="code">mnesia:fold[lr]/4</code>, <code class="code">mnesia:next/2</code>, <code class="code">mnesia:prev/2</code>, and <code class="code">mnesia:snmp_get_next_index/2</code>, <code class="code">Mnesia</code> compensates for every written or deleted record, which can reduce the performance.</p> <p>If possible, avoid writing or deleting records in the same transaction before iterating over the table.</p>  <h2>Exports</h2> <h3 id="abort-1" class="code">abort(Reason) -&gt; transaction abort</h3> 
<p>Makes the transaction silently return the tuple <code class="code">{aborted, Reason}</code>. Termination of a <code class="code">Mnesia</code> transaction means that an exception is thrown to an enclosing <code class="code">catch</code>. Thus, the expression <code class="code">catch mnesia:abort(x)</code> does not terminate the transaction.</p>  <h3 id="activate_checkpoint-1" class="code">activate_checkpoint(Args) -&gt; {ok,Name,Nodes} | {error,Reason}</h3> 
<p>A checkpoint is a consistent view of the system. A checkpoint can be activated on a set of tables. This checkpoint can then be traversed and presents a view of the system as it existed at the time when the checkpoint was activated, even if the tables are being or have been manipulated.</p> <p><code class="code">Args</code> is a list of the following tuples:</p> <ul> <li> <p><code class="code">{name,Name}</code>. <code class="code">Name</code> is the checkpoint name. Each checkpoint must have a name that is unique to the associated nodes. The name can be reused only once the checkpoint has been deactivated. By default, a name that is probably unique is generated.</p> </li> <li> <p><code class="code">{max,MaxTabs}</code>. <code class="code">MaxTabs</code> is a list of tables that are to be included in the checkpoint. Default is <code class="code">[]</code>. For these tables, the redundancy is maximized and checkpoint information is retained together with all replicas. The checkpoint becomes more fault tolerant if the tables have several replicas. When a new replica is added by the schema manipulation function <code class="code">mnesia:add_table_copy/3</code>, a retainer is also attached automatically.</p> </li> <li> <p><code class="code">{min,MinTabs}</code>. <code class="code">MinTabs</code> is a list of tables that are to be included in the checkpoint. Default is []. For these tables, the redundancy is minimized and the checkpoint information is only retained with one replica, preferably on the local node.</p> </li> <li> <p><code class="code">{allow_remote,Bool}</code>. <code class="code">false</code> means that all retainers must be local. The checkpoint cannot be activated if a table does not reside locally. <code class="code">true</code> allows retainers to be allocated on any node. Default is <code class="code">true</code>.</p> </li> <li> <p><code class="code">{ram_overrides_dump,Bool}</code>. Only applicable for <code class="code">ram_copies</code>. <code class="code">Bool</code> allows you to choose to back up the table state as it is in RAM, or as it is on disc. <code class="code">true</code> means that the latest committed records in RAM are to be included in the checkpoint. These are the records that the application accesses. <code class="code">false</code> means that the records dumped to <code class="code">DAT</code> files are to be included in the checkpoint. These records are loaded at startup. Default is <code class="code">false</code>.</p> </li> </ul> <p>Returns <code class="code">{ok,Name,Nodes}</code> or <code class="code">{error,Reason}</code>. <code class="code">Name</code> is the (possibly generated) checkpoint name. <code class="code">Nodes</code> are the nodes that are involved in the checkpoint. Only nodes that keep a checkpoint retainer know about the checkpoint.</p>  <h3 id="activity-2" class="code">activity(AccessContext, Fun [, Args]) -&gt; ResultOfFun | exit(Reason)</h3> 
<p>Calls <code class="code">mnesia:activity(AccessContext, Fun, Args, AccessMod)</code>, where <code class="code">AccessMod</code> is the default access callback module obtained by <code class="code">mnesia:system_info(access_module)</code>. <code class="code">Args</code> defaults to <code class="code">[]</code> (empty list).</p>  <h3 id="activity-4" class="code">activity(AccessContext, Fun, Args, AccessMod) -&gt; ResultOfFun | exit(Reason)</h3> 
<p>Executes the functional object <code class="code">Fun</code> with argument <code class="code">Args</code>.</p> <p>The code that executes inside the activity can consist of a series of table manipulation functions, which are performed in an <code class="code">AccessContext</code>. Currently, the following access contexts are supported:</p> <dl> <dt><strong><code class="code">transaction</code></strong></dt> <dd> <p>Short for <code class="code">{transaction, infinity}</code></p> </dd> <dt><strong><code class="code">{transaction, Retries}</code></strong></dt> <dd> <p>Calls <code class="code">mnesia:transaction(Fun, Args, Retries)</code>. Notice that the result from <code class="code">Fun</code> is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</p> </dd> <dt><strong><code class="code">sync_transaction</code></strong></dt> <dd> <p>Short for <code class="code">{sync_transaction, infinity}</code></p> </dd> <dt><strong><code class="code">{sync_transaction, Retries}</code></strong></dt> <dd> <p>Calls <code class="code">mnesia:sync_transaction(Fun, Args, Retries)</code>. Notice that the result from <code class="code">Fun</code> is returned if the transaction is successful (atomic), otherwise the function exits with an abort reason.</p> </dd> <dt><strong><code class="code">async_dirty</code></strong></dt> <dd> <p>Calls <code class="code">mnesia:async_dirty(Fun, Args)</code>.</p> </dd> <dt><strong><code class="code">sync_dirty</code></strong></dt> <dd> <p>Calls <code class="code">mnesia:sync_dirty(Fun, Args)</code>.</p> </dd> <dt><strong><code class="code">ets</code></strong></dt> <dd> <p>Calls <code class="code">mnesia:ets(Fun, Args)</code>.</p> </dd> </dl> <p>This function (<code class="code">mnesia:activity/4</code>) differs in an important way from the functions <code class="code">mnesia:transaction</code>, <code class="code">mnesia:sync_transaction</code>, <code class="code">mnesia:async_dirty</code>, <code class="code">mnesia:sync_dirty</code>, and <code class="code">mnesia:ets</code>. Argument <code class="code">AccessMod</code> is the name of a callback module, which implements the <code class="code">mnesia_access</code> behavior.</p> <p><code class="code">Mnesia</code> forwards calls to the following functions:</p> <ul> <li>mnesia:lock/2 (read_lock_table/1, write_lock_table/1) </li> <li>mnesia:write/3 (write/1, s_write/1) </li> <li>mnesia:delete/3 (delete/1, s_delete/1) </li> <li>mnesia:delete_object/3 (delete_object/1, s_delete_object/1) </li> <li>mnesia:read/3 (read/1, wread/1) </li> <li>mnesia:match_object/3 (match_object/1) </li> <li>mnesia:all_keys/1 </li> <li>mnesia:first/1 </li> <li>mnesia:last/1 </li> <li>mnesia:prev/2 </li> <li>mnesia:next/2 </li> <li>mnesia:index_match_object/4 (index_match_object/2) </li> <li>mnesia:index_read/3 </li> <li>mnesia:table_info/2 </li> </ul> <p>to the corresponding:</p> <ul> <li>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind) </li> <li>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind) </li> <li>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind) </li> <li>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS, LockKind) </li> <li>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind) </li> <li>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern, LockKind) </li> <li>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind) </li> <li>AccessMod:first(ActivityId, Opaque, Tab) </li> <li>AccessMod:last(ActivityId, Opaque, Tab) </li> <li>AccessMod:prev(ActivityId, Opaque, Tab, Key) </li> <li>AccessMod:next(ActivityId, Opaque, Tab, Key) </li> <li>AccessMod:index_match_object(ActivityId, Opaque, Tab, Pattern, Attr, LockKind) </li> <li>AccessMod:index_read(ActivityId, Opaque, Tab, SecondaryKey, Attr, LockKind) </li> <li>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem) </li> </ul> <p><code class="code">ActivityId</code> is a record that represents the identity of the enclosing <code class="code">Mnesia</code> activity. The first field (obtained with <code class="code">element(1, ActivityId)</code>) contains an atom, which can be interpreted as the activity type: <code class="code">ets</code>, <code class="code">async_dirty</code>, <code class="code">sync_dirty</code>, or <code class="code">tid</code>. <code class="code">tid</code> means that the activity is a transaction. The structure of the rest of the identity record is internal to <code class="code">Mnesia</code>.</p> <p><code class="code">Opaque</code> is an opaque data structure that is internal to <code class="code">Mnesia</code>.</p>  <h3 id="add_table_copy-3" class="code">add_table_copy(Tab, Node, Type) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Makes another copy of a table at the node <code class="code">Node</code>. Argument <code class="code">Type</code> must be either of the atoms <code class="code">ram_copies</code>, <code class="code">disc_copies</code>, or <code class="code">disc_only_copies</code>. For example, the following call ensures that a disc replica of the <code class="code">person</code> table also exists at node <code class="code">Node</code>:</p> <div class="example"><pre>
mnesia:add_table_copy(person, Node, disc_copies)</pre></div> <p>This function can also be used to add a replica of the table named <code class="code">schema</code>.</p>  <h3 id="add_table_index-2" class="code">add_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Table indexes can be used whenever the user wants to use frequently some other field than the key field to look up records. If this other field has an associated index, these lookups can occur in constant time and space. For example, if your application wishes to use field <code class="code">age</code> to find efficiently all persons with a specific age, it can be a good idea to have an index on field <code class="code">age</code>. This can be done with the following call:</p> <div class="example"><pre>
mnesia:add_table_index(person, age)</pre></div> <p>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</p>  <h3 id="all_keys-1" class="code">all_keys(Tab) -&gt; KeyList | transaction abort</h3> 
<p>Returns a list of all keys in the table named <code class="code">Tab</code>. The semantics of this function is context-sensitive. For more information, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a read lock on the entire table.</p>  <h3 id="async_dirty-2" class="code">async_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</h3> 
<p>Calls the <code class="code">Fun</code> in a context that is not protected by a transaction. The <code class="code">Mnesia</code> function calls performed in the <code class="code">Fun</code> are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions, but there is no locking, local transaction storage, or commit protocols involved. Checkpoint retainers and indexes are updated, but they are updated dirty. As for normal <code class="code">mnesia:dirty_*</code> operations, the operations are performed semi-asynchronously. For details, see <code class="code">mnesia:activity/4</code> and the User's Guide.</p> <p>The <code class="code">Mnesia</code> tables can be manipulated without using transactions. This has some serious disadvantages, but is considerably faster, as the transaction manager is not involved and no locks are set. A dirty operation does, however, guarantee a certain level of consistency, and the dirty operations cannot return garbled records. All dirty operations provide location transparency to the programmer, and a program does not have to be aware of the whereabouts of a certain table to function.</p> <p>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</p> <p>Depending on the application, it can be a good idea to use the dirty functions for certain operations. Almost all <code class="code">Mnesia</code> functions that can be called within transactions have a dirty equivalent, which is much more efficient.</p> <p>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</p> <p>Notice that calling (nesting) <code class="code">mnesia:[a]sync_dirty</code> inside a transaction-context inherits the transaction semantics.</p>  <h3 id="backup-1" class="code">backup(Opaque [, BackupMod]) -&gt; ok | {error,Reason}</h3> 
<p>Activates a new checkpoint covering all <code class="code">Mnesia</code> tables, including the schema, with maximum degree of redundancy, and performs a backup using <code class="code">backup_checkpoint/2/3</code>. The default value of the backup callback module <code class="code">BackupMod</code> is obtained by <code class="code">mnesia:system_info(backup_module)</code>.</p>  <h3 id="backup_checkpoint-2" class="code">backup_checkpoint(Name, Opaque [, BackupMod]) -&gt; ok | {error,Reason}</h3> 
<p>The tables are backed up to external media using backup module <code class="code">BackupMod</code>. Tables with the local contents property are backed up as they exist on the current node. <code class="code">BackupMod</code> is the default backup callback module obtained by <code class="code">mnesia:system_info(backup_module)</code>. For information about the exact callback interface (the <code class="code">mnesia_backup behavior</code>), see the User's Guide.</p>  <h3 id="change_config-2" class="code">change_config(Config, Value) -&gt; {error, Reason} | {ok, ReturnValue}</h3> 
<p><code class="code">Config</code> is to be an atom of the following configuration parameters:</p> <dl> <dt><strong><code class="code">extra_db_nodes</code></strong></dt> <dd> <p><code class="code">Value</code> is a list of nodes that <code class="code">Mnesia</code> is to try to connect to. <code class="code">ReturnValue</code> is those nodes in <code class="code">Value</code> that <code class="code">Mnesia</code> is connected to.</p> <p>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</p> <p>Notice that <code class="code">Mnesia</code> can be connected to other nodes than those returned in <code class="code">ReturnValue</code>.</p> </dd> <dt><strong><code class="code">dc_dump_limit</code></strong></dt> <dd> <p><code class="code">Value</code> is a number. See the description in <code class="bold_code"><a href="#configuration_parameters">Section Configuration Parameters</a></code>. <code class="code">ReturnValue</code> is the new value. Notice that this configuration parameter is not persistent. It is lost when <code class="code">Mnesia</code> has stopped.</p> </dd> </dl>  <h3 id="change_table_access_mode-2" class="code">change_table_access_mode(Tab, AccessMode) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p><code class="code">AcccessMode</code> is by default the atom <code class="code">read_write</code> but it can also be set to the atom <code class="code">read_only</code>. If <code class="code">AccessMode</code> is set to <code class="code">read_only</code>, updates to the table cannot be performed. At startup, <code class="code">Mnesia</code> always loads <code class="code">read_only</code> tables locally regardless of when and if <code class="code">Mnesia</code> is terminated on other nodes.</p>  <h3 id="change_table_copy_type-3" class="code">change_table_copy_type(Tab, Node, To) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>For example:</p> <div class="example"><pre>
mnesia:change_table_copy_type(person, node(), disc_copies)</pre></div> <p>Transforms the <code class="code">person</code> table from a RAM table into a disc-based table at <code class="code">Node</code>.</p> <p>This function can also be used to change the storage type of the table named <code class="code">schema</code>. The schema table can only have <code class="code">ram_copies</code> or <code class="code">disc_copies</code> as the storage type. If the storage type of the schema is <code class="code">ram_copies</code>, no other table can be disc-resident on that node.</p>  <h3 id="change_table_load_order-2" class="code">change_table_load_order(Tab, LoadOrder) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>The <code class="code">LoadOrder</code> priority is by default <code class="code">0</code> (zero) but can be set to any integer. The tables with the highest <code class="code">LoadOrder</code> priority are loaded first at startup.</p>  <h3 id="change_table_majority-2" class="code">change_table_majority(Tab, Majority) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p><code class="code">Majority</code> must be a boolean. Default is <code class="code">false</code>. When <code class="code">true</code>, a majority of the table replicas must be available for an update to succeed. When used on fragmented tables, <code class="code">Tab</code> must be the base table name. Directly changing the majority setting on individual fragments is not allowed.</p>  <h3 id="clear_table-1" class="code">clear_table(Tab) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Deletes all entries in the table <code class="code">Tab</code>.</p>  <h3 id="create_schema-1" class="code">create_schema(DiscNodes) -&gt; ok | {error,Reason}</h3> 
<p>Creates a new database on disc. Various files are created in the local <code class="code">Mnesia</code> directory of each node. Notice that the directory must be unique for each node. Two nodes must never share the same directory. If possible, use a local disc device to improve performance.</p> <p><code class="code">mnesia:create_schema/1</code> fails if any of the Erlang nodes given as <code class="code">DiscNodes</code> are not alive, if <code class="code">Mnesia</code> is running on any of the nodes, or if any of the nodes already have a schema. Use <code class="code">mnesia:delete_schema/1</code> to get rid of old faulty schemas.</p> <p>Notice that only nodes with disc are to be included in <code class="code">DiscNodes</code>. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</p>  <h3 id="create_table-2" class="code">create_table(Name, TabDef) -&gt; {atomic, ok} | {aborted, Reason}</h3> 
<p>Creates a <code class="code">Mnesia</code> table called <code class="code">Name</code> according to argument <code class="code">TabDef</code>. This list must be a list of <code class="code">{Item, Value}</code> tuples, where the following values are allowed:</p> <ul> <li> <p><code class="code">{access_mode, Atom}</code>. The access mode is by default the atom <code class="code">read_write</code> but it can also be set to the atom <code class="code">read_only</code>. If <code class="code">AccessMode</code> is set to <code class="code">read_only</code>, updates to the table cannot be performed.</p> <p>At startup, <code class="code">Mnesia</code> always loads <code class="code">read_only</code> table locally regardless of when and if <code class="code">Mnesia</code> is terminated on other nodes. This argument returns the access mode of the table. The access mode can be <code class="code">read_only</code> or <code class="code">read_write</code>.</p> </li> <li> <p><code class="code">{attributes, AtomList}</code> is a list of the attribute names for the records that are supposed to populate the table. Default is <code class="code">[key, val]</code>. The table must at least have one extra attribute in addition to the key.</p> <p>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use construct <code class="code">record_info(fields, RecordName)</code> instead. It can be used for records of type <code class="code">RecordName</code>.</p> </li> <li> <p><code class="code">{disc_copies, Nodelist}</code>, where <code class="code">Nodelist</code> is a list of the nodes where this table is supposed to have disc copies. If a table replica is of type <code class="code">disc_copies</code>, all write operations on this particular replica of the table are written to disc and to the RAM copy of the table.</p> <p>It is possible to have a replicated table of type <code class="code">disc_copies</code> on one node and another type on another node. Default is <code class="code">[]</code>.</p> </li> <li> <p><code class="code">{disc_only_copies, Nodelist}</code>, where <code class="code">Nodelist</code> is a list of the nodes where this table is supposed to have <code class="code">disc_only_copies</code>. A disc only table replica is kept on disc only and unlike the other replica types, the contents of the replica do not reside in RAM. These replicas are considerably slower than replicas held in RAM.</p> </li> <li> <p><code class="code">{index, Intlist}</code>, where <code class="code">Intlist</code> is a list of attribute names (atoms) or record fields for which <code class="code">Mnesia</code> is to build and maintain an extra index table. The <code class="code">qlc</code> query compiler <strong>may</strong> be able to optimize queries if there are indexes available.</p> </li> <li> <p><code class="code">{load_order, Integer}</code>. The load order priority is by default <code class="code">0</code> (zero) but can be set to any integer. The tables with the highest load order priority are loaded first at startup.</p> </li> <li> <p><code class="code">{majority, Flag}</code>, where <code class="code">Flag</code> must be a boolean. If <code class="code">true</code>, any (non-dirty) update to the table is aborted, unless a majority of the table replicas are available for the commit. When used on a fragmented table, all fragments are given the same the same majority setting.</p> </li> <li> <p><code class="code">{ram_copies, Nodelist}</code>, where <code class="code">Nodelist</code> is a list of the nodes where this table is supposed to have RAM copies. A table replica of type <code class="code">ram_copies</code> is not written to disc on a per transaction basis. <code class="code">ram_copies</code> replicas can be dumped to disc with the function <code class="code">mnesia:dump_tables(Tabs)</code>. Default value for this attribute is <code class="code">[node()]</code>.</p> </li> <li> <p><code class="code">{record_name, Name}</code>, where <code class="code">Name</code> must be an atom. All records stored in the table must have this name as the first element. It defaults to the same name as the table name.</p> </li> <li> <p><code class="code">{snmp, SnmpStruct}</code>. For a description of <code class="code">SnmpStruct</code>, see <code class="code">mnesia:snmp_open_table/2</code>. If this attribute is present in <code class="code">ArgList</code> to <code class="code">mnesia:create_table/2</code>, the table is immediately accessible by SNMP. Therefore applications that use SNMP to manipulate and control the system can be designed easily, since <code class="code">Mnesia</code> provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a <code class="code">Mnesia</code> table.</p> </li> <li> <p><code class="code">{storage_properties, [{Backend, Properties}]</code> forwards more properties to the back end storage. <code class="code">Backend</code> can currently be <code class="code">ets</code> or <code class="code">dets</code>. <code class="code">Properties</code> is a list of options sent to the back end storage during table creation. <code class="code">Properties</code> cannot contain properties already used by <code class="code">Mnesia</code>, such as <code class="code">type</code> or <code class="code">named_table</code>.</p> <p>For example:</p> <div class="example"><pre>
mnesia:create_table(table, [{ram_copies, [node()]}, {disc_only_copies, nodes()},
       {storage_properties,
        [{ets, [compressed]}, {dets, [{auto_save, 5000}]} ]}])</pre></div> </li> <li> <p><code class="code">{type, Type}</code>, where <code class="code">Type</code> must be either of the atoms <code class="code">set</code>, <code class="code">ordered_set</code>, or <code class="code">bag</code>. Default is <code class="code">set</code>. In a <code class="code">set</code>, all records have unique keys. In a <code class="code">bag</code>, several records can have the same key, but the record content is unique. If a non-unique record is stored, the old conflicting records are overwritten.</p> <p>Notice that currently <code class="code">ordered_set</code> is not supported for <code class="code">disc_only_copies</code>.</p> </li> <li> <p><code class="code">{local_content, Bool}</code>, where <code class="code">Bool</code> is <code class="code">true</code> or <code class="code">false</code>. Default is <code class="code">false</code>.</p> </li> </ul> <p>For example, the following call creates the <code class="code">person</code> table (defined earlier) and replicates it on two nodes:</p> <div class="example"><pre>
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {attributes, record_info(fields, person)}]).</pre></div> <p>If it is required that <code class="code">Mnesia</code> must build and maintain an extra index table on attribute <code class="code">address</code> of all the <code class="code">person</code> records that are inserted in the table, the following code would be issued:</p> <div class="example"><pre>
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {index, [address]},
     {attributes, record_info(fields, person)}]).
   </pre></div> <p>The specification of <code class="code">index</code> and <code class="code">attributes</code> can be hard-coded as <code class="code">{index, [2]}</code> and <code class="code">{attributes, [name, age, address, salary, children]}</code>, respectively.</p> <p><code class="code">mnesia:create_table/2</code> writes records into the table <code class="code">schema</code>. This function, and all other schema manipulation functions, are implemented with the normal transaction management system. This guarantees that schema updates are performed on all nodes in an atomic manner.</p>  <h3 id="deactivate_checkpoint-1" class="code">deactivate_checkpoint(Name) -&gt; ok | {error, Reason}</h3> 
<p>The checkpoint is automatically deactivated when some of the tables involved have no retainer attached to them. This can occur when nodes go down or when a replica is deleted. Checkpoints are also deactivated with this function. <code class="code">Name</code> is the name of an active checkpoint.</p>  <h3 id="del_table_copy-2" class="code">del_table_copy(Tab, Node) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Deletes the replica of table <code class="code">Tab</code> at node <code class="code">Node</code>. When the last replica is deleted with this function, the table disappears entirely.</p> <p>This function can also be used to delete a replica of the table named <code class="code">schema</code>. The <code class="code">Mnesia</code> node is then removed. Notice that <code class="code">Mnesia</code> must be stopped on the node first.</p>  <h3 id="del_table_index-2" class="code">del_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Deletes the index on attribute with name <code class="code">AttrName</code> in a table.</p>  <h3 id="delete-1" class="code">delete({Tab, Key}) -&gt; transaction abort | ok</h3> 
<p>Calls <code class="code">mnesia:delete(Tab, Key, write)</code>.</p>  <h3 id="delete-3" class="code">delete(Tab, Key, LockKind) -&gt; transaction abort | ok</h3> 
<p>Deletes all records in table <code class="code">Tab</code> with the key <code class="code">Key</code>.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code class="code">LockKind</code> in the record. Currently, the lock types <code class="code">write</code> and <code class="code">sticky_write</code> are supported.</p>  <h3 id="delete_object-1" class="code">delete_object(Record) -&gt; transaction abort | ok</h3> 
<p>Calls <code class="code">mnesia:delete_object(Tab, Record, write)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Record)</code>.</p>  <h3 id="delete_object-3" class="code">delete_object(Tab, Record, LockKind) -&gt; transaction abort | ok</h3> 
<p>If a table is of type <code class="code">bag</code>, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function <code class="code">delete_object/3</code>. A complete record must be supplied to this function.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code class="code">LockKind</code> on the record. Currently, the lock types <code class="code">write</code> and <code class="code">sticky_write</code> are supported.</p>  <h3 id="delete_schema-1" class="code">delete_schema(DiscNodes) -&gt; ok | {error,Reason}</h3> 
<p>Deletes a database created with <code class="code">mnesia:create_schema/1</code>. <code class="code">mnesia:delete_schema/1</code> fails if any of the Erlang nodes given as <code class="code">DiscNodes</code> are not alive, or if <code class="code">Mnesia</code> is running on any of the nodes.</p> <p>After the database is deleted, it can still be possible to start <code class="code">Mnesia</code> as a disc-less node. This depends on how configuration parameter <code class="code">schema_location</code> is set.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Use this function with extreme caution, as it makes existing persistent data obsolete. Think twice before using it.</p> </div> </div>  <h3 id="delete_table-1" class="code">delete_table(Tab) -&gt; {aborted, Reason} | {atomic, ok}</h3> 
<p>Permanently deletes all replicas of table <code class="code">Tab</code>.</p>  <h3 id="dirty_all_keys-1" class="code">dirty_all_keys(Tab) -&gt; KeyList | exit({aborted, Reason})</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:all_keys/1</code>.</p>  <h3 id="dirty_delete-1" class="code">dirty_delete({Tab, Key}) -&gt; ok | exit({aborted, Reason})</h3> 
<p>Calls <code class="code">mnesia:dirty_delete(Tab, Key)</code>.</p>  <h3 id="dirty_delete-2" class="code">dirty_delete(Tab, Key) -&gt; ok | exit({aborted, Reason})</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:delete/3</code>.</p>  <h3 id="dirty_delete_object-1" class="code">dirty_delete_object(Record)</h3> 
<p>Calls <code class="code">mnesia:dirty_delete_object(Tab, Record)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Record)</code>.</p>  <h3 id="dirty_delete_object-2" class="code">dirty_delete_object(Tab, Record)</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:delete_object/3</code>.</p>  <h3 id="dirty_first-1" class="code">dirty_first(Tab) -&gt; Key | exit({aborted, Reason})</h3> 
<p>Records in <code class="code">set</code> or <code class="code">bag</code> tables are not ordered. However, there is an ordering of the records that is unknown to the user. Therefore, a table can be traversed by this function with the function <code class="code">mnesia:dirty_next/2</code>. </p> <p>If there are no records in the table, this function returns the atom <code class="code">'$end_of_table'</code>. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</p>  <h3 id="dirty_index_match_object-2" class="code">dirty_index_match_object(Pattern, Pos)</h3> 
<p>Starts <code class="code">mnesia:dirty_index_match_object(Tab, Pattern, Pos)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Pattern)</code>.</p>  <h3 id="dirty_index_match_object-3" class="code">dirty_index_match_object(Tab, Pattern, Pos)</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:index_match_object/4</code>.</p>  <h3 id="dirty_index_read-3" class="code">dirty_index_read(Tab, SecondaryKey, Pos)</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:index_read/3</code>.</p>  <h3 id="dirty_last-1" class="code">dirty_last(Tab) -&gt; Key | exit({aborted, Reason})</h3> 
<p>Works exactly like <code class="code">mnesia:dirty_first/1</code> but returns the last object in Erlang term order for the <code class="code">ordered_set</code> table type. For all other table types, <code class="code">mnesia:dirty_first/1</code> and <code class="code">mnesia:dirty_last/1</code> are synonyms.</p>  <h3 id="dirty_match_object-1" class="code">dirty_match_object(Pattern) -&gt; RecordList | exit({aborted, Reason})</h3> 
<p>Calls <code class="code">mnesia:dirty_match_object(Tab, Pattern)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Pattern)</code>.</p>  <h3 id="dirty_match_object-2" class="code">dirty_match_object(Tab, Pattern) -&gt; RecordList | exit({aborted, Reason})</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:match_object/3</code>.</p>  <h3 id="dirty_next-2" class="code">dirty_next(Tab, Key) -&gt; Key | exit({aborted, Reason})</h3> 
<p>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key <code class="code">'$end_of_table'</code> is returned. Otherwise, the function returns a key that can be used to read the actual record. The behavior is undefined if another Erlang process performs write operations on the table while it is being traversed with the function <code class="code">mnesia:dirty_next/2</code>.</p>  <h3 id="dirty_prev-2" class="code">dirty_prev(Tab, Key) -&gt; Key | exit({aborted, Reason})</h3> 
<p>Works exactly like <code class="code">mnesia:dirty_next/2</code> but returns the previous object in Erlang term order for the <code class="code">ordered_set</code> table type. For all other table types, <code class="code">mnesia:dirty_next/2</code> and <code class="code">mnesia:dirty_prev/2</code> are synonyms.</p>  <h3 id="dirty_read-1" class="code">dirty_read({Tab, Key}) -&gt; ValueList | exit({aborted, Reason}</h3> 
<p>Calls <code class="code">mnesia:dirty_read(Tab, Key)</code>.</p>  <h3 id="dirty_read-2" class="code">dirty_read(Tab, Key) -&gt; ValueList | exit({aborted, Reason}</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:read/3</code>.</p>  <h3 id="dirty_select-2" class="code">dirty_select(Tab, MatchSpec) -&gt; ValueList | exit({aborted, Reason}</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:select/2</code>.</p>  <h3 id="dirty_slot-2" class="code">dirty_slot(Tab, Slot) -&gt; RecordList | exit({aborted, Reason})</h3> 
<p>Traverses a table in a manner similar to the function <code class="code">mnesia:dirty_next/2</code>. A table has a number of slots that range from 0 (zero) to an unknown upper bound. The function <code class="code">mnesia:dirty_slot/2</code> returns the special atom <code class="code">'$end_of_table'</code> when the end of the table is reached. The behavior of this function is undefined if a write operation is performed on the table while it is being traversed.</p>  <h3 id="dirty_update_counter-2" class="code">dirty_update_counter({Tab, Key}, Incr) -&gt; NewVal | exit({aborted, Reason})</h3> 
<p>Calls <code class="code">mnesia:dirty_update_counter(Tab, Key, Incr)</code>.</p>  <h3 id="dirty_update_counter-3" class="code">dirty_update_counter(Tab, Key, Incr) -&gt; NewVal | exit({aborted, Reason})</h3> 
<p><code class="code">Mnesia</code> has no special counter records. However, records of the form <code class="code">{Tab, Key, Integer}</code> can be used as (possibly disc-resident) counters when <code class="code">Tab</code> is a <code class="code">set</code>. This function updates a counter with a positive or negative number. However, counters can never become less than zero. There are two significant differences between this function and the action of first reading the record, performing the arithmetics, and then writing the record:</p> <ul> <li>It is much more efficient. </li> <li> <code class="code">mnesia:dirty_update_counter/3</code> is performed as an atomic operation although it is not protected by a transaction. </li> </ul> <p>If two processes perform <code class="code">mnesia:dirty_update_counter/3</code> simultaneously, both updates take effect without the risk of losing one of the updates. The new value <code class="code">NewVal</code> of the counter is returned.</p> <p>If <code class="code">Key</code> do not exists, a new record is created with value <code class="code">Incr</code> if it is larger than 0, otherwise it is set to 0.</p>  <h3 id="dirty_write-1" class="code">dirty_write(Record) -&gt; ok | exit({aborted, Reason})</h3> 
<p>Calls <code class="code">mnesia:dirty_write(Tab, Record)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Record)</code>.</p>  <h3 id="dirty_write-2" class="code">dirty_write(Tab, Record) -&gt; ok | exit({aborted, Reason})</h3> 
<p>Dirty equivalent of the function <code class="code">mnesia:write/3</code>.</p>  <h3 id="dump_log-0" class="code">dump_log() -&gt; dumped</h3> 
<p>Performs a user-initiated dump of the local log file. This is usually not necessary, as <code class="code">Mnesia</code> by default manages this automatically. See configuration parameters <code class="bold_code"><a href="#dump_log_time_threshold">dump_log_time_threshold</a></code> and <code class="bold_code"><a href="#dump_log_write_threshold">dump_log_write_threshold</a></code>. </p>  <h3 id="dump_tables-1" class="code">dump_tables(TabList) -&gt; {atomic, ok} | {aborted, Reason}</h3> 
<p>Dumps a set of <code class="code">ram_copies</code> tables to disc. The next time the system is started, these tables are initiated with the data found in the files that are the result of this dump. None of the tables can have disc-resident replicas.</p>  <h3 id="dump_to_textfile-1" class="code">dump_to_textfile(Filename)</h3> 
<p>Dumps all local tables of a <code class="code">Mnesia</code> system into a text file, which can be edited (by a normal text editor) and then be reloaded with <code class="code">mnesia:load_textfile/1</code>. Only use this function for educational purposes. Use other functions to deal with real backups.</p>  <h3 id="error_description-1" class="code">error_description(Error) -&gt; String</h3> 
<p>All <code class="code">Mnesia</code> transactions, including all the schema update functions, either return value <code class="code">{atomic, Val}</code> or the tuple <code class="code">{aborted, Reason}</code>. <code class="code">Reason</code> can be either of the atoms in the following list. The function <code class="code">error_description/1</code> returns a descriptive string that describes the error.</p> <ul> <li> <code class="code">nested_transaction</code>. Nested transactions are not allowed in this context. </li> <li> <code class="code">badarg</code>. Bad or invalid argument, possibly bad type. </li> <li> <code class="code">no_transaction</code>. Operation not allowed outside transactions. </li> <li> <code class="code">combine_error</code>. Table options illegally combined. </li> <li> <code class="code">bad_index</code>. Index already exists, or was out of bounds. </li> <li> <code class="code">already_exists</code>. Schema option to be activated is already on. </li> <li> <code class="code">index_exists</code>. Some operations cannot be performed on tables with an index. </li> <li> <code class="code">no_exists</code>. Tried to perform operation on non-existing (not-alive) item. </li> <li> <code class="code">system_limit</code>. A system limit was exhausted. </li> <li> <code class="code">mnesia_down</code>. A transaction involves records on a remote node, which became unavailable before the transaction was completed. Records are no longer available elsewhere in the network. </li> <li> <code class="code">not_a_db_node</code>. A node was mentioned that does not exist in the schema. </li> <li> <code class="code">bad_type</code>. Bad type specified in argument. </li> <li> <code class="code">node_not_running</code>. Node is not running. </li> <li> <code class="code">truncated_binary_file</code>. Truncated binary in file. </li> <li> <code class="code">active</code>. Some delete operations require that all active records are removed. </li> <li> <code class="code">illegal</code>. Operation not supported on this record. </li> </ul> <p><code class="code">Error</code> can be <code class="code">Reason</code>, <code class="code">{error, Reason}</code>, or <code class="code">{aborted, Reason}</code>. <code class="code">Reason</code> can be an atom or a tuple with <code class="code">Reason</code> as an atom in the first field.</p> <p>The following examples illustrate a function that returns an error, and the method to retrieve more detailed error information:</p> <ul> <li>The function <code class="bold_code"><a href="#create_table-2">mnesia:create_table(bar, [{attributes, 3.14}])</a></code> returns the tuple <code class="code">{aborted,Reason}</code>, where <code class="code">Reason</code> is the tuple <code class="code">{bad_type,bar,3.14000}</code>.</li> <li>The function <code class="bold_code"><a href="#error_description-1">mnesia:error_description(Reason)</a></code> returns the term <code class="code">{"Bad type on some provided arguments",bar,3.14000}</code>, which is an error description suitable for display.</li> </ul>  <h3 id="ets-2" class="code">ets(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</h3> 
<p>Calls the <code class="code">Fun</code> in a raw context that is not protected by a transaction. The <code class="code">Mnesia</code> function call is performed in the <code class="code">Fun</code> and performed directly on the local <code class="code">ets</code> tables on the assumption that the local storage type is <code class="code">ram_copies</code> and the tables are not replicated to other nodes. Subscriptions are not triggered and checkpoints are not updated, but it is extremely fast. This function can also be applied to <code class="code">disc_copies</code> tables if all operations are read only. For details, see <code class="code">mnesia:activity/4</code> and the User's Guide.</p> <p>Notice that calling (nesting) a <code class="code">mnesia:ets</code> inside a transaction-context inherits the transaction semantics.</p>  <h3 id="first-1" class="code">first(Tab) -&gt; Key | transaction abort</h3> 
<p>Records in <code class="code">set</code> or <code class="code">bag</code> tables are not ordered. However, there is an ordering of the records that is unknown to the user. A table can therefore be traversed by this function with the function <code class="code">mnesia:next/2</code>.</p> <p>If there are no records in the table, this function returns the atom <code class="code">'$end_of_table'</code>. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</p>  <h3 id="foldl-3" class="code">foldl(Function, Acc, Table) -&gt; NewAcc | transaction abort</h3> 
<p>Iterates over the table <code class="code">Table</code> and calls <code class="code">Function(Record, NewAcc)</code> for each <code class="code">Record</code> in the table. The term returned from <code class="code">Function</code> is used as the second argument in the next call to <code class="code">Function</code>.</p> <p><code class="code">foldl</code> returns the same term as the last call to <code class="code">Function</code> returned.</p>  <h3 id="foldr-3" class="code">foldr(Function, Acc, Table) -&gt; NewAcc | transaction abort</h3> 
<p>Works exactly like <code class="code">foldl/3</code> but iterates the table in the opposite order for the <code class="code">ordered_set</code> table type. For all other table types, <code class="code">foldr/3</code> and <code class="code">foldl/3</code> are synonyms.</p>  <h3 id="force_load_table-1" class="code">force_load_table(Tab) -&gt; yes | ErrorDescription</h3> 
<p>The <code class="code">Mnesia</code> algorithm for table load can lead to a situation where a table cannot be loaded. This situation occurs when a node is started and <code class="code">Mnesia</code> concludes, or suspects, that another copy of the table was active after this local copy became inactive because of a system crash.</p> <p>If this situation is not acceptable, this function can be used to override the strategy of the <code class="code">Mnesia</code> table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</p>  <h3 id="index_match_object-2" class="code">index_match_object(Pattern, Pos) -&gt; transaction abort | ObjList</h3> 
<p>Starts <code class="code">mnesia:index_match_object(Tab, Pattern, Pos, read)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Pattern)</code>.</p>  <h3 id="index_match_object-4" class="code">index_match_object(Tab, Pattern, Pos, LockKind) -&gt; transaction abort | ObjList</h3> 
<p>In a manner similar to the function <code class="code">mnesia:index_read/3</code>, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function <code class="code">mnesia:match_object/3</code>, except that this function requires the following conditions:</p> <ul> <li> <p>The table <code class="code">Tab</code> must have an index on position <code class="code">Pos</code>.</p> </li> <li> <p>The element in position <code class="code">Pos</code> in <code class="code">Pattern</code> must be bound. <code class="code">Pos</code> is an integer (<code class="code">#record.Field</code>) or an attribute name.</p> </li> </ul> <p>The two index search functions described here are automatically started when searching tables with <code class="code">qlc</code> list comprehensions and also when using the low-level <code class="code">mnesia:[dirty_]match_object</code> functions.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code class="code">LockKind</code> on the entire table or on a single record. Currently, the lock type <code class="code">read</code> is supported.</p>  <h3 id="index_read-3" class="code">index_read(Tab, SecondaryKey, Pos) -&gt; transaction abort | RecordList</h3> 
<p>Assume that there is an index on position <code class="code">Pos</code> for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table <code class="code">person</code>, the call <code class="code">mnesia:index_read(person, 36, #person.age)</code> returns a list of all persons with age 36. <code class="code">Pos</code> can also be an attribute name (atom), but if the notation <code class="code">mnesia:index_read(person, 36, age)</code> is used, the field position is searched for in runtime, for each call.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a read lock on the entire table.</p>  <h3 id="info-0" class="code">info() -&gt; ok</h3> 
<p>Prints system information on the terminal. This function can be used even if <code class="code">Mnesia</code> is not started. However, more information is displayed if <code class="code">Mnesia</code> is started.</p>  <h3 id="install_fallback-1" class="code">install_fallback(Opaque) -&gt; ok | {error,Reason}</h3> 
<p>Calls <code class="code">mnesia:install_fallback(Opaque, Args)</code>, where <code class="code">Args</code> is <code class="code">[{scope, global}]</code>.</p>  <h3 id="install_fallback-1" class="code">install_fallback(Opaque), BackupMod) -&gt; ok | {error,Reason}</h3> 
<p>Calls <code class="code">mnesia:install_fallback(Opaque, Args)</code>, where <code class="code">Args</code> is <code class="code">[{scope, global}, {module, BackupMod}]</code>.</p>  <h3 id="install_fallback-2" class="code">install_fallback(Opaque, Args) -&gt; ok | {error,Reason}</h3> 
<p>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if <code class="code">Mnesia</code> is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</p> <p><code class="code">Args</code> is a list of the following tuples:</p> <ul> <li> <p><code class="code">{module, BackupMod}</code>. All accesses of the backup media are performed through a callback module named <code class="code">BackupMod</code>. Argument <code class="code">Opaque</code> is forwarded to the callback module, which can interpret it as it wishes. The default callback module is called <code class="code">mnesia_backup</code> and it interprets argument <code class="code">Opaque</code> as a local filename. The default for this module is also configurable through configuration parameter <code class="code">-mnesia mnesia_backup</code>.</p> </li> <li> <p><code class="code">{scope, Scope}</code>. The <code class="code">Scope</code> of a fallback is either <code class="code">global</code> for the entire database or <code class="code">local</code> for one node. By default, the installation of a fallback is a global operation, which either is performed on all nodes with a disc-resident schema or none. Which nodes that are disc-resident is determined from the schema information in the backup.</p> <p>If <code class="code">Scope</code> of the operation is <code class="code">local</code>, the fallback is only installed on the local node.</p> </li> <li> <p><code class="code">{mnesia_dir, AlternateDir}</code>. This argument is only valid if the scope of the installation is <code class="code">local</code>. Normally the installation of a fallback is targeted to the <code class="code">Mnesia</code> directory, as configured with configuration parameter <code class="code">-mnesia dir</code>. But by explicitly supplying an <code class="code">AlternateDir</code>, the fallback is installed there regardless of the <code class="code">Mnesia</code> directory configuration parameter setting. After installation of a fallback on an alternative <code class="code">Mnesia</code> directory, that directory is fully prepared for use as an active <code class="code">Mnesia</code> directory.</p> <p>This is a dangerous feature that must be used with care. By unintentional mixing of directories, you can easily end up with an inconsistent database, if the same backup is installed on more than one directory.</p> </li> </ul>  <h3 id="is_transaction-0" class="code">is_transaction() -&gt; boolean</h3> 
<p>When this function is executed inside a transaction-context, it returns <code class="code">true</code>, otherwise <code class="code">false</code>.</p>  <h3 id="last-1" class="code">last(Tab) -&gt; Key | transaction abort</h3> 
<p>Works exactly like <code class="code">mnesia:first/1</code>, but returns the last object in Erlang term order for the <code class="code">ordered_set</code> table type. For all other table types, <code class="code">mnesia:first/1</code> and <code class="code">mnesia:last/1</code> are synonyms.</p>  <h3 id="load_textfile-1" class="code">load_textfile(Filename)</h3> 
<p>Loads a series of definitions and data found in the text file (generated with <code class="code">mnesia:dump_to_textfile/1</code>) into <code class="code">Mnesia</code>. This function also starts <code class="code">Mnesia</code> and possibly creates a new schema. This function is intended for educational purposes only. It is recommended to use other functions to deal with real backups.</p>  <h3 id="lock-2" class="code">lock(LockItem, LockKind) -&gt; Nodes | ok | transaction abort</h3> 
<p>Write locks are normally acquired on all nodes where a replica of the table resides (and is active). Read locks are acquired on one node (the local node if a local replica exists). Most of the context-sensitive access functions acquire an implicit lock if they are started in a transaction-context. The granularity of a lock can either be a single record or an entire table.</p> <p>The normal use is to call the function without checking the return value, as it exits if it fails and the transaction is restarted by the transaction manager. It returns all the locked nodes if a write lock is acquired and <code class="code">ok</code> if it was a read lock.</p> <p>The function <code class="code">mnesia:lock/2</code> is intended to support explicit locking on tables, but is also intended for situations when locks need to be acquired regardless of how tables are replicated. Currently, two kinds of <code class="code">LockKind</code> are supported:</p> <dl> <dt><strong><code class="code">write</code></strong></dt> <dd> <p>Write locks are exclusive. This means that if one transaction manages to acquire a write lock on an item, no other transaction can acquire any kind of lock on the same item.</p> </dd> <dt><strong><code class="code">read</code></strong></dt> <dd> <p>Read locks can be shared. This means that if one transaction manages to acquire a read lock on an item, other transactions can also acquire a read lock on the same item. However, if someone has a read lock, no one can acquire a write lock at the same item. If someone has a write lock, no one can acquire either a read lock or a write lock at the same item.</p> </dd> </dl> <p>Conflicting lock requests are automatically queued if there is no risk of a deadlock. Otherwise the transaction must be terminated and executed again. <code class="code">Mnesia</code> does this automatically as long as the upper limit of the maximum <code class="code">retries</code> is not reached. For details, see <code class="code">mnesia:transaction/3</code>.</p> <p>For the sake of completeness, sticky write locks are also described here even if a sticky write lock is not supported by this function:</p> <dl> <dt><strong><code class="code">sticky_write</code></strong></dt> <dd> <p>Sticky write locks are a mechanism that can be used to optimize write lock acquisition. If your application uses replicated tables mainly for fault tolerance (as opposed to read access optimization purpose), sticky locks can be the best option available.</p> <p>When a sticky write lock is acquired, all nodes are informed which node is locked. Then, sticky lock requests from the same node are performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction ends. For details, see the User's Guide.</p> </dd> </dl> <p>Currently, this function supports two kinds of <code class="code">LockItem</code>:</p> <dl> <dt><strong><code class="code">{table, Tab}</code></strong></dt> <dd> <p>This acquires a lock of type <code class="code">LockKind</code> on the entire table <code class="code">Tab</code>.</p> </dd> <dt><strong><code class="code">{global, GlobalKey, Nodes}</code></strong></dt> <dd> <p>This acquires a lock of type <code class="code">LockKind</code> on the global resource <code class="code">GlobalKey</code>. The lock is acquired on all active nodes in the <code class="code">Nodes</code> list.</p> </dd> </dl> <p>Locks are released when the outermost transaction ends.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires locks, otherwise it ignores the request.</p>  <h3 id="match_object-1" class="code">match_object(Pattern) -&gt; transaction abort | RecList</h3> 
<p>Calls <code class="code">mnesia:match_object(Tab, Pattern, read)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Pattern)</code>.</p>  <h3 id="match_object-3" class="code">match_object(Tab, Pattern, LockKind) -&gt; transaction abort | RecList</h3> 
<p>Takes a pattern with "don't care" variables denoted as a <code class="code">'_'</code> parameter. This function returns a list of records that matched the pattern. Since the second element of a record in a table is considered to be the key for the record, the performance of this function depends on whether this key is bound or not.</p> <p>For example, the call <code class="code">mnesia:match_object(person, {person, '_', 36, '_', '_'}, read)</code> returns a list of all person records with an <code class="code">age</code> field of 36.</p> <p>The function <code class="code">mnesia:match_object/3</code> automatically uses indexes if these exist. However, no heuristics are performed to select the best index.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code class="code">LockKind</code> on the entire table or a single record. Currently, the lock type <code class="code">read</code> is supported.</p>  <h3 id="move_table_copy-3" class="code">move_table_copy(Tab, From, To) -&gt; {aborted, Reason} | {atomic, ok}</h3> 
<p>Moves the copy of table <code class="code">Tab</code> from node <code class="code">From</code> to node <code class="code">To</code>.</p> <p>The storage type is preserved. For example, a RAM table moved from one node remains a RAM on the new node. Other transactions can still read and write in the table while it is being moved.</p> <p>This function cannot be used on <code class="code">local_content</code> tables.</p>  <h3 id="next-2" class="code">next(Tab, Key) -&gt; Key | transaction abort</h3> 
<p>Traverses a table and performs operations on all records in the table. When the end of the table is reached, the special key <code class="code">'$end_of_table'</code> is returned. Otherwise the function returns a key that can be used to read the actual record.</p>  <h3 id="prev-2" class="code">prev(Tab, Key) -&gt; Key | transaction abort</h3> 
<p>Works exactly like <code class="code">mnesia:next/2</code>, but returns the previous object in Erlang term order for the <code class="code">ordered_set</code> table type. For all other table types, <code class="code">mnesia:next/2</code> and <code class="code">mnesia:prev/2</code> are synonyms.</p>  <h3 id="read-1" class="code">read({Tab, Key}) -&gt; transaction abort | RecordList</h3> 
<p>Calls function <code class="code">mnesia:read(Tab, Key, read)</code>.</p>  <h3 id="read-2" class="code">read(Tab, Key) -&gt; transaction abort | RecordList</h3> 
<p>Calls function <code class="code">mnesia:read(Tab, Key, read)</code>.</p>  <h3 id="read-3" class="code">read(Tab, Key, LockKind) -&gt; transaction abort | RecordList</h3> 
<p>Reads all records from table <code class="code">Tab</code> with key <code class="code">Key</code>. This function has the same semantics regardless of the location of <code class="code">Tab</code>. If the table is of type <code class="code">bag</code>, the function <code class="code">mnesia:read(Tab, Key)</code> can return an arbitrarily long list. If the table is of type <code class="code">set</code>, the list is either of length 1, or <code class="code">[]</code>.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code class="code">LockKind</code>. Currently, the lock types <code class="code">read</code>, <code class="code">write</code>, and <code class="code">sticky_write</code> are supported.</p> <p>If the user wants to update the record, it is more efficient to use <code class="code">write/sticky_write</code> as the <code class="code">LockKind</code>. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</p>  <h3 id="read_lock_table-1" class="code">read_lock_table(Tab) -&gt; ok | transaction abort</h3> 
<p>Calls the function <code class="code">mnesia:lock({table, Tab}, read)</code>.</p>  <h3 id="report_event-1" class="code">report_event(Event) -&gt; ok</h3> 
<p>When tracing a system of <code class="code">Mnesia</code> applications it is useful to be able to interleave <code class="code">Mnesia</code> own events with application-related events that give information about the application context.</p> <p>Whenever the application begins a new and demanding <code class="code">Mnesia</code> task, or if it enters a new interesting phase in its execution, it can be a good idea to use <code class="code">mnesia:report_event/1</code>. <code class="code">Event</code> can be any term and generates a <code class="code">{mnesia_user, Event}</code> event for any processes that subscribe to <code class="code">Mnesia</code> system events.</p>  <h3 id="restore-2" class="code">restore(Opaque, Args) -&gt; {atomic, RestoredTabs} |{aborted, Reason}</h3> 
<p>With this function, tables can be restored online from a backup without restarting <code class="code">Mnesia</code>. <code class="code">Opaque</code> is forwarded to the backup module. <code class="code">Args</code> is a list of the following tuples:</p> <ul> <li> <code class="code">{module,BackupMod}</code>. The backup module <code class="code">BackupMod</code> is used to access the backup media. If omitted, the default backup module is used. </li> <li> <code class="code">{skip_tables, TabList}</code>, where <code class="code">TabList</code> is a list of tables that is not to be read from the backup. </li> <li> <code class="code">{clear_tables, TabList}</code>, where <code class="code">TabList</code> is a list of tables that is to be cleared before the records from the backup are inserted. That is, all records in the tables are deleted before the tables are restored. Schema information about the tables is not cleared or read from the backup. </li> <li> <code class="code">{keep_tables, TabList}</code>, where <code class="code">TabList</code> is a list of tables that is not to be cleared before the records from the backup are inserted. That is, the records in the backup are added to the records in the table. Schema information about the tables is not cleared or read from the backup. </li> <li> <code class="code">{recreate_tables, TabList}</code>, where <code class="code">TabList</code> is a list of tables that is to be recreated before the records from the backup are inserted. The tables are first deleted and then created with the schema information from the backup. All the nodes in the backup need to be operational. </li> <li> <code class="code">{default_op, Operation}</code>, where <code class="code">Operation</code> is either of the operations <code class="code">skip_tables</code>, <code class="code">clear_tables</code>, <code class="code">keep_tables</code>, or <code class="code">recreate_tables</code>. The default operation specifies which operation that is to be used on tables from the backup that is not specified in any of the mentioned lists. If omitted, operation <code class="code">clear_tables</code> is used. </li> </ul> <p>The affected tables are write-locked during the restoration. However, regardless of the lock conflicts caused by this, the applications can continue to do their work while the restoration is being performed. The restoration is performed as one single transaction.</p> <p>If the database is huge, it it not always possible to restore it online. In such cases, restore the old database by installing a fallback and then restart.</p>  <h3 id="s_delete-1" class="code">s_delete({Tab, Key}) -&gt; ok | transaction abort</h3> 
<p>Calls the function <code class="code">mnesia:delete(Tab, Key, sticky_write)</code></p>  <h3 id="s_delete_object-1" class="code">s_delete_object(Record) -&gt; ok | transaction abort</h3> 
<p>Calls the function <code class="code">mnesia:delete_object(Tab, Record, sticky_write)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Record)</code>.</p>  <h3 id="s_write-1" class="code">s_write(Record) -&gt; ok | transaction abort</h3> 
<p>Calls the function <code class="code">mnesia:write(Tab, Record, sticky_write)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Record)</code>.</p>  <h3 id="schema-0" class="code">schema() -&gt; ok</h3> 
<p>Prints information about all table definitions on the terminal.</p>  <h3 id="schema-1" class="code">schema(Tab) -&gt; ok</h3> 
<p>Prints information about one table definition on the terminal.</p>  <h3 id="select-2" class="code">select(Tab, MatchSpec [, Lock]) -&gt; transaction abort | [Object]</h3> 
<p>Matches the objects in table <code class="code">Tab</code> using a <code class="code">match_spec</code> as described in the <code class="bold_code">ets:select/3</code>. Optionally a lock <code class="code">read</code> or <code class="code">write</code> can be given as the third argument. Default is <code class="code">read</code>. The return value depends on <code class="code">MatchSpec</code>.</p> <p>Notice that for best performance, <code class="code">select</code> is to be used before any modifying operations are done on that table in the same transaction. That is, do not use <code class="code">write</code> or <code class="code">delete</code> before a <code class="code">select</code>.</p> <p>In its simplest forms, the <code class="code">match_spec</code> look as follows:</p> <ul> <li><code class="code">MatchSpec = [MatchFunction]</code></li> <li><code class="code">MatchFunction = {MatchHead, [Guard], [Result]}</code></li> <li><code class="code">MatchHead = tuple() | record()</code></li> <li><code class="code">Guard = {"Guardtest name", ...}</code></li> <li><code class="code">Result = "Term construct"</code></li> </ul> <p>For a complete description of <code class="code">select</code>, see the <code class="bold_code">ERTS</code> User's Guide and the <code class="bold_code">ets</code> manual page in <code class="code">STDLIB</code>.</p> <p>For example, to find the names of all male persons older than 30 in table <code class="code">Tab</code>:</p> <div class="example"><pre>
MatchHead = #person{name='$1', sex=male, age='$2', _='_'},
Guard = {'&gt;', '$2', 30},
Result = '$1',
mnesia:select(Tab,[{MatchHead, [Guard], [Result]}]),</pre></div>  <h3 id="select-4" class="code">select(Tab, MatchSpec, NObjects, Lock) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</h3> 
<p>Matches the objects in table <code class="code">Tab</code> using a <code class="code">match_spec</code> as described in the <code class="bold_code">ERTS</code> User's Guide, and returns a chunk of terms and a continuation. The wanted number of returned terms is specified by argument <code class="code">NObjects</code>. The lock argument can be <code class="code">read</code> or <code class="code">write</code>. The continuation is to be used as argument to <code class="code">mnesia:select/1</code>, if more or all answers are needed.</p> <p>Notice that for best performance, <code class="code">select</code> is to be used before any modifying operations are done on that table in the same transaction. That is, do not use <code class="code">mnesia:write</code> or <code class="code">mnesia:delete</code> before a <code class="code">mnesia:select</code>. For efficiency, <code class="code">NObjects</code> is a recommendation only and the result can contain anything from an empty list to all available results.</p>  <h3 id="select-1" class="code">select(Cont) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</h3> 
<p>Selects more objects with the match specification initiated by <code class="code">mnesia:select/4</code>.</p> <p>Notice that any modifying operations, that is, <code class="code">mnesia:write</code> or <code class="code">mnesia:delete</code>, that are done between the <code class="code">mnesia:select/4</code> and <code class="code">mnesia:select/1</code> calls are not visible in the result.</p>  <h3 id="set_debug_level-1" class="code">set_debug_level(Level) -&gt; OldLevel</h3> 
<p>Changes the internal debug level of <code class="code">Mnesia</code>. For details, see <code class="bold_code"><a href="#configuration_parameters">Section Configuration Parameters</a></code>.</p>  <h3 id="set_master_nodes-1" class="code">set_master_nodes(MasterNodes) -&gt; ok | {error, Reason}</h3> 
<p>For each table <code class="code">Mnesia</code> determines its replica nodes (<code class="code">TabNodes</code>) and starts <code class="code">mnesia:set_master_nodes(Tab, TabMasterNodes)</code>. where <code class="code">TabMasterNodes</code> is the intersection of <code class="code">MasterNodes</code> and <code class="code">TabNodes</code>. For semantics, see <code class="code">mnesia:set_master_nodes/2</code>.</p>  <h3 id="set_master_nodes-2" class="code">set_master_nodes(Tab, MasterNodes) -&gt; ok | {error, Reason}</h3> 
<p>If the application detects a communication failure (in a potentially partitioned network) that can have caused an inconsistent database, it can use the function <code class="code">mnesia:set_master_nodes(Tab, MasterNodes)</code> to define from which nodes each table is to be loaded. At startup, the <code class="code">Mnesia</code> normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of when and if <code class="code">Mnesia</code> terminated on other nodes. <code class="code">MasterNodes</code> can only contain nodes where the table has a replica. If the <code class="code">MasterNodes</code> list is empty, the master node recovery mechanism for the particular table is reset, and the normal load mechanism is used at the next restart.</p> <p>The master node setting is always local. It can be changed regardless if <code class="code">Mnesia</code> is started or not.</p> <p>The database can also become inconsistent if configuration parameter <code class="code">max_wait_for_decision</code> is used or if <code class="code">mnesia:force_load_table/1</code> is used.</p>  <h3 id="snmp_close_table-1" class="code">snmp_close_table(Tab) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Removes the possibility for SNMP to manipulate the table.</p>  <h3 id="snmp_get_mnesia_key-2" class="code">snmp_get_mnesia_key(Tab, RowIndex) -&gt; {ok, Key} | undefined</h3>  <p>Types:</p>      <pre>Tab ::= atom()
RowIndex ::= [integer()]
Key ::= key() | {key(), key(), ...}
key() ::= integer() | string() | [integer()]</pre>

<p>Transforms an SNMP index to the corresponding <code class="code">Mnesia</code> key. If the SNMP table has multiple keys, the key is a tuple of the key columns.</p>  <h3 id="snmp_get_next_index-2" class="code">snmp_get_next_index(Tab, RowIndex) -&gt; {ok, NextIndex} | endOfTable</h3>  <p>Types:</p>     <pre>Tab ::= atom()
RowIndex ::= [integer()]
NextIndex ::= [integer()]</pre>

<p><code class="code">RowIndex</code> can specify a non-existing row. Specifically, it can be the empty list. Returns the index of the next lexicographical row. If <code class="code">RowIndex</code> is the empty list, this function returns the index of the first row in the table.</p>  <h3 id="snmp_get_row-2" class="code">snmp_get_row(Tab, RowIndex) -&gt; {ok, Row} | undefined</h3>  <p>Types:</p>     <pre>Tab ::= atom()
RowIndex ::= [integer()]
Row ::= record(Tab)</pre>

<p>Reads a row by its SNMP index. This index is specified as an SNMP Object Identifier, a list of integers.</p>  <h3 id="snmp_open_table-2" class="code">snmp_open_table(Tab, SnmpStruct) -&gt; {aborted, R} | {atomic, ok}</h3>  <p>Types:</p>      <pre>Tab ::= atom()
SnmpStruct ::= [{key, type()}]
type() ::= type_spec() | {type_spec(), type_spec(), ...}
type_spec() ::= fix_string | string | integer</pre>

<p>A direct one-to-one mapping can be established between <code class="code">Mnesia</code> tables and SNMP tables. Many telecommunication applications are controlled and monitored by the SNMP protocol. This connection between <code class="code">Mnesia</code> and SNMP makes it simple and convenient to achieve this mapping.</p> <p>Argument <code class="code">SnmpStruct</code> is a list of SNMP information. Currently, the only information needed is information about the key types in the table. Multiple keys cannot be handled in <code class="code">Mnesia</code>, but many SNMP tables have multiple keys. Therefore, the following convention is used: if a table has multiple keys, these must always be stored as a tuple of the keys. Information about the key types is specified as a tuple of atoms describing the types. The only significant type is <code class="code">fix_string</code>. This means that a string has a fixed size.</p> <p>For example, the following causes table <code class="code">person</code> to be ordered as an SNMP table:</p> <div class="example"><pre>
mnesia:snmp_open_table(person, [{key, string}])</pre></div> <p>Consider the following schema for a table of company employees. Each employee is identified by department number and name. The other table column stores the telephone number:</p> <div class="example"><pre>
mnesia:create_table(employee,
    [{snmp, [{key, {integer, string}}]},
     {attributes, record_info(fields, employees)}]),</pre></div> <p>The corresponding SNMP table would have three columns: <code class="code">department</code>, <code class="code">name</code>, and <code class="code">telno</code>.</p> <p>An option is to have table columns that are not visible through the SNMP protocol. These columns must be the last columns of the table. In the previous example, the SNMP table could have columns <code class="code">department</code> and <code class="code">name</code> only. The application could then use column <code class="code">telno</code> internally, but it would not be visible to the SNMP managers.</p> <p>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</p> <p>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). Also, more memory is used.</p> <p>Notice that only the lexicographical SNMP ordering is implemented in <code class="code">Mnesia</code>, not the actual SNMP monitoring.</p>  <h3 id="start-0" class="code">start() -&gt; ok | {error, Reason}</h3> 
<p>The startup procedure for a set of <code class="code">Mnesia</code> nodes is a fairly complicated operation. A <code class="code">Mnesia</code> system consists of a set of nodes, with <code class="code">Mnesia</code> started locally on all participating nodes. Normally, each node has a directory where all the <code class="code">Mnesia</code> files are written. This directory is referred to as the <code class="code">Mnesia</code> directory. <code class="code">Mnesia</code> can also be started on disc-less nodes. For more information about disc-less nodes, see <code class="code">mnesia:create_schema/1</code> and the User's Guide.</p> <p>The set of nodes that makes up a <code class="code">Mnesia</code> system is kept in a schema. <code class="code">Mnesia</code> nodes can be added to or removed from the schema. The initial schema is normally created on disc with the function <code class="code">mnesia:create_schema/1</code>. On disc-less nodes, a tiny default schema is generated each time <code class="code">Mnesia</code> is started. During the startup procedure, <code class="code">Mnesia</code> exchanges schema information between the nodes to verify that the table definitions are compatible.</p> <p>Each schema has a unique cookie, which can be regarded as a unique schema identifier. The cookie must be the same on all nodes where <code class="code">Mnesia</code> is supposed to run. For details, see the User's Guide.</p> <p>The schema file and all other files that <code class="code">Mnesia</code> needs are kept in the <code class="code">Mnesia</code> directory. The command-line option <code class="code">-mnesia dir Dir</code> can be used to specify the location of this directory to the <code class="code">Mnesia</code> system. If no such command-line option is found, the name of the directory defaults to <code class="code">Mnesia.Node</code>.</p> <p><code class="code">application:start(mnesia)</code> can also be used.</p>  <h3 id="stop-0" class="code">stop() -&gt; stopped</h3> 
<p>Stops <code class="code">Mnesia</code> locally on the current node.</p> <p><code class="code">application:stop(mnesia)</code> can also be used.</p>  <h3 id="subscribe-1" class="code">subscribe(EventCategory) -&gt; {ok, Node} | {error, Reason}</h3> 
<p>Ensures that a copy of all events of type <code class="code">EventCategory</code> is sent to the caller. The available event types are described in the <code class="bold_code"><a href="../mnesia_chap5/#event_handling">User's Guide</a></code>.</p>  <h3 id="sync_dirty-2" class="code">sync_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</h3> 
<p>Calls the <code class="code">Fun</code> in a context that is not protected by a transaction. The <code class="code">Mnesia</code> function calls performed in the <code class="code">Fun</code> are mapped to the corresponding dirty functions. It is performed in almost the same context as <code class="code">mnesia:async_dirty/1,2</code>. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas before the <code class="code">Fun</code> returns. For details, see <code class="code">mnesia:activity/4</code> and the User's Guide.</p>  <h3 id="sync_log-0" class="code">sync_log() -&gt; ok | {error, Reason}</h3> 
<p>Ensures that the local transaction log file is synced to disk. On a single node system, data written to disk tables since the last dump can be lost if there is a power outage. See <code class="bold_code"><a href="#dump_log-0">dump_log/0</a></code>.</p>  <h3 id="sync_transaction-3" class="code">sync_transaction(Fun, [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</h3> 
<p>Waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as <code class="code">mnesia:transaction/[1,2,3]</code>.</p> <p>This functionality can be used to avoid that one process overloads a database on another node.</p>  <h3 id="system_info-1" class="code">system_info(InfoKey) -&gt; Info | exit({aborted, Reason})</h3> 
<p>Returns information about the <code class="code">Mnesia</code> system, such as transaction statistics, <code class="code">db_nodes</code>, and configuration parameters. The valid keys are as follows:</p> <ul> <li> <p><code class="code">all</code>. Returns a list of all local system information. Each element is a <code class="code">{InfoKey, InfoVal}</code> tuple.</p> <p>New <code class="code">InfoKey</code>s can be added and old undocumented <code class="code">InfoKey</code>s can be removed without notice.</p> </li> <li> <p><code class="code">access_module</code>. Returns the name of module that is configured to be the activity access callback module.</p> </li> <li> <p><code class="code">auto_repair</code>. Returns <code class="code">true</code> or <code class="code">false</code> to indicate if <code class="code">Mnesia</code> is configured to start the auto-repair facility on corrupted disc files.</p> </li> <li> <p><code class="code">backup_module</code>. Returns the name of the module that is configured to be the backup callback module.</p> </li> <li> <p><code class="code">checkpoints</code>. Returns a list of the names of the checkpoints currently active on this node.</p> </li> <li> <p><code class="code">event_module</code>. Returns the name of the module that is the event handler callback module.</p> </li> <li> <p><code class="code">db_nodes</code>. Returns the nodes that make up the persistent database. Disc-less nodes are only included in the list of nodes if they explicitly have been added to the schema, for example, with <code class="code">mnesia:add_table_copy/3</code>. The function can be started even if <code class="code">Mnesia</code> is not yet running.</p> </li> <li> <p><code class="code">debug</code>. Returns the current debug level of <code class="code">Mnesia</code>.</p> </li> <li> <p><code class="code">directory</code>. Returns the name of the <code class="code">Mnesia</code> directory. It can be called even if <code class="code">Mnesia</code> is not yet running.</p> </li> <li> <p><code class="code">dump_log_load_regulation</code>. Returns a boolean that tells if <code class="code">Mnesia</code> is configured to regulate the dumper process load.</p> <p>This feature is temporary and will be removed in future releases.</p> </li> <li> <p><code class="code">dump_log_time_threshold</code>. Returns the time threshold for transaction log dumps in milliseconds.</p> </li> <li> <p><code class="code">dump_log_update_in_place</code>. Returns a boolean that tells if <code class="code">Mnesia</code> is configured to perform the updates in the <code class="code">dets</code> files directly, or if the updates are to be performed in a copy of the <code class="code">dets</code> files.</p> </li> <li> <p><code class="code">dump_log_write_threshold</code>. Returns the write threshold for transaction log dumps as the number of writes to the transaction log.</p> </li> <li> <p><code class="code">extra_db_nodes</code>. Returns a list of extra <code class="code">db_nodes</code> to be contacted at startup.</p> </li> <li> <p><code class="code">fallback_activated</code>. Returns <code class="code">true</code> if a fallback is activated, otherwise <code class="code">false</code>.</p> </li> <li> <p><code class="code">held_locks</code>. Returns a list of all locks held by the local <code class="code">Mnesia</code> lock manager.</p> </li> <li> <p><code class="code">is_running</code>. Returns <code class="code">yes</code> or <code class="code">no</code> to indicate if <code class="code">Mnesia</code> is running. It can also return <code class="code">starting</code> or <code class="code">stopping</code>. Can be called even if <code class="code">Mnesia</code> is not yet running.</p> </li> <li> <p><code class="code">local_tables</code>. Returns a list of all tables that are configured to reside locally.</p> </li> <li> <p><code class="code">lock_queue</code>. Returns a list of all transactions that are queued for execution by the local lock manager.</p> </li> <li> <p><code class="code">log_version</code>. Returns the version number of the <code class="code">Mnesia</code> transaction log format.</p> </li> <li> <p><code class="code">master_node_tables</code>. Returns a list of all tables with at least one master node.</p> </li> <li> <p><code class="code">protocol_version</code>. Returns the version number of the <code class="code">Mnesia</code> inter-process communication protocol.</p> </li> <li> <p><code class="code">running_db_nodes</code>. Returns a list of nodes where <code class="code">Mnesia</code> currently is running. This function can be called even if <code class="code">Mnesia</code> is not yet running, but it then has slightly different semantics.</p> <p>If <code class="code">Mnesia</code> is down on the local node, the function returns those other <code class="code">db_nodes</code> and <code class="code">extra_db_nodes</code> that for the moment are operational.</p> <p>If <code class="code">Mnesia</code> is started, the function returns those nodes that <code class="code">Mnesia</code> on the local node is fully connected to. Only those nodes that <code class="code">Mnesia</code> has exchanged schema information with are included as <code class="code">running_db_nodes</code>. After the merge of schemas, the local <code class="code">Mnesia</code> system is fully operable and applications can perform access of remote replicas. Before the schema merge, <code class="code">Mnesia</code> only operates locally. Sometimes there are more nodes included in the <code class="code">running_db_nodes</code> list than all <code class="code">db_nodes</code> and <code class="code">extra_db_nodes</code> together.</p> </li> <li> <p><code class="code">schema_location</code>. Returns the initial schema location.</p> </li> <li> <p><code class="code">subscribers</code>. Returns a list of local processes currently subscribing to system events.</p> </li> <li> <p><code class="code">tables</code>. Returns a list of all locally known tables.</p> </li> <li> <p><code class="code">transactions</code>. Returns a list of all currently active local transactions.</p> </li> <li> <p><code class="code">transaction_failures</code>. Returns a number that indicates how many transactions have failed since <code class="code">Mnesia</code> was started.</p> </li> <li> <p><code class="code">transaction_commits</code>. Returns a number that indicates how many transactions have terminated successfully since <code class="code">Mnesia</code> was started.</p> </li> <li> <p><code class="code">transaction_restarts</code>. Returns a number that indicates how many transactions have been restarted since <code class="code">Mnesia</code> was started.</p> </li> <li> <p><code class="code">transaction_log_writes</code>. Returns a number that indicates how many write operations that have been performed to the transaction log since startup.</p> </li> <li> <p><code class="code">use_dir</code>. Returns a boolean that indicates if the <code class="code">Mnesia</code> directory is used or not. Can be started even if <code class="code">Mnesia</code> is not yet running.</p> </li> <li> <p><code class="code">version</code>. Returns the current version number of <code class="code">Mnesia</code>.</p> </li> </ul>  <h3 id="table-1" class="code">table(Tab [,[Option]]) -&gt; QueryHandle</h3> 
<p>Returns a Query List Comprehension (QLC) query handle, see the <code class="bold_code">qlc(3)</code> manual page in <code class="code">STDLIB</code>. The module <code class="code">qlc</code> implements a query language that can use <code class="code">Mnesia</code> tables as sources of data. Calling <code class="code">mnesia:table/1,2</code> is the means to make the <code class="code">mnesia</code> table <code class="code">Tab</code> usable to QLC.</p> <p><code class="code">Option</code> can contain <code class="code">Mnesia</code> options or QLC options. <code class="code">Mnesia</code> recognizes the following options (any other option is forwarded to QLC).</p> <ul> <li> <code class="code">{lock, Lock}</code>, where <code class="code">lock</code> can be <code class="code">read</code> or <code class="code">write</code>. Default is <code class="code">read</code>. </li> <li> <code class="code">{n_objects,Number}</code>, where <code class="code">n_objects</code> specifies (roughly) the number of objects returned from <code class="code">Mnesia</code> to QLC. Queries to remote tables can need a larger chunk to reduce network overhead. By default, <code class="code">100</code> objects at a time are returned. </li> <li> <code class="code">{traverse, SelectMethod}</code>, where <code class="code">traverse</code> determines the method to traverse the whole table (if needed). The default method is <code class="code">select</code>. </li> </ul> <p>There are two alternatives for <code class="code">select</code>:</p> <ul> <li> <p><code class="code">select</code>. The table is traversed by calling <code class="code">mnesia:select/4</code> and <code class="code">mnesia:select/1</code>. The match specification (the second argument of <code class="code">select/3</code>) is assembled by QLC: simple filters are translated into equivalent match specifications. More complicated filters need to be applied to all objects returned by <code class="code">select/3</code> given a match specification that matches all objects.</p> </li> <li> <p><code class="code">{select, MatchSpec}</code>. As for <code class="code">select</code>, the table is traversed by calling <code class="code">mnesia:select/3</code> and <code class="code">mnesia:select/1</code>. The difference is that the match specification is explicitly given. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</p> </li> </ul>  <h3 id="table_info-2" class="code">table_info(Tab, InfoKey) -&gt; Info | exit({aborted, Reason})</h3> 
<p>The <code class="code">table_info/2</code> function takes two arguments. The first is the name of a <code class="code">Mnesia</code> table. The second is one of the following keys:</p> <ul> <li> <p><code class="code">all</code>. Returns a list of all local table information. Each element is a <code class="code">{InfoKey, ItemVal}</code> tuple.</p> <p>New <code class="code">InfoItem</code>s can be added and old undocumented <code class="code">InfoItem</code>s can be removed without notice.</p> </li> <li> <p><code class="code">access_mode</code>. Returns the access mode of the table. The access mode can be <code class="code">read_only</code> or <code class="code">read_write</code>.</p> </li> <li> <p><code class="code">arity</code>. Returns the arity of records in the table as specified in the schema.</p> </li> <li> <p><code class="code">attributes</code>. Returns the table attribute names that are specified in the schema.</p> </li> <li> <p><code class="code">checkpoints</code>. Returns the names of the currently active checkpoints, which involve this table on this node.</p> </li> <li> <p><code class="code">cookie</code>. Returns a table cookie, which is a unique system-generated identifier for the table. The cookie is used internally to ensure that two different table definitions using the same table name cannot accidentally be intermixed. The cookie is generated when the table is created initially.</p> </li> <li> <p><code class="code">disc_copies</code>. Returns the nodes where a <code class="code">disc_copy</code> of the table resides according to the schema.</p> </li> <li> <p><code class="code">disc_only_copies</code>. Returns the nodes where a <code class="code">disc_only_copy</code> of the table resides according to the schema.</p> </li> <li> <p><code class="code">index</code>. Returns the list of index position integers for the table.</p> </li> <li> <p><code class="code">load_node</code>. Returns the name of the node that <code class="code">Mnesia</code> loaded the table from. The structure of the returned value is unspecified, but can be useful for debugging purposes.</p> </li> <li> <p><code class="code">load_order</code>. Returns the load order priority of the table. It is an integer and defaults to <code class="code">0</code> (zero).</p> </li> <li> <p><code class="code">load_reason</code>. Returns the reason of why <code class="code">Mnesia</code> decided to load the table. The structure of the returned value is unspecified, but can be useful for debugging purposes.</p> </li> <li> <p><code class="code">local_content</code>. Returns <code class="code">true</code> or <code class="code">false</code> to indicate if the table is configured to have locally unique content on each node.</p> </li> <li> <p><code class="code">master_nodes</code>. Returns the master nodes of a table.</p> </li> <li> <p><code class="code">memory</code>. Returns the number of words allocated to the table on this node.</p> </li> <li> <p><code class="code">ram_copies</code>. Returns the nodes where a <code class="code">ram_copy</code> of the table resides according to the schema.</p> </li> <li> <p><code class="code">record_name</code>. Returns the record name, common for all records in the table.</p> </li> <li> <p><code class="code">size</code>. Returns the number of records inserted in the table.</p> </li> <li> <p><code class="code">snmp</code>. Returns the SNMP struct. <code class="code">[]</code> means that the table currently has no SNMP properties.</p> </li> <li> <p><code class="code">storage_type</code>. Returns the local storage type of the table. It can be <code class="code">disc_copies</code>, <code class="code">ram_copies</code>, <code class="code">disc_only_copies</code>, or the atom <code class="code">unknown</code>. <code class="code">unknown</code> is returned for all tables that only reside remotely.</p> </li> <li> <p><code class="code">subscribers</code>. Returns a list of local processes currently subscribing to local table events that involve this table on this node.</p> </li> <li> <p><code class="code">type</code>. Returns the table type, which is <code class="code">bag</code>, <code class="code">set</code>, or <code class="code">ordered_set</code>.</p> </li> <li> <p><code class="code">user_properties</code>. Returns the user-associated table properties of the table. It is a list of the stored property records.</p> </li> <li> <p><code class="code">version</code>. Returns the current version of the table definition. The table version is incremented when the table definition is changed. The table definition can be incremented directly when it has been changed in a schema transaction, or when a committed table definition is merged with table definitions from other nodes during startup.</p> </li> <li> <p><code class="code">where_to_read</code>. Returns the node where the table can be read. If value <code class="code">nowhere</code> is returned, either the table is not loaded or it resides at a remote node that is not running.</p> </li> <li> <p><code class="code">where_to_write</code>. Returns a list of the nodes that currently hold an active replica of the table.</p> </li> <li> <p><code class="code">wild_pattern</code>. Returns a structure that can be given to the various match functions for a certain table. A record tuple is where all record fields have value <code class="code">'_'</code>.</p> </li> </ul>  <h3 id="transaction-2" class="code">transaction(Fun [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</h3> 
<p>Executes the functional object <code class="code">Fun</code> with arguments <code class="code">Args</code> as a transaction.</p> <p>The code that executes inside the transaction can consist of a series of table manipulation functions. If something goes wrong inside the transaction as a result of a user error or a certain table not being available, the entire transaction is terminated and the function <code class="code">transaction/1</code> returns the tuple <code class="code">{aborted, Reason}</code>.</p> <p>If all is going well, <code class="code">{atomic, ResultOfFun}</code> is returned, where <code class="code">ResultOfFun</code> is the value of the last expression in <code class="code">Fun</code>.</p> <p>A function that adds a family to the database can be written as follows if there is a structure <code class="code">{family, Father, Mother, ChildrenList}</code>:</p> <div class="example"><pre>
add_family({family, F, M, Children}) -&gt;
    ChildOids = lists:map(fun oid/1, Children),
    Trans = fun() -&gt;      
        mnesia:write(F#person{children = ChildOids}, 
        mnesia:write(M#person{children = ChildOids},
        Write = fun(Child) -&gt; mnesia:write(Child) end,
        lists:foreach(Write, Children)
    end,
    mnesia:transaction(Trans).

oid(Rec) -&gt; {element(1, Rec), element(2, Rec)}.</pre></div> <p>This code adds a set of people to the database. Running this code within one transaction ensures that either the whole family is added to the database, or the whole transaction terminates. For example, if the last child is badly formatted, or the executing process terminates because of an <code class="code">'EXIT'</code> signal while executing the family code, the transaction terminates. Thus, the situation where half a family is added can never occur.</p> <p>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function <code class="code">raise(Name, Amount)</code>, which adds <code class="code">Amount</code> to the salary field of a person, is to be implemented as follows:</p> <div class="example"><pre>
raise(Name, Amount) -&gt;
    mnesia:transaction(fun() -&gt;
        case mnesia:wread({person, Name}) of
            [P] -&gt;
                Salary = Amount + P#person.salary,
                P2 = P#person{salary = Salary},
                mnesia:write(P2);
            _ -&gt;
                mnesia:abort("No such person")
        end
    end).</pre></div> <p>When this function executes within a transaction, several processes running on different nodes can concurrently execute the function <code class="code">raise/2</code> without interfering with each other.</p> <p>Since <code class="code">Mnesia</code> detects deadlocks, a transaction can be restarted any number of times. This function attempts a restart as specified in <code class="code">Retries</code>. <code class="code">Retries</code> must be an integer greater than 0 or the atom <code class="code">infinity</code>. Default is <code class="code">infinity</code>.</p>  <h3 id="transform_table-4" class="code">transform_table(Tab, Fun, NewAttributeList, NewRecordName) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Applies argument <code class="code">Fun</code> to all records in the table. <code class="code">Fun</code> is a function that takes a record of the old type and returns a transformed record of the new type. Argument <code class="code">Fun</code> can also be the atom <code class="code">ignore</code>, which indicates that only the metadata about the table is updated. Use of <code class="code">ignore</code> is not recommended, but included as a possibility for the user do to an own transformation.</p> <p><code class="code">NewAttributeList</code> and <code class="code">NewRecordName</code> specify the attributes and the new record type of the converted table. Table name always remains unchanged. If <code class="code">record_name</code> is changed, only the <code class="code">Mnesia</code> functions that use table identifiers work, for example, <code class="code">mnesia:write/3</code> works, but not <code class="code">mnesia:write/1</code>.</p>  <h3 id="transform_table-3" class="code">transform_table(Tab, Fun, NewAttributeList) -&gt; {aborted, R} | {atomic, ok}</h3> 
<p>Calls <code class="code">mnesia:transform_table(Tab, Fun, NewAttributeList, RecName)</code>, where <code class="code">RecName</code> is <code class="code">mnesia:table_info(Tab, record_name)</code>.</p>  <h3 id="traverse_backup-4" class="code">traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc) -&gt; {ok, LastAcc} | {error, Reason}</h3> 
<p>Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</p> <ul> <li> <code class="code">SourceMod</code> and <code class="code">TargetMod</code> are the names of the modules that actually access the backup media. </li> <li> <code class="code">Source</code> and <code class="code">Target</code> are opaque data used exclusively by modules <code class="code">SourceMod</code> and <code class="code">TargetMod</code> to initialize the backup media. </li> <li> <code class="code">Acc</code> is an initial accumulator value. </li> <li> <code class="code">Fun(BackupItems, Acc)</code> is applied to each item in the backup. The <code class="code">Fun</code> must return a tuple <code class="code">{BackupItems,NewAcc}</code>, where <code class="code">BackupItems</code> is a list of valid backup items, and <code class="code">NewAcc</code> is a new accumulator value. The returned backup items are written in the target backup. </li> <li> <code class="code">LastAcc</code> is the last accumulator value. This is the last <code class="code">NewAcc</code> value that was returned by <code class="code">Fun</code>. </li> </ul>  <h3 id="uninstall_fallback-0" class="code">uninstall_fallback() -&gt; ok | {error,Reason}</h3> 
<p>Calls the function <code class="code">mnesia:uninstall_fallback([{scope, global}])</code>.</p>  <h3 id="uninstall_fallback-1" class="code">uninstall_fallback(Args) -&gt; ok | {error,Reason}</h3> 
<p>Deinstalls a fallback before it has been used to restore the database. This is normally a distributed operation that is either performed on all nodes with disc resident schema, or none. Uninstallation of fallbacks requires Erlang to be operational on all involved nodes, but it does not matter if <code class="code">Mnesia</code> is running or not. Which nodes that are considered as disc-resident nodes is determined from the schema information in the local fallback.</p> <p><code class="code">Args</code> is a list of the following tuples:</p> <ul> <li> <code class="code">{module, BackupMod}</code>. For semantics, see <code class="code">mnesia:install_fallback/2</code>. </li> <li> <code class="code">{scope, Scope}</code>. For semantics, see <code class="code">mnesia:install_fallback/2</code>. </li> <li> <code class="code">{mnesia_dir, AlternateDir}</code>. For semantics, see <code class="code">mnesia:install_fallback/2</code>. </li> </ul>  <h3 id="unsubscribe-1" class="code">unsubscribe(EventCategory) -&gt; {ok, Node} | {error, Reason}</h3> 
<p>Stops sending events of type <code class="code">EventCategory</code> to the caller.</p> <p><code class="code">Node</code> is the local node.</p>  <h3 id="wait_for_tables-2" class="code">wait_for_tables(TabList, Timeout) -&gt; ok | {timeout, BadTabList} | {error, Reason}</h3> 
<p>Some applications need to wait for certain tables to be accessible to do useful work. <code class="code">mnesia:wait_for_tables/2</code> either hangs until all tables in <code class="code">TabList</code> are accessible, or until <code class="code">timeout</code> is reached.</p>  <h3 id="wread-1" class="code">wread({Tab, Key}) -&gt; transaction abort | RecordList</h3> 
<p>Calls the function <code class="code">mnesia:read(Tab, Key, write)</code>.</p>  <h3 id="write-1" class="code">write(Record) -&gt; transaction abort | ok</h3> 
<p>Calls the function <code class="code">mnesia:write(Tab, Record, write)</code>, where <code class="code">Tab</code> is <code class="code">element(1, Record)</code>.</p>  <h3 id="write-3" class="code">write(Tab, Record, LockKind) -&gt; transaction abort | ok</h3> 
<p>Writes record <code class="code">Record</code> to table <code class="code">Tab</code>.</p> <p>The function returns <code class="code">ok</code>, or terminates if an error occurs. For example, the transaction terminates if no <code class="code">person</code> table exists.</p> <p>The semantics of this function is context-sensitive. For details, see <code class="code">mnesia:activity/4</code>. In transaction-context, it acquires a lock of type <code class="code">LockKind</code>. The lock types <code class="code">write</code> and <code class="code">sticky_write</code> are supported.</p>  <h3 id="write_lock_table-1" class="code">write_lock_table(Tab) -&gt; ok | transaction abort</h3> 
<p>Calls the function <code class="code">mnesia:lock({table, Tab}, write)</code>.</p>  <h2 id="id69002">Configuration Parameters</h2>   <p><code class="code">Mnesia</code> reads the following application configuration parameters:</p> <ul> <li> <p><code class="code">-mnesia access_module Module</code>. The name of the <code class="code">Mnesia</code> activity access callback module. Default is <code class="code">mnesia</code>.</p> </li> <li> <p><code class="code">-mnesia auto_repair true | false</code>. This flag controls if <code class="code">Mnesia</code> automatically tries to repair files that have not been properly closed. Default is <code class="code">true</code>.</p> </li> <li> <p><code class="code">-mnesia backup_module Module</code>. The name of the <code class="code">Mnesia</code> backup callback module. Default is <code class="code">mnesia_backup</code>.</p> </li> <li> <p><code class="code">-mnesia debug Level</code>. Controls the debug level of <code class="code">Mnesia</code>. The possible values are as follows:</p> <dl> <dt><strong><code class="code">none</code></strong></dt> <dd> <p>No trace outputs. This is the default.</p> </dd> <dt><strong><code class="code">verbose</code></strong></dt> <dd> <p>Activates tracing of important debug events. These events generate <code class="code">{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with <code class="code">mnesia:subscribe/1</code>. The events are always sent to the <code class="code">Mnesia</code> event handler.</p> </dd> <dt><strong><code class="code">debug</code></strong></dt> <dd> <p>Activates all events at the verbose level plus full trace of all debug events. These debug events generate <code class="code">{mnesia_info, Format, Args}</code> system events. Processes can subscribe to these events with <code class="code">mnesia:subscribe/1</code>. The events are always sent to the <code class="code">Mnesia</code> event handler. On this debug level, the <code class="code">Mnesia</code> event handler starts subscribing to updates in the schema table.</p> </dd> <dt><strong><code class="code">trace</code></strong></dt> <dd> <p>Activates all events at the debug level. On this level, the <code class="code">Mnesia</code> event handler starts subscribing to updates on all <code class="code">Mnesia</code> tables. This level is intended only for debugging small toy systems, as many large events can be generated.</p> </dd> <dt><strong><code class="code">false</code></strong></dt> <dd>An alias for none. </dd> <dt><strong><code class="code">true</code></strong></dt> <dd>An alias for debug. </dd> </dl> </li> <li> <p><code class="code">-mnesia core_dir Directory</code>. The name of the directory where <code class="code">Mnesia</code> core files is stored, or false. Setting it implies that also RAM-only nodes generate a core file if a crash occurs.</p> </li> <li> <p><code class="code">-mnesia dc_dump_limit Number</code>. Controls how often <code class="code">disc_copies</code> tables are dumped from memory. Tables are dumped when <code class="code">filesize(Log) &gt; (filesize(Tab)/Dc_dump_limit)</code>. Lower values reduce CPU overhead but increase disk space and startup times. Default is 4.</p> </li> <li> <p><code class="code">-mnesia dir Directory</code>. The name of the directory where all <code class="code">Mnesia</code> data is stored. The directory name must be unique for the current node. Two nodes must never share the the same <code class="code">Mnesia</code> directory. The results are unpredictable.</p> </li> <li> <p><code class="code">-mnesia dump_disc_copies_at_startup true | false</code>. If set to false, this disables the dumping of <code class="code">disc_copies</code> tables during startup while tables are being loaded. The default is true.</p> </li> <li> <p><code class="code">-mnesia dump_log_load_regulation true | false</code>. Controls if log dumps are to be performed as fast as possible, or if the dumper is to do its own load regulation. Default is <code class="code">false</code>.</p> <p>This feature is temporary and will be removed in a future release</p> </li> <li> <p><code class="code">-mnesia dump_log_update_in_place true | false</code>. Controls if log dumps are performed on a copy of the original data file, or if the log dump is performed on the original data file. Default is <code class="code">true</code></p> </li> <li id="dump_log_write_threshold">  <p><code class="code">-mnesia dump_log_write_threshold Max</code>. <code class="code">Max</code> is an integer that specifies the maximum number of writes allowed to the transaction log before a new dump of the log is performed. Default is <code class="code">100</code> log writes.</p> </li> <li id="dump_log_time_threshold">  <p><code class="code">-mnesia dump_log_time_threshold Max</code>. <code class="code">Max</code> is an integer that specifies the dump log interval in milliseconds. Default is 3 minutes. If a dump has not been performed within <code class="code">dump_log_time_threshold</code> milliseconds, a new dump is performed regardless of the number of writes performed.</p> </li> <li> <p><code class="code">-mnesia event_module Module</code>. The name of the <code class="code">Mnesia</code> event handler callback module. Default is <code class="code">mnesia_event</code>.</p> </li> <li> <p><code class="code">-mnesia extra_db_nodes Nodes</code> specifies a list of nodes, in addition to the ones found in the schema, with which <code class="code">Mnesia</code> is also to establish contact. Default is <code class="code">[]</code> (empty list).</p> </li> <li> <p><code class="code">-mnesia fallback_error_function {UserModule, UserFunc}</code>. Specifies a user-supplied callback function, which is called if a fallback is installed and <code class="code">Mnesia</code> goes down on another node. <code class="code">Mnesia</code> calls the function with one argument, the name of the dying node, for example, <code class="code">UserModule:UserFunc(DyingNode)</code>. <code class="code">Mnesia</code> must be restarted, otherwise the database can be inconsistent. The default behavior is to terminate <code class="code">Mnesia</code>.</p> </li> <li> <p><code class="code">-mnesia max_wait_for_decision Timeout</code>. Specifies how long <code class="code">Mnesia</code> waits for other nodes to share their knowledge about the outcome of an unclear transaction. By default, <code class="code">Timeout</code> is set to the atom <code class="code">infinity</code>. This implies that if <code class="code">Mnesia</code> upon startup detects a "heavyweight transaction" whose outcome is unclear, the local <code class="code">Mnesia</code> waits until <code class="code">Mnesia</code> is started on some (in the worst case all) of the other nodes that were involved in the interrupted transaction. This is a rare situation, but if it occurs, <code class="code">Mnesia</code> does not guess if the transaction on the other nodes was committed or terminated. <code class="code">Mnesia</code> waits until it knows the outcome and then acts accordingly.</p> <p>If <code class="code">Timeout</code> is set to an integer value in milliseconds, <code class="code">Mnesia</code> forces "heavyweight transactions" to be finished, even if the outcome of the transaction for the moment is unclear. After <code class="code">Timeout</code> milliseconds, <code class="code">Mnesia</code> commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</p> </li> <li> <p><code class="code">-mnesia no_table_loaders NUMBER</code>. Specifies the number of parallel table loaders during start. More loaders can be good if the network latency is high or if many tables contain few records. Default is <code class="code">2</code>.</p> </li> <li> <p><code class="code">-mnesia send_compressed Level</code>. Specifies the level of compression to be used when copying a table from the local node to another one. Default is <code class="code">0</code>.</p> <p><code class="code">Level</code> must be an integer in the interval <code class="code">[0, 9]</code>, where <code class="code">0</code> means no compression and <code class="code">9</code> means maximum compression. Before setting it to a non-zero value, ensure that the remote nodes understand this configuration.</p> </li> <li> <p><code class="code">-mnesia schema_location Loc</code>. Controls where <code class="code">Mnesia</code> looks for its schema. Parameter <code class="code">Loc</code> can be one of the following atoms:</p> <dl> <dt><strong><code class="code">disc</code></strong></dt> <dd> <p>Mandatory disc. The schema is assumed to be located in the <code class="code">Mnesia</code> directory. If the schema cannot be found, <code class="code">Mnesia</code> refuses to start. This is the old behavior.</p> </dd> <dt><strong><code class="code">ram</code></strong></dt> <dd> <p>Mandatory RAM. The schema resides in RAM only. At startup, a tiny new schema is generated. This default schema only contains the definition of the schema table and only resides on the local node. Since no other nodes are found in the default schema, configuration parameter <code class="code">extra_db_nodes</code> must be used to let the node share its table definitions with other nodes.</p> <p>Parameter <code class="code">extra_db_nodes</code> can also be used on disc based nodes.</p> </dd> <dt><strong><code class="code">opt_disc</code></strong></dt> <dd> <p>Optional disc. The schema can reside on disc or in RAM. If the schema is found on disc, <code class="code">Mnesia</code> starts as a disc-based node and the storage type of the schema table is <code class="code">disc_copies</code>. If no schema is found on disc, <code class="code">Mnesia</code> starts as a disc-less node and the storage type of the schema table is <code class="code">ram_copies</code>. Default value for the application parameter is <code class="code">opt_disc</code>.</p> </dd> </dl> </li> </ul> <p>First, the <code class="code">SASL</code> application parameters are checked, then the command-line flags are checked, and finally, the default value is chosen.</p>  <h2 id="id91413">See Also</h2>  <p><code class="bold_code">application(3)</code>, <code class="bold_code">dets(3)</code>, <code class="bold_code">disk_log(3)</code>, <code class="bold_code">ets(3)</code>, <code class="bold_code">mnesia_registry(3)</code>, <code class="bold_code">qlc(3)</code></p>
<div class="_attribution">
  <p class="_attribution-p">
     19992016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
