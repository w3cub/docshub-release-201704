
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erl_driver - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" erl_driver ">
  <meta name="keywords" content="erl, driver, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/erts-7.3/doc/html/erl_driver/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erl_driver</h1> <h2>C library</h2> <p class="REFBODY">erl_driver</p> <h2>Library summary</h2> <p class="REFBODY">API functions for an Erlang driver</p> <h2>Description</h2> 
<p>An Erlang driver is a library containing a set of native driver callback functions that the Erlang VM calls when certain events occur. There may be multiple instances of a driver, each instance is associated with an Erlang port.</p>  <div class="warning"> <div class="label">Warning</div> <div class="content">

<p><strong>Use this functionality with extreme care!</strong></p> <p>A driver callback is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM can <strong>not</strong> provide the same services as provided when executing Erlang code, such as preemptive scheduling or memory protection. If the driver callback function doesn't behave well, the whole VM will misbehave.</p> <ul> <li><p>A driver callback that crash will crash the whole VM.</p></li> <li><p>An erroneously implemented driver callback might cause a VM internal state inconsistency which may cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the driver callback.</p></li> <li><p>A driver callback that do <code class="bold_code"><a href="#lengthy_work">lengthy work</a></code> before returning will degrade responsiveness of the VM, and may cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that might occur due to lengthy work may also vary between OTP releases.</p></li> </ul> </div> </div> <p>As of erts version 5.5.3 the driver interface has been extended (see <code class="bold_code"><a href="../driver_entry/#extended_marker">extended marker</a></code>). The extended interface introduce <code class="bold_code"><a href="#version_management">version management</a></code>, the possibility to pass capability flags (see <code class="bold_code"><a href="../driver_entry/#driver_flags">driver flags</a></code>) to the runtime system at driver initialization, and some new driver API functions. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As of erts version 5.9 old drivers have to be recompiled and have to use the extended interface. They also have to be adjusted to the <code class="bold_code"><a href="#rewrites_for_64_bits">64-bit capable driver interface. </a></code> </p> </div> </div> <p>The driver calls back to the emulator, using the API functions declared in <code class="code">erl_driver.h</code>. They are used for outputting data from the driver, using timers, etc.</p> <p>Each driver instance is associated with a port. Every port has a port owner process. Communication with the port is normally done through the port owner process. Most of the functions take the <code class="code">port</code> handle as an argument. This identifies the driver instance. Note that this port handle must be stored by the driver, it is not given when the driver is called from the emulator (see <code class="bold_code"><a href="../driver_entry/#emulator">driver_entry</a></code>).</p> <p>Some of the functions take a parameter of type <code class="code">ErlDrvBinary</code>, a driver binary. It should be both allocated and freed by the caller. Using a binary directly avoids one extra copying of data.</p> <p id="smp_support">Many of the output functions have a "header buffer", with <code class="code">hbuf</code> and <code class="code">hlen</code> parameters. This buffer is sent as a list before the binary (or list, depending on port mode) that is sent. This is convenient when matching on messages received from the port. (Although in the latest versions of Erlang, there is the binary syntax, that enables you to match on the beginning of a binary.)  </p> <p>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, i.e., only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads may execute code in the driver at the same time. There will only be one thread at a time calling driver call-backs corresponding to the same port, though. In order to enable port level locking set the <code class="code">ERL_DRV_FLAG_USE_PORT_LOCKING</code> <code class="bold_code"><a href="../driver_entry/#driver_flags">driver flag</a></code> in the <code class="bold_code"><a href="../driver_entry/">driver_entry</a></code> used by the driver. When port level locking is used it is the responsibility of the driver writer to synchronize all accesses to data shared by the ports (driver instances).</p> <p>Most drivers written before the runtime system with SMP support existed will be able to run in the runtime system with SMP support without being rewritten if driver level locking is used.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>It is assumed that drivers do not access other drivers. If drivers should access each other they have to provide their own mechanism for thread safe synchronization. Such "inter driver communication" is strongly discouraged.</p> </div> </div> <p>Previously, in the runtime system without SMP support, specific driver call-backs were always called from the same thread. This is <strong>not</strong> the case in the runtime system with SMP support. Regardless of locking scheme used, calls to driver call-backs may be made from different threads, e.g., two consecutive calls to exactly the same call-back for exactly the same port may be made from two different threads. This will for <strong>most</strong> drivers not be a problem, but it might. Drivers that depend on all call-backs being called in the same thread, <strong>have</strong> to be rewritten before being used in the runtime system with SMP support.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Regardless of locking scheme used, calls to driver call-backs may be made from different threads.</p> </div> </div> <p>Most functions in this API are <strong>not</strong> thread-safe, i.e., they may <strong>not</strong> be called from an arbitrary thread. Functions that are not documented as thread-safe may only be called from driver call-backs or function calls descending from a driver call-back call. Note that driver call-backs may be called from different threads. This, however, is not a problem for any function in this API, since the emulator has control over these threads.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Functions not explicitly documented as thread safe are <strong>not</strong> thread safe. Also note that some functions are <strong>only</strong> thread safe when used in a runtime system with SMP support.</p> <p>A function not explicitly documented as thread safe may at some point in time have a thread safe implementation in the runtime system. Such an implementation may however change to a thread <strong>unsafe</strong> implementation at any time <strong>without any notice</strong> at all. </p> <p><strong>Only use functions explicitly documented as thread safe from arbitrary threads.</strong></p> </div> </div> <p id="lengthy_work"> As mentioned in the <code class="bold_code"><a href="#WARNING">warning</a></code> text at the beginning of this document it is of vital importance that a driver callback does return relatively fast. It is hard to give an exact maximum amount of time that a driver callback is allowed to work, but as a rule of thumb a well behaving driver callback should return before a millisecond has passed. This can be achieved using different approaches. If you have full control over the code that are to execute in the driver callback, the best approach is to divide the work into multiple chunks of work and trigger multiple calls to the <code class="bold_code"><a href="../driver_entry/#timeout">timeout callback</a></code> using zero timeouts. The <code class="bold_code"><a href="#erl_drv_consume_timeslice"><span class="code">erl_drv_consume_timeslice()</span></a></code> function can be useful in order to determine when to trigger such timeout callback calls. It might, however, not always be possible to implement it this way, e.g. when calling third party libraries. In this case you typically want to dispatch the work to another thread. Information about thread primitives can be found below.</p>  <h2 id="id185229">Functionality</h2>  <p>All functions that a driver needs to do with Erlang are performed through driver API functions. There are functions for the following functionality:</p> <dl> <dt><strong>Timer functions</strong></dt> <dd>Timer functions are used to control the timer that a driver may use. The timer will have the emulator call the <code class="bold_code"><a href="../driver_entry/#timeout">timeout</a></code> entry function after a specified time. Only one timer is available for each driver instance.</dd> <dt><strong>Queue handling</strong></dt> <dd> <p>Every driver instance has an associated queue. This queue is a <code class="code">SysIOVec</code> that works as a buffer. It's mostly used for the driver to buffer data that should be written to a device, it is a byte stream. If the port owner process closes the driver, and the queue is not empty, the driver will not be closed. This enables the driver to flush its buffers before closing.</p> <p>The queue can be manipulated from arbitrary threads if a port data lock is used. See documentation of the <code class="bold_code"><a href="#ErlDrvPDL">ErlDrvPDL</a></code> type for more information.</p> </dd> <dt><strong>Output functions</strong></dt> <dd>With the output functions, the driver sends data back to the emulator. They will be received as messages by the port owner process, see <code class="code">open_port/2</code>. The vector function and the function taking a driver binary are faster, because they avoid copying the data buffer. There is also a fast way of sending terms from the driver, without going through the binary term format.</dd> <dt><strong>Failure</strong></dt> <dd>The driver can exit and signal errors up to Erlang. This is only for severe errors, when the driver can't possibly keep open.</dd> <dt><strong>Asynchronous calls</strong></dt> <dd>The latest Erlang versions (R7B and later) has provision for asynchronous function calls, using a thread pool provided by Erlang. There is also a select call, that can be used for asynchronous drivers.</dd> <dt><strong id="multi_threading">Multi-threading</strong></dt> <dd> <p>A POSIX thread like API for multi-threading is provided. The Erlang driver thread API only provide a subset of the functionality provided by the POSIX thread API. The subset provided is more or less the basic functionality needed for multi-threaded programming: </p> <ul> <li><code class="bold_code"><a href="#ErlDrvTid">Threads</a></code></li> <li><code class="bold_code"><a href="#ErlDrvMutex">Mutexes</a></code></li> <li><code class="bold_code"><a href="#ErlDrvCond">Condition variables</a></code></li> <li><code class="bold_code"><a href="#ErlDrvRWLock">Read/Write locks</a></code></li> <li><code class="bold_code"><a href="#ErlDrvTSDKey">Thread specific data</a></code></li> </ul> <p>The Erlang driver thread API can be used in conjunction with the POSIX thread API on UN-ices and with the Windows native thread API on Windows. The Erlang driver thread API has the advantage of being portable, but there might exist situations where you want to use functionality from the POSIX thread API or the Windows native thread API. </p> <p>The Erlang driver thread API only returns error codes when it is reasonable to recover from an error condition. If it isn't reasonable to recover from an error condition, the whole runtime system is terminated. For example, if a create mutex operation fails, an error code is returned, but if a lock operation on a mutex fails, the whole runtime system is terminated. </p> <p>Note that there exists no "condition variable wait with timeout" in the Erlang driver thread API. This is due to issues with <code class="code">pthread_cond_timedwait()</code>. When the system clock suddenly is changed, it isn't always guaranteed that you will wake up from the call as expected. An Erlang runtime system has to be able to cope with sudden changes of the system clock. Therefore, we have omitted it from the Erlang driver thread API. In the Erlang driver case, timeouts can and should be handled with the timer functionality of the Erlang driver API. </p> <p>In order for the Erlang driver thread API to function, thread support has to be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of <code class="bold_code"><a href="#driver_system_info">driver_system_info()</a></code>. Note that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved via <code class="bold_code"><a href="#driver_system_info">driver_system_info()</a></code>. Also note that a lot of functions in the Erlang driver API are <strong>not</strong> thread-safe regardless of whether SMP support is enabled or not. If a function isn't documented as thread-safe it is <strong>not</strong> thread-safe. </p> <p><strong>NOTE</strong>: When executing in an emulator thread, it is <strong>very important</strong> that you unlock <strong>all</strong> locks you have locked before letting the thread out of your control; otherwise, you are <strong>very likely</strong> to deadlock the whole emulator. If you need to use thread specific data in an emulator thread, only have the thread specific data set while the thread is under your control, and clear the thread specific data before you let the thread out of your control. </p> <p>In the future there will probably be debug functionality integrated with the Erlang driver thread API. All functions that create entities take a <code class="code">name</code> argument. Currently the <code class="code">name</code> argument is unused, but it will be used when the debug functionality has been implemented. If you name all entities created well, the debug functionality will be able to give you better error reports. </p> </dd> <dt><strong>Adding / removing drivers</strong></dt> <dd><p>A driver can add and later remove drivers.</p></dd> <dt><strong>Monitoring processes</strong></dt> <dd><p>A driver can monitor a process that does not own a port.</p></dd> <dt><strong id="version_management">Version management</strong></dt> <dd> <p>Version management is enabled for drivers that have set the <code class="bold_code"><a href="../driver_entry/#extended_marker">extended_marker</a></code> field of their <code class="bold_code"><a href="../driver_entry/">driver_entry</a></code> to <code class="code">ERL_DRV_EXTENDED_MARKER</code>. <code class="code">erl_driver.h</code> defines <code class="code">ERL_DRV_EXTENDED_MARKER</code>, <code class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</code>, and <code class="code">ERL_DRV_EXTENDED_MINOR_VERSION</code>. <code class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</code> will be incremented when driver incompatible changes are made to the Erlang runtime system. Normally it will suffice to recompile drivers when the <code class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</code> has changed, but it could, under rare circumstances, mean that drivers have to be slightly modified. If so, this will of course be documented. <code class="code">ERL_DRV_EXTENDED_MINOR_VERSION</code> will be incremented when new features are added. The runtime system uses the minor version of the driver to determine what features to use. The runtime system will normally refuse to load a driver if the major versions differ, or if the major versions are equal and the minor version used by the driver is greater than the one used by the runtime system. Old drivers with lower major versions will however be allowed after a bump of the major version during a transition period of two major releases. Such old drivers might however fail if deprecated features are used.</p> <p>The emulator will refuse to load a driver that does not use the extended driver interface, to allow for 64-bit capable drivers, since incompatible type changes for the callbacks <code class="bold_code"><a href="../driver_entry/#output">output</a></code>, <code class="bold_code"><a href="../driver_entry/#control">control</a></code> and <code class="bold_code"><a href="../driver_entry/#call">call</a></code> were introduced in release R15B. A driver written with the old types would compile with warnings and when called return garbage sizes to the emulator causing it to read random memory and create huge incorrect result blobs.</p> <p>Therefore it is not enough to just recompile drivers written with version management for pre-R15B types; the types have to be changed in the driver suggesting other rewrites especially regarding size variables. Investigate all warnings when recompiling!</p> <p>Also, the API driver functions <code class="code">driver_output*</code>, <code class="code">driver_vec_to_buf</code>, <code class="code">driver_alloc/realloc*</code> and the <code class="code">driver_*</code> queue functions were changed to have larger length arguments and return values. This is a lesser problem since code that passes smaller types will get them auto converted in the calls and as long as the driver does not handle sizes that overflow an <code class="code">int</code> all will work as before.</p> </dd> <dt><strong id="time_measurement">Time Measurement</strong></dt> <dd> <p>Support for time measurement in drivers: </p>
<ul> <li><code class="bold_code"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></code></li> <li><code class="bold_code"><a href="#erl_drv_monotonic_time"><span class="code">erl_drv_monotonic_time()</span></a></code></li> <li><code class="bold_code"><a href="#erl_drv_time_offset"><span class="code">erl_drv_time_offset()</span></a></code></li> <li><code class="bold_code"><a href="#erl_drv_convert_time_unit"><span class="code">erl_drv_convert_time_unit()</span></a></code></li> </ul> </dd> </dl>  <h2 id="id185669"> rewrites for 64-bit driver interface </h2>   <p> For erts-5.9 two new integer types <code class="bold_code"><a href="#ErlDrvSizeT">ErlDrvSizeT</a></code> and <code class="bold_code"><a href="#ErlDrvSSizeT">ErlDrvSSizeT</a></code> were introduced that can hold 64-bit sizes if necessary. </p> <p> To not update a driver and just recompile it probably works when building for a 32-bit machine creating a false sense of security. Hopefully that will generate many important warnings. But when recompiling the same driver later on for a 64-bit machine there <strong>will</strong> be warnings and almost certainly crashes. So it is a BAD idea to postpone updating the driver and not fixing the warnings! </p> <p> When recompiling with <code class="code">gcc</code> use the <code class="code">-Wstrict-prototypes</code> flag to get better warnings. Try to find a similar flag if you are using some other compiler. </p> <p> Here follows a checklist for rewriting a pre erts-5.9 driver, most important first. </p> <dl> <dt><strong>Return types for driver callbacks</strong></dt> <dd> <p> Rewrite driver callback <code class="bold_code"><a href="../driver_entry/#control"><span class="code">control</span></a></code> to use return type <code class="code">ErlDrvSSizeT</code> instead of <code class="code">int</code>. </p> <p> Rewrite driver callback <code class="bold_code"><a href="../driver_entry/#call"><span class="code">call</span></a></code> to use return type <code class="code">ErlDrvSSizeT</code> instead of <code class="code">int</code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> These changes are essential to not crash the emulator or worse cause malfunction. Without them a driver may return garbage in the high 32 bits to the emulator causing it to build a huge result from random bytes either crashing on memory allocation or succeeding with a random result from the driver call. </p> </div> </div> </dd> <dt><strong>Arguments to driver callbacks</strong></dt> <dd> <p> Driver callback <code class="bold_code"><a href="../driver_entry/#output"><span class="code">output</span></a></code> now gets <code class="code">ErlDrvSizeT</code> as 3rd argument instead of previously <code class="code">int</code>. </p> <p> Driver callback <code class="bold_code"><a href="../driver_entry/#control"><span class="code">control</span></a></code> now gets <code class="code">ErlDrvSizeT</code> as 4th and 6th arguments instead of previously <code class="code">int</code>. </p> <p> Driver callback <code class="bold_code"><a href="../driver_entry/#call"><span class="code">call</span></a></code> now gets <code class="code">ErlDrvSizeT</code> as 4th and 6th arguments instead of previously <code class="code">int</code>. </p> <p> Sane compiler's calling conventions probably make these changes necessary only for a driver to handle data chunks that require 64-bit size fields (mostly larger than 2 GB since that is what an <code class="code">int</code> of 32 bits can hold). But it is possible to think of non-sane calling conventions that would make the driver callbacks mix up the arguments causing malfunction. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The argument type change is from signed to unsigned which may cause problems for e.g. loop termination conditions or error conditions if you just change the types all over the place. </p> </div> </div> </dd> <dt><strong>Larger <code class="code">size</code> field in <code class="code">ErlIOVec</code></strong></dt> <dd> <p> The <code class="code">size</code> field in <code class="bold_code"><a href="#ErlIOVec"><span class="code">ErlIOVec</span></a></code> has been changed to <code class="code">ErlDrvSizeT</code> from <code class="code">int</code>. Check all code that use that field. </p> <p> Automatic type casting probably makes these changes necessary only for a driver that encounters sizes larger than 32 bits. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> The <code class="code">size</code> field changed from signed to unsigned which may cause problems for e.g. loop termination conditions or error conditions if you just change the types all over the place. </p> </div> </div> </dd> <dt><strong>Arguments and return values in the driver API</strong></dt> <dd> <p> Many driver API functions have changed argument type and/or return value to <code class="code">ErlDrvSizeT</code> from mostly <code class="code">int</code>. Automatic type casting probably makes these changes necessary only for a driver that encounters sizes larger than 32 bits. </p> <dl> <dt><strong><code class="bold_code"><a href="#driver_output">driver_output</a></code></strong></dt> <dd>3rd argument</dd> <dt><strong><code class="bold_code"><a href="#driver_output2">driver_output2</a></code></strong></dt> <dd>3rd and 5th arguments</dd> <dt><strong> <code class="bold_code"><a href="#driver_output_binary">driver_output_binary</a></code> </strong></dt> <dd>3rd 5th and 6th arguments</dd> <dt><strong><code class="bold_code"><a href="#driver_outputv">driver_outputv</a></code></strong></dt> <dd>3rd and 5th arguments</dd> <dt><strong> <code class="bold_code"><a href="#driver_vec_to_buf">driver_vec_to_buf</a></code> </strong></dt> <dd>3rd argument and return value</dd> <dt><strong><code class="bold_code"><a href="#driver_alloc">driver_alloc</a></code></strong></dt> <dd>1st argument</dd> <dt><strong><code class="bold_code"><a href="#driver_realloc">driver_realloc</a></code></strong></dt> <dd>2nd argument</dd> <dt><strong> <code class="bold_code"><a href="#driver_alloc_binary">driver_alloc_binary</a></code> </strong></dt> <dd>1st argument</dd> <dt><strong> <code class="bold_code"><a href="#driver_realloc_binary">driver_realloc_binary</a></code> </strong></dt> <dd>2nd argument</dd> <dt><strong><code class="bold_code"><a href="#driver_enq">driver_enq</a></code></strong></dt> <dd>3rd argument</dd> <dt><strong><code class="bold_code"><a href="#driver_pushq">driver_pushq</a></code></strong></dt> <dd>3rd argument</dd> <dt><strong><code class="bold_code"><a href="#driver_deq">driver_deq</a></code></strong></dt> <dd>2nd argument and return value</dd> <dt><strong><code class="bold_code"><a href="#driver_sizeq">driver_sizeq</a></code></strong></dt> <dd>return value</dd> <dt><strong><code class="bold_code"><a href="#driver_enq_bin">driver_enq_bin</a></code></strong></dt> <dd>3rd and 4th argument</dd> <dt><strong><code class="bold_code"><a href="#driver_pushq_bin">driver_pushq_bin</a></code></strong></dt> <dd>3rd and 4th argument</dd> <dt><strong><code class="bold_code"><a href="#driver_enqv">driver_enqv</a></code></strong></dt> <dd>3rd argument</dd> <dt><strong><code class="bold_code"><a href="#driver_pushqv">driver_pushqv</a></code></strong></dt> <dd>3rd argument</dd> <dt><strong><code class="bold_code"><a href="#driver_peekqv">driver_peekqv</a></code></strong></dt> <dd>return value</dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p> This is a change from signed to unsigned which may cause problems for e.g. loop termination conditions and error conditions if you just change the types all over the place. </p> </div> </div> </dd> </dl>  <h2 id="id186154">Data types</h2>  <dl> <dt><strong id="ErlDrvSizeT">ErlDrvSizeT</strong></dt> <dd><p>An unsigned integer type to be used as <code class="code">size_t</code></p></dd> <dt><strong id="ErlDrvSSizeT">ErlDrvSSizeT</strong></dt> <dd><p>A signed integer type the size of <code class="code">ErlDrvSizeT</code></p></dd> <dt><strong id="ErlDrvSysInfo">ErlDrvSysInfo</strong></dt> <dd>  <div class="example"><pre>
typedef struct ErlDrvSysInfo {
   int driver_major_version;
   int driver_minor_version;
   char *erts_version;
   char *otp_release;
   int thread_support;
   int smp_support;
   int async_threads;
   int scheduler_threads;
   int nif_major_version;
   int nif_minor_version;
   int dirty_scheduler_support;
} ErlDrvSysInfo;
      </pre></div> <p> The <code class="code">ErlDrvSysInfo</code> structure is used for storage of information about the Erlang runtime system. <code class="bold_code"><a href="#driver_system_info">driver_system_info()</a></code> will write the system information when passed a reference to a <code class="code">ErlDrvSysInfo</code> structure. A description of the fields in the structure follows: </p> <dl> <dt><strong><code class="code">driver_major_version</code></strong></dt> <dd>The value of <code class="bold_code"><a href="#version_management">ERL_DRV_EXTENDED_MAJOR_VERSION</a></code> when the runtime system was compiled. This value is the same as the value of <code class="bold_code"><a href="#version_management">ERL_DRV_EXTENDED_MAJOR_VERSION</a></code> used when compiling the driver; otherwise, the runtime system would have refused to load the driver. </dd> <dt><strong><code class="code">driver_minor_version</code></strong></dt> <dd>The value of <code class="bold_code"><a href="#version_management">ERL_DRV_EXTENDED_MINOR_VERSION</a></code> when the runtime system was compiled. This value might differ from the value of <code class="bold_code"><a href="#version_management">ERL_DRV_EXTENDED_MINOR_VERSION</a></code> used when compiling the driver. </dd> <dt><strong><code class="code">erts_version</code></strong></dt> <dd>A string containing the version number of the runtime system (the same as returned by <code class="bold_code"><a href="../erlang/#system_info_version">erlang:system_info(version)</a></code>). </dd> <dt><strong><code class="code">otp_release</code></strong></dt> <dd>A string containing the OTP release number (the same as returned by <code class="bold_code"><a href="../erlang/#system_info_otp_release">erlang:system_info(otp_release)</a></code>). </dd> <dt><strong><code class="code">thread_support</code></strong></dt> <dd>A value <code class="code">!= 0</code> if the runtime system has thread support; otherwise, <code class="code">0</code>. </dd> <dt><strong><code class="code">smp_support</code></strong></dt> <dd>A value <code class="code">!= 0</code> if the runtime system has SMP support; otherwise, <code class="code">0</code>. </dd> <dt><strong><code class="code">async_threads</code></strong></dt> <dd>The number of async threads in the async thread pool used by <code class="bold_code"><a href="#driver_async">driver_async()</a></code> (the same as returned by <code class="bold_code"><a href="../erlang/#system_info_thread_pool_size">erlang:system_info(thread_pool_size)</a></code>). </dd> <dt><strong><code class="code">scheduler_threads</code></strong></dt> <dd>The number of scheduler threads used by the runtime system (the same as returned by <code class="bold_code"><a href="../erlang/#system_info_schedulers">erlang:system_info(schedulers)</a></code>). </dd> <dt><strong><code class="code">nif_major_version</code></strong></dt> <dd>The value of <code class="code">ERL_NIF_MAJOR_VERSION</code> when the runtime system was compiled. </dd> <dt><strong><code class="code">nif_minor_version</code></strong></dt> <dd>The value of <code class="code">ERL_NIF_MINOR_VERSION</code> when the runtime system was compiled. </dd> <dt><strong><code class="code">dirty_scheduler_support</code></strong></dt> <dd>A value <code class="code">!= 0</code> if the runtime system has support for dirty scheduler threads; otherwise <code class="code">0</code>. </dd> </dl> </dd> <dt><strong id="ErlDrvBinary">ErlDrvBinary</strong></dt> <dd>  <div class="example"><pre>
typedef struct ErlDrvBinary {
   ErlDrvSint orig_size;
   char orig_bytes[];
} ErlDrvBinary;
</pre></div> <p>The <code class="code">ErlDrvBinary</code> structure is a binary, as sent between the emulator and the driver. All binaries are reference counted; when <code class="code">driver_binary_free</code> is called, the reference count is decremented, when it reaches zero, the binary is deallocated. The <code class="code">orig_size</code> is the size of the binary, and <code class="code">orig_bytes</code> is the buffer. The <code class="code">ErlDrvBinary</code> does not have a fixed size, its size is <code class="code">orig_size + 2 * sizeof(int)</code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The <code class="code">refc</code> field has been removed. The reference count of an <code class="code">ErlDrvBinary</code> is now stored elsewhere. The reference count of an <code class="code">ErlDrvBinary</code> can be accessed via <code class="bold_code"><a href="#driver_binary_get_refc">driver_binary_get_refc()</a></code>, <code class="bold_code"><a href="#driver_binary_inc_refc">driver_binary_inc_refc()</a></code>, and <code class="bold_code"><a href="#driver_binary_dec_refc">driver_binary_dec_refc()</a></code>.</p> </div> </div> <p>Some driver calls, such as <code class="code">driver_enq_binary</code>, increment the driver reference count, and others, such as <code class="code">driver_deq</code> decrement it.</p> <p>Using a driver binary instead of a normal buffer, is often faster, since the emulator doesn't need to copy the data, only the pointer is used.</p> <p>A driver binary allocated in the driver, with <code class="code">driver_alloc_binary</code>, should be freed in the driver (unless otherwise stated), with <code class="code">driver_free_binary</code>. (Note that this doesn't necessarily deallocate it, if the driver is still referred in the emulator, the ref-count will not go to zero.)</p> <p>Driver binaries are used in the <code class="code">driver_output2</code> and <code class="code">driver_outputv</code> calls, and in the queue. Also the driver call-back <code class="bold_code"><a href="../driver_entry/#outputv">outputv</a></code> uses driver binaries.</p> <p>If the driver for some reason or another, wants to keep a driver binary around, in a static variable for instance, the reference count should be incremented, and the binary can later be freed in the <code class="bold_code"><a href="../driver_entry/#stop">stop</a></code> call-back, with <code class="code">driver_free_binary</code>.</p> <p>Note that since a driver binary is shared by the driver and the emulator, a binary received from the emulator or sent to the emulator, must not be changed by the driver.</p> <p>Since erts version 5.5 (OTP release R11B), orig_bytes is guaranteed to be properly aligned for storage of an array of doubles (usually 8-byte aligned).</p> </dd> <dt><strong>ErlDrvData</strong></dt> <dd> <p>The <code class="code">ErlDrvData</code> is a handle to driver-specific data, passed to the driver call-backs. It is a pointer, and is most often type cast to a specific pointer in the driver.</p> </dd> <dt><strong>SysIOVec</strong></dt> <dd> <p>This is a system I/O vector, as used by <code class="code">writev</code> on unix and <code class="code">WSASend</code> on Win32. It is used in <code class="code">ErlIOVec</code>.</p> </dd> <dt><strong id="ErlIOVec">ErlIOVec</strong></dt> <dd>  <div class="example"><pre>
typedef struct ErlIOVec {
  int vsize;
  ErlDrvSizeT size;
  SysIOVec* iov;
  ErlDrvBinary** binv;
} ErlIOVec;
</pre></div> <p>The I/O vector used by the emulator and drivers, is a list of binaries, with a <code class="code">SysIOVec</code> pointing to the buffers of the binaries. It is used in <code class="code">driver_outputv</code> and the <code class="bold_code"><a href="../driver_entry/#outputv">outputv</a></code> driver call-back. Also, the driver queue is an <code class="code">ErlIOVec</code>.</p> </dd> <dt><strong>ErlDrvMonitor</strong></dt> <dd> <p>When a driver creates a monitor for a process, a <code class="code">ErlDrvMonitor</code> is filled in. This is an opaque data-type which can be assigned to but not compared without using the supplied compare function (i.e. it behaves like a struct).</p> <p>The driver writer should provide the memory for storing the monitor when calling <code class="bold_code"><a href="#driver_monitor_process">driver_monitor_process</a></code>. The address of the data is not stored outside of the driver, so the <code class="code">ErlDrvMonitor</code> can be used as any other datum, it can be copied, moved in memory, forgotten etc.</p> </dd> <dt><strong id="ErlDrvNowData">ErlDrvNowData</strong></dt> <dd> <p>The <code class="code">ErlDrvNowData</code> structure holds a timestamp consisting of three values measured from some arbitrary point in the past. The three structure members are:</p> <dl> <dt><strong>megasecs</strong></dt> <dd>The number of whole megaseconds elapsed since the arbitrary point in time</dd> <dt><strong>secs</strong></dt> <dd>The number of whole seconds elapsed since the arbitrary point in time</dd> <dt><strong>microsecs</strong></dt> <dd>The number of whole microseconds elapsed since the arbitrary point in time</dd> </dl> </dd> <dt><strong id="ErlDrvPDL">ErlDrvPDL</strong></dt> <dd> <p>If certain port specific data have to be accessed from other threads than those calling the driver call-backs, a port data lock can be used in order to synchronize the operations on the data. Currently, the only port specific data that the emulator associates with the port data lock is the driver queue.</p> <p>Normally a driver instance does not have a port data lock. If the driver instance wants to use a port data lock, it has to create the port data lock by calling <code class="bold_code"><a href="#driver_pdl_create">driver_pdl_create()</a></code>. <strong>NOTE</strong>: Once the port data lock has been created, every access to data associated with the port data lock has to be done while having the port data lock locked. The port data lock is locked, and unlocked, respectively, by use of <code class="bold_code"><a href="#driver_pdl_lock">driver_pdl_lock()</a></code>, and <code class="bold_code"><a href="#driver_pdl_unlock">driver_pdl_unlock()</a></code>.</p> <p>A port data lock is reference counted, and when the reference count reaches zero, it will be destroyed. The emulator will at least increment the reference count once when the lock is created and decrement it once when the port associated with the lock terminates. The emulator will also increment the reference count when an async job is enqueued and decrement it after an async job has been invoked. Besides this, it is the responsibility of the driver to ensure that the reference count does not reach zero before the last use of the lock by the driver has been made. The reference count can be read, incremented, and decremented, respectively, by use of <code class="bold_code"><a href="#driver_pdl_get_refc">driver_pdl_get_refc()</a></code>, <code class="bold_code"><a href="#driver_pdl_inc_refc">driver_pdl_inc_refc()</a></code>, and <code class="bold_code"><a href="#driver_pdl_dec_refc">driver_pdl_dec_refc()</a></code>.</p> </dd> <dt><strong id="ErlDrvTid">ErlDrvTid</strong></dt> <dd> <p>Thread identifier.</p> <p>See also: <code class="bold_code"><a href="#erl_drv_thread_create">erl_drv_thread_create()</a></code>, <code class="bold_code"><a href="#erl_drv_thread_exit">erl_drv_thread_exit()</a></code>, <code class="bold_code"><a href="#erl_drv_thread_join">erl_drv_thread_join()</a></code>, <code class="bold_code"><a href="#erl_drv_thread_self">erl_drv_thread_self()</a></code>, and <code class="bold_code"><a href="#erl_drv_equal_tids">erl_drv_equal_tids()</a></code>. </p> </dd> <dt><strong id="ErlDrvThreadOpts">ErlDrvThreadOpts</strong></dt> <dd>  <div class="example"><pre>
int suggested_stack_size;
     </pre></div> <p>Thread options structure passed to <code class="bold_code"><a href="#erl_drv_thread_create">erl_drv_thread_create()</a></code>. Currently the following fields exist: </p> <dl> <dt><strong>suggested_stack_size</strong></dt> <dd>A suggestion, in kilo-words, on how large a stack to use. A value less than zero means default size. </dd> </dl> <p>See also: <code class="bold_code"><a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create()</a></code>, <code class="bold_code"><a href="#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy()</a></code>, and <code class="bold_code"><a href="#erl_drv_thread_create">erl_drv_thread_create()</a></code>. </p> </dd> <dt><strong id="ErlDrvMutex">ErlDrvMutex</strong></dt> <dd> <p>Mutual exclusion lock. Used for synchronizing access to shared data. Only one thread at a time can lock a mutex. </p> <p>See also: <code class="bold_code"><a href="#erl_drv_mutex_create">erl_drv_mutex_create()</a></code>, <code class="bold_code"><a href="#erl_drv_mutex_destroy">erl_drv_mutex_destroy()</a></code>, <code class="bold_code"><a href="#erl_drv_mutex_lock">erl_drv_mutex_lock()</a></code>, <code class="bold_code"><a href="#erl_drv_mutex_trylock">erl_drv_mutex_trylock()</a></code>, and <code class="bold_code"><a href="#erl_drv_mutex_unlock">erl_drv_mutex_unlock()</a></code>. </p> </dd> <dt><strong id="ErlDrvCond">ErlDrvCond</strong></dt> <dd> <p>Condition variable. Used when threads need to wait for a specific condition to appear before continuing execution. Condition variables need to be used with associated mutexes. </p> <p>See also: <code class="bold_code"><a href="#erl_drv_cond_create">erl_drv_cond_create()</a></code>, <code class="bold_code"><a href="#erl_drv_cond_destroy">erl_drv_cond_destroy()</a></code>, <code class="bold_code"><a href="#erl_drv_cond_signal">erl_drv_cond_signal()</a></code>, <code class="bold_code"><a href="#erl_drv_cond_broadcast">erl_drv_cond_broadcast()</a></code>, and <code class="bold_code"><a href="#erl_drv_cond_wait">erl_drv_cond_wait()</a></code>. </p> </dd> <dt><strong id="ErlDrvRWLock">ErlDrvRWLock</strong></dt> <dd> <p>Read/write lock. Used to allow multiple threads to read shared data while only allowing one thread to write the same data. Multiple threads can read lock an rwlock at the same time, while only one thread can read/write lock an rwlock at a time. </p> <p>See also: <code class="bold_code"><a href="#erl_drv_rwlock_create">erl_drv_rwlock_create()</a></code>, <code class="bold_code"><a href="#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy()</a></code>, <code class="bold_code"><a href="#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock()</a></code>, <code class="bold_code"><a href="#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock()</a></code>, <code class="bold_code"><a href="#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock()</a></code>, <code class="bold_code"><a href="#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock()</a></code>, <code class="bold_code"><a href="#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock()</a></code>, and <code class="bold_code"><a href="#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock()</a></code>. </p> </dd> <dt><strong id="ErlDrvTSDKey">ErlDrvTSDKey</strong></dt> <dd> <p>Key which thread specific data can be associated with.</p> <p>See also: <code class="bold_code"><a href="#erl_drv_tsd_key_create">erl_drv_tsd_key_create()</a></code>, <code class="bold_code"><a href="#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy()</a></code>, <code class="bold_code"><a href="#erl_drv_tsd_set">erl_drv_tsd_set()</a></code>, and <code class="bold_code"><a href="#erl_drv_tsd_get">erl_drv_tsd_get()</a></code>. </p> </dd> <dt><strong id="ErlDrvTime">ErlDrvTime</strong></dt> <dd> <p>A signed 64-bit integer type for representation of time.</p> </dd> <dt><strong id="ErlDrvTimeUnit">ErlDrvTimeUnit</strong></dt> <dd> <p>An enumeration of time units supported by the driver API:</p> <dl> <dt><strong><code class="code">ERL_DRV_SEC</code></strong></dt> <dd><p>Seconds</p></dd> <dt><strong><code class="code">ERL_DRV_MSEC</code></strong></dt> <dd><p>Milliseconds</p></dd> <dt><strong><code class="code">ERL_DRV_USEC</code></strong></dt> <dd><p>Microseconds</p></dd> <dt><strong><code class="code">ERL_DRV_NSEC</code></strong></dt> <dd><p>Nanoseconds</p></dd> </dl> </dd> </dl>  <h2>Exports</h2> <h3 id="driver_system_info" class="code">void driver_system_info(ErlDrvSysInfo *sys_info_ptr, size_t size)</h3> 
<p>This function will write information about the Erlang runtime system into the <code class="bold_code"><a href="#ErlDrvSysInfo">ErlDrvSysInfo</a></code> structure referred to by the first argument. The second argument should be the size of the <code class="bold_code"><a href="#ErlDrvSysInfo">ErlDrvSysInfo</a></code> structure, i.e., <code class="code">sizeof(ErlDrvSysInfo)</code>.</p> <p>See the documentation of the <code class="bold_code"><a href="#ErlDrvSysInfo">ErlDrvSysInfo</a></code> structure for information about specific fields.</p>  <h3 id="driver_output" class="code">int driver_output(ErlDrvPort port, char *buf, ErlDrvSizeT len)</h3> 
<p>The <code class="code">driver_output</code> function is used to send data from the driver up to the emulator. The data will be received as terms or binary data, depending on how the driver port was opened.</p> <p>The data is queued in the port owner process' message queue. Note that this does not yield to the emulator. (Since the driver and the emulator run in the same thread.)</p> <p>The parameter <code class="code">buf</code> points to the data to send, and <code class="code">len</code> is the number of bytes.</p> <p>The return value for all output functions is 0. (Unless the driver is used for distribution, in which case it can fail and return -1. For normal use, the output function always returns 0.)</p>  <h3 id="driver_output2" class="code">int driver_output2(ErlDrvPort port, char *hbuf, ErlDrvSizeT hlen, char *buf, ErlDrvSizeT len)</h3> 
<p>The <code class="code">driver_output2</code> function first sends <code class="code">hbuf</code> (length in <code class="code">hlen</code>) data as a list, regardless of port settings. Then <code class="code">buf</code> is sent as a binary or list. E.g. if <code class="code">hlen</code> is 3 then the port owner process will receive <code class="code">[H1, H2, H3 | T]</code>.</p> <p>The point of sending data as a list header, is to facilitate matching on the data received.</p> <p>The return value is 0 for normal use.</p>  <h3 id="driver_output_binary" class="code">int driver_output_binary(ErlDrvPort port, char *hbuf, ErlDrvSizeT hlen, ErlDrvBinary* bin, ErlDrvSizeT offset, ErlDrvSizeT len)</h3> 
<p>This function sends data to port owner process from a driver binary, it has a header buffer (<code class="code">hbuf</code> and <code class="code">hlen</code>) just like <code class="code">driver_output2</code>. The <code class="code">hbuf</code> parameter can be <code class="code">NULL</code>.</p> <p>The parameter <code class="code">offset</code> is an offset into the binary and <code class="code">len</code> is the number of bytes to send.</p> <p>Driver binaries are created with <code class="code">driver_alloc_binary</code>.</p> <p>The data in the header is sent as a list and the binary as an Erlang binary in the tail of the list.</p> <p>E.g. if <code class="code">hlen</code> is 2, then the port owner process will receive <code class="code">[H1, H2 | &lt;&lt;T&gt;&gt;]</code>.</p> <p>The return value is 0 for normal use.</p> <p>Note that, using the binary syntax in Erlang, the driver application can match the header directly from the binary, so the header can be put in the binary, and hlen can be set to 0.</p>  <h3 id="driver_outputv" class="code">int driver_outputv(ErlDrvPort port, char* hbuf, ErlDrvSizeT hlen, ErlIOVec *ev, ErlDrvSizeT skip)</h3> 
<p>This function sends data from an IO vector, <code class="code">ev</code>, to the port owner process. It has a header buffer (<code class="code">hbuf</code> and <code class="code">hlen</code>), just like <code class="code">driver_output2</code>.</p> <p>The <code class="code">skip</code> parameter is a number of bytes to skip of the <code class="code">ev</code> vector from the head.</p> <p>You get vectors of <code class="code">ErlIOVec</code> type from the driver queue (see below), and the <code class="bold_code"><a href="../driver_entry/#outputv">outputv</a></code> driver entry function. You can also make them yourself, if you want to send several <code class="code">ErlDrvBinary</code> buffers at once. Often it is faster to use <code class="code">driver_output</code> or <code class="code">driver_output_binary</code>.</p> <p>E.g. if <code class="code">hlen</code> is 2 and <code class="code">ev</code> points to an array of three binaries, the port owner process will receive <code class="code">[H1, H2, &lt;&lt;B1&gt;&gt;, &lt;&lt;B2&gt;&gt; | &lt;&lt;B3&gt;&gt;]</code>.</p> <p>The return value is 0 for normal use.</p> <p>The comment for <code class="code">driver_output_binary</code> applies for <code class="code">driver_outputv</code> too.</p>  <h3 id="driver_vec_to_buf" class="code">ErlDrvSizeT driver_vec_to_buf(ErlIOVec *ev, char *buf, ErlDrvSizeT len)</h3> 
<p>This function collects several segments of data, referenced by <code class="code">ev</code>, by copying them in order to the buffer <code class="code">buf</code>, of the size <code class="code">len</code>.</p> <p>If the data is to be sent from the driver to the port owner process, it is faster to use <code class="code">driver_outputv</code>.</p> <p>The return value is the space left in the buffer, i.e. if the <code class="code">ev</code> contains less than <code class="code">len</code> bytes it's the difference, and if <code class="code">ev</code> contains <code class="code">len</code> bytes or more, it's 0. This is faster if there is more than one header byte, since the binary syntax can construct integers directly from the binary.</p>  <h3 id="driver_set_timer" class="code">int driver_set_timer(ErlDrvPort port, unsigned long time)</h3> 
<p>This function sets a timer on the driver, which will count down and call the driver when it is timed out. The <code class="code">time</code> parameter is the time in milliseconds before the timer expires.</p> <p>When the timer reaches 0 and expires, the driver entry function <code class="bold_code"><a href="../driver_entry/#timeout">timeout</a></code> is called.</p> <p>Note that there is only one timer on each driver instance; setting a new timer will replace an older one.</p> <p>Return value is 0 (-1 only when the <code class="code">timeout</code> driver function is <code class="code">NULL</code>).</p>  <h3 id="driver_cancel_timer" class="code">int driver_cancel_timer(ErlDrvPort port)</h3> 
<p>This function cancels a timer set with <code class="code">driver_set_timer</code>.</p> <p>The return value is 0.</p>  <h3 id="driver_read_timer" class="code">int driver_read_timer(ErlDrvPort port, unsigned long *time_left)</h3> 
<p>This function reads the current time of a timer, and places the result in <code class="code">time_left</code>. This is the time in milliseconds, before the timeout will occur.</p> <p>The return value is 0.</p>  <h3 id="driver_get_now" class="code">int driver_get_now(ErlDrvNowData *now)</h3> 
<div class="warning"> <div class="label">Warning</div> <div class="content">

<p><strong>This function is deprecated! Do not use it!</strong> Use <code class="bold_code"><a href="#erl_drv_monotonic_time"><span class="code">erl_drv_monotonic_time()</span></a></code> (perhaps in combination with <code class="bold_code"><a href="#erl_drv_time_offset"><span class="code">erl_drv_time_offset()</span></a></code>) instead.</p>
</div> </div> <p>This function reads a timestamp into the memory pointed to by the parameter <code class="code">now</code>. See the description of <code class="bold_code"><a href="#ErlDrvNowData">ErlDrvNowData</a></code> for specification of its fields. </p> <p>The return value is 0 unless the <code class="code">now</code> pointer is not valid, in which case it is &lt; 0. </p>  <h3 id="driver_select" class="code">int driver_select(ErlDrvPort port, ErlDrvEvent event, int mode, int on)</h3> 
<p>This function is used by drivers to provide the emulator with events to check for. This enables the emulator to call the driver when something has happened asynchronously.</p> <p>The <code class="code">event</code> argument identifies an OS-specific event object. On Unix systems, the functions <code class="code">select</code>/<code class="code">poll</code> are used. The event object must be a socket or pipe (or other object that <code class="code">select</code>/<code class="code">poll</code> can use). On windows, the Win32 API function <code class="code">WaitForMultipleObjects</code> is used. This places other restrictions on the event object. Refer to the Win32 SDK documentation. On Enea OSE, the receive function is used. See the  for more details.</p> <p>The <code class="code">on</code> parameter should be <code class="code">1</code> for setting events and <code class="code">0</code> for clearing them.</p> <p>The <code class="code">mode</code> argument is a bitwise-or combination of <code class="code">ERL_DRV_READ</code>, <code class="code">ERL_DRV_WRITE</code> and <code class="code">ERL_DRV_USE</code>. The first two specify whether to wait for read events and/or write events. A fired read event will call <code class="bold_code"><a href="../driver_entry/#ready_input">ready_input</a></code> while a fired write event will call <code class="bold_code"><a href="../driver_entry/#ready_output">ready_output</a></code>. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Some OS (Windows and Enea OSE) do not differentiate between read and write events. The call-back for a fired event then only depends on the value of <code class="code">mode</code>.</p> </div> </div> <p><code class="code">ERL_DRV_USE</code> specifies if we are using the event object or if we want to close it. On an emulator with SMP support, it is not safe to clear all events and then close the event object after <code class="code">driver_select</code> has returned. Another thread may still be using the event object internally. To safely close an event object call <code class="code">driver_select</code> with <code class="code">ERL_DRV_USE</code> and <code class="code">on==0</code>. That will clear all events and then call <code class="bold_code"><a href="../driver_entry/#stop_select">stop_select</a></code> when it is safe to close the event object. <code class="code">ERL_DRV_USE</code> should be set together with the first event for an event object. It is harmless to set <code class="code">ERL_DRV_USE</code> even though it already has been done. Clearing all events but keeping <code class="code">ERL_DRV_USE</code> set will indicate that we are using the event object and probably will set events for it again.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>ERL_DRV_USE was added in OTP release R13. Old drivers will still work as before. But it is recommended to update them to use <code class="code">ERL_DRV_USE</code> and <code class="code">stop_select</code> to make sure that event objects are closed in a safe way.</p> </div> </div> <p>The return value is 0 (failure, -1, only if the <code class="code">ready_input</code>/<code class="code">ready_output</code> is <code class="code">NULL</code>).</p>  <h3 id="driver_alloc" class="code">void *driver_alloc(ErlDrvSizeT size)</h3> 
<p>This function allocates a memory block of the size specified in <code class="code">size</code>, and returns it. This only fails on out of memory, in that case <code class="code">NULL</code> is returned. (This is most often a wrapper for <code class="code">malloc</code>).</p> <p>Memory allocated must be explicitly freed with a corresponding call to <code class="code">driver_free</code> (unless otherwise stated).</p> <p>This function is thread-safe.</p>  <h3 id="driver_realloc" class="code">void *driver_realloc(void *ptr, ErlDrvSizeT size)</h3> 
<p>This function resizes a memory block, either in place, or by allocating a new block, copying the data and freeing the old block. A pointer is returned to the reallocated memory. On failure (out of memory), <code class="code">NULL</code> is returned. (This is most often a wrapper for <code class="code">realloc</code>.)</p> <p>This function is thread-safe.</p>  <h3 id="driver_free" class="code">void driver_free(void *ptr)</h3> 
<p>This function frees the memory pointed to by <code class="code">ptr</code>. The memory should have been allocated with <code class="code">driver_alloc</code>. All allocated memory should be deallocated, just once. There is no garbage collection in drivers.</p> <p>This function is thread-safe.</p>  <h3 id="driver_alloc_binary" class="code">ErlDrvBinary *driver_alloc_binary(ErlDrvSizeT size)</h3> 
<p>This function allocates a driver binary with a memory block of at least <code class="code">size</code> bytes, and returns a pointer to it, or NULL on failure (out of memory). When a driver binary has been sent to the emulator, it must not be altered. Every allocated binary should be freed by a corresponding call to <code class="code">driver_free_binary</code> (unless otherwise stated).</p> <p>Note that a driver binary has an internal reference counter, this means that calling <code class="code">driver_free_binary</code> it may not actually dispose of it. If it's sent to the emulator, it may be referenced there.</p> <p>The driver binary has a field, <code class="code">orig_bytes</code>, which marks the start of the data in the binary.</p> <p>This function is thread-safe.</p>  <h3 id="driver_realloc_binary" class="code">ErlDrvBinary *driver_realloc_binary(ErlDrvBinary *bin, ErlDrvSizeT size)</h3> 
<p>This function resizes a driver binary, while keeping the data. The resized driver binary is returned. On failure (out of memory), <code class="code">NULL</code> is returned.</p> <p>This function is only thread-safe when the emulator with SMP support is used.</p>  <h3 id="driver_free_binary" class="code">void driver_free_binary(ErlDrvBinary *bin)</h3> 
<p>This function frees a driver binary <code class="code">bin</code>, allocated previously with <code class="code">driver_alloc_binary</code>. Since binaries in Erlang are reference counted, the binary may still be around.</p> <p>This function is only thread-safe when the emulator with SMP support is used.</p>  <h3 id="driver_binary_get_refc" class="code">long driver_binary_get_refc(ErlDrvBinary *bin)</h3> 
<p>Returns current reference count on <code class="code">bin</code>.</p> <p>This function is only thread-safe when the emulator with SMP support is used.</p>  <h3 id="driver_binary_inc_refc" class="code">long driver_binary_inc_refc(ErlDrvBinary *bin)</h3> 
<p>Increments the reference count on <code class="code">bin</code> and returns the reference count reached after the increment.</p> <p>This function is only thread-safe when the emulator with SMP support is used.</p>  <h3 id="driver_binary_dec_refc" class="code">long driver_binary_dec_refc(ErlDrvBinary *bin)</h3> 
<p>Decrements the reference count on <code class="code">bin</code> and returns the reference count reached after the decrement.</p> <p>This function is only thread-safe when the emulator with SMP support is used.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>You should normally decrement the reference count of a driver binary by calling <code class="bold_code"><a href="#driver_free_binary">driver_free_binary()</a></code>. <code class="code">driver_binary_dec_refc()</code> does <strong>not</strong> free the binary if the reference count reaches zero. <strong>Only</strong> use <code class="code">driver_binary_dec_refc()</code> when you are sure <strong>not</strong> to reach a reference count of zero.</p> </div> </div>  <h3 id="driver_enq" class="code">int driver_enq(ErlDrvPort port, char* buf, ErlDrvSizeT len)</h3> 
<p>This function enqueues data in the driver queue. The data in <code class="code">buf</code> is copied (<code class="code">len</code> bytes) and placed at the end of the driver queue. The driver queue is normally used in a FIFO way.</p> <p>The driver queue is available to queue output from the emulator to the driver (data from the driver to the emulator is queued by the emulator in normal erlang message queues). This can be useful if the driver has to wait for slow devices etc, and wants to yield back to the emulator. The driver queue is implemented as an ErlIOVec.</p> <p>When the queue contains data, the driver won't close, until the queue is empty.</p> <p>The return value is 0.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_pushq" class="code">int driver_pushq(ErlDrvPort port, char* buf, ErlDrvSizeT len)</h3> 
<p>This function puts data at the head of the driver queue. The data in <code class="code">buf</code> is copied (<code class="code">len</code> bytes) and placed at the beginning of the queue.</p> <p>The return value is 0.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_deq" class="code">ErlDrvSizeT driver_deq(ErlDrvPort port, ErlDrvSizeT size)</h3> 
<p>This function dequeues data by moving the head pointer forward in the driver queue by <code class="code">size</code> bytes. The data in the queue will be deallocated.</p> <p>The return value is the number of bytes remaining in the queue or -1 on failure.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_sizeq" class="code">ErlDrvSizeT driver_sizeq(ErlDrvPort port)</h3> 
<p>This function returns the number of bytes currently in the driver queue.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_enq_bin" class="code">int driver_enq_bin(ErlDrvPort port, ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len)</h3> 
<p>This function enqueues a driver binary in the driver queue. The data in <code class="code">bin</code> at <code class="code">offset</code> with length <code class="code">len</code> is placed at the end of the queue. This function is most often faster than <code class="code">driver_enq</code>, because the data doesn't have to be copied.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p> <p>The return value is 0.</p>  <h3 id="driver_pushq_bin" class="code">int driver_pushq_bin(ErlDrvPort port, ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len)</h3> 
<p>This function puts data in the binary <code class="code">bin</code>, at <code class="code">offset</code> with length <code class="code">len</code> at the head of the driver queue. It is most often faster than <code class="code">driver_pushq</code>, because the data doesn't have to be copied.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p> <p>The return value is 0.</p>  <h3 id="driver_peekqv" class="code">ErlDrvSizeT driver_peekqv(ErlDrvPort port, ErlIOVec *ev)</h3> 
<p> This function retrieves the driver queue into a supplied <code class="code">ErlIOVec</code> <code class="code">ev</code>. It also returns the queue size. This is one of two ways to get data out of the queue. </p> <p> If <code class="code">ev</code> is <code class="code">NULL</code> all ones i.e. <code class="code">-1</code> type cast to <code class="code">ErlDrvSizeT</code> is returned. </p> <p>Nothing is removed from the queue by this function, that must be done with <code class="code">driver_deq</code>.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_peekq" class="code">SysIOVec *driver_peekq(ErlDrvPort port, int *vlen)</h3> 
<p>This function retrieves the driver queue as a pointer to an array of <code class="code">SysIOVec</code>s. It also returns the number of elements in <code class="code">vlen</code>. This is one of two ways to get data out of the queue.</p> <p>Nothing is removed from the queue by this function, that must be done with <code class="code">driver_deq</code>.</p> <p>The returned array is suitable to use with the Unix system call <code class="code">writev</code>.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_enqv" class="code">int driver_enqv(ErlDrvPort port, ErlIOVec *ev, ErlDrvSizeT skip)</h3> 
<p>This function enqueues the data in <code class="code">ev</code>, skipping the first <code class="code">skip</code> bytes of it, at the end of the driver queue. It is faster than <code class="code">driver_enq</code>, because the data doesn't have to be copied.</p> <p>The return value is 0.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_pushqv" class="code">int driver_pushqv(ErlDrvPort port, ErlIOVec *ev, ErlDrvSizeT skip)</h3> 
<p>This function puts the data in <code class="code">ev</code>, skipping the first <code class="code">skip</code> bytes of it, at the head of the driver queue. It is faster than <code class="code">driver_pushq</code>, because the data doesn't have to be copied.</p> <p>The return value is 0.</p> <p>This function can be called from an arbitrary thread if a <code class="bold_code"><a href="#ErlDrvPDL">port data lock</a></code> associated with the <code class="code">port</code> is locked by the calling thread during the call.</p>  <h3 id="driver_pdl_create" class="code">ErlDrvPDL driver_pdl_create(ErlDrvPort port)</h3> 
<p>This function creates a port data lock associated with the <code class="code">port</code>. <strong>NOTE</strong>: Once a port data lock has been created, it has to be locked during all operations on the driver queue of the <code class="code">port</code>.</p> <p>On success a newly created port data lock is returned. On failure <code class="code">NULL</code> is returned. <code class="code">driver_pdl_create()</code> will fail if <code class="code">port</code> is invalid or if a port data lock already has been associated with the <code class="code">port</code>.</p>  <h3 id="driver_pdl_lock" class="code">void driver_pdl_lock(ErlDrvPDL pdl)</h3> 
<p>This function locks the port data lock passed as argument (<code class="code">pdl</code>).</p> <p>This function is thread-safe.</p>  <h3 id="driver_pdl_unlock" class="code">void driver_pdl_unlock(ErlDrvPDL pdl)</h3> 
<p>This function unlocks the port data lock passed as argument (<code class="code">pdl</code>).</p> <p>This function is thread-safe.</p>  <h3 id="driver_pdl_get_refc" class="code">long driver_pdl_get_refc(ErlDrvPDL pdl)</h3> 
<p>This function returns the current reference count of the port data lock passed as argument (<code class="code">pdl</code>).</p> <p>This function is thread-safe.</p>  <h3 id="driver_pdl_inc_refc" class="code">long driver_pdl_inc_refc(ErlDrvPDL pdl)</h3> 
<p>This function increments the reference count of the port data lock passed as argument (<code class="code">pdl</code>).</p> <p>The current reference count after the increment has been performed is returned.</p> <p>This function is thread-safe.</p>  <h3 id="driver_pdl_dec_refc" class="code">long driver_pdl_dec_refc(ErlDrvPDL pdl)</h3> 
<p>This function decrements the reference count of the port data lock passed as argument (<code class="code">pdl</code>).</p> <p>The current reference count after the decrement has been performed is returned.</p> <p>This function is thread-safe.</p>  <h3 id="driver_monitor_process" class="code">int driver_monitor_process(ErlDrvPort port, ErlDrvTermData process, ErlDrvMonitor *monitor)</h3> 
<p>Start monitoring a process from a driver. When a process is monitored, a process exit will result in a call to the provided <code class="bold_code"><a href="../driver_entry/#process_exit">process_exit</a></code> call-back in the <code class="bold_code"><a href="../driver_entry/">ErlDrvEntry</a></code> structure. The <code class="code">ErlDrvMonitor</code> structure is filled in, for later removal or compare.</p> <p>The <code class="code">process</code> parameter should be the return value of an earlier call to <code class="bold_code"><a href="#driver_caller">driver_caller</a></code> or <code class="bold_code"><a href="#driver_connected">driver_connected</a></code> call.</p> <p>The function returns 0 on success, &lt; 0 if no call-back is provided and &gt; 0 if the process is no longer alive.</p>  <h3 id="driver_demonitor_process" class="code">int driver_demonitor_process(ErlDrvPort port, const ErlDrvMonitor *monitor)</h3> 
<p>This function cancels a monitor created earlier. </p> <p>The function returns 0 if a monitor was removed and &gt; 0 if the monitor did no longer exist.</p>  <h3 id="driver_get_monitored_process" class="code">ErlDrvTermData driver_get_monitored_process(ErlDrvPort port, const ErlDrvMonitor *monitor)</h3> 
<p>The function returns the process id associated with a living monitor. It can be used in the <code class="code">process_exit</code> call-back to get the process identification for the exiting process.</p> <p>The function returns <code class="code">driver_term_nil</code> if the monitor no longer exists.</p>  <h3 id="driver_compare_monitors" class="code">int driver_compare_monitors(const ErlDrvMonitor *monitor1, const ErlDrvMonitor *monitor2)</h3> 
<p>This function is used to compare two <code class="code">ErlDrvMonitor</code>s. It can also be used to imply some artificial order on monitors, for whatever reason.</p> <p>The function returns 0 if <code class="code">monitor1</code> and <code class="code">monitor2</code> are equal, &lt; 0 if <code class="code">monitor1</code> is less than <code class="code">monitor2</code> and &gt; 0 if <code class="code">monitor1</code> is greater than <code class="code">monitor2</code>.</p>  <h3 id="add_driver_entry" class="code">void add_driver_entry(ErlDrvEntry *de)</h3> 
<p>This function adds a driver entry to the list of drivers known by Erlang. The <code class="bold_code"><a href="../driver_entry/#init">init</a></code> function of the <code class="code">de</code> parameter is called.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>To use this function for adding drivers residing in dynamically loaded code is dangerous. If the driver code for the added driver resides in the same dynamically loaded module (i.e. <code class="code">.so</code> file) as a normal dynamically loaded driver (loaded with the <code class="code">erl_ddll</code> interface), the caller should call <code class="bold_code"><a href="#driver_lock_driver">driver_lock_driver</a></code> before adding driver entries.</p> <p>Use of this function is generally deprecated.</p> </div> </div>  <h3 id="remove_driver_entry" class="code">int remove_driver_entry(ErlDrvEntry *de)</h3> 
<p>This function removes a driver entry <code class="code">de</code> previously added with <code class="code">add_driver_entry</code>.</p> <p>Driver entries added by the <code class="code">erl_ddll</code> erlang interface can not be removed by using this interface.</p>  <h3 id="erl_errno_id" class="code">char *erl_errno_id(int error)</h3> 
<p>This function returns the atom name of the erlang error, given the error number in <code class="code">error</code>. Error atoms are: <code class="code">einval</code>, <code class="code">enoent</code>, etc. It can be used to make error terms from the driver.</p>  <h3 id="erl_drv_busy_msgq_limits" class="code">void erl_drv_busy_msgq_limits(ErlDrvPort port, ErlDrvSizeT *low, ErlDrvSizeT *high)</h3> 
<p>Sets and gets limits that will be used for controling the busy state of the port message queue.</p> <p>The port message queue will be set into a busy state when the amount of command data queued on the message queue reaches the <code class="code">high</code> limit. The port message queue will be set into a not busy state when the amount of command data queued on the message queue falls below the <code class="code">low</code> limit. Command data is in this context data passed to the port using either <code class="code">Port ! {Owner, {command, Data}}</code>, or <code class="code">port_command/[2,3]</code>. Note that these limits only concerns command data that have not yet reached the port. The <code class="bold_code"><a href="#set_busy_port">busy port</a></code> feature can be used for data that has reached the port.</p> <p>Valid limits are values in the range <code class="code">[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]</code>. Limits will be automatically adjusted to be sane. That is, the system will adjust values so that the low limit used is lower than or equal to the high limit used. By default the high limit will be 8 kB and the low limit will be 4 kB.</p> <p>By passing a pointer to an integer variable containing the value <code class="code">ERL_DRV_BUSY_MSGQ_READ_ONLY</code>, currently used limit will be read and written back to the integer variable. A new limit can be set by passing a pointer to an integer variable containing a valid limit. The passed value will be written to the internal limit. The internal limit will then be adjusted. After this the adjusted limit will be written back to the integer variable from which the new value was read. Values are in bytes.</p> <p>The busy message queue feature can be disabled either by setting the <code class="code">ERL_DRV_FLAG_NO_BUSY_MSGQ</code> <code class="bold_code"><a href="../driver_entry/#driver_flags">driver flag</a></code> in the <code class="bold_code"><a href="../driver_entry/">driver_entry</a></code> used by the driver, or by calling this function with <code class="code">ERL_DRV_BUSY_MSGQ_DISABLED</code> as a limit (either low or high). When this feature has been disabled it cannot be enabled again. When reading the limits both of them will be <code class="code">ERL_DRV_BUSY_MSGQ_DISABLED</code>, if this feature has been disabled.</p> <p>Processes sending command data to the port will be suspended if either the port is busy or if the port message queue is busy. Suspended processes will be resumed when neither the port is busy, nor the port message queue is busy.</p> <p>For information about busy port functionality see the documentation of the <code class="bold_code"><a href="#set_busy_port">set_busy_port()</a></code> function.</p>  <h3 id="set_busy_port" class="code">void set_busy_port(ErlDrvPort port, int on)</h3> 
<p>This function set and unset the busy state of the port. If <code class="code">on</code> is non-zero, the port is set to busy, if it's zero the port is set to not busy. You typically want to combine this feature with the <code class="bold_code"><a href="#erl_drv_busy_msgq_limits">busy port message queue</a></code> functionality.</p> <p>Processes sending command data to the port will be suspended if either the port is busy or if the port message queue is busy. Suspended processes will be resumed when neither the port is busy, nor the port message queue is busy. Command data is in this context data passed to the port using either <code class="code">Port ! {Owner, {command, Data}}</code>, or <code class="code">port_command/[2,3]</code>.</p> <p>If the <code class="bold_code"><a href="../driver_entry/#driver_flags">ERL_DRV_FLAG_SOFT_BUSY</a></code> has been set in the <code class="bold_code"><a href="../driver_entry/">driver_entry</a></code>, data can be forced into the driver via <code class="bold_code"><a href="../erlang/#port_command-3">port_command(Port, Data, [force])</a></code> even though the driver has signaled that it is busy. </p> <p>For information about busy port message queue functionality see the documentation of the <code class="bold_code"><a href="#erl_drv_busy_msgq_limits">erl_drv_busy_msgq_limits()</a></code> function.</p>  <h3 id="set_port_control_flags" class="code">void set_port_control_flags(ErlDrvPort port, int flags)</h3> 
<p>This function sets flags for how the <code class="bold_code"><a href="../driver_entry/#control">control</a></code> driver entry function will return data to the port owner process. (The <code class="code">control</code> function is called from <code class="code">port_control/3</code> in erlang.)</p> <p>Currently there are only two meaningful values for <code class="code">flags</code>: 0 means that data is returned in a list, and <code class="code">PORT_CONTROL_FLAG_BINARY</code> means data is returned as a binary from <code class="code">control</code>.</p>  <h3 id="driver_failure_eof" class="code">int driver_failure_eof(ErlDrvPort port)</h3> 
<p>This function signals to erlang that the driver has encountered an EOF and should be closed, unless the port was opened with the <code class="code">eof</code> option, in that case eof is sent to the port. Otherwise, the port is closed and an <code class="code">'EXIT'</code> message is sent to the port owner process.</p> <p>The return value is 0.</p>  <h3 id="driver_failure" class="code">int driver_failure_atom(ErlDrvPort port, char *string)<br>int driver_failure_posix(ErlDrvPort port, int error)<br>int driver_failure(ErlDrvPort port, int error)</h3> 
<p>These functions signal to Erlang that the driver has encountered an error and should be closed. The port is closed and the tuple <code class="code">{'EXIT', error, Err}</code>, is sent to the port owner process, where error is an error atom (<code class="code">driver_failure_atom</code> and <code class="code">driver_failure_posix</code>), or an integer (<code class="code">driver_failure</code>).</p> <p>The driver should fail only when in severe error situations, when the driver cannot possibly keep open, for instance buffer allocation gets out of memory. For normal errors it is more appropriate to send error codes with <code class="code">driver_output</code>.</p> <p>The return value is 0.</p>  <h3 id="driver_connected" class="code">ErlDrvTermData driver_connected(ErlDrvPort port)</h3> 
<p>This function returns the port owner process.</p> <p>Note that this function is <strong>not</strong> thread-safe, not even when the emulator with SMP support is used.</p>  <h3 id="driver_caller" class="code">ErlDrvTermData driver_caller(ErlDrvPort port)</h3> 
<p>This function returns the process id of the process that made the current call to the driver. The process id can be used with <code class="code">driver_send_term</code> to send back data to the caller. <code class="code">driver_caller()</code> only returns valid data when currently executing in one of the following driver callbacks:</p> <dl> <dt><strong><code class="bold_code"><a href="../driver_entry/#start">start</a></code></strong></dt> <dd>Called from <code class="code">open_port/2</code>.</dd> <dt><strong><code class="bold_code"><a href="../driver_entry/#output">output</a></code></strong></dt> <dd>Called from <code class="code">erlang:send/2</code>, and <code class="code">erlang:port_command/2</code> </dd> <dt><strong><code class="bold_code"><a href="../driver_entry/#outputv">outputv</a></code></strong></dt> <dd>Called from <code class="code">erlang:send/2</code>, and <code class="code">erlang:port_command/2</code> </dd> <dt><strong><code class="bold_code"><a href="../driver_entry/#control">control</a></code></strong></dt> <dd>Called from <code class="code">erlang:port_control/3</code> </dd> <dt><strong><code class="bold_code"><a href="../driver_entry/#call">call</a></code></strong></dt> <dd>Called from <code class="code">erlang:port_call/3</code> </dd> </dl> <p>Note that this function is <strong>not</strong> thread-safe, not even when the emulator with SMP support is used.</p>  <h3 id="erl_drv_output_term" class="code">int erl_drv_output_term(ErlDrvTermData port, ErlDrvTermData* term, int n)</h3> 
<p>This functions sends data in the special driver term format to the port owner process. This is a fast way to deliver term data from a driver. It also needs no binary conversion, so the port owner process receives data as normal Erlang terms. The <code class="bold_code"><a href="#erl_drv_send_term">erl_drv_send_term()</a></code> functions can be used for sending to any arbitrary process on the local node.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Note that the <code class="code">port</code> parameter is <strong>not</strong> an ordinary port handle, but a port handle converted using <code class="code">driver_mk_port()</code>.</p>
</div> </div> <p>The <code class="code">term</code> parameter points to an array of <code class="code">ErlDrvTermData</code>, with <code class="code">n</code> elements. This array contains terms described in the driver term format. Every term consists of one to four elements in the array. The term first has a term type, and then arguments. The <code class="code">port</code> parameter specifies the sending port.</p> <p>Tuples, maps and lists (with the exception of strings, see below), are built in reverse polish notation, so that to build a tuple, the elements are given first, and then the tuple term, with a count. Likewise for lists and maps.</p> <p>A tuple must be specified with the number of elements. (The elements precede the <code class="code">ERL_DRV_TUPLE</code> term.)</p> <p>A list must be specified with the number of elements, including the tail, which is the last term preceding <code class="code">ERL_DRV_LIST</code>.</p> <p>A map must be specified with the number of key-value pairs <code class="code">N</code>. The key-value pairs must precede the <code class="code">ERL_DRV_MAP</code> in this order: <code class="code">key1,value1,key2,value2,...,keyN,valueN</code>. Duplicate keys are not allowed.</p> <p>The special term <code class="code">ERL_DRV_STRING_CONS</code> is used to "splice" in a string in a list, a string given this way is not a list per se, but the elements are elements of the surrounding list.</p> <div class="example"><pre>
Term type            Argument(s)
===========================================
ERL_DRV_NIL
ERL_DRV_ATOM         ErlDrvTermData atom (from driver_mk_atom(char *string))
ERL_DRV_INT          ErlDrvSInt integer
ERL_DRV_UINT         ErlDrvUInt integer
ERL_DRV_INT64        ErlDrvSInt64 *integer_ptr
ERL_DRV_UINT64       ErlDrvUInt64 *integer_ptr
ERL_DRV_PORT         ErlDrvTermData port (from driver_mk_port(ErlDrvPort port))
ERL_DRV_BINARY       ErlDrvBinary *bin, ErlDrvUInt len, ErlDrvUInt offset
ERL_DRV_BUF2BINARY   char *buf, ErlDrvUInt len
ERL_DRV_STRING       char *str, int len
ERL_DRV_TUPLE        int sz
ERL_DRV_LIST         int sz
ERL_DRV_PID          ErlDrvTermData pid (from driver_connected(ErlDrvPort port) or driver_caller(ErlDrvPort port))
ERL_DRV_STRING_CONS  char *str, int len
ERL_DRV_FLOAT        double *dbl
ERL_DRV_EXT2TERM     char *buf, ErlDrvUInt len
ERL_DRV_MAP          int sz
        </pre></div> <p>The unsigned integer data type <code class="code">ErlDrvUInt</code> and the signed integer data type <code class="code">ErlDrvSInt</code> are 64 bits wide on a 64 bit runtime system and 32 bits wide on a 32 bit runtime system. They were introduced in erts version 5.6, and replaced some of the <code class="code">int</code> arguments in the list above. </p> <p>The unsigned integer data type <code class="code">ErlDrvUInt64</code> and the signed integer data type <code class="code">ErlDrvSInt64</code> are always 64 bits wide. They were introduced in erts version 5.7.4. </p> <p>To build the tuple <code class="code">{tcp, Port, [100 | Binary]}</code>, the following call could be made.</p> <div class="example"><pre>
ErlDrvBinary* bin = ...
ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("tcp"),
    ERL_DRV_PORT, driver_mk_port(drvport),
        ERL_DRV_INT, 100,
        ERL_DRV_BINARY, bin, 50, 0,
        ERL_DRV_LIST, 2,
    ERL_DRV_TUPLE, 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));
    
  </pre></div> <p>Where <code class="code">bin</code> is a driver binary of length at least 50 and <code class="code">drvport</code> is a port handle. Note that the <code class="code">ERL_DRV_LIST</code> comes after the elements of the list, likewise the <code class="code">ERL_DRV_TUPLE</code>.</p> <p>The term <code class="code">ERL_DRV_STRING_CONS</code> is a way to construct strings. It works differently from how <code class="code">ERL_DRV_STRING</code> works. <code class="code">ERL_DRV_STRING_CONS</code> builds a string list in reverse order, (as opposed to how <code class="code">ERL_DRV_LIST</code> works), concatenating the strings added to a list. The tail must be given before <code class="code">ERL_DRV_STRING_CONS</code>.</p> <p>The <code class="code">ERL_DRV_STRING</code> constructs a string, and ends it. (So it's the same as <code class="code">ERL_DRV_NIL</code> followed by <code class="code">ERL_DRV_STRING_CONS</code>.)</p> <div class="example"><pre>
/* to send [x, "abc", y] to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("x"),
    ERL_DRV_STRING, (ErlDrvTermData)"abc", 3,
    ERL_DRV_ATOM, driver_mk_atom("y"),
    ERL_DRV_NIL,
    ERL_DRV_LIST, 4
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));
    </pre></div>  <div class="example"><pre>
/* to send "abc123" to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_NIL,        /* with STRING_CONS, the tail comes first */
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"123", 3,
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"abc", 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));
    </pre></div> <p>The <code class="code">ERL_DRV_EXT2TERM</code> term type is used for passing a term encoded with the <code class="bold_code"><a href="../erl_ext_dist/">external format</a></code>, i.e., a term that has been encoded by <code class="bold_code"><a href="../erlang/#term_to_binary-2">erlang:term_to_binary</a></code>, <code class="bold_code">erl_interface</code>, etc. For example, if <code class="code">binp</code> is a pointer to an <code class="code">ErlDrvBinary</code> that contains the term <code class="code">{17, 4711}</code> encoded with the <code class="bold_code"><a href="../erl_ext_dist/">external format</a></code> and you want to wrap it in a two tuple with the tag <code class="code">my_tag</code>, i.e., <code class="code">{my_tag, {17, 4711}}</code>, you can do as follows: </p> <div class="example"><pre>
ErlDrvTermData spec[] = {
        ERL_DRV_ATOM, driver_mk_atom("my_tag"),
        ERL_DRV_EXT2TERM, (ErlDrvTermData) binp-&gt;orig_bytes, binp-&gt;orig_size
    ERL_DRV_TUPLE, 2,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));
    </pre></div> <p>To build the map <code class="code">#{key1 =&gt; 100, key2 =&gt; {200, 300}}</code>, the following call could be made.</p> <div class="example"><pre>
   ErlDrvPort port = ...
   ErlDrvTermData spec[] = {
         ERL_DRV_ATOM, driver_mk_atom("key1"),
  ERL_DRV_INT, 100,
         ERL_DRV_ATOM, driver_mk_atom("key2"),
    ERL_DRV_INT, 200,
    ERL_DRV_INT, 300,
  ERL_DRV_TUPLE, 2,
ERL_DRV_MAP, 2
   };
   erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));
       
     </pre></div> <p>If you want to pass a binary and don't already have the content of the binary in an <code class="code">ErlDrvBinary</code>, you can benefit from using <code class="code">ERL_DRV_BUF2BINARY</code> instead of creating an <code class="code">ErlDrvBinary</code> via <code class="code">driver_alloc_binary()</code> and then pass the binary via <code class="code">ERL_DRV_BINARY</code>. The runtime system will often allocate binaries smarter if <code class="code">ERL_DRV_BUF2BINARY</code> is used. However, if the content of the binary to pass already resides in an <code class="code">ErlDrvBinary</code>, it is normally better to pass the binary using <code class="code">ERL_DRV_BINARY</code> and the <code class="code">ErlDrvBinary</code> in question. </p> <p>The <code class="code">ERL_DRV_UINT</code>, <code class="code">ERL_DRV_BUF2BINARY</code>, and <code class="code">ERL_DRV_EXT2TERM</code> term types were introduced in the 5.6 version of erts. </p> <p>This function is only thread-safe when the emulator with SMP support is used.</p>  <h3 id="driver_output_term" class="code">int driver_output_term(ErlDrvPort port, ErlDrvTermData* term, int n)</h3> 
<div class="warning"> <div class="label">Warning</div> <div class="content">

<p><code class="code">driver_output_term()</code> is deprecated and will be removed in the OTP-R17 release. Use <code class="bold_code"><a href="#erl_drv_send_term">erl_drv_output_term()</a></code> instead.</p> </div> </div> <p>The parameters <code class="code">term</code> and <code class="code">n</code> do the same thing as in <code class="bold_code"><a href="#erl_drv_output_term">erl_drv_output_term()</a></code>.</p> <p>Note that this function is <strong>not</strong> thread-safe, not even when the emulator with SMP support is used.</p>  <h3 id="driver_mk_atom" class="code">ErlDrvTermData driver_mk_atom(char* string)</h3> 
<p>This function returns an atom given a name <code class="code">string</code>. The atom is created and won't change, so the return value may be saved and reused, which is faster than looking up the atom several times.</p> <p>Note that this function is <strong>not</strong> thread-safe, not even when the emulator with SMP support is used.</p>  <h3 id="driver_mk_port" class="code">ErlDrvTermData driver_mk_port(ErlDrvPort port)</h3> 
<p>This function converts a port handle to the erlang term format, usable in the <code class="bold_code"><a href="#erl_drv_output_term">erl_drv_output_term()</a></code>, and <code class="bold_code"><a href="#erl_drv_send_term">erl_drv_send_term()</a></code> functions.</p> <p>Note that this function is <strong>not</strong> thread-safe, not even when the emulator with SMP support is used.</p>  <h3 id="erl_drv_send_term" class="code">int erl_drv_send_term(ErlDrvTermData port, ErlDrvTermData receiver, ErlDrvTermData* term, int n)</h3> 
<p>This function is the only way for a driver to send data to <strong>other</strong> processes than the port owner process. The <code class="code">receiver</code> parameter specifies the process to receive the data.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Note that the <code class="code">port</code> parameter is <strong>not</strong> an ordinary port handle, but a port handle converted using <code class="code">driver_mk_port()</code>.</p>
</div> </div> <p>The parameters <code class="code">port</code>, <code class="code">term</code> and <code class="code">n</code> do the same thing as in <code class="bold_code"><a href="#erl_drv_output_term">erl_drv_output_term()</a></code>.</p> <p>This function is only thread-safe when the emulator with SMP support is used.</p>  <h3 id="driver_send_term" class="code">int driver_send_term(ErlDrvPort port, ErlDrvTermData receiver, ErlDrvTermData* term, int n)</h3> 
<div class="warning"> <div class="label">Warning</div> <div class="content">

<p><code class="code">driver_send_term()</code> is deprecated and will be removed in the OTP-R17 release. Use <code class="bold_code"><a href="#erl_drv_send_term">erl_drv_send_term()</a></code> instead.</p> <p>Also note that parameters of <code class="code">driver_send_term()</code> cannot be properly checked by the runtime system when executed by arbitrary threads. This may cause the <code class="code">driver_send_term()</code> function not to fail when it should.</p> </div> </div> <p>The parameters <code class="code">term</code> and <code class="code">n</code> do the same thing as in <code class="bold_code"><a href="#erl_drv_output_term">erl_drv_output_term()</a></code>.</p> <p>This function is only thread-safe when the emulator with SMP support is used.</p>  <h3 id="driver_async%20" class="code">long driver_async (ErlDrvPort port, unsigned int* key, void (*async_invoke)(void*), void* async_data, void (*async_free)(void*))</h3> 
<p>This function performs an asynchronous call. The function <code class="code">async_invoke</code> is invoked in a thread separate from the emulator thread. This enables the driver to perform time-consuming, blocking operations without blocking the emulator.</p> <p>The async thread pool size can be set with the <code class="bold_code"><a href="../erl/#async_thread_pool_size">+A</a></code> command line argument of <code class="bold_code"><a href="../erl/">erl(1)</a></code>. If no async thread pool is available, the call is made synchronously in the thread calling <code class="code">driver_async()</code>. The current number of async threads in the async thread pool can be retrieved via <code class="bold_code"><a href="#driver_system_info">driver_system_info()</a></code>.</p> <p>If there is a thread pool available, a thread will be used. If the <code class="code">key</code> argument is null, the threads from the pool are used in a round-robin way, each call to <code class="code">driver_async</code> uses the next thread in the pool. With the <code class="code">key</code> argument set, this behaviour is changed. The two same values of <code class="code">*key</code> always get the same thread.</p> <p>To make sure that a driver instance always uses the same thread, the following call can be used:</p>  <div class="example"><pre>
unsigned int myKey = driver_async_port_key(myPort);

r = driver_async(myPort, &amp;myKey, myData, myFunc);
    </pre></div> <p>It is enough to initialize <code class="code">myKey</code> once for each driver instance.</p> <p>If a thread is already working, the calls will be queued up and executed in order. Using the same thread for each driver instance ensures that the calls will be made in sequence.</p> <p>The <code class="code">async_data</code> is the argument to the functions <code class="code">async_invoke</code> and <code class="code">async_free</code>. It's typically a pointer to a structure that contains a pipe or event that can be used to signal that the async operation completed. The data should be freed in <code class="code">async_free</code>.</p> <p>When the async operation is done, <code class="bold_code"><a href="../driver_entry/#ready_async">ready_async</a></code> driver entry function is called. If <code class="code">ready_async</code> is null in the driver entry, the <code class="code">async_free</code> function is called instead.</p> <p>The return value is -1 if the <code class="code">driver_async</code> call fails.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>As of erts version 5.5.4.3 the default stack size for threads in the async-thread pool is 16 kilowords, i.e., 64 kilobyte on 32-bit architectures. This small default size has been chosen since the amount of async-threads might be quite large. The default stack size is enough for drivers delivered with Erlang/OTP, but might not be sufficiently large for other dynamically linked in drivers that use the driver_async() functionality. A suggested stack size for threads in the async-thread pool can be configured via the <code class="bold_code"><a href="../erl/#async_thread_stack_size">+a</a></code> command line argument of <code class="bold_code"><a href="../erl/">erl(1)</a></code>.</p> </div> </div>  <h3 id="driver_async_port_key%20" class="code">unsigned int driver_async_port_key (ErlDrvPort port)</h3> 
<p>This function calculates a key for later use in <code class="bold_code"><a href="#driver_async">driver_async()</a></code>. The keys are evenly distributed so that a fair mapping between port id's and async thread id's is achieved.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Before OTP-R16, the actual port id could be used as a key with proper casting, but after the rewrite of the port subsystem, this is no longer the case. With this function, you can achieve the same distribution based on port id's as before OTP-R16.</p> </div> </div>  <h3 id="driver_lock_driver" class="code">int driver_lock_driver(ErlDrvPort port)</h3> 
<p>This function locks the driver used by the port <code class="code">port</code> in memory for the rest of the emulator process' lifetime. After this call, the driver behaves as one of Erlang's statically linked in drivers.</p>  <h3 id="driver_create_port" class="code">ErlDrvPort driver_create_port(ErlDrvPort port, ErlDrvTermData owner_pid, char* name, ErlDrvData drv_data)</h3> 
<p>This function creates a new port executing the same driver code as the port creating the new port. A short description of the arguments:</p> <dl> <dt><strong><code class="code">port</code></strong></dt> <dd>The port handle of the port (driver instance) creating the new port.</dd> <dt><strong><code class="code">owner_pid</code></strong></dt> <dd>The process id of the Erlang process which will be owner of the new port. This process will be linked to the new port. You usually want to use <code class="code">driver_caller(port)</code> as <code class="code">owner_pid</code>.</dd> <dt><strong><code class="code">name</code></strong></dt> <dd>The port name of the new port. You usually want to use the same port name as the driver name (<code class="bold_code"><a href="../driver_entry/#driver_name">driver_name</a></code> field of the <code class="bold_code"><a href="../driver_entry/">driver_entry</a></code>).</dd> <dt><strong><code class="code">drv_data</code></strong></dt> <dd>The driver defined handle that will be passed in subsequent calls to driver call-backs. Note, that the <code class="bold_code"><a href="../driver_entry/#start">driver start call-back</a></code> will not be called for this new driver instance. The driver defined handle is normally created in the <code class="bold_code"><a href="../driver_entry/#start">driver start call-back</a></code> when a port is created via <code class="bold_code"><a href="../erlang/#open_port-2">erlang:open_port/2</a></code>. </dd> </dl> <p>The caller of <code class="code">driver_create_port()</code> is allowed to manipulate the newly created port when <code class="code">driver_create_port()</code> has returned. When <code class="bold_code"><a href="#smp_support">port level locking</a></code> is used, the creating port is, however, only allowed to manipulate the newly created port until the current driver call-back that was called by the emulator returns.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>When <code class="bold_code"><a href="#smp_support">port level locking</a></code> is used, the creating port is only allowed to manipulate the newly created port until the current driver call-back returns.</p> </div> </div>  <h3 id="erl_drv_thread_create" class="code">int erl_drv_thread_create(char *name, ErlDrvTid *tid, void * (*func)(void *), void *arg, ErlDrvThreadOpts *opts)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">name</code></strong></dt> <dd>A string identifying the created thread. It will be used to identify the thread in planned future debug functionality. </dd> <dt><strong><code class="code">tid</code></strong></dt> <dd>A pointer to a thread identifier variable.</dd> <dt><strong><code class="code">func</code></strong></dt> <dd>A pointer to a function to execute in the created thread.</dd> <dt><strong><code class="code">arg</code></strong></dt> <dd>A pointer to argument to the <code class="code">func</code> function.</dd> <dt><strong><code class="code">opts</code></strong></dt> <dd>A pointer to thread options to use or <code class="code">NULL</code>.</dd> </dl> <p>This function creates a new thread. On success <code class="code">0</code> is returned; otherwise, an <code class="code">errno</code> value is returned to indicate the error. The newly created thread will begin executing in the function pointed to by <code class="code">func</code>, and <code class="code">func</code> will be passed <code class="code">arg</code> as argument. When <code class="code">erl_drv_thread_create()</code> returns the thread identifier of the newly created thread will be available in <code class="code">*tid</code>. <code class="code">opts</code> can be either a <code class="code">NULL</code> pointer, or a pointer to an <code class="bold_code"><a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a></code> structure. If <code class="code">opts</code> is a <code class="code">NULL</code> pointer, default options will be used; otherwise, the passed options will be used. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>You are not allowed to allocate the <code class="bold_code"><a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a></code> structure by yourself. It has to be allocated and initialized by <code class="bold_code"><a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create()</a></code>. </p>
</div> </div> <p>The created thread will terminate either when <code class="code">func</code> returns or if <code class="bold_code"><a href="#erl_drv_thread_exit">erl_drv_thread_exit()</a></code> is called by the thread. The exit value of the thread is either returned from <code class="code">func</code> or passed as argument to <code class="bold_code"><a href="#erl_drv_thread_exit">erl_drv_thread_exit()</a></code>. The driver creating the thread has the responsibility of joining the thread, via <code class="bold_code"><a href="#erl_drv_thread_join">erl_drv_thread_join()</a></code>, before the driver is unloaded. It is not possible to create "detached" threads, i.e., threads that don't need to be joined. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>All created threads need to be joined by the driver before it is unloaded. If the driver fails to join all threads created before it is unloaded, the runtime system will most likely crash when the code of the driver is unloaded. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_thread_opts_create" class="code">ErlDrvThreadOpts *erl_drv_thread_opts_create(char *name)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">name</code></strong></dt> <dd>A string identifying the created thread options. It will be used to identify the thread options in planned future debug functionality. </dd> </dl> <p>This function allocates and initialize a thread option structure. On failure <code class="code">NULL</code> is returned. A thread option structure is used for passing options to <code class="bold_code"><a href="#erl_drv_thread_create">erl_drv_thread_create()</a></code>. If the structure isn't modified before it is passed to <code class="bold_code"><a href="#erl_drv_thread_create">erl_drv_thread_create()</a></code>, the default values will be used. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>You are not allowed to allocate the <code class="bold_code"><a href="#ErlDrvThreadOpts">ErlDrvThreadOpts</a></code> structure by yourself. It has to be allocated and initialized by <code class="code">erl_drv_thread_opts_create()</code>. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_thread_opts_destroy" class="code">void erl_drv_thread_opts_destroy(ErlDrvThreadOpts *opts)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">opts</code></strong></dt> <dd>A pointer to thread options to destroy.</dd> </dl> <p>This function destroys thread options previously created by <code class="bold_code"><a href="#erl_drv_thread_opts_create">erl_drv_thread_opts_create()</a></code>. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_thread_exit" class="code">void erl_drv_thread_exit(void *exit_value)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">exit_value</code></strong></dt> <dd>A pointer to an exit value or <code class="code">NULL</code>.</dd> </dl> <p>This function terminates the calling thread with the exit value passed as argument. You are only allowed to terminate threads created with <code class="bold_code"><a href="#erl_drv_thread_create">erl_drv_thread_create()</a></code>. The exit value can later be retrieved by another thread via <code class="bold_code"><a href="#erl_drv_thread_join">erl_drv_thread_join()</a></code>. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_thread_join" class="code">int erl_drv_thread_join(ErlDrvTid tid, void **exit_value)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">tid</code></strong></dt> <dd>The thread identifier of the thread to join.</dd> <dt><strong><code class="code">exit_value</code></strong></dt> <dd>A pointer to a pointer to an exit value, or <code class="code">NULL</code>.</dd> </dl> <p>This function joins the calling thread with another thread, i.e., the calling thread is blocked until the thread identified by <code class="code">tid</code> has terminated. On success <code class="code">0</code> is returned; otherwise, an <code class="code">errno</code> value is returned to indicate the error. A thread can only be joined once. The behavior of joining more than once is undefined, an emulator crash is likely. If <code class="code">exit_value == NULL</code>, the exit value of the terminated thread will be ignored; otherwise, the exit value of the terminated thread will be stored at <code class="code">*exit_value</code>. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_thread_self" class="code">ErlDrvTid erl_drv_thread_self(void)</h3> 
<p>This function returns the thread identifier of the calling thread. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_equal_tids" class="code">int erl_drv_equal_tids(ErlDrvTid tid1, ErlDrvTid tid2)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">tid1</code></strong></dt> <dd>A thread identifier.</dd> <dt><strong><code class="code">tid2</code></strong></dt> <dd>A thread identifier.</dd> </dl> <p>This function compares two thread identifiers for equality, and returns <code class="code">0</code> it they aren't equal, and a value not equal to <code class="code">0</code> if they are equal.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A Thread identifier may be reused very quickly after a thread has terminated. Therefore, if a thread corresponding to one of the involved thread identifiers has terminated since the thread identifier was saved, the result of <code class="code">erl_drv_equal_tids()</code> might not give the expected result. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_mutex_create" class="code">ErlDrvMutex *erl_drv_mutex_create(char *name)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">name</code></strong></dt> <dd>A string identifying the created mutex. It will be used to identify the mutex in planned future debug functionality. </dd> </dl> <p>This function creates a mutex and returns a pointer to it. On failure <code class="code">NULL</code> is returned. The driver creating the mutex has the responsibility of destroying it before the driver is unloaded. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_mutex_destroy" class="code">void erl_drv_mutex_destroy(ErlDrvMutex *mtx)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">mtx</code></strong></dt> <dd>A pointer to a mutex to destroy.</dd> </dl> <p>This function destroys a mutex previously created by <code class="bold_code"><a href="#erl_drv_mutex_create">erl_drv_mutex_create()</a></code>. The mutex has to be in an unlocked state before being destroyed. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_mutex_lock" class="code">void erl_drv_mutex_lock(ErlDrvMutex *mtx)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">mtx</code></strong></dt> <dd>A pointer to a mutex to lock.</dd> </dl> <p>This function locks a mutex. The calling thread will be blocked until the mutex has been locked. A thread which currently has locked the mutex may <strong>not</strong> lock the same mutex again. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will <strong>very likely</strong> deadlock the whole emulator. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_mutex_trylock" class="code">int erl_drv_mutex_trylock(ErlDrvMutex *mtx)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">mtx</code></strong></dt> <dd>A pointer to a mutex to try to lock.</dd> </dl> <p>This function tries to lock a mutex. If successful <code class="code">0</code>, is returned; otherwise, <code class="code">EBUSY</code> is returned. A thread which currently has locked the mutex may <strong>not</strong> try to lock the same mutex again. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will <strong>very likely</strong> deadlock the whole emulator. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_mutex_unlock" class="code">void erl_drv_mutex_unlock(ErlDrvMutex *mtx)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">mtx</code></strong></dt> <dd>A pointer to a mutex to unlock.</dd> </dl> <p>This function unlocks a mutex. The mutex currently has to be locked by the calling thread. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_cond_create" class="code">ErlDrvCond *erl_drv_cond_create(char *name)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">name</code></strong></dt> <dd>A string identifying the created condition variable. It will be used to identify the condition variable in planned future debug functionality. </dd> </dl> <p>This function creates a condition variable and returns a pointer to it. On failure <code class="code">NULL</code> is returned. The driver creating the condition variable has the responsibility of destroying it before the driver is unloaded.</p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_cond_destroy" class="code">void erl_drv_cond_destroy(ErlDrvCond *cnd)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">cnd</code></strong></dt> <dd>A pointer to a condition variable to destroy.</dd> </dl> <p>This function destroys a condition variable previously created by <code class="bold_code"><a href="#erl_drv_cond_create">erl_drv_cond_create()</a></code>. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_cond_signal" class="code">void erl_drv_cond_signal(ErlDrvCond *cnd)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">cnd</code></strong></dt> <dd>A pointer to a condition variable to signal on.</dd> </dl> <p>This function signals on a condition variable. That is, if other threads are waiting on the condition variable being signaled, <strong>one</strong> of them will be woken. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_cond_broadcast" class="code">void erl_drv_cond_broadcast(ErlDrvCond *cnd)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">cnd</code></strong></dt> <dd>A pointer to a condition variable to broadcast on.</dd> </dl> <p>This function broadcasts on a condition variable. That is, if other threads are waiting on the condition variable being broadcast on, <strong>all</strong> of them will be woken. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_cond_wait" class="code">void erl_drv_cond_wait(ErlDrvCond *cnd, ErlDrvMutex *mtx)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">cnd</code></strong></dt> <dd>A pointer to a condition variable to wait on.</dd> <dt><strong><code class="code">mtx</code></strong></dt> <dd>A pointer to a mutex to unlock while waiting.</dd>   </dl> <p>This function waits on a condition variable. The calling thread is blocked until another thread wakes it by signaling or broadcasting on the condition variable. Before the calling thread is blocked it unlocks the mutex passed as argument, and when the calling thread is woken it locks the same mutex before returning. That is, the mutex currently has to be locked by the calling thread when calling this function. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p><code class="code">erl_drv_cond_wait()</code> might return even though no-one has signaled or broadcast on the condition variable. Code calling <code class="code">erl_drv_cond_wait()</code> should always be prepared for <code class="code">erl_drv_cond_wait()</code> returning even though the condition that the thread was waiting for hasn't occurred. That is, when returning from <code class="code">erl_drv_cond_wait()</code> always check if the condition has occurred, and if not call <code class="code">erl_drv_cond_wait()</code> again. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_create" class="code">ErlDrvRWLock *erl_drv_rwlock_create(char *name)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">name</code></strong></dt> <dd>A string identifying the created rwlock. It will be used to identify the rwlock in planned future debug functionality. </dd> </dl> <p>This function creates an rwlock and returns a pointer to it. On failure <code class="code">NULL</code> is returned. The driver creating the rwlock has the responsibility of destroying it before the driver is unloaded. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_destroy" class="code">void erl_drv_rwlock_destroy(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an rwlock to destroy.</dd> </dl> <p>This function destroys an rwlock previously created by <code class="bold_code"><a href="#erl_drv_rwlock_create">erl_drv_rwlock_create()</a></code>. The rwlock has to be in an unlocked state before being destroyed. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_rlock" class="code">void erl_drv_rwlock_rlock(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an rwlock to read lock.</dd> </dl> <p>This function read locks an rwlock. The calling thread will be blocked until the rwlock has been read locked. A thread which currently has read or read/write locked the rwlock may <strong>not</strong> lock the same rwlock again. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will <strong>very likely</strong> deadlock the whole emulator. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_tryrlock" class="code">int erl_drv_rwlock_tryrlock(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an rwlock to try to read lock.</dd> </dl> <p>This function tries to read lock an rwlock. If successful <code class="code">0</code>, is returned; otherwise, <code class="code">EBUSY</code> is returned. A thread which currently has read or read/write locked the rwlock may <strong>not</strong> try to lock the same rwlock again. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will <strong>very likely</strong> deadlock the whole emulator. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_runlock" class="code">void erl_drv_rwlock_runlock(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an rwlock to read unlock.</dd> </dl> <p>This function read unlocks an rwlock. The rwlock currently has to be read locked by the calling thread. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_rwlock" class="code">void erl_drv_rwlock_rwlock(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an rwlock to read/write lock.</dd> </dl> <p>This function read/write locks an rwlock. The calling thread will be blocked until the rwlock has been read/write locked. A thread which currently has read or read/write locked the rwlock may <strong>not</strong> lock the same rwlock again. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will <strong>very likely</strong> deadlock the whole emulator. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_tryrwlock" class="code">int erl_drv_rwlock_tryrwlock(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an rwlock to try to read/write lock.</dd> </dl> <p>This function tries to read/write lock an rwlock. If successful <code class="code">0</code>, is returned; otherwise, <code class="code">EBUSY</code> is returned. A thread which currently has read or read/write locked the rwlock may <strong>not</strong> try to lock the same rwlock again. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will <strong>very likely</strong> deadlock the whole emulator. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_rwlock_rwunlock" class="code">void erl_drv_rwlock_rwunlock(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an rwlock to read/write unlock.</dd> </dl> <p>This function read/write unlocks an rwlock. The rwlock currently has to be read/write locked by the calling thread. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_tsd_key_create" class="code">int erl_drv_tsd_key_create(char *name, ErlDrvTSDKey *key)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">name</code></strong></dt> <dd>A string identifying the created key. It will be used to identify the key in planned future debug functionality. </dd> <dt><strong><code class="code">key</code></strong></dt> <dd>A pointer to a thread specific data key variable.</dd> </dl> <p>This function creates a thread specific data key. On success <code class="code">0</code> is returned; otherwise, an <code class="code">errno</code> value is returned to indicate the error. The driver creating the key has the responsibility of destroying it before the driver is unloaded. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_tsd_key_destroy" class="code">void erl_drv_tsd_key_destroy(ErlDrvTSDKey key)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">key</code></strong></dt> <dd>A thread specific data key to destroy.</dd> </dl> <p>This function destroys a thread specific data key previously created by <code class="bold_code"><a href="#erl_drv_tsd_key_create">erl_drv_tsd_key_create()</a></code>. All thread specific data using this key in all threads have to be cleared (see <code class="bold_code"><a href="#erl_drv_tsd_set">erl_drv_tsd_set()</a></code>) prior to the call to <code class="code">erl_drv_tsd_key_destroy()</code>. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>A destroyed key is very likely to be reused soon. Therefore, if you fail to clear the thread specific data using this key in a thread prior to destroying the key, you will <strong>very likely</strong> get unexpected errors in other parts of the system. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_tsd_set" class="code">void erl_drv_tsd_set(ErlDrvTSDKey key, void *data)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">key</code></strong></dt> <dd>A thread specific data key.</dd> <dt><strong><code class="code">data</code></strong></dt> <dd>A pointer to data to associate with <code class="code">key</code> in calling thread. </dd> </dl> <p>This function sets thread specific data associated with <code class="code">key</code> for the calling thread. You are only allowed to set thread specific data for threads while they are fully under your control. For example, if you set thread specific data in a thread calling a driver call-back function, it has to be cleared, i.e. set to <code class="code">NULL</code>, before returning from the driver call-back function. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>If you fail to clear thread specific data in an emulator thread before letting it out of your control, you might not ever be able to clear this data with later unexpected errors in other parts of the system as a result. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_tsd_get" class="code">void *erl_drv_tsd_get(ErlDrvTSDKey key)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">key</code></strong></dt> <dd>A thread specific data key.</dd> </dl> <p>This function returns the thread specific data associated with <code class="code">key</code> for the calling thread. If no data has been associated with <code class="code">key</code> for the calling thread, <code class="code">NULL</code> is returned. </p> <p>This function is thread-safe.</p>  <h3 id="erl_drv_putenv" class="code">int erl_drv_putenv(const char *key, char *value)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">key</code></strong></dt> <dd>A null terminated string containing the name of the environment variable.</dd> <dt><strong><code class="code">value</code></strong></dt> <dd>A null terminated string containing the new value of the environment variable.</dd> </dl> <p>This function sets the value of an environment variable. It returns <code class="code">0</code> on success, and a value <code class="code">!= 0</code> on failure. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The result of passing the empty string ("") as a value is platform dependent. On some platforms the value of the variable is set to the empty string, on others, the environment variable is removed.</p> </div> </div> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Do <strong>not</strong> use libc's <code class="code">putenv</code> or similar C library interfaces from a driver. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_getenv" class="code">int erl_drv_getenv(const char *key, char *value, size_t *value_size)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">key</code></strong></dt> <dd>A null terminated string containing the name of the environment variable.</dd> <dt><strong><code class="code">value</code></strong></dt> <dd>A pointer to an output buffer.</dd> <dt><strong><code class="code">value_size</code></strong></dt> <dd>A pointer to an integer. The integer is both used for passing input and output sizes (see below). </dd> </dl> <p>This function retrieves the value of an environment variable. When called, <code class="code">*value_size</code> should contain the size of the <code class="code">value</code> buffer. On success <code class="code">0</code> is returned, the value of the environment variable has been written to the <code class="code">value</code> buffer, and <code class="code">*value_size</code> contains the string length (excluding the terminating null character) of the value written to the <code class="code">value</code> buffer. On failure, i.e., no such environment variable was found, a value less than <code class="code">0</code> is returned. When the size of the <code class="code">value</code> buffer is too small, a value greater than <code class="code">0</code> is returned and <code class="code">*value_size</code> has been set to the buffer size needed. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Do <strong>not</strong> use libc's <code class="code">getenv</code> or similar C library interfaces from a driver. </p>
</div> </div> <p>This function is thread-safe.</p>  <h3 id="erl_drv_consume_timeslice" class="code">int erl_drv_consume_timeslice(ErlDrvPort port, int percent)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">port</code></strong></dt> <dd>Port handle of the executing port.</dd> <dt><strong><code class="code">percent</code></strong></dt> <dd>Approximate consumed fraction of a full time-slice in percent.</dd> </dl> <p>Give the runtime system a hint about how much CPU time the current driver callback call has consumed since last hint, or since the start of the callback if no previous hint has been given. The time is given as a fraction, in percent, of a full time-slice that a port is allowed to execute before it should surrender the CPU to other runnable ports or processes. Valid range is <code class="code">[1, 100]</code>. The scheduling time-slice is not an exact entity, but can usually be approximated to about 1 millisecond.</p> <p>Note that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms may use other means in order to determine the consumed fraction of the time-slice. Lengthy driver callbacks should regardless of this frequently call the <code class="code">erl_drv_consume_timeslice()</code> function in order to determine if it is allowed to continue execution or not.</p> <p><code class="code">erl_drv_consume_timeslice()</code> returns a non-zero value if the time-slice has been exhausted, and zero if the callback is allowed to continue execution. If a non-zero value is returned the driver callback should return as soon as possible in order for the port to be able to yield.</p> <p>This function is provided to better support co-operative scheduling, improve system responsiveness, and to make it easier to prevent misbehaviors of the VM due to a port monopolizing a scheduler thread. It can be used when dividing length work into a number of repeated driver callback calls without the need to use threads. Also see the important <code class="bold_code"><a href="#WARNING">warning</a></code> text at the beginning of this document.</p>  <h3 id="erl_drv_cond_name" class="code">char *erl_drv_cond_name(ErlDrvCond *cnd)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">cnd</code></strong></dt> <dd>A pointer to an initialized condition.</dd> </dl> <p> Returns a pointer to the name of the condition. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is intended for debugging purposes only.</p> </div> </div>  <h3 id="erl_drv_mutex_name" class="code">char *erl_drv_mutex_name(ErlDrvMutex *mtx)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">mtx</code></strong></dt> <dd>A pointer to an initialized mutex.</dd> </dl> <p> Returns a pointer to the name of the mutex. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is intended for debugging purposes only.</p> </div> </div>  <h3 id="erl_drv_rwlock_name" class="code">char *erl_drv_rwlock_name(ErlDrvRWLock *rwlck)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">rwlck</code></strong></dt> <dd>A pointer to an initialized r/w-lock.</dd> </dl> <p> Returns a pointer to the name of the r/w-lock. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is intended for debugging purposes only.</p> </div> </div>  <h3 id="erl_drv_thread_name" class="code">char *erl_drv_thread_name(ErlDrvTid tid)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">tid</code></strong></dt> <dd>A thread identifier.</dd> </dl> <p> Returns a pointer to the name of the thread. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is intended for debugging purposes only.</p> </div> </div>  <h3 id="erl_drv_monotonic_time" class="code">ErlDrvTime erl_drv_monotonic_time(ErlDrvTimeUnit time_unit)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">time_unit</code></strong></dt> <dd>Time unit of returned value.</dd> </dl> <p> Returns <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code>. Note that it is not uncommon with negative values. </p> <p>Returns <code class="code">ERL_DRV_TIME_ERROR</code> if called with an invalid time unit argument, or if called from a thread that is not a scheduler thread.</p> <p>See also:</p> <ul> <li><code class="bold_code"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></code></li> </ul>  <h3 id="erl_drv_time_offset" class="code">ErlDrvTime erl_drv_time_offset(ErlDrvTimeUnit time_unit)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">time_unit</code></strong></dt> <dd>Time unit of returned value.</dd> </dl> <p>Returns the current time offset between <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code> converted into the <code class="code">time_unit</code> passed as argument.</p> <p>Returns <code class="code">ERL_DRV_TIME_ERROR</code> if called with an invalid time unit argument, or if called from a thread that is not a scheduler thread.</p> <p>See also:</p> <ul> <li><code class="bold_code"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></code></li> </ul>  <h3 id="erl_drv_convert_time_unit" class="code">ErlDrvTime erl_drv_convert_time_unit(ErlDrvTime val, ErlDrvTimeUnit from, ErlDrvTimeUnit to)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">val</code></strong></dt> <dd>Value to convert time unit for.</dd> <dt><strong><code class="code">from</code></strong></dt> <dd>Time unit of <code class="code">val</code>.</dd> <dt><strong><code class="code">to</code></strong></dt> <dd>Time unit of returned value.</dd> </dl> <p>Converts the <code class="code">val</code> value of time unit <code class="code">from</code> to the corresponding value of time unit <code class="code">to</code>. The result is rounded using the floor function.</p> <p>Returns <code class="code">ERL_DRV_TIME_ERROR</code> if called with an invalid time unit argument.</p> <p>See also:</p> <ul> <li><code class="bold_code"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></code></li> </ul>  <h2 id="id193987">See also</h2>  <p><code class="bold_code"><a href="../driver_entry/">driver_entry(3)</a></code>, <code class="bold_code">erl_ddll(3)</code>, <code class="bold_code"><a href="../erlang/">erlang(3)</a></code></p> <p>An Alternative Distribution Driver (ERTS User's Guide Ch. 3)</p>
<div class="_attribution">
  <p class="_attribution-p">
     19992016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
