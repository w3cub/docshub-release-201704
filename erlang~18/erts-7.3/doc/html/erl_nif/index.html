
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Erl_nif - Erlang 18 - W3cubDocs</title>
  
  <meta name="description" content=" erl_nif ">
  <meta name="keywords" content="erl, nif, -, erlang, erlang~18">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~18/erts-7.3/doc/html/erl_nif/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/erlang~18.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~18/" class="_nav-link" title="" style="margin-left:0;">Erlang 18</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>erl_nif</h1> <h2>C library</h2> <p class="REFBODY">erl_nif</p> <h2>Library summary</h2> <p class="REFBODY">API functions for an Erlang NIF library</p> <h2>Description</h2> 
<p>A NIF library contains native implementation of some functions of an Erlang module. The native implemented functions (NIFs) are called like any other functions without any difference to the caller. Each NIF must also have an implementation in Erlang that will be invoked if the function is called before the NIF library has been successfully loaded. A typical such stub implementation is to throw an exception. But it can also be used as a fallback implementation if the NIF library is not implemented for some architecture.</p>  <div class="warning"> <div class="label">Warning</div> <div class="content">

<p><strong>Use this functionality with extreme care!</strong></p> <p>A native function is executed as a direct extension of the native code of the VM. Execution is not made in a safe environment. The VM can <strong>not</strong> provide the same services as provided when executing Erlang code, such as preemptive scheduling or memory protection. If the native function doesn't behave well, the whole VM will misbehave.</p> <ul> <li><p>A native function that crash will crash the whole VM.</p></li> <li><p>An erroneously implemented native function might cause a VM internal state inconsistency which may cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call to the native function.</p></li> <li><p>A native function that do <code class="bold_code"><a href="#lengthy_work">lengthy work</a></code> before returning will degrade responsiveness of the VM, and may cause miscellaneous strange behaviors. Such strange behaviors include, but are not limited to, extreme memory usage, and bad load balancing between schedulers. Strange behaviors that might occur due to lengthy work may also vary between OTP releases.</p></li> </ul> </div> </div> <p>A minimal example of a NIF library can look like this:</p>  <div class="example"><pre>
/* niftest.c */
#include "erl_nif.h"

static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    return enif_make_string(env, "Hello world!", ERL_NIF_LATIN1);
}

static ErlNifFunc nif_funcs[] =
{
    {"hello", 0, hello}
};

ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL)
</pre></div> <p>and the Erlang module would have to look something like this:</p>  <div class="example"><pre>
-module(niftest).

-export([init/0, hello/0]).

init() -&gt;
      erlang:load_nif("./niftest", 0).

hello() -&gt;
      "NIF library not loaded".
</pre></div> <p>and compile and test something like this (on Linux):</p>  <div class="example"><pre>
$&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
$&gt; erl

1&gt; c(niftest).
{ok,niftest}
2&gt; niftest:hello().
"NIF library not loaded"
3&gt; niftest:init().
ok
4&gt; niftest:hello().
"Hello world!"
</pre></div> <p>A better solution for a real module is to take advantage of the new directive <code class="bold_code">on_load</code> to automatically load the NIF library when the module is loaded.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A NIF does not have to be exported, it can be local to the module. Note however that unused local stub functions will be optimized away by the compiler causing loading of the NIF library to fail.</p> </div> </div> <p>A loaded NIF library is tied to the Erlang module code version that loaded it. If the module is upgraded with a new version, the new Erlang code will have to load its own NIF library (or maybe choose not to). The new code version can however choose to load the exact same NIF library as the old code if it wants to. Sharing the same dynamic library will mean that static data defined by the library will be shared as well. To avoid unintentionally shared static data, each Erlang module code can keep its own private data. This private data can be set when the NIF library is loaded and then retrieved by calling <code class="bold_code"><a href="#enif_priv_data">enif_priv_data</a></code>.</p> <p>There is no way to explicitly unload a NIF library. A library will be automatically unloaded when the module code that it belongs to is purged by the code server.</p> <p id="lengthy_work"> As mentioned in the <code class="bold_code"><a href="#WARNING">warning</a></code> text at the beginning of this document it is of vital importance that a native function return relatively quickly. It is hard to give an exact maximum amount of time that a native function is allowed to work, but as a rule of thumb a well-behaving native function should return to its caller before a millisecond has passed. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times, either directly from Erlang code or by having a native function schedule a future NIF call via the <code class="bold_code"><a href="#enif_schedule_nif"> enif_schedule_nif</a></code> function. Function <code class="bold_code"><a href="#enif_consume_timeslice">enif_consume_timeslice</a></code> can be used to help with such work division. In some cases, however, this might not be possible, e.g. when calling third-party libraries. Then you typically want to dispatch the work to another thread, return from the native function, and wait for the result. The thread can send the result back to the calling thread using message passing. Information about thread primitives can be found below. If you have built your system with <strong>the currently experimental</strong> support for dirty schedulers, you may want to try out this functionality by dispatching the work to a <code class="bold_code"><a href="#dirty_nifs">dirty NIF</a></code>, which does not have the same duration restriction as a normal NIF.</p>  <h2 id="id197653">Functionality</h2>  <p>All functions that a NIF library needs to do with Erlang are performed through the NIF API functions. There are functions for the following functionality:</p> <dl> <dt><strong>Read and write Erlang terms</strong></dt> <dd> <p>Any Erlang terms can be passed to a NIF as function arguments and be returned as function return values. The terms are of C-type <code class="bold_code"><a href="#ERL_NIF_TERM">ERL_NIF_TERM</a></code> and can only be read or written using API functions. Most functions to read the content of a term are prefixed <code class="code">enif_get_</code> and usually return true (or false) if the term was of the expected type (or not). The functions to write terms are all prefixed <code class="code">enif_make_</code> and usually return the created <code class="code">ERL_NIF_TERM</code>. There are also some functions to query terms, like <code class="code">enif_is_atom</code>, <code class="code">enif_is_identical</code> and <code class="code">enif_compare</code>.</p> <p>All terms of type <code class="code">ERL_NIF_TERM</code> belong to an environment of type <code class="bold_code"><a href="#ErlNifEnv">ErlNifEnv</a></code>. The lifetime of a term is controlled by the lifetime of its environment object. All API functions that read or write terms has the environment, that the term belongs to, as the first function argument.</p> </dd> <dt><strong>Binaries</strong></dt> <dd> <p>Terms of type binary are accessed with the help of the struct type <code class="bold_code"><a href="#ErlNifBinary">ErlNifBinary</a></code> that contains a pointer (<code class="code">data</code>) to the raw binary data and the length (<code class="code">size</code>) of the data in bytes. Both <code class="code">data</code> and <code class="code">size</code> are read-only and should only be written using calls to API functions. Instances of <code class="code">ErlNifBinary</code> are however always allocated by the user (usually as local variables).</p> <p>The raw data pointed to by <code class="code">data</code> is only mutable after a call to <code class="bold_code"><a href="#enif_alloc_binary">enif_alloc_binary</a></code> or <code class="bold_code"><a href="#enif_realloc_binary">enif_realloc_binary</a></code>. All other functions that operates on a binary will leave the data as read-only. A mutable binary must in the end either be freed with <code class="bold_code"><a href="#enif_release_binary">enif_release_binary</a></code> or made read-only by transferring it to an Erlang term with <code class="bold_code"><a href="#enif_make_binary">enif_make_binary</a></code>. But it does not have to happen in the same NIF call. Read-only binaries do not have to be released.</p> <p><code class="bold_code"><a href="#enif_make_new_binary">enif_make_new_binary</a></code> can be used as a shortcut to allocate and return a binary in the same NIF call.</p> <p>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</p> </dd> <dt><strong>Resource objects</strong></dt> <dd id="enif_resource_example"> <p>The use of resource objects is a safe way to return pointers to native data structures from a NIF. A resource object is just a block of memory allocated with <code class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></code>. A handle ("safe pointer") to this memory block can then be returned to Erlang by the use of <code class="bold_code"><a href="#enif_make_resource">enif_make_resource</a></code>. The term returned by <code class="code">enif_make_resource</code> is totally opaque in nature. It can be stored and passed between processes on the same node, but the only real end usage is to pass it back as an argument to a NIF. The NIF can then call <code class="bold_code"><a href="#enif_get_resource">enif_get_resource</a></code> and get back a pointer to the memory block that is guaranteed to still be valid. A resource object will not be deallocated until the last handle term has been garbage collected by the VM and the resource has been released with <code class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></code> (not necessarily in that order).</p> <p>All resource objects are created as instances of some <strong>resource type</strong>. This makes resources from different modules to be distinguishable. A resource type is created by calling <code class="bold_code"><a href="#enif_open_resource_type">enif_open_resource_type</a></code> when a library is loaded. Objects of that resource type can then later be allocated and <code class="code">enif_get_resource</code> verifies that the resource is of the expected type. A resource type can have a user supplied destructor function that is automatically called when resources of that type are released (by either the garbage collector or <code class="code">enif_release_resource</code>). Resource types are uniquely identified by a supplied name string and the name of the implementing module.</p> <p>Here is a template example of how to create and return a resource object.</p>  <div class="example"><pre>
ERL_NIF_TERM term;
MyStruct* obj = enif_alloc_resource(my_resource_type, sizeof(MyStruct));

/* initialize struct ... */

term = enif_make_resource(env, obj);

if (keep_a_reference_of_our_own) {
    /* store 'obj' in static variable, private data or other resource object */
}
else {
    enif_release_resource(obj);
    /* resource now only owned by "Erlang" */
}
return term;
</pre></div> <p>Note that once <code class="code">enif_make_resource</code> creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely solely on the garbage collector to eventually deallocate the resource object when it collects the term.</p> <p>Another usage of resource objects is to create binary terms with user defined memory management. <code class="bold_code"><a href="#enif_make_resource_binary">enif_make_resource_binary</a></code> will create a binary term that is connected to a resource object. The destructor of the resource will be called when the binary is garbage collected, at which time the binary data can be released. An example of this can be a binary term consisting of data from a <code class="code">mmap</code>'ed file. The destructor can then do <code class="code">munmap</code> to release the memory region.</p> <p>Resource types support upgrade in runtime by allowing a loaded NIF library to takeover an already existing resource type and thereby "inherit" all existing objects of that type. The destructor of the new library will thereafter be called for the inherited objects and the library with the old destructor function can be safely unloaded. Existing resource objects, of a module that is upgraded, must either be deleted or taken over by the new NIF library. The unloading of a library will be postponed as long as there exist resource objects with a destructor function in the library. </p> </dd> <dt><strong>Threads and concurrency</strong></dt> <dd> <p>A NIF is thread-safe without any explicit synchronization as long as it acts as a pure function and only reads the supplied arguments. As soon as you write towards a shared state either through static variables or <code class="bold_code"><a href="#enif_priv_data">enif_priv_data</a></code> you need to supply your own explicit synchronization. This includes terms in process independent environments that are shared between threads. Resource objects will also require synchronization if you treat them as mutable.</p> <p>The library initialization callbacks <code class="code">load</code>, <code class="code">reload</code> and <code class="code">upgrade</code> are all thread-safe even for shared state data.</p> </dd> <dt><strong id="version_management">Version Management</strong></dt> <dd> <p> When a NIF library is built, information about NIF API version is compiled into the library. When a NIF library is loaded the runtime system verifies that the library is of a compatible version. <code class="code">erl_nif.h</code> defines <code class="code">ERL_NIF_MAJOR_VERSION</code>, and <code class="code">ERL_NIF_MINOR_VERSION</code>. <code class="code">ERL_NIF_MAJOR_VERSION</code> will be incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it will suffice to recompile the NIF library when the <code class="code">ERL_NIF_MAJOR_VERSION</code> has changed, but it could, under rare circumstances, mean that NIF libraries have to be slightly modified. If so, this will of course be documented. <code class="code">ERL_NIF_MINOR_VERSION</code> will be incremented when new features are added. The runtime system uses the minor version to determine what features to use. </p> <p> The runtime system will normally refuse to load a NIF library if the major versions differ, or if the major versions are equal and the minor version used by the NIF library is greater than the one used by the runtime system. Old NIF libraries with lower major versions will however be allowed after a bump of the major version during a transition period of two major releases. Such old NIF libraries might however fail if deprecated features are used. </p> </dd> <dt><strong id="time_measurement">Time Measurement</strong></dt> <dd> <p>Support for time measurement in NIF libraries: </p>
<ul> <li><code class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code></li> <li><code class="bold_code"><a href="#enif_monotonic_time"><span class="code">enif_monotonic_time()</span></a></code></li> <li><code class="bold_code"><a href="#enif_time_offset"><span class="code">enif_time_offset()</span></a></code></li> <li><code class="bold_code"><a href="#enif_convert_time_unit"><span class="code">enif_convert_time_unit()</span></a></code></li> </ul> </dd> <dt><strong>Long-running NIFs</strong></dt> <dd> <p id="dirty_nifs">Native functions <code class="bold_code"><a href="#lengthy_work"> must normally run quickly</a></code>, as explained earlier in this document. They generally should execute for no more than a millisecond. But not all native functions can execute so quickly; for example, functions that encrypt large blocks of data or perform lengthy file system operations can often run for tens of seconds or more.</p> <p>If the functionality of a long-running NIF can be split so that its work can be achieved through a series of shorter NIF calls, the application can either make that series of NIF calls from the Erlang level, or it can call a NIF that first performs a chunk of the work, then invokes the <code class="bold_code"><a href="#enif_schedule_nif">enif_schedule_nif</a></code> function to schedule another NIF call to perform the next chunk. The final call scheduled in this manner can then return the overall result. Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs, thereby avoiding degraded responsiveness, scheduler load balancing problems, and other strange behaviours.</p> <p>A NIF that cannot be split and cannot execute in a millisecond or less is called a "dirty NIF" because it performs work that the Erlang runtime cannot handle cleanly. <strong>Note that the dirty NIF functionality described here is experimental</strong> and that you have to enable support for dirty schedulers when building OTP in order to try the functionality out. Applications that make use of such functions must indicate to the runtime that the functions are dirty so they can be handled specially. To schedule a dirty NIF for execution, the appropriate flags value can be set for the NIF in its <code class="bold_code"><a href="#ErlNifFunc">ErlNifFunc</a></code> entry, or the application can call <code class="bold_code"><a href="#enif_schedule_nif">enif_schedule_nif</a></code>, passing to it a pointer to the dirty NIF to be executed and indicating with the <code class="code">flags</code> argument whether it expects the operation to be CPU-bound or I/O-bound.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Dirty NIF support is available only when the emulator is configured with dirty schedulers enabled. This feature is currently disabled by default. To determine whether the dirty NIF API is available, native code can check to see if the C preprocessor macro <code class="code">ERL_NIF_DIRTY_SCHEDULER_SUPPORT</code> is defined. Also, if the Erlang runtime was built without threading support, dirty schedulers are disabled. To check at runtime for the presence of dirty scheduler threads, code can use the <code class="bold_code"><a href="#enif_system_info"><span class="code"> enif_system_info()</span></a></code> API function.</p>
</div> </div> </dd> </dl>  <h2 id="id198164">Initialization</h2>  <dl> <dt><strong id="ERL_NIF_INIT">ERL_NIF_INIT(MODULE, ErlNifFunc funcs[], load, reload, upgrade, unload)</strong></dt> <dd> <p>This is the magic macro to initialize a NIF library. It should be evaluated in global file scope.</p> <p><code class="code">MODULE</code> is the name of the Erlang module as an identifier without string quotations. It will be stringified by the macro.</p> <p><code class="code">funcs</code> is a static array of function descriptors for all the implemented NIFs in this library.</p> <p><code class="code">load</code>, <code class="code">reload</code>, <code class="code">upgrade</code> and <code class="code">unload</code> are pointers to functions. One of <code class="code">load</code>, <code class="code">reload</code> or <code class="code">upgrade</code> will be called to initialize the library. <code class="code">unload</code> is called to release the library. They are all described individually below.</p> <p>If compiling a nif for static inclusion via --enable-static-nifs you have to define STATIC_ERLANG_NIF before the ERL_NIF_INIT declaration.</p> </dd> <dt><strong id="load">int (*load)(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)</strong></dt> <dd> <p><code class="code">load</code> is called when the NIF library is loaded and there is no previously loaded library for this module.</p> <p><code class="code">*priv_data</code> can be set to point to some private data that the library needs in order to keep a state between NIF calls. <code class="code">enif_priv_data</code> will return this pointer. <code class="code">*priv_data</code> will be initialized to NULL when <code class="code">load</code> is called.</p> <p><code class="code">load_info</code> is the second argument to <code class="bold_code"><a href="../erlang/#load_nif-2">erlang:load_nif/2</a></code>.</p> <p>The library will fail to load if <code class="code">load</code> returns anything other than 0. <code class="code">load</code> can be NULL in case no initialization is needed.</p> </dd> <dt><strong id="upgrade">int (*upgrade)(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info)</strong></dt> <dd> <p><code class="code">upgrade</code> is called when the NIF library is loaded and there is old code of this module with a loaded NIF library.</p> <p>Works the same as <code class="code">load</code>. The only difference is that <code class="code">*old_priv_data</code> already contains the value set by the last call to <code class="code">load</code> or <code class="code">reload</code> for the old module code. <code class="code">*priv_data</code> will be initialized to NULL when <code class="code">upgrade</code> is called. It is allowed to write to both *priv_data and *old_priv_data.</p> <p>The library will fail to load if <code class="code">upgrade</code> returns anything other than 0 or if <code class="code">upgrade</code> is NULL.</p> </dd> <dt><strong id="unload">void (*unload)(ErlNifEnv* env, void* priv_data)</strong></dt> <dd> <p><code class="code">unload</code> is called when the module code that the NIF library belongs to is purged as old. New code of the same module may or may not exist. Note that <code class="code">unload</code> is not called for a replaced library as a consequence of <code class="code">reload</code>.</p> </dd> <dt><strong id="reload">int (*reload)(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)</strong></dt> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The reload mechanism is <strong>deprecated</strong>. It was only intended as a development feature. Do not use it as an upgrade method for live production systems. It might be removed in future releases. Be sure to pass <code class="code">reload</code> as <code class="code">NULL</code> to <code class="bold_code"><a href="#ERL_NIF_INIT">ERL_NIF_INIT</a></code> to disable it when not used.</p> </div> </div> <dd> <p><code class="code">reload</code> is called when the NIF library is loaded and there is already a previously loaded library for this module code.</p> <p>Works the same as <code class="code">load</code>. The only difference is that <code class="code">*priv_data</code> already contains the value set by the previous call to <code class="code">load</code> or <code class="code">reload</code>.</p> <p>The library will fail to load if <code class="code">reload</code> returns anything other than 0 or if <code class="code">reload</code> is NULL.</p> </dd> </dl>  <h2 id="id198455">Data types</h2>  <dl> <dt><strong id="ERL_NIF_TERM">ERL_NIF_TERM</strong></dt> <dd> <p>Variables of type <code class="code">ERL_NIF_TERM</code> can refer to any Erlang term. This is an opaque type and values of it can only by used either as arguments to API functions or as return values from NIFs. All <code class="code">ERL_NIF_TERM</code>'s belong to an environment (<code class="bold_code"><a href="#ErlNifEnv">ErlNifEnv</a></code>). A term can not be destructed individually, it is valid until its environment is destructed.</p> </dd> <dt><strong id="ErlNifEnv">ErlNifEnv</strong></dt> <dd> <p><code class="code">ErlNifEnv</code> represents an environment that can host Erlang terms. All terms in an environment are valid as long as the environment is valid. <code class="code">ErlNifEnv</code> is an opaque type and pointers to it can only be passed on to API functions. There are two types of environments; process bound and process independent.</p> <p>A <strong>process bound environment</strong> is passed as the first argument to all NIFs. All function arguments passed to a NIF will belong to that environment. The return value from a NIF must also be a term belonging to the same environment. In addition a process bound environment contains transient information about the calling Erlang process. The environment is only valid in the thread where it was supplied as argument until the NIF returns. It is thus useless and dangerous to store pointers to process bound environments between NIF calls. </p> <p>A <strong>process independent environment</strong> is created by calling <code class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></code>. It can be used to store terms between NIF calls and to send terms with <code class="bold_code"><a href="#enif_send">enif_send</a></code>. A process independent environment with all its terms is valid until you explicitly invalidates it with <code class="bold_code"><a href="#enif_free_env">enif_free_env</a></code> or <code class="code">enif_send</code>.</p> <p>All contained terms of a list/tuple/map must belong to the same environment as the list/tuple/map itself. Terms can be copied between environments with <code class="bold_code"><a href="#enif_make_copy">enif_make_copy</a></code>.</p> </dd> <dt><strong id="ErlNifFunc">ErlNifFunc</strong></dt> <dd>  <div class="example"><pre>
typedef struct {
    const char* name;
    unsigned arity;
    ERL_NIF_TERM (*fptr)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
    unsigned flags;
} ErlNifFunc;
</pre></div> <p>Describes a NIF by its name, arity and implementation. <code class="code">fptr</code> is a pointer to the function that implements the NIF. The argument <code class="code">argv</code> of a NIF will contain the function arguments passed to the NIF and <code class="code">argc</code> is the length of the array, i.e. the function arity. <code class="code">argv[N-1]</code> will thus denote the Nth argument to the NIF. Note that the <code class="code">argc</code> argument allows for the same C function to implement several Erlang functions with different arity (but same name probably). For a regular NIF, <code class="code">flags</code> is 0 (and so its value can be omitted for statically initialized <code class="code">ErlNifFunc</code> instances), or it can be used to indicate that the NIF is a <code class="bold_code"><a href="#dirty_nifs">dirty NIF</a></code> that should be executed on a dirty scheduler thread (<strong>note that the dirty NIF functionality described here is experimental</strong> and that you have to enable support for dirty schedulers when building OTP in order to try the functionality out). If the dirty NIF is expected to be CPU-bound, its <code class="code">flags</code> field should be set to <code class="code">ERL_NIF_DIRTY_JOB_CPU_BOUND</code>, or for I/O-bound jobs, <code class="code">ERL_NIF_DIRTY_JOB_IO_BOUND</code>.</p> </dd> <dt><strong id="ErlNifBinary">ErlNifBinary</strong></dt> <dd>  <div class="example"><pre>
typedef struct {
    unsigned size;
    unsigned char* data;
} ErlNifBinary;
</pre></div> <p><code class="code">ErlNifBinary</code> contains transient information about an inspected binary term. <code class="code">data</code> is a pointer to a buffer of <code class="code">size</code> bytes with the raw content of the binary.</p> <p>Note that <code class="code">ErlNifBinary</code> is a semi-opaque type and you are only allowed to read fields <code class="code">size</code> and <code class="code">data</code>.</p> </dd> <dt><strong id="ErlNifPid">ErlNifPid</strong></dt> <dd> <p><code class="code">ErlNifPid</code> is a process identifier (pid). In contrast to pid terms (instances of <code class="code">ERL_NIF_TERM</code>), <code class="code">ErlNifPid</code>'s are self contained and not bound to any <code class="bold_code"><a href="#ErlNifEnv">environment</a></code>. <code class="code">ErlNifPid</code> is an opaque type.</p> </dd> <dt><strong id="ErlNifResourceType">ErlNifResourceType</strong></dt> <dd> <p>Each instance of <code class="code">ErlNifResourceType</code> represent a class of memory managed resource objects that can be garbage collected. Each resource type has a unique name and a destructor function that is called when objects of its type are released.</p> </dd> <dt><strong id="ErlNifResourceDtor">ErlNifResourceDtor</strong></dt> <dd>  <div class="example"><pre>
typedef void ErlNifResourceDtor(ErlNifEnv* env, void* obj);
</pre></div> <p>The function prototype of a resource destructor function. A destructor function is not allowed to call any term-making functions.</p> </dd> <dt><strong id="ErlNifCharEncoding">ErlNifCharEncoding</strong></dt> <dd>  <div class="example"><pre>
typedef enum {
    ERL_NIF_LATIN1
}ErlNifCharEncoding;
</pre></div> <p>The character encoding used in strings and atoms. The only supported encoding is currently <code class="code">ERL_NIF_LATIN1</code> for iso-latin-1 (8-bit ascii).</p> </dd> <dt><strong id="ErlNifSysInfo">ErlNifSysInfo</strong></dt> <dd> <p>Used by <code class="bold_code"><a href="#enif_system_info">enif_system_info</a></code> to return information about the runtime system. Contains currently the exact same content as <code class="bold_code"><a href="../erl_driver/#ErlDrvSysInfo">ErlDrvSysInfo</a></code>.</p> </dd> <dt><strong id="ErlNifSInt64">ErlNifSInt64</strong></dt> <dd><p>A native signed 64-bit integer type.</p></dd> <dt><strong id="ErlNifUInt64">ErlNifUInt64</strong></dt> <dd><p>A native unsigned 64-bit integer type.</p></dd> <dt><strong id="ErlNifTime">ErlNifTime</strong></dt> <dd> <p>A signed 64-bit integer type for representation of time.</p> </dd> <dt><strong id="ErlNifTimeUnit">ErlNifTimeUnit</strong></dt> <dd> <p>An enumeration of time units supported by the NIF API:</p> <dl> <dt><strong><code class="code">ERL_NIF_SEC</code></strong></dt> <dd><p>Seconds</p></dd> <dt><strong><code class="code">ERL_NIF_MSEC</code></strong></dt> <dd><p>Milliseconds</p></dd> <dt><strong><code class="code">ERL_NIF_USEC</code></strong></dt> <dd><p>Microseconds</p></dd> <dt><strong><code class="code">ERL_NIF_NSEC</code></strong></dt> <dd><p>Nanoseconds</p></dd> </dl> </dd> </dl>  <h2>Exports</h2> <h3 id="enif_alloc" class="code">void *enif_alloc(size_t size)</h3> 
<p>Allocate memory of <code class="code">size</code> bytes. Return NULL if allocation failed.</p> <h3 id="enif_alloc_binary" class="code">int enif_alloc_binary(size_t size, ErlNifBinary* bin)</h3> 
<p>Allocate a new binary of size <code class="code">size</code> bytes. Initialize the structure pointed to by <code class="code">bin</code> to refer to the allocated binary. The binary must either be released by <code class="bold_code"><a href="#enif_release_binary">enif_release_binary</a></code> or ownership transferred to an Erlang term with <code class="bold_code"><a href="#enif_make_binary">enif_make_binary</a></code>. An allocated (and owned) <code class="code">ErlNifBinary</code> can be kept between NIF calls.</p> <p>Return true on success or false if allocation failed.</p>  <h3 id="enif_alloc_env" class="code">ErlNifEnv *enif_alloc_env()</h3> 
<p>Allocate a new process independent environment. The environment can be used to hold terms that is not bound to any process. Such terms can later be copied to a process environment with <code class="bold_code"><a href="#enif_make_copy">enif_make_copy</a></code> or be sent to a process as a message with <code class="bold_code"><a href="#enif_send">enif_send</a></code>.</p> <p>Return pointer to the new environment.</p>  <h3 id="enif_alloc_resource" class="code">void *enif_alloc_resource(ErlNifResourceType* type, unsigned size)</h3> 
<p>Allocate a memory managed resource object of type <code class="code">type</code> and size <code class="code">size</code> bytes.</p> <h3 id="enif_clear_env" class="code">void enif_clear_env(ErlNifEnv* env)</h3> 
<p>Free all terms in an environment and clear it for reuse. The environment must have been allocated with <code class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></code>. </p> <h3 id="enif_compare" class="code">int enif_compare(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs)</h3> 
<p>Return an integer less than, equal to, or greater than zero if <code class="code">lhs</code> is found, respectively, to be less than, equal, or greater than <code class="code">rhs</code>. Corresponds to the Erlang operators <code class="code">==</code>, <code class="code">/=</code>, <code class="code">=&lt;</code>, <code class="code">&lt;</code>, <code class="code">&gt;=</code> and <code class="code">&gt;</code> (but <strong>not</strong> <code class="code">=:=</code> or <code class="code">=/=</code>).</p> <h3 id="enif_cond_broadcast" class="code">void enif_cond_broadcast(ErlNifCond *cnd)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_cond_broadcast">erl_drv_cond_broadcast</a></code>. </p> <h3 id="enif_cond_create" class="code">ErlNifCond *enif_cond_create(char *name)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_cond_create">erl_drv_cond_create</a></code>. </p> <h3 id="enif_cond_destroy" class="code">void enif_cond_destroy(ErlNifCond *cnd)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_cond_destroy">erl_drv_cond_destroy</a></code>. </p> <h3 id="enif_cond_signal" class="code">void enif_cond_signal(ErlNifCond *cnd)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_cond_signal">erl_drv_cond_signal</a></code>. </p> <h3 id="enif_cond_wait" class="code">void enif_cond_wait(ErlNifCond *cnd, ErlNifMutex *mtx)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_cond_wait">erl_drv_cond_wait</a></code>. </p> <h3 id="enif_consume_timeslice" class="code">int enif_consume_timeslice(ErlNifEnv *env, int percent)</h3> 
<p>Give the runtime system a hint about how much CPU time the current NIF call has consumed since last hint, or since the start of the NIF if no previous hint has been given. The time is given as a <code class="code">percent</code> of the timeslice that a process is allowed to execute Erlang code until it may be suspended to give time for other runnable processes. The scheduling timeslice is not an exact entity, but can usually be approximated to about 1 millisecond.</p> <p>Note that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms may use other means in order to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call <code class="code">enif_consume_timeslice</code> in order to determine if it is allowed to continue execution or not.</p> <p>Returns 1 if the timeslice is exhausted, or 0 otherwise. If 1 is returned the NIF should return as soon as possible in order for the process to yield.</p> <p>Argument <code class="code">percent</code> must be an integer between 1 and 100. This function must only be called from a NIF-calling thread and argument <code class="code">env</code> must be the environment of the calling process.</p> <p>This function is provided to better support co-operative scheduling, improve system responsiveness, and make it easier to prevent misbehaviors of the VM due to a NIF monopolizing a scheduler thread. It can be used to divide <code class="bold_code"><a href="#lengthy_work">length work</a></code> into a number of repeated NIF-calls without the need to create threads. See also the <code class="bold_code"><a href="#WARNING">warning</a></code> text at the beginning of this document.</p>  <h3 id="enif_equal_tids" class="code">int enif_equal_tids(ErlNifTid tid1, ErlNifTid tid2)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_equal_tids">erl_drv_equal_tids</a></code>. </p> <h3 id="enif_free" class="code">void enif_free(void* ptr)</h3> 
<p>Free memory allocated by <code class="code">enif_alloc</code>.</p> <h3 id="enif_free_env" class="code">void enif_free_env(ErlNifEnv* env)</h3> 
<p>Free an environment allocated with <code class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></code>. All terms created in the environment will be freed as well.</p> <h3 id="enif_get_atom" class="code">int enif_get_atom(ErlNifEnv* env, ERL_NIF_TERM term, char* buf, unsigned size, ErlNifCharEncoding encode)</h3> 
<p>Write a null-terminated string, in the buffer pointed to by <code class="code">buf</code> of size <code class="code">size</code>, consisting of the string representation of the atom <code class="code">term</code> with encoding <code class="bold_code"><a href="#ErlNifCharEncoding">encode</a></code>. Return the number of bytes written (including terminating null character) or 0 if <code class="code">term</code> is not an atom with maximum length of <code class="code">size-1</code>.</p> <h3 id="enif_get_atom_length" class="code">int enif_get_atom_length(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len, ErlNifCharEncoding encode)</h3> 
<p>Set <code class="code">*len</code> to the length (number of bytes excluding terminating null character) of the atom <code class="code">term</code> with encoding <code class="code">encode</code>. Return true on success or false if <code class="code">term</code> is not an atom.</p> <h3 id="enif_get_double" class="code">int enif_get_double(ErlNifEnv* env, ERL_NIF_TERM term, double* dp)</h3> 
<p>Set <code class="code">*dp</code> to the floating point value of <code class="code">term</code>. Return true on success or false if <code class="code">term</code> is not a float.</p> <h3 id="enif_get_int" class="code">int enif_get_int(ErlNifEnv* env, ERL_NIF_TERM term, int* ip)</h3> 
<p>Set <code class="code">*ip</code> to the integer value of <code class="code">term</code>. Return true on success or false if <code class="code">term</code> is not an integer or is outside the bounds of type <code class="code">int</code>.</p> <h3 id="enif_get_int64" class="code">int enif_get_int64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifSInt64* ip)</h3> 
<p>Set <code class="code">*ip</code> to the integer value of <code class="code">term</code>. Return true on success or false if <code class="code">term</code> is not an integer or is outside the bounds of a signed 64-bit integer.</p> <h3 id="enif_get_local_pid" class="code">int enif_get_local_pid(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifPid* pid)</h3> 
<p>If <code class="code">term</code> is the pid of a node local process, initialize the pid variable <code class="code">*pid</code> from it and return true. Otherwise return false. No check if the process is alive is done.</p> <h3 id="enif_get_list_cell" class="code">int enif_get_list_cell(ErlNifEnv* env, ERL_NIF_TERM list, ERL_NIF_TERM* head, ERL_NIF_TERM* tail)</h3> 
<p>Set <code class="code">*head</code> and <code class="code">*tail</code> from <code class="code">list</code> and return true, or return false if <code class="code">list</code> is not a non-empty list.</p> <h3 id="enif_get_list_length" class="code">int enif_get_list_length(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len)</h3> 
<p>Set <code class="code">*len</code> to the length of list <code class="code">term</code> and return true, or return false if <code class="code">term</code> is not a list.</p> <h3 id="enif_get_long" class="code">int enif_get_long(ErlNifEnv* env, ERL_NIF_TERM term, long int* ip)</h3> 
<p>Set <code class="code">*ip</code> to the long integer value of <code class="code">term</code> and return true, or return false if <code class="code">term</code> is not an integer or is outside the bounds of type <code class="code">long int</code>.</p> <h3 id="enif_get_map_size" class="code">int enif_get_map_size(ErlNifEnv* env, ERL_NIF_TERM term, size_t *size)</h3> 
<p>Set <code class="code">*size</code> to the number of key-value pairs in the map <code class="code">term</code> and return true, or return false if <code class="code">term</code> is not a map.</p> <h3 id="enif_get_map_value" class="code">int enif_get_map_value(ErlNifEnv* env, ERL_NIF_TERM map, ERL_NIF_TERM key, ERL_NIF_TERM* value)</h3> 
<p>Set <code class="code">*value</code> to the value associated with <code class="code">key</code> in the map <code class="code">map</code> and return true. Return false if <code class="code">map</code> is not a map or if <code class="code">map</code> does not contain <code class="code">key</code>.</p> <h3 id="enif_get_resource" class="code">int enif_get_resource(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifResourceType* type, void** objp)</h3> 
<p>Set <code class="code">*objp</code> to point to the resource object referred to by <code class="code">term</code>.</p> <p>Return true on success or false if <code class="code">term</code> is not a handle to a resource object of type <code class="code">type</code>.</p> <h3 id="enif_get_string" class="code">int enif_get_string(ErlNifEnv* env, ERL_NIF_TERM list, char* buf, unsigned size, ErlNifCharEncoding encode)</h3> 
<p>Write a null-terminated string, in the buffer pointed to by <code class="code">buf</code> with size <code class="code">size</code>, consisting of the characters in the string <code class="code">list</code>. The characters are written using encoding <code class="bold_code"><a href="#ErlNifCharEncoding">encode</a></code>. Return the number of bytes written (including terminating null character), or <code class="code">-size</code> if the string was truncated due to buffer space, or 0 if <code class="code">list</code> is not a string that can be encoded with <code class="code">encode</code> or if <code class="code">size</code> was less than 1. The written string is always null-terminated unless buffer <code class="code">size</code> is less than 1.</p> <h3 id="enif_get_tuple" class="code">int enif_get_tuple(ErlNifEnv* env, ERL_NIF_TERM term, int* arity, const ERL_NIF_TERM** array)</h3> 
<p>If <code class="code">term</code> is a tuple, set <code class="code">*array</code> to point to an array containing the elements of the tuple and set <code class="code">*arity</code> to the number of elements. Note that the array is read-only and <code class="code">(*array)[N-1]</code> will be the Nth element of the tuple. <code class="code">*array</code> is undefined if the arity of the tuple is zero.</p>
<p>Return true on success or false if <code class="code">term</code> is not a tuple.</p> <h3 id="enif_get_uint" class="code">int enif_get_uint(ErlNifEnv* env, ERL_NIF_TERM term, unsigned int* ip)</h3> 
<p>Set <code class="code">*ip</code> to the unsigned integer value of <code class="code">term</code> and return true, or return false if <code class="code">term</code> is not an unsigned integer or is outside the bounds of type <code class="code">unsigned int</code>.</p> <h3 id="enif_get_uint64" class="code">int enif_get_uint64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifUInt64* ip)</h3> 
<p>Set <code class="code">*ip</code> to the unsigned integer value of <code class="code">term</code> and return true, or return false if <code class="code">term</code> is not an unsigned integer or is outside the bounds of an unsigned 64-bit integer.</p> <h3 id="enif_get_ulong" class="code">int enif_get_ulong(ErlNifEnv* env, ERL_NIF_TERM term, unsigned long* ip)</h3> 
<p>Set <code class="code">*ip</code> to the unsigned long integer value of <code class="code">term</code> and return true, or return false if <code class="code">term</code> is not an unsigned integer or is outside the bounds of type <code class="code">unsigned long</code>.</p> <h3 id="enif_getenv" class="code">int enif_getenv(const char* key, char* value, size_t *value_size)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_getenv">erl_drv_getenv</a></code>.</p> <h3 id="enif_has_pending_exception" class="code">int enif_has_pending_exception(ErlNifEnv* env, ERL_NIF_TERM* reason)</h3> 
<p>Return true if a pending exception is associated with the environment <code class="code">env</code>. If <code class="code">reason</code> is a null pointer, ignore it. Otherwise, if there's a pending exception associated with <code class="code">env</code>, set the ERL_NIF_TERM to which <code class="code">reason</code> points to the value of the exception's term. For example, if <code class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></code> is called to set a pending <code class="code">badarg</code> exception, a subsequent call to <code class="code">enif_has_pending_exception(env, &amp;reason)</code> will set <code class="code">reason</code> to the atom <code class="code">badarg</code>, then return true.</p> <p>See also: <code class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></code> and <code class="bold_code"><a href="#enif_raise_exception">enif_raise_exception</a></code>.</p>  <h3 id="enif_inspect_binary" class="code">int enif_inspect_binary(ErlNifEnv* env, ERL_NIF_TERM bin_term, ErlNifBinary* bin)</h3> 
<p>Initialize the structure pointed to by <code class="code">bin</code> with information about the binary term <code class="code">bin_term</code>. Return true on success or false if <code class="code">bin_term</code> is not a binary.</p> <h3 id="enif_inspect_iolist_as_binary" class="code">int enif_inspect_iolist_as_binary(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifBinary* bin)</h3> 
<p>Initialize the structure pointed to by <code class="code">bin</code> with one continuous buffer with the same byte content as <code class="code">iolist</code>. As with inspect_binary, the data pointed to by <code class="code">bin</code> is transient and does not need to be released. Return true on success or false if <code class="code">iolist</code> is not an iolist.</p>  <h3 id="enif_is_atom" class="code">int enif_is_atom(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is an atom.</p> <h3 id="enif_is_binary" class="code">int enif_is_binary(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a binary</p> <h3 id="enif_is_empty_list" class="code">int enif_is_empty_list(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is an empty list.</p> <h3 id="enif_is_exception" class="code">int enif_is_exception(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is an exception.</p> <h3 id="enif_is_map" class="code">int enif_is_map(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a map, false otherwise.</p> <h3 id="enif_is_number" class="code">int enif_is_number(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a number.</p> <h3 id="enif_is_fun" class="code">int enif_is_fun(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a fun.</p> <h3 id="enif_is_identical" class="code">int enif_is_identical(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs)</h3> 
<p>Return true if the two terms are identical. Corresponds to the Erlang operators <code class="code">=:=</code> and <code class="code">=/=</code>.</p> <h3 id="enif_is_on_dirty_scheduler" class="code">int enif_is_on_dirty_scheduler(ErlNifEnv* env)</h3> 
<p>Check to see if the current NIF is executing on a dirty scheduler thread. If the emulator is built with threading support, calling <code class="code">enif_is_on_dirty_scheduler</code> from within a dirty NIF returns true. It returns false when the calling NIF is a regular NIF running on a normal scheduler thread, or when the emulator is built without threading support.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>This function is available only when the emulator is configured with dirty schedulers enabled. This feature is currently disabled by default. To determine whether the dirty NIF API is available, native code can check to see if the C preprocessor macro <code class="code">ERL_NIF_DIRTY_SCHEDULER_SUPPORT</code> is defined.</p>
</div> </div>  <h3 id="enif_is_pid" class="code">int enif_is_pid(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a pid.</p> <h3 id="enif_is_port" class="code">int enif_is_port(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a port.</p> <h3 id="enif_is_ref" class="code">int enif_is_ref(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a reference.</p> <h3 id="enif_is_tuple" class="code">int enif_is_tuple(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a tuple.</p> <h3 id="enif_is_list" class="code">int enif_is_list(ErlNifEnv* env, ERL_NIF_TERM term)</h3> 
<p>Return true if <code class="code">term</code> is a list.</p> <h3 id="enif_keep_resource" class="code">int enif_keep_resource(void* obj)</h3> 
<p>Add a reference to resource object <code class="code">obj</code> obtained from <code class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></code>. Each call to <code class="code">enif_keep_resource</code> for an object must be balanced by a call to <code class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></code> before the object will be destructed.</p> <h3 id="enif_make_atom" class="code">ERL_NIF_TERM enif_make_atom(ErlNifEnv* env, const char* name)</h3> 
<p>Create an atom term from the null-terminated C-string <code class="code">name</code> with iso-latin-1 encoding. If the length of <code class="code">name</code> exceeds the maximum length allowed for an atom (255 characters), <code class="code">enif_make_atom</code> invokes <code class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></code>. </p> <h3 id="enif_make_atom_len" class="code">ERL_NIF_TERM enif_make_atom_len(ErlNifEnv* env, const char* name, size_t len)</h3> 
<p>Create an atom term from the string <code class="code">name</code> with length <code class="code">len</code>. Null-characters are treated as any other characters. If <code class="code">len</code> is greater than the maximum length allowed for an atom (255 characters), <code class="code">enif_make_atom</code> invokes <code class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></code>. </p> <h3 id="enif_make_badarg" class="code">ERL_NIF_TERM enif_make_badarg(ErlNifEnv* env)</h3> 
<p>Make a badarg exception to be returned from a NIF, and associate it with the environment <code class="code">env</code>. Once a NIF or any function it calls invokes <code class="code">enif_make_badarg</code>, the runtime ensures that a <code class="code">badarg</code> exception is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead. The return value from <code class="code">enif_make_badarg</code> may be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to <code class="bold_code"><a href="#enif_is_exception">enif_is_exception</a></code>, but not to any other NIF API function.</p> <p>See also: <code class="bold_code"><a href="#enif_has_pending_exception">enif_has_pending_exception</a></code> and <code class="bold_code"><a href="#enif_raise_exception">enif_raise_exception</a></code> </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>In earlier versions (older than erts-7.0, OTP 18) the return value from <code class="code">enif_make_badarg</code> had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if <code class="code">enif_make_badarg</code> has been invoked.</p>
</div> </div> <h3 id="enif_make_binary" class="code">ERL_NIF_TERM enif_make_binary(ErlNifEnv* env, ErlNifBinary* bin)</h3> 
<p>Make a binary term from <code class="code">bin</code>. Any ownership of the binary data will be transferred to the created term and <code class="code">bin</code> should be considered read-only for the rest of the NIF call and then as released.</p> <h3 id="enif_make_copy" class="code">ERL_NIF_TERM enif_make_copy(ErlNifEnv* dst_env, ERL_NIF_TERM src_term)</h3> 
<p>Make a copy of term <code class="code">src_term</code>. The copy will be created in environment <code class="code">dst_env</code>. The source term may be located in any environment.</p> <h3 id="enif_make_double" class="code">ERL_NIF_TERM enif_make_double(ErlNifEnv* env, double d)</h3> 
<p>Create a floating-point term from a <code class="code">double</code>. If the <code class="code">double</code> argument is not finite or is NaN, <code class="code">enif_make_double</code> invokes <code class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></code>. </p> <h3 id="enif_make_existing_atom" class="code">int enif_make_existing_atom(ErlNifEnv* env, const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding encode)</h3> 
<p>Try to create the term of an already existing atom from the null-terminated C-string <code class="code">name</code> with encoding <code class="bold_code"><a href="#ErlNifCharEncoding">encode</a></code>. If the atom already exists store the term in <code class="code">*atom</code> and return true, otherwise return false. If the length of <code class="code">name</code> exceeds the maximum length allowed for an atom (255 characters), <code class="code">enif_make_existing_atom</code> returns false.</p> <h3 id="enif_make_existing_atom_len" class="code">int enif_make_existing_atom_len(ErlNifEnv* env, const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding encoding)</h3> 
<p>Try to create the term of an already existing atom from the string <code class="code">name</code> with length <code class="code">len</code> and encoding <code class="bold_code"><a href="#ErlNifCharEncoding">encode</a></code>. Null-characters are treated as any other characters. If the atom already exists store the term in <code class="code">*atom</code> and return true, otherwise return false. If <code class="code">len</code> is greater than the maximum length allowed for an atom (255 characters), <code class="code">enif_make_existing_atom_len</code> returns false.</p> <h3 id="enif_make_int" class="code">ERL_NIF_TERM enif_make_int(ErlNifEnv* env, int i)</h3> 
<p>Create an integer term.</p> <h3 id="enif_make_int64" class="code">ERL_NIF_TERM enif_make_int64(ErlNifEnv* env, ErlNifSInt64 i)</h3> 
<p>Create an integer term from a signed 64-bit integer.</p> <h3 id="enif_make_list" class="code">ERL_NIF_TERM enif_make_list(ErlNifEnv* env, unsigned cnt, ...)</h3> 
<p>Create an ordinary list term of length <code class="code">cnt</code>. Expects <code class="code">cnt</code> number of arguments (after <code class="code">cnt</code>) of type ERL_NIF_TERM as the elements of the list. An empty list is returned if <code class="code">cnt</code> is 0.</p> <h3 id="enif_make_list9" class="code">ERL_NIF_TERM enif_make_list1(ErlNifEnv* env, ERL_NIF_TERM e1)<br>ERL_NIF_TERM enif_make_list2(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2)<br>ERL_NIF_TERM enif_make_list3(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)<br>ERL_NIF_TERM enif_make_list4(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)<br>ERL_NIF_TERM enif_make_list5(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)<br>ERL_NIF_TERM enif_make_list6(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)<br>ERL_NIF_TERM enif_make_list7(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)<br>ERL_NIF_TERM enif_make_list8(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)<br>ERL_NIF_TERM enif_make_list9(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)</h3> 
<p>Create an ordinary list term with length indicated by the function name. Prefer these functions (macros) over the variadic <code class="code">enif_make_list</code> to get a compile time error if the number of arguments does not match.</p> <h3 id="enif_make_list_cell" class="code">ERL_NIF_TERM enif_make_list_cell(ErlNifEnv* env, ERL_NIF_TERM head, ERL_NIF_TERM tail)</h3> 
<p>Create a list cell <code class="code">[head | tail]</code>.</p> <h3 id="enif_make_list_from_array" class="code">ERL_NIF_TERM enif_make_list_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)</h3> 
<p>Create an ordinary list containing the elements of array <code class="code">arr</code> of length <code class="code">cnt</code>. An empty list is returned if <code class="code">cnt</code> is 0.</p> <h3 id="enif_make_long" class="code">ERL_NIF_TERM enif_make_long(ErlNifEnv* env, long int i)</h3> 
<p>Create an integer term from a <code class="code">long int</code>.</p> <h3 id="enif_make_new_binary" class="code">unsigned char *enif_make_new_binary(ErlNifEnv* env, size_t size, ERL_NIF_TERM* termp)</h3> 
<p>Allocate a binary of size <code class="code">size</code> bytes and create an owning term. The binary data is mutable until the calling NIF returns. This is a quick way to create a new binary without having to use <code class="bold_code"><a href="#ErlNifBinary">ErlNifBinary</a></code>. The drawbacks are that the binary can not be kept between NIF calls and it can not be reallocated.</p>
<p>Return a pointer to the raw binary data and set <code class="code">*termp</code> to the binary term.</p> <h3 id="enif_make_new_map" class="code">ERL_NIF_TERM enif_make_new_map(ErlNifEnv* env)</h3> 
<p>Make an empty map term.</p> <h3 id="enif_make_map_put" class="code">int enif_make_map_put(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value, ERL_NIF_TERM* map_out)</h3> 
<p>Make a copy of map <code class="code">map_in</code> and insert <code class="code">key</code> with <code class="code">value</code>. If <code class="code">key</code> already exists in <code class="code">map_in</code>, the old associated value is replaced by <code class="code">value</code>. If successful set <code class="code">*map_out</code> to the new map and return true. Return false if <code class="code">map_in</code> is not a map.</p> <p>The <code class="code">map_in</code> term must belong to the environment <code class="code">env</code>.</p> <h3 id="enif_make_map_update" class="code">int enif_make_map_update(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM new_value, ERL_NIF_TERM* map_out)</h3> 
<p>Make a copy of map <code class="code">map_in</code> and replace the old associated value for <code class="code">key</code> with <code class="code">new_value</code>. If successful set <code class="code">*map_out</code> to the new map and return true. Return false if <code class="code">map_in</code> is not a map or if it does no contain <code class="code">key</code>.</p> <p>The <code class="code">map_in</code> term must belong to the environment <code class="code">env</code>.</p> <h3 id="enif_make_map_remove" class="code">int enif_make_map_remove(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM* map_out)</h3> 
<p>If map <code class="code">map_in</code> contains <code class="code">key</code>, make a copy of <code class="code">map_in</code> in <code class="code">*map_out</code> and remove <code class="code">key</code> and associated value. If map <code class="code">map_in</code> does not contain <code class="code">key</code>, set <code class="code">*map_out</code> to <code class="code">map_in</code>. Return true for success or false if <code class="code">map_in</code> is not a map.</p> <p>The <code class="code">map_in</code> term must belong to the environment <code class="code">env</code>.</p> <h3 id="enif_make_pid" class="code">ERL_NIF_TERM enif_make_pid(ErlNifEnv* env, const ErlNifPid* pid)</h3> 
<p>Make a pid term from <code class="code">*pid</code>.</p> <h3 id="enif_make_ref" class="code">ERL_NIF_TERM enif_make_ref(ErlNifEnv* env)</h3> 
<p>Create a reference like <code class="bold_code"><a href="../erlang/#make_ref-0">erlang:make_ref/0</a></code>.</p> <h3 id="enif_make_resource" class="code">ERL_NIF_TERM enif_make_resource(ErlNifEnv* env, void* obj)</h3> 
<p>Create an opaque handle to a memory managed resource object obtained by <code class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></code>. No ownership transfer is done, as the resource object still needs to be released by <code class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></code>, but note that the call to <code class="code">enif_release_resource</code> can occur immediately after obtaining the term from <code class="code">enif_make_resource</code>, in which case the resource object will be deallocated when the term is garbage collected. See the <code class="bold_code"><a href="#enif_resource_example">example of creating and returning a resource object</a></code> for more details.</p> <p>Note that the only defined behaviour of using a resource term in an Erlang program is to store it and send it between processes on the same node. Other operations such as matching or <code class="code">term_to_binary</code> will have unpredictable (but harmless) results.</p> <h3 id="enif_make_resource_binary" class="code">ERL_NIF_TERM enif_make_resource_binary(ErlNifEnv* env, void* obj, const void* data, size_t size)</h3> 
<p>Create a binary term that is memory managed by a resource object <code class="code">obj</code> obtained by <code class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></code>. The returned binary term will consist of <code class="code">size</code> bytes pointed to by <code class="code">data</code>. This raw binary data must be kept readable and unchanged until the destructor of the resource is called. The binary data may be stored external to the resource object in which case it is the responsibility of the destructor to release the data.</p> <p>Several binary terms may be managed by the same resource object. The destructor will not be called until the last binary is garbage collected. This can be useful as a way to return different parts of a larger binary buffer.</p> <p>As with <code class="bold_code"><a href="#enif_make_resource">enif_make_resource</a></code>, no ownership transfer is done. The resource still needs to be released with <code class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></code>.</p>  <h3 id="enif_make_reverse_list" class="code">int enif_make_reverse_list(ErlNifEnv* env, ERL_NIF_TERM list_in, ERL_NIF_TERM *list_out)</h3> 
<p>Set <code class="code">*list_out</code> to the reverse list of the list <code class="code">list_in</code> and return true, or return false if <code class="code">list_in</code> is not a list. This function should only be used on short lists as a copy will be created of the list which will not be released until after the nif returns.</p> <p>The <code class="code">list_in</code> term must belong to the environment <code class="code">env</code>.</p> <h3 id="enif_make_string" class="code">ERL_NIF_TERM enif_make_string(ErlNifEnv* env, const char* string, ErlNifCharEncoding encoding)</h3> 
<p>Create a list containing the characters of the null-terminated string <code class="code">string</code> with encoding <code class="bold_code"><a href="#ErlNifCharEncoding">encoding</a></code>.</p> <h3 id="enif_make_string_len" class="code">ERL_NIF_TERM enif_make_string_len(ErlNifEnv* env, const char* string, size_t len, ErlNifCharEncoding encoding)</h3> 
<p>Create a list containing the characters of the string <code class="code">string</code> with length <code class="code">len</code> and encoding <code class="bold_code"><a href="#ErlNifCharEncoding">encoding</a></code>. Null-characters are treated as any other characters.</p> <h3 id="enif_make_sub_binary" class="code">ERL_NIF_TERM enif_make_sub_binary(ErlNifEnv* env, ERL_NIF_TERM bin_term, size_t pos, size_t size)</h3> 
<p>Make a subbinary of binary <code class="code">bin_term</code>, starting at zero-based position <code class="code">pos</code> with a length of <code class="code">size</code> bytes. <code class="code">bin_term</code> must be a binary or bitstring and <code class="code">pos+size</code> must be less or equal to the number of whole bytes in <code class="code">bin_term</code>.</p> <h3 id="enif_make_tuple" class="code">ERL_NIF_TERM enif_make_tuple(ErlNifEnv* env, unsigned cnt, ...)</h3> 
<p>Create a tuple term of arity <code class="code">cnt</code>. Expects <code class="code">cnt</code> number of arguments (after <code class="code">cnt</code>) of type ERL_NIF_TERM as the elements of the tuple.</p> <h3 id="enif_make_tuple9" class="code">ERL_NIF_TERM enif_make_tuple1(ErlNifEnv* env, ERL_NIF_TERM e1)<br>ERL_NIF_TERM enif_make_tuple2(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2)<br>ERL_NIF_TERM enif_make_tuple3(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)<br>ERL_NIF_TERM enif_make_tuple4(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)<br>ERL_NIF_TERM enif_make_tuple5(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)<br>ERL_NIF_TERM enif_make_tuple6(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)<br>ERL_NIF_TERM enif_make_tuple7(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)<br>ERL_NIF_TERM enif_make_tuple8(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)<br>ERL_NIF_TERM enif_make_tuple9(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)</h3> 
<p>Create a tuple term with length indicated by the function name. Prefer these functions (macros) over the variadic <code class="code">enif_make_tuple</code> to get a compile time error if the number of arguments does not match.</p> <h3 id="enif_make_tuple_from_array" class="code">ERL_NIF_TERM enif_make_tuple_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)</h3> 
<p>Create a tuple containing the elements of array <code class="code">arr</code> of length <code class="code">cnt</code>.</p> <h3 id="enif_make_uint" class="code">ERL_NIF_TERM enif_make_uint(ErlNifEnv* env, unsigned int i)</h3> 
<p>Create an integer term from an <code class="code">unsigned int</code>.</p> <h3 id="enif_make_uint64" class="code">ERL_NIF_TERM enif_make_uint64(ErlNifEnv* env, ErlNifUInt64 i)</h3> 
<p>Create an integer term from an unsigned 64-bit integer.</p> <h3 id="enif_make_ulong" class="code">ERL_NIF_TERM enif_make_ulong(ErlNifEnv* env, unsigned long i)</h3> 
<p>Create an integer term from an <code class="code">unsigned long int</code>.</p> <h3 id="enif_map_iterator_create" class="code">int enif_map_iterator_create(ErlNifEnv *env, ERL_NIF_TERM map, ErlNifMapIterator *iter, ErlNifMapIteratorEntry entry)</h3> 
<p>Create an iterator for the map <code class="code">map</code> by initializing the structure pointed to by <code class="code">iter</code>. The <code class="code">entry</code> argument determines the start position of the iterator: <code class="code">ERL_NIF_MAP_ITERATOR_FIRST</code> or <code class="code">ERL_NIF_MAP_ITERATOR_LAST</code>. Return true on success or false if <code class="code">map</code> is not a map.</p> <p>A map iterator is only useful during the lifetime of the environment <code class="code">env</code> that the <code class="code">map</code> belongs to. The iterator must be destroyed by calling <code class="bold_code"><a href="#enif_map_iterator_destroy"> enif_map_iterator_destroy</a></code>.</p> <div class="example"><pre>
ERL_NIF_TERM key, value;
ErlNifMapIterator iter;
enif_map_iterator_create(env, my_map, &amp;iter, ERL_NIF_MAP_ITERATOR_FIRST);

while (enif_map_iterator_get_pair(env, &amp;iter, &amp;key, &amp;value)) {
    do_something(key,value);
    enif_map_iterator_next(env, &amp;iter);
}
enif_map_iterator_destroy(env, &amp;iter);
      </pre></div> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The key-value pairs of a map have no defined iteration order. The only guarantee is that the iteration order of a single map instance is preserved during the lifetime of the environment that the map belongs to.</p> </div> </div>  <h3 id="enif_map_iterator_destroy" class="code">void enif_map_iterator_destroy(ErlNifEnv *env, ErlNifMapIterator *iter)</h3> 
<p>Destroy a map iterator created by <code class="bold_code"><a href="#enif_map_iterator_create">enif_map_iterator_create</a></code>. </p> <h3 id="enif_map_iterator_get_pair" class="code">int enif_map_iterator_get_pair(ErlNifEnv *env, ErlNifMapIterator *iter, ERL_NIF_TERM *key, ERL_NIF_TERM *value)</h3> 
<p>Get key and value terms at current map iterator position. On success set <code class="code">*key</code> and <code class="code">*value</code> and return true. Return false if the iterator is positioned at head (before first entry) or tail (beyond last entry).</p> <h3 id="enif_map_iterator_is_head" class="code">int enif_map_iterator_is_head(ErlNifEnv *env, ErlNifMapIterator *iter)</h3> 
<p>Return true if map iterator <code class="code">iter</code> is positioned before first entry.</p> <h3 id="enif_map_iterator_is_tail" class="code">int enif_map_iterator_is_tail(ErlNifEnv *env, ErlNifMapIterator *iter)</h3> 
<p>Return true if map iterator <code class="code">iter</code> is positioned after last entry.</p> <h3 id="enif_map_iterator_next" class="code">int enif_map_iterator_next(ErlNifEnv *env, ErlNifMapIterator *iter)</h3> 
<p>Increment map iterator to point to next key-value entry. Return true if the iterator is now positioned at a valid key-value entry, or false if the iterator is positioned at the tail (beyond the last entry).</p> <h3 id="enif_map_iterator_prev" class="code">int enif_map_iterator_prev(ErlNifEnv *env, ErlNifMapIterator *iter)</h3> 
<p>Decrement map iterator to point to previous key-value entry. Return true if the iterator is now positioned at a valid key-value entry, or false if the iterator is positioned at the head (before the first entry).</p> <h3 id="enif_mutex_create" class="code">ErlNifMutex *enif_mutex_create(char *name)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_mutex_create">erl_drv_mutex_create</a></code>. </p> <h3 id="enif_mutex_destroy" class="code">void enif_mutex_destroy(ErlNifMutex *mtx)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_mutex_destroy">erl_drv_mutex_destroy</a></code>. </p> <h3 id="enif_mutex_lock" class="code">void enif_mutex_lock(ErlNifMutex *mtx)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_mutex_lock">erl_drv_mutex_lock</a></code>. </p> <h3 id="enif_mutex_trylock" class="code">int enif_mutex_trylock(ErlNifMutex *mtx)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_mutex_trylock">erl_drv_mutex_trylock</a></code>. </p> <h3 id="enif_mutex_unlock" class="code">void enif_mutex_unlock(ErlNifMutex *mtx)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_mutex_unlock">erl_drv_mutex_unlock</a></code>. </p> <h3 id="enif_open_resource_type" class="code">ErlNifResourceType *enif_open_resource_type(ErlNifEnv* env, const char* module_str, const char* name, ErlNifResourceDtor* dtor, ErlNifResourceFlags flags, ErlNifResourceFlags* tried)</h3> 
<p>Create or takeover a resource type identified by the string <code class="code">name</code> and give it the destructor function pointed to by <code class="bold_code"><a href="#ErlNifResourceDtor">dtor</a></code>. Argument <code class="code">flags</code> can have the following values:</p> <dl> <dt><strong><code class="code">ERL_NIF_RT_CREATE</code></strong></dt> <dd>Create a new resource type that does not already exist.</dd> <dt><strong><code class="code">ERL_NIF_RT_TAKEOVER</code></strong></dt> <dd>Open an existing resource type and take over ownership of all its instances. The supplied destructor <code class="code">dtor</code> will be called both for existing instances as well as new instances not yet created by the calling NIF library.</dd> </dl> <p>The two flag values can be combined with bitwise-or. The name of the resource type is local to the calling module. Argument <code class="code">module_str</code> is not (yet) used and must be NULL. The <code class="code">dtor</code> may be <code class="code">NULL</code> in case no destructor is needed.</p> <p>On success, return a pointer to the resource type and <code class="code">*tried</code> will be set to either <code class="code">ERL_NIF_RT_CREATE</code> or <code class="code">ERL_NIF_RT_TAKEOVER</code> to indicate what was actually done. On failure, return <code class="code">NULL</code> and set <code class="code">*tried</code> to <code class="code">flags</code>. It is allowed to set <code class="code">tried</code> to <code class="code">NULL</code>.</p> <p>Note that <code class="code">enif_open_resource_type</code> is only allowed to be called in the three callbacks <code class="bold_code"><a href="#load">load</a></code>, <code class="bold_code"><a href="#reload">reload</a></code> and <code class="bold_code"><a href="#upgrade">upgrade</a></code>.</p>  <h3 id="enif_priv_data" class="code">void *enif_priv_data(ErlNifEnv* env)</h3> 
<p>Return the pointer to the private data that was set by <code class="code">load</code>, <code class="code">reload</code> or <code class="code">upgrade</code>.</p> <p>Was previously named <code class="code">enif_get_data</code>.</p> <h3 id="enif_raise_exception" class="code">ERL_NIF_TERM enif_raise_exception(ErlNifEnv* env, ERL_NIF_TERM reason)</h3> 
<p>Create an error exception with the term <code class="code">reason</code> to be returned from a NIF, and associate it with the environment <code class="code">env</code>. Once a NIF or any function it calls invokes <code class="code">enif_raise_exception</code>, the runtime ensures that the exception it creates is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead. The return value from <code class="code">enif_raise_exception</code> may be used only as the return value from the NIF that invoked it (directly or indirectly) or be passed to <code class="bold_code"><a href="#enif_is_exception">enif_is_exception</a></code>, but not to any other NIF API function.</p> <p>See also: <code class="bold_code"><a href="#enif_has_pending_exception">enif_has_pending_exception</a></code> and <code class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></code>.</p> <h3 id="enif_realloc_binary" class="code">int enif_realloc_binary(ErlNifBinary* bin, size_t size)</h3> 
<p>Change the size of a binary <code class="code">bin</code>. The source binary may be read-only, in which case it will be left untouched and a mutable copy is allocated and assigned to <code class="code">*bin</code>. Return true on success, false if memory allocation failed.</p> <h3 id="enif_release_binary" class="code">void enif_release_binary(ErlNifBinary* bin)</h3> 
<p>Release a binary obtained from <code class="code">enif_alloc_binary</code>.</p> <h3 id="enif_release_resource" class="code">void enif_release_resource(void* obj)</h3> 
<p>Remove a reference to resource object <code class="code">obj</code>obtained from <code class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></code>. The resource object will be destructed when the last reference is removed. Each call to <code class="code">enif_release_resource</code> must correspond to a previous call to <code class="code">enif_alloc_resource</code> or <code class="bold_code"><a href="#enif_keep_resource">enif_keep_resource</a></code>. References made by <code class="bold_code"><a href="#enif_make_resource">enif_make_resource</a></code> can only be removed by the garbage collector.</p> <h3 id="enif_rwlock_create" class="code">ErlNifRWLock *enif_rwlock_create(char *name)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_create">erl_drv_rwlock_create</a></code>. </p> <h3 id="enif_rwlock_destroy" class="code">void enif_rwlock_destroy(ErlNifRWLock *rwlck)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy</a></code>. </p> <h3 id="enif_rwlock_rlock" class="code">void enif_rwlock_rlock(ErlNifRWLock *rwlck)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock</a></code>. </p> <h3 id="enif_rwlock_runlock" class="code">void enif_rwlock_runlock(ErlNifRWLock *rwlck)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock</a></code>. </p> <h3 id="enif_rwlock_rwlock" class="code">void enif_rwlock_rwlock(ErlNifRWLock *rwlck)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock</a></code>. </p> <h3 id="enif_rwlock_rwunlock" class="code">void enif_rwlock_rwunlock(ErlNifRWLock *rwlck)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock</a></code>. </p> <h3 id="enif_rwlock_tryrlock" class="code">int enif_rwlock_tryrlock(ErlNifRWLock *rwlck)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock</a></code>. </p> <h3 id="enif_rwlock_tryrwlock" class="code">int enif_rwlock_tryrwlock(ErlNifRWLock *rwlck)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock</a></code>. </p> <h3 id="enif_schedule_nif" class="code">ERL_NIF_TERM enif_schedule_nif(ErlNifEnv* env, const char* fun_name, int flags, ERL_NIF_TERM (*fp)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]), int argc, const ERL_NIF_TERM argv[])</h3> 
<p>Schedule NIF <code class="code">fp</code> to execute. This function allows an application to break up long-running work into multiple regular NIF calls or to schedule a <code class="bold_code"><a href="#dirty_nifs">dirty NIF</a></code> to execute on a dirty scheduler thread (<strong>note that the dirty NIF functionality described here is experimental</strong> and that you have to enable support for dirty schedulers when building OTP in order to try the functionality out).</p> <p>The <code class="code">fun_name</code> argument provides a name for the NIF being scheduled for execution. If it cannot be converted to an atom, <code class="code">enif_schedule_nif</code> returns a <code class="code">badarg</code> exception.</p> <p>The <code class="code">flags</code> argument must be set to 0 for a regular NIF, or if the emulator was built the experimental dirty scheduler support enabled, <code class="code">flags</code> can be set to either <code class="code">ERL_NIF_DIRTY_JOB_CPU_BOUND</code> if the job is expected to be primarily CPU-bound, or <code class="code">ERL_NIF_DIRTY_JOB_IO_BOUND</code> for jobs that will be I/O-bound. If dirty scheduler threads are not available in the emulator, a try to schedule such a job will result in a <code class="code">badarg</code> exception.</p> <p>The <code class="code">argc</code> and <code class="code">argv</code> arguments can either be the originals passed into the calling NIF, or they can be values created by the calling NIF.</p> <p>The calling NIF must use the return value of <code class="code">enif_schedule_nif</code> as its own return value.</p> <p>Be aware that <code class="code">enif_schedule_nif</code>, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return, which means that the calling NIF can't expect to receive the scheduled NIF return value and use it for further operations.</p>  <h3 id="enif_self" class="code">ErlNifPid *enif_self(ErlNifEnv* caller_env, ErlNifPid* pid)</h3> 
<p>Initialize the pid variable <code class="code">*pid</code> to represent the calling process. Return <code class="code">pid</code>.</p> <h3 id="enif_send" class="code">int enif_send(ErlNifEnv* env, ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg)</h3> 
<p>Send a message to a process.</p> <dl> <dt><strong><code class="code">env</code></strong></dt> <dd>The environment of the calling process. Must be NULL if and only if calling from a created thread.</dd> <dt><strong><code class="code">*to_pid</code></strong></dt> <dd>The pid of the receiving process. The pid should refer to a process on the local node.</dd> <dt><strong><code class="code">msg_env</code></strong></dt> <dd>The environment of the message term. Must be a process independent environment allocated with <code class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></code>.</dd> <dt><strong><code class="code">msg</code></strong></dt> <dd>The message term to send.</dd> </dl> <p>Return true on success, or false if <code class="code">*to_pid</code> does not refer to an alive local process.</p> <p>The message environment <code class="code">msg_env</code> with all its terms (including <code class="code">msg</code>) will be invalidated by a successful call to <code class="code">enif_send</code>. The environment should either be freed with <code class="bold_code"><a href="#enif_free_env">enif_free_env</a></code> of cleared for reuse with <code class="bold_code"><a href="#enif_clear_env">enif_clear_env</a></code>.</p> <p>This function is only thread-safe when the emulator with SMP support is used. It can only be used in a non-SMP emulator from a NIF-calling thread.</p>  <h3 id="enif_sizeof_resource" class="code">unsigned enif_sizeof_resource(void* obj)</h3> 
<p>Get the byte size of a resource object <code class="code">obj</code> obtained by <code class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></code>.</p> <h3 id="enif_system_info" class="code">void enif_system_info(ErlNifSysInfo *sys_info_ptr, size_t size)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#driver_system_info">driver_system_info</a></code>. </p> <h3 id="enif_thread_create" class="code">int enif_thread_create(char *name,ErlNifTid *tid,void * (*func)(void *),void *args,ErlNifThreadOpts *opts)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_thread_create">erl_drv_thread_create</a></code>. </p> <h3 id="enif_thread_exit" class="code">void enif_thread_exit(void *resp)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_thread_exit">erl_drv_thread_exit</a></code>. </p> <h3 id="enif_thread_join" class="code">int enif_thread_join(ErlNifTid, void **respp)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_thread_join">erl_drv_thread_join </a></code>. </p> <h3 id="enif_thread_opts_create" class="code">ErlNifThreadOpts *enif_thread_opts_create(char *name)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a></code>. </p> <h3 id="enif_thread_opts_destroy" class="code">void enif_thread_opts_destroy(ErlNifThreadOpts *opts)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy</a></code>. </p> <h3 id="enif_thread_self" class="code">ErlNifTid enif_thread_self(void)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_thread_self">erl_drv_thread_self</a></code>. </p> <h3 id="enif_tsd_key_create" class="code">int enif_tsd_key_create(char *name, ErlNifTSDKey *key)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_tsd_key_create">erl_drv_tsd_key_create</a></code>. </p> <h3 id="enif_tsd_key_destroy" class="code">void enif_tsd_key_destroy(ErlNifTSDKey key)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy</a></code>. </p> <h3 id="enif_tsd_get" class="code">void *enif_tsd_get(ErlNifTSDKey key)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_tsd_get">erl_drv_tsd_get</a></code>. </p> <h3 id="enif_tsd_set" class="code">void enif_tsd_set(ErlNifTSDKey key, void *data)</h3> 
<p>Same as <code class="bold_code"><a href="../erl_driver/#erl_drv_tsd_set">erl_drv_tsd_set</a></code>. </p> <h3 id="enif_monotonic_time" class="code">ErlNifTime enif_monotonic_time(ErlNifTimeUnit time_unit)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">time_unit</code></strong></dt> <dd>Time unit of returned value.</dd> </dl> <p> Returns <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code>. Note that it is not uncommon with negative values. </p> <p>Returns <code class="code">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument, or if called from a thread that is not a scheduler thread.</p> <p>See also:</p> <ul> <li><code class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code></li> </ul>  <h3 id="enif_time_offset" class="code">ErlNifTime enif_time_offset(ErlNifTimeUnit time_unit)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">time_unit</code></strong></dt> <dd>Time unit of returned value.</dd> </dl> <p>Returns the current time offset between <code class="bold_code"><a href="../time_correction/#Erlang_Monotonic_Time">Erlang monotonic time</a></code> and <code class="bold_code"><a href="../time_correction/#Erlang_System_Time">Erlang system time</a></code> converted into the <code class="code">time_unit</code> passed as argument.</p> <p>Returns <code class="code">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument, or if called from a thread that is not a scheduler thread.</p> <p>See also:</p> <ul> <li><code class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code></li> </ul>  <h3 id="enif_convert_time_unit" class="code">ErlNifTime enif_convert_time_unit(ErlNifTime val, ErlNifTimeUnit from, ErlNifTimeUnit to)</h3> 
<p>Arguments:</p> <dl> <dt><strong><code class="code">val</code></strong></dt> <dd>Value to convert time unit for.</dd> <dt><strong><code class="code">from</code></strong></dt> <dd>Time unit of <code class="code">val</code>.</dd> <dt><strong><code class="code">to</code></strong></dt> <dd>Time unit of returned value.</dd> </dl> <p>Converts the <code class="code">val</code> value of time unit <code class="code">from</code> to the corresponding value of time unit <code class="code">to</code>. The result is rounded using the floor function.</p> <p>Returns <code class="code">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument.</p> <p>See also:</p> <ul> <li><code class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></code></li> <li><code class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></code></li> </ul>  <h2 id="id203581">See also</h2>  <p><code class="bold_code"><a href="../erlang/#load_nif-2">erlang:load_nif/2</a></code></p>
<div class="_attribution">
  <p class="_attribution-p">
     19992016 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
