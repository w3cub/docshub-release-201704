
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Modules - Ansible - W3cubDocs</title>
  
  <meta name="description" content="This in-depth dive helps you understand Ansible’s program flow to execute modules. It is written for people working on the portions of the Core &hellip;">
  <meta name="keywords" content="modules, -, ansible">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ansible/dev_guide/developing_program_flow_modules/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/ansible.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ansible/" class="_nav-link" title="" style="margin-left:0;">Ansible</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="flow-modules">Modules</h1> <p id="modules">This in-depth dive helps you understand Ansible’s program flow to execute modules. It is written for people working on the portions of the Core Ansible Engine that execute a module. Those writing Ansible Modules may also find this in-depth dive to be of interest, but individuals simply using Ansible Modules will not likely find this to be helpful.</p>  <h2 id="flow-types-of-modules">Types of Modules</h2> <p id="types-of-modules">Ansible supports several different types of modules in its code base. Some of these are for backwards compatibility and others are to enable flexibility.</p>  <h3 id="flow-action-plugins">Action Plugins</h3> <p id="action-plugins">Action Plugins look like modules to end users who are writing <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-playbooks" target="_blank"><span class="xref std std-term">playbooks</span></a> but they’re distinct entities for the purposes of this document. Action Plugins always execute on the controller and are sometimes able to do all work there (for instance, the <code>debug</code> Action Plugin which prints some text for the user to see or the <code>assert</code> Action Plugin which can test whether several values in a playbook satisfy certain criteria.)</p> <p>More often, Action Plugins set up some values on the controller, then invoke an actual module on the managed node that does something with these values. An easy to understand version of this is the <a class="reference internal" href="../../template_module/#template"><span class="std std-ref">template Action Plugin</span></a>. The <a class="reference internal" href="../../template_module/#template"><span class="std std-ref">template Action Plugin</span></a> takes values from the user to construct a file in a temporary location on the controller using variables from the playbook environment. It then transfers the temporary file to a temporary file on the remote system. After that, it invokes the <a class="reference internal" href="../../copy_module/#copy"><span class="std std-ref">copy module</span></a> which operates on the remote system to move the file into its final location, sets file permissions, and so on.</p>   <h3 id="flow-new-style-modules">New-style Modules</h3> <p id="new-style-modules">All of the modules that ship with Ansible fall into this category.</p> <p>New-style modules have the arguments to the module embedded inside of them in some manner. Non-new-style modules must copy a separate file over to the managed node, which is less efficient as it requires two over-the-wire connections instead of only one.</p>  <h4 id="flow-python-modules">Python</h4> <p id="python">New-style Python modules use the <a class="reference internal" href="#ansiballz"><span class="std std-ref">Ansiballz</span></a> framework for constructing modules. All official modules (shipped with Ansible) use either this or the <a class="reference internal" href="#flow-powershell-modules"><span class="std std-ref">powershell module framework</span></a>.</p> <p>These modules use imports from <code>ansible.module_utils</code> in order to pull in boilerplate module code, such as argument parsing, formatting of return values as <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-json" target="_blank"><span class="xref std std-term">JSON</span></a>, and various file operations.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In Ansible, up to version 2.0.x, the official Python modules used the <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a> framework. For module authors, <a class="reference internal" href="#ansiballz"><span class="std std-ref">Ansiballz</span></a> is largely a superset of <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a> functionality, so you usually do not need to know about one versus the other.</p> </div>   <h4 id="flow-powershell-modules">Powershell</h4> <p id="powershell">New-style powershell modules use the <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a> framework for constructing modules. These modules get a library of powershell code embedded in them before being sent to the managed node.</p>   <h4 id="flow-jsonargs-modules">JSONARGS</h4> <p id="jsonargs">Scripts can arrange for an argument string to be placed within them by placing the string <code>&lt;&lt;INCLUDE_ANSIBLE_MODULE_JSON_ARGS&gt;&gt;</code> somewhere inside of the file. The module typically sets a variable to that value like this:</p> <pre data-language="yaml">json_arguments = """&lt;&lt;INCLUDE_ANSIBLE_MODULE_JSON_ARGS&gt;&gt;"""
</pre> <p>Which is expanded as:</p> <pre data-language="yaml">json_arguments = """{"param1": "test's quotes", "param2": "\"To be or not to be\" - Hamlet"}"""
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Ansible outputs a <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-json" target="_blank"><span class="xref std std-term">JSON</span></a> string with bare quotes. Double quotes are used to quote string values, double quotes inside of string values are backslash escaped, and single quotes may appear unescaped inside of a string value. To use JSONARGS, your scripting language must have a way to handle this type of string. The example uses Python’s triple quoted strings to do this. Other scripting languages may have a similar quote character that won’t be confused by any quotes in the JSON or it may allow you to define your own start-of-quote and end-of-quote characters. If the language doesn’t give you any of these then you’ll need to write a <a class="reference internal" href="#flow-want-json-modules"><span class="std std-ref">non-native JSON module</span></a> or <a class="reference internal" href="#flow-old-style-modules"><span class="std std-ref">Old-style module</span></a> instead.</p> </div> <p>The module typically parses the contents of <code>json_arguments</code> using a JSON library and then use them as native variables throughout the rest of its code.</p>    <h3 id="flow-want-json-modules">Non-native want JSON modules</h3> <p id="non-native-want-json-modules">If a module has the string <code>WANT_JSON</code> in it anywhere, Ansible treats it as a non-native module that accepts a filename as its only command line parameter. The filename is for a temporary file containing a <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-json" target="_blank"><span class="xref std std-term">JSON</span></a> string containing the module’s parameters. The module needs to open the file, read and parse the parameters, operate on the data, and print its return data as a JSON encoded dictionary to stdout before exiting.</p> <p>These types of modules are self-contained entities. As of Ansible 2.1, Ansible only modifies them to change a shebang line if present.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">Examples of Non-native modules written in ruby are in the <a class="reference external" href="https://github.com/ansible/ansible-for-rubyists" target="_blank">Ansible for Rubyists</a> repository.</p> </div>   <h3 id="flow-binary-modules">Binary Modules</h3> <p id="binary-modules">From Ansible 2.2 onwards, modules may also be small binary programs. Ansible doesn’t perform any magic to make these portable to different systems so they may be specific to the system on which they were compiled or require other binary runtime dependencies. Despite these drawbacks, a site may sometimes have no choice but to compile a custom module against a specific binary library if that’s the only way they have to get access to certain resources.</p> <p>Binary modules take their arguments and will return data to Ansible in the same way as <a class="reference internal" href="#flow-want-json-modules"><span class="std std-ref">want JSON modules</span></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">One example of a <a class="reference external" href="https://github.com/ansible/ansible/blob/devel/test/integration/library/helloworld.go" target="_blank">binary module</a> written in go.</p> </div>   <h3 id="flow-old-style-modules">Old-style Modules</h3> <p id="old-style-modules">Old-style modules are similar to <a class="reference internal" href="#flow-want-json-modules"><span class="std std-ref">want JSON modules</span></a>, except that the file that they take contains <code>key=value</code> pairs for their parameters instead of <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-json" target="_blank"><span class="xref std std-term">JSON</span></a>.</p> <p>Ansible decides that a module is old-style when it doesn’t have any of the markers that would show that it is one of the other types.</p>    <h2 id="flow-how-modules-are-executed">How modules are executed</h2> <p id="how-modules-are-executed">When a user uses <strong class="program">ansible</strong> or <strong class="program">ansible-playbook</strong>, they specify a task to execute. The task is usually the name of a module along with several parameters to be passed to the module. Ansible takes these values and processes them in various ways before they are finally executed on the remote machine.</p>  <h3 id="flow-executor-task-executor">executor/task_executor</h3> <p id="executor-task-executor">The TaskExecutor receives the module name and parameters that were parsed from the <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-playbooks" target="_blank"><span class="xref std std-term">playbook</span></a> (or from the command line in the case of <strong class="command">/usr/bin/ansible</strong>). It uses the name to decide whether it’s looking at a module or an <a class="reference internal" href="#flow-action-plugins"><span class="std std-ref">Action Plugin</span></a>. If it’s a module, it loads the <a class="reference internal" href="#flow-normal-action-plugin"><span class="std std-ref">Normal Action Plugin</span></a> and passes the name, variables, and other information about the task and play to that Action Plugin for further processing.</p>   <h3 id="flow-normal-action-plugin">Normal Action Plugin</h3> <p id="normal-action-plugin">The <code>normal</code> Action Plugin executes the module on the remote host. It is the primary coordinator of much of the work to actually execute the module on the managed machine.</p> <ul class="simple"> <li>It takes care of creating a connection to the managed machine by instantiating a <code>Connection</code> class according to the inventory configuration for that host.</li> <li>It adds any internal Ansible variables to the module’s parameters (for instance, the ones that pass along <code>no_log</code> to the module).</li> <li>It takes care of creating any temporary files on the remote machine and cleans up afterwards.</li> <li>It does the actual work of pushing the module and module parameters to the remote host, although the <a class="reference internal" href="#flow-executor-module-common"><span class="std std-ref">module_common</span></a> code described in the next section does the work of deciding which format those will take.</li> <li>It handles any special cases regarding modules (for instance, various complications around Windows modules that must have the same names as Python modules, so that internal calling of modules from other Action Plugins work.)</li> </ul> <p>Much of this functionality comes from the <code>BaseAction</code> class, which lives in <code>plugins/action/__init__.py</code>. It makes use of <code>Connection</code> and <code>Shell</code> objects to do its work.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-tasks" target="_blank"><span class="xref std std-term">tasks</span></a> are run with the <code>async:</code> parameter, Ansible uses the <code>async</code> Action Plugin instead of the <code>normal</code> Action Plugin to invoke it. That program flow is currently not documented. Read the source for information on how that works.</p> </div>   <h3 id="flow-executor-module-common">executor/module_common.py</h3> <p id="executor-module-common-py">Code in <code>executor/module_common.py</code> takes care of assembling the module to be shipped to the managed node. The module is first read in, then examined to determine its type. <a class="reference internal" href="#flow-powershell-modules"><span class="std std-ref">PowerShell</span></a> and <a class="reference internal" href="#flow-jsonargs-modules"><span class="std std-ref">JSON-args modules</span></a> are passed through <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a>. New-style <a class="reference internal" href="#flow-python-modules"><span class="std std-ref">Python modules</span></a> are assembled by <a class="reference internal" href="#ansiballz"><span class="std std-ref">Ansiballz</span></a>. <a class="reference internal" href="#flow-want-json-modules"><span class="std std-ref">Non-native-want-JSON</span></a>, <a class="reference internal" href="#flow-binary-modules"><span class="std std-ref">Binary modules</span></a>, and <a class="reference internal" href="#flow-old-style-modules"><span class="std std-ref">Old-Style modules</span></a> aren’t touched by either of these and pass through unchanged. After the assembling step, one final modification is made to all modules that have a shebang line. Ansible checks whether the interpreter in the shebang line has a specific path configured via an <code>ansible_$X_interpreter</code> inventory variable. If it does, Ansible substitutes that path for the interpreter path given in the module. After this, Ansible returns the complete module data and the module type to the <a class="reference internal" href="#flow-normal-action-plugin"><span class="std std-ref">Normal Action</span></a> which continues execution of the module.</p> <p>Next we’ll go into some details of the two assembler frameworks.</p>  <h4 id="id1">Module Replacer</h4> <p id="module-replacer">The Module Replacer framework is the original framework implementing new-style modules. It is essentially a preprocessor (like the C Preprocessor for those familiar with that programming language). It does straight substitutions of specific substring patterns in the module file. There are two types of substitutions:</p> <ul class="simple"> <li>Replacements that only happen in the module file. These are public replacement strings that modules can utilize to get helpful boilerplate or access to arguments.<ul> <li>
<code>from ansible.module_utils.MOD_LIB_NAME import *</code> is replaced with the contents of the <code>ansible/module_utils/MOD_LIB_NAME.py</code> These should only be used with <a class="reference internal" href="#flow-python-modules"><span class="std std-ref">new-style Python modules</span></a>.</li> <li>
<code>#&lt;&lt;INCLUDE_ANSIBLE_MODULE_COMMON&gt;&gt;</code> is equivalent to <code>from ansible.module_utils.basic import *</code> and should also only apply to new-style Python modules.</li> <li>
<code># POWERSHELL_COMMON</code> substitutes the contents of <code>ansible/module_utils/powershell.ps1</code>. It should only be used with <a class="reference internal" href="#flow-powershell-modules"><span class="std std-ref">new-style Powershell modules</span></a>.</li> </ul> </li> <li>Replacements that are used by <code>ansible.module_utils</code> code. These are internal replacement patterns. They may be used internally, in the above public replacements, but shouldn’t be used directly by modules.<ul> <li>
<code>"&lt;&lt;ANSIBLE_VERSION&gt;&gt;"</code> is substituted with the Ansible version. In <a class="reference internal" href="#flow-python-modules"><span class="std std-ref">new-style Python modules</span></a> under the <a class="reference internal" href="#ansiballz"><span class="std std-ref">Ansiballz</span></a> frameworkthe proper way is to instead instantiate an <code>AnsibleModule</code> and then access the version from :attr:<code>AnsibleModule.ansible_version</code>.</li> <li>
<code>"&lt;&lt;INCLUDE_ANSIBLE_MODULE_COMPLEX_ARGS&gt;&gt;"</code> is substituted with a string which is the Python <code>repr</code> of the <a class="reference internal" href="https://docs.ansible.com/ansible/glossary.html#term-json" target="_blank"><span class="xref std std-term">JSON</span></a> encoded module parameters. Using <code>repr</code> on the JSON string makes it safe to embed in a Python file. In new-style Python modules under the Ansiballz framework this is better accessed by instantiating an <code>AnsibleModule</code> and then using <code>AnsibleModule.params</code>.</li> <li>
<code>&lt;&lt;SELINUX_SPECIAL_FILESYSTEMS&gt;&gt;</code> substitutes a string which is a comma separated list of file systems which have a file system dependent security context in SELinux. In new-style Python modules, if you really need this you should instantiate an <code>AnsibleModule</code> and then use <code>AnsibleModule._selinux_special_fs</code>. The variable has also changed from a comma separated string of file system names to an actual python list of filesystem names.</li> <li>
<code>&lt;&lt;INCLUDE_ANSIBLE_MODULE_JSON_ARGS&gt;&gt;</code> substitutes the module parameters as a JSON string. Care must be taken to properly quote the string as JSON data may contain quotes. This pattern is not substituted in new-style Python modules as they can get the module parameters another way.</li> <li>The string <code>syslog.LOG_USER</code> is replaced wherever it occurs with the <code>syslog_facility</code> which was named in <code>ansible.cfg</code> or any <code>ansible_syslog_facility</code> inventory variable that applies to this host. In new-style Python modules this has changed slightly. If you really need to access it, you should instantiate an <code>AnsibleModule</code> and then use <code>AnsibleModule._syslog_facility</code> to access it. It is no longer the actual syslog facility and is now the name of the syslog facility. See the <a class="reference internal" href="#flow-internal-arguments"><span class="std std-ref">documentation on internal arguments</span></a> for details.</li> </ul> </li> </ul>   <h4 id="id2">Ansiballz</h4> <p id="ansiballz">Ansible 2.1 switched from the <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a> framework to the Ansiballz framework for assembling modules. The Ansiballz framework differs from module replacer in that it uses real Python imports of things in <code>ansible/module_utils</code> instead of merely preprocessing the module. It does this by constructing a zipfile – which includes the module file, files in <code>ansible/module_utils</code> that are imported by the module, and some boilerplate to pass in the module’s parameters. The zipfile is then Base64 encoded and wrapped in a small Python script which decodes the Base64 encoding and places the zipfile into a temp directory on the managed node. It then extracts just the ansible module script from the zip file and places that in the temporary directory as well. Then it sets the PYTHONPATH to find python modules inside of the zip file and invokes <strong class="command">python</strong> on the extracted ansible module.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Ansible wraps the zipfile in the Python script for two reasons:</p> <ul class="last simple"> <li>for compatibility with Python-2.4 and Python-2.6 which have less featureful versions of Python’s <code>-m</code> command line switch.</li> <li>so that pipelining will function properly. Pipelining needs to pipe the Python module into the Python interpreter on the remote node. Python understands scripts on stdin but does not understand zip files.</li> </ul> </div> <p>In Ansiballz, any imports of Python modules from the <code>ansible.module_utils</code> package trigger inclusion of that Python file into the zipfile. Instances of <code>#&lt;&lt;INCLUDE_ANSIBLE_MODULE_COMMON&gt;&gt;</code> in the module are turned into <code>from ansible.module_utils.basic import *</code> and <code>ansible/module-utils/basic.py</code> is then included in the zipfile. Files that are included from <code>module_utils</code> are themselves scanned for imports of other Python modules from <code>module_utils</code> to be included in the zipfile as well.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">At present, the Ansiballz Framework cannot determine whether an import should be included if it is a relative import. Always use an absolute import that has <code>ansible.module_utils</code> in it to allow Ansiballz to determine that the file should be included.</p> </div>  <h5 id="flow-passing-module-args">Passing args</h5> <p id="passing-args">In <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a>, module arguments are turned into a JSON-ified string and substituted into the combined module file. In <a class="reference internal" href="#ansiballz"><span class="std std-ref">Ansiballz</span></a>, the JSON-ified string is passed into the module via stdin. When a <code>ansible.module_utils.basic.AnsibleModule</code> is instantiated, it parses this string and places the args into <code>AnsibleModule.params</code> where it can be accessed by the module’s other code.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Internally, the <code>AnsibleModule</code> uses the helper function, <code>ansible.module_utils.basic._load_params()</code>, to load the parameters from stdin and save them into an internal global variable. Very dynamic custom modules which need to parse the parameters prior to instantiating an <code>AnsibleModule</code> may use <code>_load_params</code> to retrieve the parameters. Be aware that <code>_load_params</code> is an internal function and may change in breaking ways if necessary to support changes in the code. However, we’ll do our best not to break it gratuitously, which is not something that can be said for either the way parameters are passed or the internal global variable.</p> </div>    <h4 id="flow-internal-arguments">Internal arguments</h4> <p id="internal-arguments">Both <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a> and <a class="reference internal" href="#ansiballz"><span class="std std-ref">Ansiballz</span></a> send additional arguments to the module beyond those which the user specified in the playbook. These additional arguments are internal parameters that help implement global Ansible features. Modules often do not need to know about these explicitly as the features are implemented in <code>ansible.module_utils.basic</code> but certain features need support from the module so it’s good to know about them.</p>  <h5 id="ansible-no-log">_ansible_no_log</h5> <p>This is a boolean. If it’s True then the playbook specified <code>no_log</code> (in a task’s parameters or as a play parameter). This automatically affects calls to <code>AnsibleModule.log()</code>. If a module implements its own logging then it needs to check this value. The best way to look at this is for the module to instantiate an <code>AnsibleModule</code> and then check the value of <code>AnsibleModule.no_log</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>no_log</code> specified in a module’s argument_spec are handled by a different mechanism.</p> </div>   <h5 id="ansible-debug">_ansible_debug</h5> <p>This is a boolean that turns on more verbose logging. If a module uses <code>AnsibleModule.debug()</code> rather than <code>AnsibleModule.log()</code> then the messages are only logged if this is True. This also turns on logging of external commands that the module executes. This can be changed via the``debug`` setting in <code>ansible.cfg</code> or the environment variable <code id="index-0">ANSIBLE_DEBUG</code>. If, for some reason, a module must access this, it should do so by instantiating an <code>AnsibleModule</code> and accessing <code>AnsibleModule._debug</code>.</p>   <h5 id="ansible-diff">_ansible_diff</h5> <p>This boolean is turned on via the <code>--diff</code> command line option. If a module supports it, it will tell the module to show a unified diff of changes to be made to templated files. The proper way for a module to access this is by instantiating an <code>AnsibleModule</code> and accessing <code>AnsibleModule._diff</code>.</p>   <h5 id="ansible-verbosity">_ansible_verbosity</h5> <p>This value could be used for finer grained control over logging. However, it is currently unused.</p>   <h5 id="ansible-selinux-special-fs">_ansible_selinux_special_fs</h5> <p>This is a list of names of filesystems which should have a special selinux context. They are used by the <code>AnsibleModule</code> methods which operate on files (changing attributes, moving, and copying). The list of names is set via a comma separated string of filesystem names from <code>ansible.cfg</code>:</p> <pre data-language="yaml"># ansible.cfg
[selinux]
special_context_filesystems=nfs,vboxsf,fuse,ramfs
</pre> <p>If a module cannot use the builtin <code>AnsibleModule</code> methods to manipulate files and needs to know about these special context filesystems, it should instantiate an <code>AnsibleModule</code> and then examine the list in <code>AnsibleModule._selinux_special_fs</code>.</p> <p>This replaces <code>ansible.module_utils.basic.SELINUX_SPECIAL_FS</code> from <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a>. In module replacer it was a comma separated string of filesystem names. Under Ansiballz it’s an actual list.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 2.1.</span></p> </div>   <h5 id="ansible-syslog-facility">_ansible_syslog_facility</h5> <p>This parameter controls which syslog facility ansible module logs to. It may be set by changing the <code>syslog_facility</code> value in <code>ansible.cfg</code>. Most modules should just use <code>AnsibleModule.log()</code> which will then make use of this. If a module has to use this on its own, it should instantiate an <code>AnsibleModule</code> and then retrieve the name of the syslog facility from <code>AnsibleModule._syslog_facility</code>. The code will look slightly different than it did under <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a> due to how hacky the old way was:</p> <pre data-language="yaml"># Old way
import syslog
syslog.openlog(NAME, 0, syslog.LOG_USER)

# New way
import syslog
facility_name = module._syslog_facility
facility = getattr(syslog, facility_name, syslog.LOG_USER)
syslog.openlog(NAME, 0, facility)
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 2.1.</span></p> </div>   <h5 id="ansible-version">_ansible_version</h5> <p>This parameter passes the version of ansible that runs the module. To access it, a module should instantiate an <code>AnsibleModule</code> and then retrieve it from <code>AnsibleModule.ansible_version</code>. This replaces <code>ansible.module_utils.basic.ANSIBLE_VERSION</code> from <a class="reference internal" href="#module-replacer"><span class="std std-ref">Module Replacer</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 2.1.</span></p> </div>     <h3 id="flow-special-considerations">Special Considerations</h3>  <h4 id="flow-pipelining">Pipelining</h4> <p id="special-considerations">Ansible can transfer a module to a remote machine in one of two ways:</p> <ul class="simple"> <li>it can write out the module to a temporary file on the remote host and then use a second connection to the remote host to execute it with the interpreter that the module needs</li> <li>or it can use what’s known as pipelining to execute the module by piping it into the remote interpreter’s stdin.</li> </ul> <p>Pipelining only works with modules written in Python at this time because Ansible only knows that Python supports this mode of operation. Supporting pipelining means that whatever format the module payload takes before being sent over the wire must be executable by Python via stdin.</p>   <h4 id="flow-args-over-stdin">Why pass args over stdin?</h4> <p id="why-pass-args-over-stdin">Passing arguments via stdin was chosen for the following reasons:</p> <ul class="simple"> <li>When combined with <a class="reference internal" href="../../intro_configuration/#pipelining"><span class="std std-ref">pipelining</span></a>, this keeps the module’s arguments from temporarily being saved onto disk on the remote machine. This makes it harder (but not impossible) for a malicious user on the remote machine to steal any sensitive information that may be present in the arguments.</li> <li>Command line arguments would be insecure as most systems allow unprivileged users to read the full commandline of a process.</li> <li>Environment variables are usually more secure than the commandline but some systems limit the total size of the environment. This could lead to truncation of the parameters if we hit that limit.</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2016 Michael DeHaan<br>© 2016 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/dev_guide/developing_program_flow_modules.html" class="_attribution-link" target="_blank">https://docs.ansible.com/ansible/dev_guide/developing_program_flow_modules.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
