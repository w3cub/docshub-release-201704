
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Storage&#92;Handler&#92;PdoSessionHandler (Component&#92;HttpFoundation&#92;Session) - Symfony 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" class PdoSessionHandler implements SessionHandlerInterface ">
  <meta name="keywords" content="symfony, component, httpfoundation, session, storage, handler, pdosessionhandler, -, symfony~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/symfony~2.7/symfony/component/httpfoundation/session/storage/handler/pdosessionhandler/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/symfony~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/symfony~2.7/" class="_nav-link" title="" style="margin-left:0;">Symfony 2.7</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _laravel">
				
<h1>Symfony\Component\HttpFoundation\Session\Storage\Handler\PdoSessionHandler</h1>  <p> class <strong>PdoSessionHandler</strong> implements <a href="http://php.net/SessionHandlerInterface" title="SessionHandlerInterface" target="_blank">SessionHandlerInterface</a></p> <div class="description"> <p>Session handler using a PDO connection to read and write data.</p> <p>It works with MySQL, PostgreSQL, Oracle, SQL Server and SQLite and implements different locking strategies to handle concurrent access to the same session. Locking is necessary to prevent loss of data due to race conditions and to keep the session data consistent between read() and write(). With locking, requests for the same session will wait until the other one finished writing. For this reason it's best practice to close a session as early as possible to improve concurrency. PHPs internal files session handler also implements locking.</p> <p>Attention: Since SQLite does not support row level locks but locks the whole database, it means only one session can be accessed at a time. Even different sessions would wait for another to finish. So saving session in SQLite should only be considered for development or prototypes.</p> <p>Session data is a binary string that can contain non-printable characters like the null byte. For this reason it must be saved in a binary column in the database like BLOB in MySQL. Saving it in a character column could corrupt the data. You can use createTable() to initialize a correctly defined table.</p> </div> <h2>Constants</h2> <table> <tr> <td>LOCK_NONE</td> <td class="last"> <p><em>No locking is done.</em></p> <p>This means sessions are prone to loss of data due to race conditions of concurrent requests to the same session. The last session write will win in this case. It might be useful when you implement your own logic to deal with this like an optimistic approach.</p> </td> </tr> <tr> <td>LOCK_ADVISORY</td> <td class="last"> <p><em>Creates an application-level lock on a session.</em></p> <p>The disadvantage is that the lock is not enforced by the database and thus other, unaware parts of the application could still concurrently modify the session. The advantage is it does not require a transaction. This mode is not available for SQLite and not yet implemented for oci and sqlsrv.</p> </td> </tr> <tr> <td>LOCK_TRANSACTIONAL</td> <td class="last"> <p><em>Issues a real row lock.</em></p> <p>Since it uses a transaction between opening and closing a session, you have to be careful when you use same database connection that you also use for your application logic. This mode is the default because it's the only reliable solution across DBMSs.</p> </td> </tr> </table> <h2>Methods</h2> <table> <tr> <td class="type"> </td> <td class="last"> <a href="#method___construct">__construct</a>(<a href="http://php.net/PDO" title="PDO" target="_blank">PDO</a>|string|null $pdoOrDsn = null, array $options = array()) <p>Constructor.</p> </td> <td></td> </tr> <tr> <td class="type"> </td> <td class="last"> <a href="#method_createTable">createTable</a>() <p>Creates the table to store sessions which can be called once for setup.</p> </td> <td></td> </tr> <tr> <td class="type"> bool </td> <td class="last"> <a href="#method_isSessionExpired">isSessionExpired</a>() <p>Returns true when the current session exists but expired according to session.gc_maxlifetime.</p> </td> <td></td> </tr> <tr> <td class="type"> </td> <td class="last"> <a href="#method_open">open</a>($savePath, $sessionName) <p>{@inheritdoc}</p> </td> <td></td> </tr> <tr> <td class="type"> </td> <td class="last"> <a href="#method_read">read</a>($sessionId) <p>{@inheritdoc}</p> </td> <td></td> </tr> <tr> <td class="type"> </td> <td class="last"> <a href="#method_gc">gc</a>($maxlifetime) <p>{@inheritdoc}</p> </td> <td></td> </tr> <tr> <td class="type"> </td> <td class="last"> <a href="#method_destroy">destroy</a>($sessionId) <p>{@inheritdoc}</p> </td> <td></td> </tr> <tr> <td class="type"> </td> <td class="last"> <a href="#method_write">write</a>($sessionId, $data) <p>{@inheritdoc}</p> </td> <td></td> </tr> <tr> <td class="type"> </td> <td class="last"> <a href="#method_close">close</a>() <p>{@inheritdoc}</p> </td> <td></td> </tr> </table> <h2>Details</h2> <h3 id="method___construct">              public            
    __construct(<a href="http://php.net/PDO" title="PDO" target="_blank">PDO</a>|string|null $pdoOrDsn = null, array $options = array()) </h3>  <p>Constructor.</p> <p>You can either pass an existing database connection as PDO instance or pass a DSN string that will be used to lazy-connect to the database when the session is actually used. Furthermore it's possible to pass null which will then use the session.save_path ini setting as PDO DSN parameter.</p> <p>List of available options: * db<em>table: The name of the table [default: sessions] * db</em>id<em>col: The column where to store the session id [default: sess</em>id] * db<em>data</em>col: The column where to store the session data [default: sess<em>data] * db</em>lifetime<em>col: The column where to store the lifetime [default: sess</em>lifetime] * db<em>time</em>col: The column where to store the timestamp [default: sess<em>time] * db</em>username: The username when lazy-connect [default: ''] * db<em>password: The password when lazy-connect [default: ''] * db</em>connection<em>options: An array of driver-specific connection options [default: array()] * lock</em>mode: The strategy for locking, see constants [default: LOCK_TRANSACTIONAL]</p> <div class="tags"> <h4>Parameters</h4> <table> <tr> <td>
<a href="http://php.net/PDO" title="PDO" target="_blank">PDO</a>|string|null</td> <td>$pdoOrDsn</td> <td>A \PDO instance or DSN string or null</td> </tr> <tr> <td>array</td> <td>$options</td> <td>An associative array of options</td> </tr> </table> <h4>Exceptions</h4> <table> <tr> <td><a href="http://php.net/InvalidArgumentException" title="InvalidArgumentException" target="_blank">InvalidArgumentException</a></td> <td>When PDO error mode is not PDO::ERRMODE_EXCEPTION</td> </tr> </table> </div>  <h3 id="method_createTable">              public            
    createTable() </h3>  <p>Creates the table to store sessions which can be called once for setup.</p> <p>Session ID is saved in a column of maximum length 128 because that is enough even for a 512 bit configured session.hash_function like Whirlpool. Session data is saved in a BLOB. One could also use a shorter inlined varbinary column if one was sure the data fits into it.</p> <div class="tags"> <h4>Exceptions</h4> <table> <tr> <td><a href="http://php.net/PDOException" title="PDOException" target="_blank">PDOException</a></td> <td>When the table already exists</td> </tr> <tr> <td><a href="http://php.net/DomainException" title="DomainException" target="_blank">DomainException</a></td> <td>When an unsupported PDO driver is used</td> </tr> </table> </div>  <h3 id="method_isSessionExpired">              public            bool
    isSessionExpired() </h3>  <p>Returns true when the current session exists but expired according to session.gc_maxlifetime.</p> <p>Can be used to distinguish between a new session and one that expired due to inactivity.</p> <div class="tags"> <h4>Return Value</h4> <table> <tr> <td>bool</td> <td>Whether current session expired</td> </tr> </table> </div>  <h3 id="method_open">              public            
    open($savePath, $sessionName) </h3>  <p>{@inheritdoc}</p>  <div class="tags"> <h4>Parameters</h4> <table> <tr> <td></td> <td>$savePath</td> <td> </td> </tr> <tr> <td></td> <td>$sessionName</td> <td> </td> </tr> </table> </div>  <h3 id="method_read">              public            
    read($sessionId) </h3>  <p>{@inheritdoc}</p>  <div class="tags"> <h4>Parameters</h4> <table> <tr> <td></td> <td>$sessionId</td> <td> </td> </tr> </table> </div>  <h3 id="method_gc">              public            
    gc($maxlifetime) </h3>  <p>{@inheritdoc}</p>  <div class="tags"> <h4>Parameters</h4> <table> <tr> <td></td> <td>$maxlifetime</td> <td> </td> </tr> </table> </div>  <h3 id="method_destroy">              public            
    destroy($sessionId) </h3>  <p>{@inheritdoc}</p>  <div class="tags"> <h4>Parameters</h4> <table> <tr> <td></td> <td>$sessionId</td> <td> </td> </tr> </table> </div>  <h3 id="method_write">              public            
    write($sessionId, $data) </h3>  <p>{@inheritdoc}</p>  <div class="tags"> <h4>Parameters</h4> <table> <tr> <td></td> <td>$sessionId</td> <td> </td> </tr> <tr> <td></td> <td>$data</td> <td> </td> </tr> </table> </div>  <h3 id="method_close">              public            
    close() </h3>  <p>{@inheritdoc}</p>  <div class="_attribution">
  <p class="_attribution-p">
    © 2004–2016 Fabien Potencier<br>Licensed under the MIT License.<br>
    <a href="http://api.symfony.com/2.7/Symfony/Component/HttpFoundation/Session/Storage/Handler/PdoSessionHandler.html" class="_attribution-link" target="_blank">http://api.symfony.com/2.7/Symfony/Component/HttpFoundation/Session/Storage/Handler/PdoSessionHandler.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
