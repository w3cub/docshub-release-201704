
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Perlunicode - Perl 5.20 - W3cubDocs</title>
  
  <meta name="description" content=" perlunicode - Unicode support in Perl ">
  <meta name="keywords" content="perlunicode, -, perl, perl~5.20">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/perl~5.20/perlunicode/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/perl~5.20.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.20/" class="_nav-link" title="" style="margin-left:0;">Perl 5.20</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _perl">
				
<h1>perlunicode</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li>
<a href="#DESCRIPTION">DESCRIPTION</a><ul>
<li><a href="#Important-Caveats">Important Caveats</a></li>
<li><a href="#Byte-and-Character-Semantics">Byte and Character Semantics</a></li>
<li><a href="#Effects-of-Character-Semantics">Effects of Character Semantics</a></li>
<li><a href="#Unicode-Character-Properties">Unicode Character Properties</a></li>
<li><a href="#User-Defined-Character-Properties">User-Defined Character Properties</a></li>
<li><a href="#User-Defined-Case-Mappings-(for-serious-hackers-only)">User-Defined Case Mappings (for serious hackers only)</a></li>
<li><a href="#Character-Encodings-for-Input-and-Output">Character Encodings for Input and Output</a></li>
<li><a href="#Unicode-Regular-Expression-Support-Level">Unicode Regular Expression Support Level</a></li>
<li><a href="#Unicode-Encodings">Unicode Encodings</a></li>
<li><a href="#Non-character-code-points">Non-character code points</a></li>
<li><a href="#Beyond-Unicode-code-points">Beyond Unicode code points</a></li>
<li><a href="#Security-Implications-of-Unicode">Security Implications of Unicode</a></li>
<li><a href="#Unicode-in-Perl-on-EBCDIC">Unicode in Perl on EBCDIC</a></li>
<li><a href="#Locales">Locales</a></li>
<li><a href="#When-Unicode-Does-Not-Happen">When Unicode Does Not Happen</a></li>
<li><a href="#The-%22Unicode-Bug%22">The "Unicode Bug"</a></li>
<li><a href="#Forcing-Unicode-in-Perl-(Or-Unforcing-Unicode-in-Perl)">Forcing Unicode in Perl (Or Unforcing Unicode in Perl)</a></li>
<li><a href="#Using-Unicode-in-XS">Using Unicode in XS</a></li>
<li><a href="#Hacking-Perl-to-work-on-earlier-Unicode-versions-(for-very-serious-hackers-only)">Hacking Perl to work on earlier Unicode versions (for very serious hackers only)</a></li>
</ul>
</li>
<li>
<a href="#BUGS">BUGS</a><ul>
<li><a href="#Interaction-with-Locales">Interaction with Locales</a></li>
<li><a href="#Problems-with-characters-in-the-Latin-1-Supplement-range">Problems with characters in the Latin-1 Supplement range</a></li>
<li><a href="#Interaction-with-Extensions">Interaction with Extensions</a></li>
<li><a href="#Speed">Speed</a></li>
<li><a href="#Problems-on-EBCDIC-platforms">Problems on EBCDIC platforms</a></li>
<li><a href="#Porting-code-from-perl-5.6.X">Porting code from perl-5.6.X</a></li>
</ul>
</li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>perlunicode - Unicode support in Perl</p> <h2 id="DESCRIPTION">DESCRIPTION</h2> <h3 id="Important-Caveats">Important Caveats</h3> <p>Unicode support is an extensive requirement. While Perl does not implement the Unicode standard or the accompanying technical reports from cover to cover, Perl does support many Unicode features.</p> <p>People who want to learn to use Unicode in Perl, should probably read the <a href="../perlunitut/">Perl Unicode tutorial, perlunitut</a> and <a href="../perluniintro/">perluniintro</a>, before reading this reference document.</p> <p>Also, the use of Unicode may present security issues that aren't obvious. Read <a href="http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36" target="_blank">Unicode Security Considerations</a>.</p> <ul> <li id="Safest-if-you-use-feature-'unicode_strings'">
<b>Safest if you <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> </b> <p>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> is specified. (This is automatically selected if you use <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="n">5.012</span></code> or higher.) Failure to do this can trigger unexpected surprises. See <a href="#The-%22Unicode-Bug%22">The Unicode Bug</a> below.</p> <p>This pragma doesn't affect I/O. Nor does it change the internal representation of strings, only their interpretation. There are still several places where Unicode isn't fully supported, such as in filenames.</p> </li> <li id="Input-and-Output-Layers">
<b>Input and Output Layers</b> <p>Perl knows when a filehandle uses Perl's internal Unicode encodings (UTF-8, or UTF-EBCDIC if in EBCDIC) if the filehandle is opened with the <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span><span class="w">utf8</span><span class="s">)</span></code> layer. Other encodings can be converted to Perl's encoding on input or from Perl's encoding on output by use of the <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span>...<span class="s">)</span></code> layer. See <a href="../open/">open</a>.</p> <p>To indicate that Perl source itself is in UTF-8, use <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">utf8</span><span class="sc">;</span></code> .</p> </li> <li id="use-utf8-still-needed-to-enable-UTF-8%2fUTF-EBCDIC-in-scripts">
<b><code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">utf8</span></code> still needed to enable UTF-8/UTF-EBCDIC in scripts</b> <p>As a compatibility measure, the <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">utf8</span></code> pragma must be explicitly included to enable recognition of UTF-8 in the Perl scripts themselves (in string or regular expression literals, or in identifier names) on ASCII-based machines or to recognize UTF-EBCDIC on EBCDIC-based machines. <b>These are the only times when an explicit <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">utf8</span></code> is needed.</b> See <a href="../utf8/">utf8</a>.</p> </li> <li id="BOM-marked-scripts-and-UTF-16-scripts-autodetected">
<b><code class="inline"><span class="w">BOM</span></code> -marked scripts and UTF-16 scripts autodetected</b> <p>If a Perl script begins marked with the Unicode <code class="inline"><span class="w">BOM</span></code> (UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like non-<code class="inline"><span class="w">BOM</span></code> -marked UTF-16 of either endianness, Perl will correctly read in the script as Unicode. (<code class="inline"><span class="w">BOM</span></code> less UTF-8 cannot be effectively recognized or differentiated from ISO 8859-1 or other eight-bit encodings.)</p> </li> <li id="use-encoding-needed-to-upgrade-non-Latin-1-byte-strings">
<b><code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">encoding</span></code> needed to upgrade non-Latin-1 byte strings</b> <p>By default, there is a fundamental asymmetry in Perl's Unicode model: implicit upgrading from byte strings to Unicode strings assumes that they were encoded in <i>ISO 8859-1 (Latin-1)</i>, but Unicode strings are downgraded with UTF-8 encoding. This happens because the first 256 codepoints in Unicode happens to agree with Latin-1.</p> <p>See <a href="#Byte-and-Character-Semantics">Byte and Character Semantics</a> for more details.</p> </li> </ul> <h3 id="Byte-and-Character-Semantics">Byte and Character Semantics</h3> <p>Perl uses logically-wide characters to represent strings internally.</p> <p>Starting in Perl 5.14, Perl-level operations work with characters rather than bytes within the scope of a <code class="inline"><a href="../feature/">use feature 'unicode_strings'</a></code> (or equivalently <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="n">5.012</span></code> or higher). (This is not true if bytes have been explicitly requested by <code class="inline"><a href="../bytes/">use bytes</a></code>, nor necessarily true for interactions with the platform's operating system.)</p> <p>For earlier Perls, and when <code class="inline"><span class="w">unicode_strings</span></code> is not in effect, Perl provides a fairly safe environment that can handle both types of semantics in programs. For operations where Perl can unambiguously decide that the input data are characters, Perl switches to character semantics. For operations where this determination cannot be made without additional information from the user, Perl decides in favor of compatibility and chooses to use byte semantics.</p> <p>When <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">locale</span></code> (but not <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">locale</span> <span class="q">':not_characters'</span></code> ) is in effect, Perl uses the rules associated with the current locale. (<code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">locale</span></code> overrides <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> in the same scope; while <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">locale</span> <span class="q">':not_characters'</span></code> effectively also selects <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> in its scope; see <a href="../perllocale/">perllocale</a>.) Otherwise, Perl uses the platform's native byte semantics for characters whose code points are less than 256, and Unicode rules for those greater than 255. That means that non-ASCII characters are undefined except for their ordinal numbers. This means that none have case (upper and lower), nor are any a member of character classes, like <code class="inline">[:alpha:]</code> or <code class="inline">\<span class="w">w</span></code> . (But all do belong to the <code class="inline">\<span class="w">W</span></code> class or the Perl regular expression extension <code class="inline">[:^alpha:]</code>.)</p> <p>This behavior preserves compatibility with earlier versions of Perl, which allowed byte semantics in Perl operations only if none of the program's inputs were marked as being a source of Unicode character data. Such data may come from filehandles, from calls to external programs, from information provided by the system (such as <code class="inline"><span class="i">%ENV</span></code> ), or from literals and constants in the source text.</p> <p>The <code class="inline"><span class="w">utf8</span></code> pragma is primarily a compatibility device that enables recognition of UTF-(8|EBCDIC) in literals encountered by the parser. Note that this pragma is only required while Perl defaults to byte semantics; when character semantics become the default, this pragma may become a no-op. See <a href="../utf8/">utf8</a>.</p> <p>If strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will have character semantics. This can cause surprises: See <a href="#BUGS">BUGS</a>, below. You can choose to be warned when this happens. See <code class="inline"><a href="../encoding/warnings/">encoding::warnings</a></code>.</p> <p>Under character semantics, many operations that formerly operated on bytes now operate on characters. A character in Perl is logically just a number ranging from 0 to 2**31 or so. Larger characters may encode into longer sequences of bytes internally, but this internal detail is mostly hidden for Perl code. See <a href="../perluniintro/">perluniintro</a> for more.</p> <h3 id="Effects-of-Character-Semantics">Effects of Character Semantics</h3> <p>Character semantics have the following effects:</p> <ul> <li> <p>Strings--including hash keys--and regular expression patterns may contain characters that have an ordinal value larger than 255.</p> <p>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a <code class="inline"><span class="w">BOM</span></code> or <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">utf8</span></code> , the latter requires a <code class="inline"><span class="w">BOM</span></code> .)</p> <p>Unicode characters can also be added to a string by using the <code class="inline">\<span class="i">N</span><span class="s">{</span><span class="w">U</span>+...<span class="s">}</span></code> notation. The Unicode code for the desired character, in hexadecimal, should be placed in the braces, after the <code class="inline"><span class="w">U</span></code> . For instance, a smiley face is <code class="inline">\N{U+263A}</code>.</p> <p>Alternatively, you can use the <code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code> notation for characters <code class="inline"><span class="n">0x100</span></code> and above. For characters below <code class="inline"><span class="n">0x100</span></code> you may get byte semantics instead of character semantics; see <a href="#The-%22Unicode-Bug%22">The Unicode Bug</a>. On EBCDIC machines there is the additional problem that the value for such characters gives the EBCDIC character rather than the Unicode one, thus it is more portable to use <code class="inline">\<span class="i">N</span><span class="s">{</span><span class="w">U</span>+...<span class="s">}</span></code> instead.</p> <p>Additionally, you can use the <code class="inline">\<span class="i">N</span><span class="s">{</span>...<span class="s">}</span></code> notation and put the official Unicode character name within the braces, such as <code class="inline">\<span class="i">N</span><span class="s">{</span><span class="w">WHITE</span> <span class="w">SMILING</span> <span class="w">FACE</span><span class="s">}</span></code> . This automatically loads the <a href="../charnames/">charnames</a> module with the <code class="inline"><span class="j">:</span><span class="w">full</span></code> and <code class="inline"><span class="j">:</span><span class="w">short</span></code> options. If you prefer different options for this module, you can instead, before the <code class="inline">\<span class="i">N</span><span class="s">{</span>...<span class="s">}</span></code> , explicitly load it with your desired options; for example,</p> <pre class="verbatim" data-language="perl">use charnames ':loose';
</pre>
</li> <li> <p>If an appropriate <a href="../encoding/">encoding</a> is specified, identifiers within the Perl script may contain Unicode alphanumeric characters, including ideographs. Perl does not currently attempt to canonicalize variable names.</p> </li> <li> <p>Regular expressions match characters instead of bytes. <code class="inline"><span class="q">"."</span></code> matches a character instead of a byte.</p> </li> <li> <p>Bracketed character classes in regular expressions match characters instead of bytes and match against the character properties specified in the Unicode properties database. <code class="inline">\<span class="w">w</span></code> can be used to match a Japanese ideograph, for instance.</p> </li> <li> <p>Named Unicode properties, scripts, and block ranges may be used (like bracketed character classes) by using the <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> "matches property" construct and the <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> negation, "doesn't match property". See <a href="#Unicode-Character-Properties">Unicode Character Properties</a> for more details.</p> <p>You can define your own character properties and use them in the regular expression with the <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> or <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> construct. See <a href="#User-Defined-Character-Properties">User-Defined Character Properties</a> for more details.</p> </li> <li> <p>The special pattern <code class="inline">\<span class="w">X</span></code> matches a logical character, an "extended grapheme cluster" in Standardese. In Unicode what appears to the user to be a single character, for example an accented <code class="inline"><span class="w">G</span></code> , may in fact be composed of a sequence of characters, in this case a <code class="inline"><span class="w">G</span></code> followed by an accent character. <code class="inline">\<span class="w">X</span></code> will match the entire sequence.</p> </li> <li> <p>The <code class="inline"><a class="l_k" href="../functions/tr/">tr///</a></code> operator translates characters instead of bytes. Note that the <code class="inline"><a class="l_k" href="../functions/tr/">tr///CU</a></code> functionality has been removed. For similar functionality see pack('U0', ...) and pack('C0', ...).</p> </li> <li> <p>Case translation operators use the Unicode case translation tables when character input is provided. Note that <code class="inline"><a class="l_k" href="../functions/uc/">uc()</a></code>, or <code class="inline">\<span class="w">U</span></code> in interpolated strings, translates to uppercase, while <code class="inline"><a class="l_k" href="../functions/ucfirst/">ucfirst</a></code>, or <code class="inline">\<span class="w">u</span></code> in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</p> </li> <li> <p>Most operators that deal with positions or lengths in a string will automatically switch to using character positions, including <code class="inline"><a class="l_k" href="../functions/chop/">chop()</a></code>, <code class="inline"><a class="l_k" href="../functions/chomp/">chomp()</a></code>, <code class="inline"><a class="l_k" href="../functions/substr/">substr()</a></code>, <code class="inline"><a class="l_k" href="../functions/pos/">pos()</a></code>, <code class="inline"><a class="l_k" href="../functions/">index()</a></code>, <code class="inline"><a class="l_k" href="../functions/rindex/">rindex()</a></code>, <code class="inline"><a class="l_k" href="../functions/sprintf/">sprintf()</a></code>, <code class="inline"><a class="l_k" href="../functions/write/">write()</a></code>, and <code class="inline"><a class="l_k" href="../functions/length/">length()</a></code>. An operator that specifically does not switch is <code class="inline"><a class="l_k" href="../functions/vec/">vec()</a></code>. Operators that really don't care include operators that treat strings as a bucket of bits such as <code class="inline"><a class="l_k" href="../functions/sort/">sort()</a></code>, and operators dealing with filenames.</p> </li> <li> <p>The <code class="inline"><a class="l_k" href="../functions/pack/">pack()</a></code>/<code class="inline"><a class="l_k" href="../functions/unpack/">unpack()</a></code> letter <code class="inline"><span class="w">C</span></code> does <i>not</i> change, since it is often used for byte-oriented formats. Again, think <code class="inline"><span class="w">char</span></code> in the C language.</p> <p>There is a new <code class="inline"><span class="w">U</span></code> specifier that converts between Unicode characters and code points. There is also a <code class="inline"><span class="w">W</span></code> specifier that is the equivalent of <code class="inline"><a class="l_k" href="../functions/chr/">chr</a></code>/<code class="inline"><a class="l_k" href="../functions/ord/">ord</a></code> and properly handles character values even if they are above 255.</p> </li> <li> <p>The <code class="inline"><a class="l_k" href="../functions/chr/">chr()</a></code> and <code class="inline"><a class="l_k" href="../functions/ord/">ord()</a></code> functions work on characters, similar to <code class="inline"><a class="l_k" href="../functions/pack/">pack("W")</a></code> and <code class="inline"><a class="l_k" href="../functions/unpack/">unpack("W")</a></code>, <i>not</i> <code class="inline"><a class="l_k" href="../functions/pack/">pack("C")</a></code> and <code class="inline"><a class="l_k" href="../functions/unpack/">unpack("C")</a></code>. <code class="inline"><a class="l_k" href="../functions/pack/">pack("C")</a></code> and <code class="inline"><a class="l_k" href="../functions/unpack/">unpack("C")</a></code> are methods for emulating byte-oriented <code class="inline"><a class="l_k" href="../functions/chr/">chr()</a></code> and <code class="inline"><a class="l_k" href="../functions/ord/">ord()</a></code> on Unicode strings. While these methods reveal the internal encoding of Unicode strings, that is not something one normally needs to care about at all.</p> </li> <li> <p>The bit string operators, <code class="inline"><span class="i">&amp; |</span> ^ ~</code> , can operate on character data. However, for backward compatibility, such as when using bit string operations when characters are all less than 256 in ordinal value, one should not use <code class="inline">~</code> (the bit complement) with characters of both values less than 256 and values greater than 256. Most importantly, DeMorgan's laws (<code class="inline">~<span class="s">(</span><span class="i">$x</span>|<span class="i">$y</span><span class="s">)</span> eq ~<span class="i">$x</span>&amp;~<span class="i">$y</span></code> and <code class="inline">~<span class="s">(</span><span class="i">$x</span>&amp;<span class="i">$y</span><span class="s">)</span> eq ~<span class="i">$x</span>|~<span class="i">$y</span></code> ) will not hold. The reason for this mathematical <i>faux pas</i> is that the complement cannot return <b>both</b> the 8-bit (byte-wide) bit complement <b>and</b> the full character-wide bit complement.</p> </li> <li> <p>There is a CPAN module, <code class="inline"><a href="http://search.cpan.org/perldoc/Unicode::Casing" target="_blank">Unicode::Casing</a></code>, which allows you to define your own mappings to be used in <code class="inline"><a class="l_k" href="../functions/lc/">lc()</a></code>, <code class="inline"><a class="l_k" href="../functions/lcfirst/">lcfirst()</a></code>, <code class="inline"><a class="l_k" href="../functions/uc/">uc()</a></code>, <code class="inline"><a class="l_k" href="../functions/ucfirst/">ucfirst()</a></code>, and <code class="inline"><a class="l_k" href="../functions/fc/">fc</a></code> (or their double-quoted string inlined versions such as <code class="inline">\<span class="w">U</span></code> ). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</p> </li> </ul> <ul> <li> <p>And finally, <code class="inline"><a class="l_k" href="../functions/scalar/">scalar</a> <a class="l_k" href="../functions/reverse/">reverse</a><span class="s">(</span><span class="s">)</span></code> reverses by character rather than by byte.</p> </li> </ul> <h3 id="Unicode-Character-Properties">Unicode Character Properties</h3> <p>(The only time that Perl considers a sequence of individual code points as a single logical character is in the <code class="inline">\<span class="w">X</span></code> construct, already mentioned above. Therefore "character" in this discussion means a single Unicode code point.)</p> <p>Very nearly all Unicode character properties are accessible through regular expressions by using the <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> "matches property" construct and the <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> "doesn't match property" for its negation.</p> <p>For instance, <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Uppercase</span><span class="s">}</span></code> matches any single character with the Unicode <code class="inline"><span class="q">"Uppercase"</span></code> property, while <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">L</span><span class="s">}</span></code> matches any character with a <code class="inline"><span class="w">General_Category</span></code> of <code class="inline"><span class="q">"L"</span></code> (letter) property (see <a href="#General_Category">General_Category</a> below). Brackets are not required for single letter property names, so <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">L</span><span class="s">}</span></code> is equivalent to <code class="inline">\<span class="w">pL</span></code> .</p> <p>More formally, <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Uppercase</span><span class="s">}</span></code> matches any single character whose Unicode <code class="inline"><span class="w">Uppercase</span></code> property value is <code class="inline"><span class="w">True</span></code> , and <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">Uppercase</span><span class="s">}</span></code> matches any character whose <code class="inline"><span class="w">Uppercase</span></code> property value is <code class="inline"><span class="w">False</span></code> , and they could have been written as <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Uppercase</span>=<span class="w">True</span><span class="s">}</span></code> and <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Uppercase</span>=<span class="w">False</span><span class="s">}</span></code> , respectively.</p> <p>This formality is needed when properties are not binary; that is, if they can take on more values than just <code class="inline"><span class="w">True</span></code> and <code class="inline"><span class="w">False</span></code> . For example, the <code class="inline"><span class="w">Bidi_Class</span></code> property (see <a href="#Bidirectional-Character-Types">Bidirectional Character Types</a> below), can take on several different values, such as <code class="inline"><span class="w">Left</span></code> , <code class="inline"><span class="w">Right</span></code> , <code class="inline"><span class="w">Whitespace</span></code> , and others. To match these, one needs to specify both the property name (<code class="inline"><span class="w">Bidi_Class</span></code> ), AND the value being matched against (<code class="inline"><span class="w">Left</span></code> , <code class="inline"><span class="w">Right</span></code> , etc.). This is done, as in the examples above, by having the two components separated by an equal sign (or interchangeably, a colon), like <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Bidi_Class:</span> <span class="w">Left</span><span class="s">}</span></code> .</p> <p>All Unicode-defined character properties may be written in these compound forms of <code class="inline">\p{<i>property</i>=<i>value</i>}</code> or <code class="inline">\p{<i>property</i>:<i>value</i>}</code>, but Perl provides some additional properties that are written only in the single form, as well as single-form short-cuts for all binary properties and certain others described below, in which you may omit the property name and the equals or colon separator.</p> <p>Most Unicode character properties have at least two synonyms (or aliases if you prefer): a short one that is easier to type and a longer one that is more descriptive and hence easier to understand. Thus the <code class="inline"><span class="q">"L"</span></code> and <code class="inline"><span class="q">"Letter"</span></code> properties above are equivalent and can be used interchangeably. Likewise, <code class="inline"><span class="q">"Upper"</span></code> is a synonym for <code class="inline"><span class="q">"Uppercase"</span></code> , and we could have written <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Uppercase</span><span class="s">}</span></code> equivalently as <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Upper</span><span class="s">}</span></code> . Also, there are typically various synonyms for the values the property can be. For binary properties, <code class="inline"><span class="q">"True"</span></code> has 3 synonyms: <code class="inline"><span class="q">"T"</span></code> , <code class="inline"><span class="q">"Yes"</span></code> , and <code class="inline"><span class="q">"Y"</span></code> ; and <code class="inline"><span class="q">"False"</span></code> has correspondingly <code class="inline"><span class="q">"F"</span></code> , <code class="inline"><span class="q">"No"</span></code> , and <code class="inline"><span class="q">"N"</span></code> . But be careful. A short form of a value for one property may not mean the same thing as the same short form for another. Thus, for the <code class="inline"><a href="#General_Category">General_Category</a></code> property, <code class="inline"><span class="q">"L"</span></code> means <code class="inline"><span class="q">"Letter"</span></code> , but for the <a href="#Bidirectional-Character-Types">Bidi_Class </a> property, <code class="inline"><span class="q">"L"</span></code> means <code class="inline"><span class="q">"Left"</span></code> . A complete list of properties and synonyms is in <a href="../perluniprops/">perluniprops</a>.</p> <p>Upper/lower case differences in property names and values are irrelevant; thus <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Upper</span><span class="s">}</span></code> means the same thing as <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">upper</span><span class="s">}</span></code> or even <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">UpPeR</span><span class="s">}</span></code> . Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">U_p_p_e_r</span><span class="s">}</span></code> . And white space is irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so <code class="inline">\<span class="i">p</span><span class="s">{</span>   <span class="w">Upper</span>  <span class="s">}</span></code> and <code class="inline">\<span class="i">p</span><span class="s">{</span> <span class="j">Upper_case :</span> <span class="w">Y</span> <span class="s">}</span></code> are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even <code class="inline">\<span class="i">p</span><span class="s">{</span> <span class="w">Up</span>-<span class="w">per</span> case = <span class="w">Yes</span><span class="s">}</span></code> is equivalent. All this is called "loose-matching" by Unicode. The few places where stricter matching is used is in the middle of numbers, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</p> <p>You can also use negation in both <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> and <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> by introducing a caret (<code class="inline">^</code>) between the first brace and the property name: <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">^Tamil</span><span class="s">}</span></code> is equal to <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">Tamil</span><span class="s">}</span></code> .</p> <p>Almost all properties are immune to case-insensitive matching. That is, adding a <code class="inline">/i</code> regular expression modifier does not change what they match. There are two sets that are affected. The first set is <code class="inline"><span class="w">Uppercase_Letter</span></code> , <code class="inline"><span class="w">Lowercase_Letter</span></code> , and <code class="inline"><span class="w">Titlecase_Letter</span></code> , all of which match <code class="inline"><span class="w">Cased_Letter</span></code> under <code class="inline">/i</code> matching. And the second set is <code class="inline"><span class="w">Uppercase</span></code> , <code class="inline"><span class="w">Lowercase</span></code> , and <code class="inline"><span class="w">Titlecase</span></code> , all of which match <code class="inline"><span class="w">Cased</span></code> under <code class="inline">/i</code> matching. This set also includes its subsets <code class="inline"><span class="w">PosixUpper</span></code> and <code class="inline"><span class="w">PosixLower</span></code> both of which under <code class="inline">/i</code> match <code class="inline"><span class="w">PosixAlpha</span></code> . (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case so they are <code class="inline"><span class="w">Cased</span></code> , but aren't considered letters, so they aren't <code class="inline"><span class="w">Cased_Letter</span></code> s.)</p> <p>See <a href="#Beyond-Unicode-code-points">Beyond Unicode code points</a> for special considerations when matching Unicode properties against non-Unicode code points.</p> <h4 id="*General_Category*"><b>General_Category</b></h4> <p>Every Unicode character is assigned a general category, which is the "most usual categorization of a character" (from <a href="http://www.unicode.org/reports/tr44" target="_blank">http://www.unicode.org/reports/tr44</a>).</p> <p>The compound way of writing these is like <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">General_Category</span>=<span class="w">Number</span><span class="s">}</span></code> (short, <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">gc:</span><span class="w">n</span><span class="s">}</span></code> ). But Perl furnishes shortcuts in which everything up through the equal or colon separator is omitted. So you can instead just write <code class="inline">\<span class="w">pN</span></code> .</p> <p>Here are the short and long forms of the values the <code class="inline"><span class="w">General</span> <span class="w">Category</span></code> property can have:</p> <pre class="verbatim" data-language="perl">Short       Long

L           Letter
LC, L&amp;      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
Lu          Uppercase_Letter
Ll          Lowercase_Letter
Lt          Titlecase_Letter
Lm          Modifier_Letter
Lo          Other_Letter

M           Mark
Mn          Nonspacing_Mark
Mc          Spacing_Mark
Me          Enclosing_Mark

N           Number
Nd          Decimal_Number (also Digit)
Nl          Letter_Number
No          Other_Number

P           Punctuation (also Punct)
Pc          Connector_Punctuation
Pd          Dash_Punctuation
Ps          Open_Punctuation
Pe          Close_Punctuation
Pi          Initial_Punctuation
            (may behave like Ps or Pe depending on usage)
Pf          Final_Punctuation
            (may behave like Ps or Pe depending on usage)
Po          Other_Punctuation

S           Symbol
Sm          Math_Symbol
Sc          Currency_Symbol
Sk          Modifier_Symbol
So          Other_Symbol

Z           Separator
Zs          Space_Separator
Zl          Line_Separator
Zp          Paragraph_Separator

C           Other
Cc          Control (also Cntrl)
Cf          Format
Cs          Surrogate
Co          Private_Use
Cn          Unassigned
</pre>
<p>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. <code class="inline"><span class="w">LC</span></code> and <code class="inline"><span class="w">L</span><span class="i">&amp;</span></code> are special: both are aliases for the set consisting of everything matched by <code class="inline"><span class="w">Ll</span></code> , <code class="inline"><span class="w">Lu</span></code> , and <code class="inline"><span class="w">Lt</span></code> .</p> <h4 id="*Bidirectional-Character-Types*"><b>Bidirectional Character Types</b></h4> <p>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a <code class="inline"><span class="w">Bidi_Class</span></code> property. Some of the values this property can have are:</p> <pre class="verbatim" data-language="perl">Value       Meaning

L           Left-to-Right
LRE         Left-to-Right Embedding
LRO         Left-to-Right Override
R           Right-to-Left
AL          Arabic Letter
RLE         Right-to-Left Embedding
RLO         Right-to-Left Override
PDF         Pop Directional Format
EN          European Number
ES          European Separator
ET          European Terminator
AN          Arabic Number
CS          Common Separator
NSM         Non-Spacing Mark
BN          Boundary Neutral
B           Paragraph Separator
S           Segment Separator
WS          Whitespace
ON          Other Neutrals
</pre>
<p>This property is always written in the compound form. For example, <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Bidi_Class:</span><span class="w">R</span><span class="s">}</span></code> matches characters that are normally written right to left. Unlike the <code class="inline"><a href="#General_Category">General_Category</a></code> property, this property can have more values added in a future Unicode release. Those listed above comprised the complete set for many Unicode releases, but others were added in Unicode 6.3; you can always find what the current ones are in in <a href="../perluniprops/">perluniprops</a>. And <a href="http://www.unicode.org/reports/tr9/" target="_blank">http://www.unicode.org/reports/tr9/</a> describes how to use them.</p> <h4 id="*Scripts*"><b>Scripts</b></h4> <p>The world's languages are written in many different scripts. This sentence (unless you're reading it in translation) is written in Latin, while Russian is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in Hiragana or Katakana. There are many more.</p> <p>The Unicode Script and Script_Extensions properties give what script a given character is in. Either property can be specified with the compound form like <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Script</span>=<span class="w">Hebrew</span><span class="s">}</span></code> (short: <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">sc</span>=<span class="w">hebr</span><span class="s">}</span></code> ), or <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Script_Extensions</span>=<span class="w">Javanese</span><span class="s">}</span></code> (short: <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">scx</span>=<span class="w">java</span><span class="s">}</span></code> ). In addition, Perl furnishes shortcuts for all <code class="inline"><span class="w">Script</span></code> property names. You can omit everything up through the equals (or colon), and simply write <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Latin</span><span class="s">}</span></code> or <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">Cyrillic</span><span class="s">}</span></code> . (This is not true for <code class="inline"><span class="w">Script_Extensions</span></code> , which is required to be written in the compound form.)</p> <p>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named <code class="inline"><span class="w">Common</span></code> . Other characters are used in just a few scripts. For example, the <code class="inline"><span class="q">"KATAKANA-HIRAGANA DOUBLE HYPHEN"</span></code> is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The <code class="inline"><span class="w">Script</span></code> property places all characters that are used in multiple scripts in the <code class="inline"><span class="w">Common</span></code> script, while the <code class="inline"><span class="w">Script_Extensions</span></code> property places those that are used in only a few scripts into each of those scripts; while still using <code class="inline"><span class="w">Common</span></code> for those used in many scripts. Thus both these match:</p> <pre class="verbatim" data-language="perl">"0" =~ /\p{sc=Common}/     # Matches
"0" =~ /\p{scx=Common}/    # Matches
</pre>
<p>and only the first of these match:</p> <pre class="verbatim" data-language="perl">"\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Common}  # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Common} # No match
</pre>
<p>And only the last two of these match:</p> <pre class="verbatim" data-language="perl">"\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Hiragana}  # No match
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{sc=Katakana}  # No match
"\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Hiragana} # Matches
 "\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}" =~ /\p{scx=Katakana} # Matches
</pre>
<p><code class="inline"><span class="w">Script_Extensions</span></code> is thus an improved <code class="inline"><span class="w">Script</span></code> , in which there are fewer characters in the <code class="inline"><span class="w">Common</span></code> script, and correspondingly more in other scripts. It is new in Unicode version 6.0, and its data are likely to change significantly in later releases, as things get sorted out.</p> <p>(Actually, besides <code class="inline"><span class="w">Common</span></code> , the <code class="inline"><span class="w">Inherited</span></code> script, contains characters that are used in multiple scripts. These are modifier characters which modify other characters, and inherit the script value of the controlling character. Some of these are used in many scripts, and so go into <code class="inline"><span class="w">Inherited</span></code> in both <code class="inline"><span class="w">Script</span></code> and <code class="inline"><span class="w">Script_Extensions</span></code> . Others are used in just a few scripts, so are in <code class="inline"><span class="w">Inherited</span></code> in <code class="inline"><span class="w">Script</span></code> , but not in <code class="inline"><span class="w">Script_Extensions</span></code> .)</p> <p>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by <code class="inline">\<span class="w">d</span></code> in a regular expression. If they are used in a single language only, they are in that language's <code class="inline"><span class="w">Script</span></code> and <code class="inline"><span class="w">Script_Extension</span></code> . If they are used in more than one script, they will be in <code class="inline"><span class="w">sc</span>=<span class="w">Common</span></code> , but only if they are used in many scripts should they be in <code class="inline"><span class="w">scx</span>=<span class="w">Common</span></code> .</p> <p>A complete list of scripts and their shortcuts is in <a href="../perluniprops/">perluniprops</a>.</p> <h4 id="*Use-of-the-%22Is%22-Prefix*"><b>Use of the <code class="inline"><span class="q">"Is"</span></code> Prefix</b></h4> <p>For backward compatibility (with Perl 5.6), all properties mentioned so far may have <code class="inline"><span class="w">Is</span></code> or <code class="inline"><span class="w">Is_</span></code> prepended to their name, so <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">Is_Lu</span><span class="s">}</span></code> , for example, is equal to <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">Lu</span><span class="s">}</span></code> , and <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">IsScript:</span><span class="w">Arabic</span><span class="s">}</span></code> is equal to <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Arabic</span><span class="s">}</span></code> .</p> <h4 id="*Blocks*"><b>Blocks</b></h4> <p>In addition to <b>scripts</b>, Unicode also defines <b>blocks</b> of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the <code class="inline"><span class="q">"Basic Latin"</span></code> block is all characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The <code class="inline"><span class="q">"Latin"</span></code> script contains some letters from this as well as several other blocks, like <code class="inline"><span class="q">"Latin-1 Supplement"</span></code> , <code class="inline"><span class="q">"Latin Extended-A"</span></code> , etc., but it does not contain all the characters from those blocks. It does not, for example, contain the digits 0-9, because those digits are shared across many scripts, and hence are in the <code class="inline"><span class="w">Common</span></code> script.</p> <p>For more about scripts versus blocks, see UAX#24 "Unicode Script Property": <a href="http://www.unicode.org/reports/tr24" target="_blank">http://www.unicode.org/reports/tr24</a></p> <p>The <code class="inline"><span class="w">Script</span></code> or <code class="inline"><span class="w">Script_Extensions</span></code> properties are likely to be the ones you want to use when processing natural language; the <code class="inline"><span class="w">Block</span></code> property may occasionally be useful in working with the nuts and bolts of Unicode.</p> <p>Block names are matched in the compound form, like <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Block:</span> <span class="w">Arrows</span><span class="s">}</span></code> or <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Blk</span>=<span class="w">Hebrew</span><span class="s">}</span></code> . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight) shortcut: You can say, for example <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">In_Arrows</span><span class="s">}</span></code> or <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">In_Hebrew</span><span class="s">}</span></code> . For backwards compatibility, the <code class="inline"><span class="w">In</span></code> prefix may be omitted if there is no naming conflict with a script or any other property, and you can even use an <code class="inline"><span class="w">Is</span></code> prefix instead in those cases. But it is not a good idea to do this, for a couple reasons:</p> <dl> <dt>1</dt>
<dd> <p>It is confusing. There are many naming conflicts, and you may forget some. For example, <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Hebrew</span><span class="s">}</span></code> means the <i>script</i> Hebrew, and NOT the <i>block</i> Hebrew. But would you remember that 6 months from now?</p> </dd> <dt>2</dt>
<dd> <p>It is unstable. A new version of Unicode may preempt the current meaning by creating a property with the same name. There was a time in very early Unicode releases when <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Hebrew</span><span class="s">}</span></code> would have matched the <i>block</i> Hebrew; now it doesn't.</p> </dd> </dl> <p>Some people prefer to always use <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Block:</span> <span class="w">foo</span><span class="s">}</span></code> and <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Script:</span> <span class="w">bar</span><span class="s">}</span></code> instead of the shortcuts, whether for clarity, because they can't remember the difference between 'In' and 'Is' anyway, or they aren't confident that those who eventually will read their code will know that difference.</p> <p>A complete list of blocks and their shortcuts is in <a href="../perluniprops/">perluniprops</a>.</p> <h4 id="*Other-Properties*"><b>Other Properties</b></h4> <p>There are many more properties than the very basic ones described here. A complete list is in <a href="../perluniprops/">perluniprops</a>.</p> <p>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in <a href="http://www.unicode.org/reports/tr18" target="_blank">http://www.unicode.org/reports/tr18</a>).</p> <p>This section gives some details on all extensions that aren't just synonyms for compound-form Unicode properties (for those properties, you'll have to refer to the <a href="http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44" target="_blank">Unicode Standard</a>.</p> <ul> <li id="*%5cp%7bAll%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">All</span><span class="s">}</span></code> </b></b> <p>This matches every possible code point. It is equivalent to <code class="inline"><a class="l_k" href="../functions/qr/">qr/./s</a></code>. Unlike all the other non-user-defined <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> property matches, no warning is ever generated if this is property is matched against a non-Unicode code point (see <a href="#Beyond-Unicode-code-points">Beyond Unicode code points</a> below).</p> </li> <li id="*%5cp%7bAlnum%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Alnum</span><span class="s">}</span></code> </b></b> <p>This matches any <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Alphabetic</span><span class="s">}</span></code> or <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Decimal_Number</span><span class="s">}</span></code> character.</p> </li> <li id="*%5cp%7bAny%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Any</span><span class="s">}</span></code> </b></b> <p>This matches any of the 1_114_112 Unicode code points. It is a synonym for <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Unicode</span><span class="s">}</span></code> .</p> </li> <li id="*%5cp%7bASCII%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">ASCII</span><span class="s">}</span></code> </b></b> <p>This matches any of the 128 characters in the US-ASCII character set, which is a subset of Unicode.</p> </li> <li id="*%5cp%7bAssigned%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Assigned</span><span class="s">}</span></code> </b></b> <p>This matches any assigned code point; that is, any code point whose <a href="#General_Category">general category</a> is not <code class="inline"><span class="w">Unassigned</span></code> (or equivalently, not <code class="inline"><span class="w">Cn</span></code> ).</p> </li> <li id="*%5cp%7bBlank%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Blank</span><span class="s">}</span></code> </b></b> <p>This is the same as <code class="inline">\<span class="w">h</span></code> and <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">HorizSpace</span><span class="s">}</span></code> : A character that changes the spacing horizontally.</p> </li> <li id="*%5cp%7bDecomposition_Type%3a-Non_Canonical%7d*----(Short%3a-%5cp%7bDt%3dNonCanon%7d)">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Decomposition_Type:</span> <span class="w">Non_Canonical</span><span class="s">}</span></code> </b> (Short: <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Dt</span>=<span class="w">NonCanon</span><span class="s">}</span></code> )</b> <p>Matches a character that has a non-canonical decomposition.</p> <p>To understand the use of this rarely used <i>property=value</i> combination, it is necessary to know some basics about decomposition. Consider a character, say H. It could appear with various marks around it, such as an acute accent, or a circumflex, or various hooks, circles, arrows, <i>etc.</i>, above, below, to one side or the other, etc. There are many possibilities among the world's languages. The number of combinations is astronomical, and if there were a character for each combination, it would soon exhaust Unicode's more than a million possible characters. So Unicode took a different approach: there is a character for the base H, and a character for each of the possible marks, and these can be variously combined to get a final logical character. So a logical character--what appears to be a single character--can be a sequence of more than one individual characters. This is called an "extended grapheme cluster"; Perl furnishes the <code class="inline">\<span class="w">X</span></code> regular expression construct to match such sequences.</p> <p>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations. An example is ISO-8859-1, which has quite a few of these in the Latin-1 range, an example being <code class="inline"><span class="q">"LATIN</span>
<span class="q">CAPITAL LETTER E WITH ACUTE"</span></code> . Because this character was in this pre-existing standard, Unicode added it to its repertoire. But this character is considered by Unicode to be equivalent to the sequence consisting of the character <code class="inline"><span class="q">"LATIN CAPITAL LETTER E"</span></code> followed by the character <code class="inline"><span class="q">"COMBINING ACUTE ACCENT"</span></code> .</p> <p><code class="inline"><span class="q">"LATIN CAPITAL LETTER E WITH ACUTE"</span></code> is called a "pre-composed" character, and its equivalence with the sequence is called canonical equivalence. All pre-composed characters are said to have a decomposition (into the equivalent sequence), and the decomposition type is also called canonical.</p> <p>However, many more characters have a different type of decomposition, a "compatible" or "non-canonical" decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example, again in the Latin-1 range, is the <code class="inline"><span class="q">"SUPERSCRIPT ONE"</span></code> . It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a "compatible" decomposition, specifically a "super" decomposition. There are several such compatibility decompositions (see <a href="http://www.unicode.org/reports/tr44" target="_blank">http://www.unicode.org/reports/tr44</a>), including one called "compat", which means some miscellaneous type of decomposition that doesn't fit into the decomposition categories that Unicode has chosen.</p> <p>Note that most Unicode characters don't have a decomposition, so their decomposition type is <code class="inline"><span class="q">"None"</span></code> .</p> <p>For your convenience, Perl has added the <code class="inline"><span class="w">Non_Canonical</span></code> decomposition type to mean any of the several compatibility decompositions.</p> </li> <li id="*%5cp%7bGraph%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Graph</span><span class="s">}</span></code> </b></b> <p>Matches any character that is graphic. Theoretically, this means a character that on a printer would cause ink to be used.</p> </li> <li id="*%5cp%7bHorizSpace%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">HorizSpace</span><span class="s">}</span></code> </b></b> <p>This is the same as <code class="inline">\<span class="w">h</span></code> and <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Blank</span><span class="s">}</span></code> : a character that changes the spacing horizontally.</p> </li> <li id="*%5cp%7bIn%3d*%7d*">
<b><b><code class="inline">\p{In=*}</code></b></b> <p>This is a synonym for <code class="inline">\p{Present_In=*}</code></p> </li> <li id="*%5cp%7bPerlSpace%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">PerlSpace</span><span class="s">}</span></code> </b></b> <p>This is the same as <code class="inline">\s</code>, restricted to ASCII, namely <code class="inline"><span class="s">[</span> \<span class="w">f</span>\<span class="w">n</span>\<span class="w">r</span>\<span class="w">t</span><span class="s">]</span></code> and starting in Perl v5.18, experimentally, a vertical tab.</p> <p>Mnemonic: Perl's (original) space</p> </li> <li id="*%5cp%7bPerlWord%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">PerlWord</span><span class="s">}</span></code> </b></b> <p>This is the same as <code class="inline">\<span class="w">w</span></code> , restricted to ASCII, namely <code class="inline"><span class="s">[</span><span class="w">A</span>-<span class="w">Za</span>-<span class="w">z0</span>-<span class="n">9_</span><span class="s">]</span></code> </p> <p>Mnemonic: Perl's (original) word.</p> </li> <li id="*%5cp%7bPosix...%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Posix</span>...<span class="s">}</span></code> </b></b> <p>There are several of these, which are equivalents using the <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> notation for Posix classes and are described in <a href="../perlrecharclass/#POSIX-Character-Classes">POSIX Character Classes in perlrecharclass</a>.</p> </li> <li id="*%5cp%7bPresent_In%3a-*%7d*----(Short%3a-%5cp%7bIn%3d*%7d)">
<b><b><code class="inline">\p{Present_In: *}</code></b> (Short: <code class="inline">\p{In=*}</code>)</b> <p>This property is used when you need to know in what Unicode version(s) a character is.</p> <p>The "*" above stands for some two digit Unicode version number, such as <code class="inline"><span class="n">1.1</span></code> or <code class="inline"><span class="n">4.0</span></code> ; or the "*" can also be <code class="inline"><span class="w">Unassigned</span></code> . This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Present_In:</span> <span class="w">Unassigned</span><span class="s">}</span></code> will match those code points whose meaning has yet to be assigned.</p> <p>For example, <code class="inline"><span class="w">U</span>+<span class="n">0041</span></code> <code class="inline"><span class="q">"LATIN CAPITAL LETTER A"</span></code> was present in the very first Unicode release available, which is <code class="inline"><span class="n">1.1</span></code> , so this property is true for all valid "*" versions. On the other hand, <code class="inline">U+1EFF</code> was not assigned until version 5.1 when it became <code class="inline"><span class="q">"LATIN SMALL LETTER Y WITH LOOP"</span></code> , so the only "*" that would match it are 5.1, 5.2, and later.</p> <p>Unicode furnishes the <code class="inline"><span class="w">Age</span></code> property from which this is derived. The problem with Age is that a strict interpretation of it (which Perl takes) has it matching the precise release a code point's meaning is introduced in. Thus <code class="inline"><span class="w">U</span>+<span class="n">0041</span></code> would match only 1.1; and <code class="inline">U+1EFF</code> only 5.1. This is not usually what you want.</p> <p>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl <code class="inline"><span class="w">Present_In</span></code> property; just be aware of that.</p> <p>Another confusion with both these properties is that the definition is not that the code point has been <i>assigned</i>, but that the meaning of the code point has been <i>determined</i>. This is because 66 code points will always be unassigned, and so the <code class="inline"><span class="w">Age</span></code> for them is the Unicode version in which the decision to make them so was made. For example, <code class="inline"><span class="w">U</span>+<span class="w">FDD0</span></code> is to be permanently unassigned to a character, and the decision to do that was made in version 3.1, so <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Age</span>=<span class="n">3.1</span><span class="s">}</span></code> matches this character, as also does <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="j">Present_In:</span> <span class="n">3.1</span><span class="s">}</span></code> and up.</p> </li> <li id="*%5cp%7bPrint%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Print</span><span class="s">}</span></code> </b></b> <p>This matches any character that is graphical or blank, except controls.</p> </li> <li id="*%5cp%7bSpacePerl%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">SpacePerl</span><span class="s">}</span></code> </b></b> <p>This is the same as <code class="inline">\s</code>, including beyond ASCII.</p> <p>Mnemonic: Space, as modified by Perl. (It doesn't include the vertical tab which both the Posix standard and Unicode consider white space.)</p> </li> <li id="*%5cp%7bTitle%7d*-and--*%5cp%7bTitlecase%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Title</span><span class="s">}</span></code> </b> and <b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Titlecase</span><span class="s">}</span></code> </b></b> <p>Under case-sensitive matching, these both match the same code points as <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">General</span> <span class="w">Category</span>=<span class="w">Titlecase_Letter</span><span class="s">}</span></code> (<code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">gc</span>=<a class="l_k" href="../functions/lt/">lt</a><span class="s">}</span></code> ). The difference is that under <code class="inline">/i</code> caseless matching, these match the same as <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Cased</span><span class="s">}</span></code> , whereas <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">gc</span>=<a class="l_k" href="../functions/lt/">lt</a><span class="s">}</span></code> matches <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Cased_Letter</span></code> ).</p> </li> <li id="*%5cp%7bUnicode%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Unicode</span><span class="s">}</span></code> </b></b> <p>This matches any of the 1_114_112 Unicode code points. <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Any</span><span class="s">}</span></code> .</p> </li> <li id="*%5cp%7bVertSpace%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">VertSpace</span><span class="s">}</span></code> </b></b> <p>This is the same as <code class="inline">\<span class="w">v</span></code> : A character that changes the spacing vertically.</p> </li> <li id="*%5cp%7bWord%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Word</span><span class="s">}</span></code> </b></b> <p>This is the same as <code class="inline">\<span class="w">w</span></code> , including over 100_000 characters beyond ASCII.</p> </li> <li id="*%5cp%7bXPosix...%7d*">
<b><b><code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">XPosix</span>...<span class="s">}</span></code> </b></b> <p>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in <a href="../perlrecharclass/#POSIX-Character-Classes">POSIX Character Classes in perlrecharclass</a>.</p> </li> </ul> <h3 id="User-Defined-Character-Properties">User-Defined Character Properties</h3> <p>You can define your own binary character properties by defining subroutines whose names begin with <code class="inline"><span class="q">"In"</span></code> or <code class="inline"><span class="q">"Is"</span></code> . (The experimental feature <a href="../perlre/#(%3f%5b-%5d)">(?[ ]) in perlre</a> provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. The user-defined properties can be used in the regular expression <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> and <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> or <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> construct.</p> <pre class="verbatim" data-language="perl"># assuming property Is_Foreign defined in Lang::
package main;  # property package name required
if ($txt =~ /\p{Lang::IsForeign}+/) { ... }

package Lang;  # property package name not required
if ($txt =~ /\p{IsForeign}+/) { ... }
</pre>
<p>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</p> <p>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</p> <p>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</p> <ul> <li> <p>A single hexadecimal number denoting a code point to include.</p> </li> <li> <p>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include.</p> </li> <li> <p>Something to include, prefixed by <code class="inline"><span class="q">"+"</span></code> : a built-in character property (prefixed by <code class="inline"><span class="q">"utf8::"</span></code> ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</p> </li> <li> <p>Something to exclude, prefixed by <code class="inline"><span class="q">"-"</span></code> : an existing character property (prefixed by <code class="inline"><span class="q">"utf8::"</span></code> ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</p> </li> <li> <p>Something to negate, prefixed <code class="inline"><span class="q">"!"</span></code> : an existing character property (prefixed by <code class="inline"><span class="q">"utf8::"</span></code> ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</p> </li> <li> <p>Something to intersect with, prefixed by <code class="inline"><span class="q">"&amp;"</span></code> : an existing character property (prefixed by <code class="inline"><span class="q">"utf8::"</span></code> ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</p> </li> </ul> <p>For example, to define a property that covers both the Japanese syllabaries (hiragana and katakana), you can define</p> <pre class="verbatim" data-language="perl">sub InKana {
    return &lt;&lt;END;
3040\t309F
30A0\t30FF
END
}
</pre>
<p>Imagine that the here-doc end marker is at the beginning of the line. Now you can use <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">InKana</span><span class="s">}</span></code> and <code class="inline">\<span class="i">P</span><span class="s">{</span><span class="w">InKana</span><span class="s">}</span></code> .</p> <p>You could also have used the existing block property names:</p> <pre class="verbatim" data-language="perl">sub InKana {
    return &lt;&lt;'END';
+utf8::InHiragana
+utf8::InKatakana
END
}
</pre>
<p>Suppose you wanted to match only the allocated characters, not the raw block ranges: in other words, you want to remove the non-characters:</p> <pre class="verbatim" data-language="perl">sub InKana {
    return &lt;&lt;'END';
+utf8::InHiragana
+utf8::InKatakana
-utf8::IsCn
END
}
</pre>
<p>The negation is useful for defining (surprise!) negated classes.</p> <pre class="verbatim" data-language="perl">sub InNotKana {
    return &lt;&lt;'END';
!utf8::InHiragana
-utf8::InKatakana
+utf8::IsCn
END
}
</pre>
<p>This will match all non-Unicode code points, since every one of them is not in Kana. You can use intersection to exclude these, if desired, as this modified example shows:</p> <pre class="verbatim" data-language="perl">sub InNotKana {
    return &lt;&lt;'END';
!utf8::InHiragana
-utf8::InKatakana
+utf8::IsCn
&amp;utf8::Any
END
}
</pre>
<p><code class="inline"><span class="i">&amp;utf8::Any</span></code> must be the last line in the definition.</p> <p>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use <code class="inline"><span class="q">"&amp;"</span></code> for the first set; that would be intersecting with nothing, resulting in an empty set.</p> <p>Unlike non-user-defined <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see <a href="#Beyond-Unicode-code-points">Beyond Unicode code points</a> below).</p> <h3 id="User-Defined-Case-Mappings-(for-serious-hackers-only)">User-Defined Case Mappings (for serious hackers only)</h3> <p><b>This feature has been removed as of Perl 5.16.</b> The CPAN module <code class="inline"><a href="http://search.cpan.org/perldoc/Unicode::Casing" target="_blank">Unicode::Casing</a></code> provides better functionality without the drawbacks that this feature had. If you are using a Perl earlier than 5.16, this feature was most fully documented in the 5.14 version of this pod: <a href="http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29" target="_blank">http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29</a></p> <h3 id="Character-Encodings-for-Input-and-Output">Character Encodings for Input and Output</h3> <p>See <a href="../encode/">Encode</a>.</p> <h3 id="Unicode-Regular-Expression-Support-Level">Unicode Regular Expression Support Level</h3> <p>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to "Level N" and the section numbers refer to the Unicode Technical Standard #18, "Unicode Regular Expressions", version 13, from August 2008.</p> <ul> <li> <p>Level 1 - Basic Unicode Support</p> <pre class="verbatim" data-language="perl">RL1.1   Hex Notation                     - done          [1]
RL1.2   Properties                       - done          [2][3]
RL1.2a  Compatibility Properties         - done          [4]
RL1.3   Subtraction and Intersection     - experimental  [5]
RL1.4   Simple Word Boundaries           - done          [6]
RL1.5   Simple Loose Matches             - done          [7]
RL1.6   Line Boundaries                  - MISSING       [8][9]
RL1.7   Supplementary Code Points        - done          [10]
</pre>
<ul> <li id="%5b1%5d">
<b>[1]</b> <p><code class="inline">\<span class="i">x</span><span class="s">{</span>...<span class="s">}</span></code> </p> </li> <li id="%5b2%5d">
<b>[2]</b> <p><code class="inline">\<span class="i">p</span><span class="s">{</span>...<span class="s">}</span></code> <code class="inline">\<span class="i">P</span><span class="s">{</span>...<span class="s">}</span></code> </p> </li> <li id="%5b3%5d">
<b>[3]</b> <p>supports not only minimal list, but all Unicode character properties (see Unicode Character Properties above)</p> </li> <li id="%5b4%5d">
<b>[4]</b> <p><code class="inline">\<span class="w">d</span></code> <code class="inline">\<span class="w">D</span></code> <code class="inline">\s</code> <code class="inline">\<span class="w">S</span></code> <code class="inline">\<span class="w">w</span></code> <code class="inline">\<span class="w">W</span></code> <code class="inline">\<span class="w">X</span></code> <code class="inline">[:<i>prop</i>:]</code> <code class="inline">[:^<i>prop</i>:]</code></p> </li> <li id="%5b5%5d">
<b>[5]</b> <p>The experimental feature in v5.18 <code class="inline"><span class="q">"(?[...])"</span></code> accomplishes this. See <a href="../perlre/#(%3f%5b-%5d)">(?[ ]) in perlre</a>. If you don't want to use an experimental feature, you can use one of the following:</p> <ul> <li id="*-Regular-expression-look-ahead">
<b>Regular expression look-ahead</b> <p>You can mimic class subtraction using lookahead. For example, what UTS#18 might write as</p> <pre class="verbatim" data-language="perl">[{Block=Greek}-[{UNASSIGNED}]]
</pre>
<p>in Perl can be written as:</p> <pre class="verbatim" data-language="perl">(?!\p{Unassigned})\p{Block=Greek}
    (?=\p{Assigned})\p{Block=Greek}
</pre>
<p>But in this particular example, you probably really want</p> <pre class="verbatim" data-language="perl">\p{Greek}
</pre>
<p>which will match assigned characters known to be part of the Greek script.</p> </li> <li id="*-CPAN-module-the-Unicode%3a%3aRegex%3a%3aSet-manpage">
<b>CPAN module <code class="inline"><a href="http://search.cpan.org/perldoc/Unicode::Regex::Set" target="_blank">Unicode::Regex::Set</a></code></b> <p>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</p> </li> <li id="*-the-%2f%22User-Defined-Character-Properties%22-manpage">
<b><a href="#User-Defined-Character-Properties">User-Defined Character Properties</a></b> <p><code class="inline"><span class="q">"+"</span></code> for union, <code class="inline"><span class="q">"-"</span></code> for removal (set-difference), <code class="inline"><span class="q">"&amp;"</span></code> for intersection</p> </li> </ul> </li> <li id="%5b6%5d">
<b>[6]</b> <p><code class="inline">\<span class="w">b</span></code> <code class="inline">\<span class="w">B</span></code> </p> </li> <li id="%5b7%5d">
<b>[7]</b> <p>Note that Perl does Full case-folding in matching (but with bugs), not Simple: for example <code class="inline"><span class="w">U</span>+<span class="n">1</span><span class="w">F88</span></code> is equivalent to <code class="inline"><span class="w">U</span>+<span class="n">1</span><span class="w">F00</span> <span class="w">U</span>+<span class="n">03</span><span class="w">B9</span></code> , instead of just <code class="inline"><span class="w">U</span>+<span class="n">1</span><span class="w">F80</span></code> . This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.</p> </li> <li id="%5b8%5d">
<b>[8]</b> <p>Should do <code class="inline">^</code> and <code class="inline"><span class="i">$</span></code> also on <code class="inline"><span class="w">U</span>+<span class="n">000</span><span class="w">B</span></code> (<code class="inline">\<span class="w">v</span></code> in C), <code class="inline"><span class="w">FF</span></code> (<code class="inline">\<span class="w">f</span></code> ), <code class="inline"><span class="w">CR</span></code> (<code class="inline">\<span class="w">r</span></code> ), <code class="inline"><span class="w">CRLF</span></code> (<code class="inline">\<span class="w">r</span>\<span class="w">n</span></code> ), <code class="inline"><span class="w">NEL</span></code> (<code class="inline"><span class="w">U</span>+<span class="n">0085</span></code> ), <code class="inline"><span class="w">LS</span></code> (<code class="inline"><span class="w">U</span>+<span class="n">2028</span></code> ), and <code class="inline"><span class="w">PS</span></code> (<code class="inline"><span class="w">U</span>+<span class="n">2029</span></code> ); should also affect <code class="inline">&lt;&gt;</code> , <code class="inline"><span class="i">$.</span></code> , and script line numbers; should not split lines within <code class="inline"><span class="w">CRLF</span></code> (i.e. there is no empty line between <code class="inline">\<span class="w">r</span></code> and <code class="inline">\<span class="w">n</span></code> ). For <code class="inline"><span class="w">CRLF</span></code> , try the <code class="inline"><span class="j">:</span><span class="w">crlf</span></code> layer (see <a href="../perlio/">PerlIO</a>).</p> </li> <li id="%5b9%5d">
<b>[9]</b> <p>Linebreaking conformant with <a href="http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr14" target="_blank">UAX#14 Unicode Line Breaking Algorithm</a> is available through the <code class="inline"><a href="http://search.cpan.org/perldoc/Unicode::LineBreak" target="_blank">Unicode::LineBreak</a></code> module.</p> </li> <li id="%5b10%5d">
<b>[10]</b> <p>UTF-8/UTF-EBDDIC used in Perl allows not only <code class="inline"><span class="w">U</span>+<span class="n">10000</span></code> to <code class="inline"><span class="w">U</span>+<span class="n">10</span><span class="w">FFFF</span></code> but also beyond <code class="inline"><span class="w">U</span>+<span class="n">10</span><span class="w">FFFF</span></code> </p> </li> </ul> </li> <li> <p>Level 2 - Extended Unicode Support</p> <pre class="verbatim" data-language="perl">RL2.1   Canonical Equivalents           - MISSING       [10][11]
RL2.2   Default Grapheme Clusters       - MISSING       [12]
RL2.3   Default Word Boundaries         - MISSING       [14]
RL2.4   Default Loose Matches           - MISSING       [15]
RL2.5   Name Properties                 - DONE
RL2.6   Wildcard Properties             - MISSING

[10] see UAX#15 "Unicode Normalization Forms"
[11] have Unicode::Normalize but not integrated to regexes
[12] have \X but we don't have a "Grapheme Cluster Mode"
[14] see UAX#29, Word Boundaries
[15] This is covered in Chapter 3.13 (in Unicode 6.0)
</pre>
</li> <li> <p>Level 3 - Tailored Support</p> <pre class="verbatim" data-language="perl">RL3.1   Tailored Punctuation            - MISSING
RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
RL3.3   Tailored Word Boundaries        - MISSING
RL3.4   Tailored Loose Matches          - MISSING
RL3.5   Tailored Ranges                 - MISSING
RL3.6   Context Matching                - MISSING       [19]
RL3.7   Incremental Matches             - MISSING
     ( RL3.8   Unicode Set Sharing )
RL3.9   Possible Match Sets             - MISSING
RL3.10  Folded Matching                 - MISSING       [20]
RL3.11  Submatchers                     - MISSING

[17] see UAX#10 "Unicode Collation Algorithms"
[18] have Unicode::Collate but not integrated to regexes
[19] have (?&lt;=x) and (?=x), but look-aheads or look-behinds
     should see outside of the target substring
[20] need insensitive matching for linguistic features other
     than case; for example, hiragana to katakana, wide and
     narrow, simplified Han to traditional Han (see UTR#30
     "Character Foldings")
</pre>
</li> </ul> <h3 id="Unicode-Encodings">Unicode Encodings</h3> <p>Unicode characters are assigned to <i>code points</i>, which are abstract numbers. To use these numbers, various encodings are needed.</p> <ul> <li> <p>UTF-8</p> <p>UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding. For ASCII (and we really do mean 7-bit ASCII, not another 8-bit encoding), UTF-8 is transparent.</p> <p>The following table is from Unicode 3.2.</p> <pre class="verbatim" data-language="perl">Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte

  U+0000..U+007F       00..7F
  U+0080..U+07FF     * C2..DF    80..BF
  U+0800..U+0FFF       E0      * A0..BF    80..BF
  U+1000..U+CFFF       E1..EC    80..BF    80..BF
  U+D000..U+D7FF       ED        80..9F    80..BF
  U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
  U+E000..U+FFFF       EE..EF    80..BF    80..BF
 U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
 U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF
</pre>
<p>Note the gaps marked by "*" before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</p> <p>Another way to look at it is via bits:</p> <pre class="verbatim" data-language="perl">               Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte

                  0aaaaaaa  0aaaaaaa
          00000bbbbbaaaaaa  110bbbbb  10aaaaaa
          ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa
</pre>
<p>As you can see, the continuation bytes all begin with <code class="inline"><span class="q">"10"</span></code> , and the leading bits of the start byte tell how many bytes there are in the encoded character.</p> <p>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to <code class="inline"><span class="n">0x7FFF_FFFF</span></code> . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</p> <p>The Unicode non-character code points are also disallowed in UTF-8 in "open interchange". See <a href="#Non-character-code-points">Non-character code points</a>.</p> </li> <li> <p>UTF-EBCDIC</p> <p>Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is ASCII-safe.</p> </li> <li> <p>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and <code class="inline"><span class="w">BOM</span></code> s (Byte Order Marks)</p> <p>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</p> <p>Like UTF-8, UTF-16 is a variable-width encoding, but where UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units. All code points occupy either 2 or 4 bytes in UTF-16: code points <code class="inline"><span class="w">U</span>+<span class="n">0000</span>..<span class="w">U</span>+<span class="w">FFFF</span></code> are stored in a single 16-bit unit, and code points <code class="inline">U+10000..U+10FFFF</code> in two 16-bit units. The latter case is using <i>surrogates</i>, the first 16-bit unit being the <i>high surrogate</i>, and the second being the <i>low surrogate</i>.</p> <p>Surrogates are code points set aside to encode the <code class="inline">U+10000..U+10FFFF</code> range of Unicode code points in pairs of 16-bit units. The <i>high surrogates</i> are the range <code class="inline"><span class="w">U</span>+<span class="w">D800</span>..<span class="w">U</span>+<span class="w">DBFF</span></code> and the <i>low surrogates</i> are the range <code class="inline"><span class="w">U</span>+<span class="w">DC00</span>..<span class="w">U</span>+<span class="w">DFFF</span></code> . The surrogate encoding is</p> <pre class="verbatim" data-language="perl">$hi = ($uni - 0x10000) / 0x400 + 0xD800;
$lo = ($uni - 0x10000) % 0x400 + 0xDC00;
</pre>
<p>and the decoding is</p> <pre class="verbatim" data-language="perl">$uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
</pre>
<p>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</p> <p>This introduces another problem: what if you just know that your data is UTF-16, but you don't know which endianness? Byte Order Marks, or <code class="inline"><span class="w">BOM</span></code> s, are a solution to this. A special character has been reserved in Unicode to function as a byte order marker: the character with the code point <code class="inline"><span class="w">U</span>+<span class="w">FEFF</span></code> is the <code class="inline"><span class="w">BOM</span></code> .</p> <p>The trick is that if you read a <code class="inline"><span class="w">BOM</span></code> , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes <code class="inline">0xFE 0xFF</code>, but if it was written on a little-endian platform, you will read the bytes <code class="inline">0xFF 0xFE</code>. (And if the originating platform was writing in UTF-8, you will read the bytes <code class="inline">0xEF 0xBB 0xBF</code>.)</p> <p>The way this trick works is that the character with the code point <code class="inline"><span class="w">U</span>+<span class="w">FFFE</span></code> is not supposed to be in input streams, so the sequence of bytes <code class="inline">0xFF 0xFE</code> is unambiguously "<code class="inline"><span class="w">BOM</span></code> , represented in little-endian format" and cannot be <code class="inline"><span class="w">U</span>+<span class="w">FFFE</span></code> , represented in big-endian format".</p> <p>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying <code class="inline"><a class="l_k" href="../functions/chr/">chr(0xD801)</a></code>, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their <code class="inline"><a href="#General_Category">General_Category</a></code> is <code class="inline"><span class="q">"Cs"</span></code> . But because their use is somewhat dangerous, Perl will warn (using the warning category <code class="inline"><span class="q">"surrogate"</span></code> , which is a sub-category of <code class="inline"><span class="q">"utf8"</span></code> ) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</p> </li> <li> <p>UTF-32, UTF-32BE, UTF-32LE</p> <p>The UTF-32 family is pretty much like the UTF-16 family, expect that the units are 32-bit, and therefore the surrogate scheme is not needed. UTF-32 is a fixed-width encoding. The <code class="inline"><span class="w">BOM</span></code> signatures are <code class="inline">0x00 0x00 0xFE 0xFF</code> for BE and <code class="inline">0xFF 0xFE 0x00 0x00</code> for LE.</p> </li> <li> <p>UCS-2, UCS-4</p> <p>Legacy, fixed-width encodings defined by the ISO 10646 standard. UCS-2 is a 16-bit encoding. Unlike UTF-16, UCS-2 is not extensible beyond <code class="inline"><span class="w">U</span>+<span class="w">FFFF</span></code> , because it does not use surrogates. UCS-4 is a 32-bit encoding, functionally identical to UTF-32 (the difference being that UCS-4 forbids neither surrogates nor code points larger than <code class="inline"><span class="n">0x10_FFFF</span></code> ).</p> </li> <li> <p>UTF-7</p> <p>A seven-bit safe (non-eight-bit) encoding, which is useful if the transport or storage is not eight-bit safe. Defined by RFC 2152.</p> </li> </ul> <h3 id="Non-character-code-points">Non-character code points</h3> <p>66 code points are set aside in Unicode as "non-character code points". These all have the <code class="inline"><span class="w">Unassigned</span></code> (<code class="inline"><span class="w">Cn</span></code> ) <code class="inline"><a href="#General_Category">General_Category</a></code>, and they never will be assigned. These are never supposed to be in legal Unicode input streams, so that code can use them as sentinels that can be mixed in with character data, and they always will be distinguishable from that data. To keep them out of Perl input streams, strict UTF-8 should be specified, such as by using the layer <code class="inline"><span class="j">:</span><span class="i">encoding</span><span class="s">(</span><span class="q">'UTF-8'</span><span class="s">)</span></code> . The non-character code points are the 32 between <code class="inline"><span class="w">U</span>+<span class="w">FDD0</span></code> and <code class="inline"><span class="w">U</span>+<span class="w">FDEF</span></code> , and the 34 code points <code class="inline"><span class="w">U</span>+<span class="w">FFFE</span></code> , <code class="inline"><span class="w">U</span>+<span class="w">FFFF</span></code> , <code class="inline"><span class="w">U</span>+<span class="n">1</span><span class="w">FFFE</span></code> , <code class="inline"><span class="w">U</span>+<span class="n">1</span><span class="w">FFFF</span></code> , ... <code class="inline"><span class="w">U</span>+<span class="n">10</span><span class="w">FFFE</span></code> , <code class="inline"><span class="w">U</span>+<span class="n">10</span><span class="w">FFFF</span></code> . Some people are under the mistaken impression that these are "illegal", but that is not true. An application or cooperating set of applications can legally use them at will internally; but these code points are "illegal for open interchange". Therefore, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category <code class="inline"><span class="q">"nonchar"</span></code> , which is a sub-category of <code class="inline"><span class="q">"utf8"</span></code> ) if an attempt is made to output them.</p> <h3 id="Beyond-Unicode-code-points">Beyond Unicode code points</h3> <p>The maximum Unicode code point is <code class="inline"><span class="w">U</span>+<span class="n">10</span><span class="w">FFFF</span></code> , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category <code class="inline"><span class="q">"non_unicode"</span></code> , which is a sub-category of <code class="inline"><span class="q">"utf8"</span></code> ) if any are output.</p> <p>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the <code class="inline"><span class="q">"non_unicode"</span></code> category. For example, <code class="inline"><a class="l_k" href="../functions/uc/">uc("\x{11_0000}")</a></code> will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. In fact, all the case changing operations, not just uppercasing, work this way.</p> <p>The situation with matching Unicode properties in regular expressions, the <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> and <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</p> <p>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or <code class="inline"><span class="w">FALSE</span></code> . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> matches as failing, but all <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> matches as succeeding.</p> <p>One problem with this is that it leads to unexpected, and confusting results in some cases:</p> <pre class="verbatim" data-language="perl">chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Failed on &lt;= v5.18
chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Failed! on &lt;= v5.18
</pre>
<p>That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: "How could both be false when they are complements?" Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</p> <p>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has non-character code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</p> <p>Perl, in most cases, will raise a warning when matching an above-Unicode code point against a Unicode property when the result is <code class="inline"><span class="w">TRUE</span></code> for <code class="inline">\<span class="w">p</span><span class="s">{</span><span class="s">}</span></code> , and <code class="inline"><span class="w">FALSE</span></code> for <code class="inline">\<span class="w">P</span><span class="s">{</span><span class="s">}</span></code> . For example:</p> <pre class="verbatim" data-language="perl">chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails, no warning
chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Succeeds, with warning
</pre>
<p>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence <code class="inline"><span class="w">FALSE</span></code> , result. So a warning is raised for it.</p> <p>Thus the warning is raised for many fewer cases than in earlier Perls, and only when what the result is could be arguable. It turns out that none of the optimizations made by Perl (or are ever likely to be made) cause the warning to be skipped, so it solves both problems of Perl's earlier approach. The most commonly used property that is affected by this change is <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Unassigned</span><span class="s">}</span></code> which is a short form for <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">General_Category</span>=<span class="w">Unassigned</span><span class="s">}</span></code> . Starting in v5.20, all non-Unicode code points are considered <code class="inline"><span class="w">Unassigned</span></code> . In earlier releases the matches failed because the result was considered undefined.</p> <p>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring <code class="inline"><span class="q">"foobar"</span></code> . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</p> <p>This behavior is more "Do what I mean" than in earlier Perls for most applications. But it catches fewer issues for code that needs to be strictly Unicode compliant. Therefore there is an additional mode of operation available to accommodate such code. This mode is enabled if a regular expression pattern is compiled within the lexical scope where the <code class="inline"><span class="q">"non_unicode"</span></code> warning class has been made fatal, say by:</p> <pre class="verbatim" data-language="perl">use warnings FATAL =&gt; "non_unicode"
</pre>
<p>(see <a href="../warnings/">warnings</a>). In this mode of operation, Perl will raise the warning for all matches against a non-Unicode code point (not just the arguable ones), and it skips the optimizations that might cause the warning to not be output. (It currently still won't warn if the match isn't even attempted, like in the <code class="inline"><span class="q">"foobar"</span></code> example above.)</p> <p>In summary, Perl now normally treats non-Unicode code points as typical Unicode unassigned code points for regular expression matches, raising a warning only when it is arguable what the result should be. However, if this warning has been made fatal, it isn't skipped.</p> <p>There is one exception to all this. <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">All</span><span class="s">}</span></code> looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Any</span><span class="s">}</span></code> , matching code points <code class="inline"><span class="n">0</span></code> through <code class="inline"><span class="n">0x10FFFF</span></code> .)</p> <h3 id="Security-Implications-of-Unicode">Security Implications of Unicode</h3> <p>Read <a href="http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36" target="_blank">Unicode Security Considerations</a>. Also, note the following:</p> <ul> <li> <p>Malformed UTF-8</p> <p>Unfortunately, the original specification of UTF-8 leaves some room for interpretation of how many bytes of encoded output one should generate from one input Unicode character. Strictly speaking, the shortest possible sequence of UTF-8 bytes should be generated, because otherwise there is potential for an input buffer overflow at the receiving end of a UTF-8 connection. Perl always generates the shortest length UTF-8, and with warnings on, Perl will warn about non-shortest length UTF-8 along with other malformations, such as the surrogates, which are not Unicode code points valid for interchange.</p> </li> <li> <p>Regular expression pattern matching may surprise you if you're not accustomed to Unicode. Starting in Perl 5.14, several pattern modifiers are available to control this, called the character set modifiers. Details are given in <a href="../perlre/#Character-set-modifiers">Character set modifiers in perlre</a>.</p> </li> </ul> <p>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of bytes and the new world of characters, upgrading from bytes to characters when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to characters should happen. Characters shouldn't get downgraded to bytes, either. It is possible to accidentally mix bytes and characters, however (see <a href="../perluniintro/">perluniintro</a>), in which case <code class="inline">\<span class="w">w</span></code> in regular expressions might start behaving differently (unless the <code class="inline"><span class="q">/a</span></code> modifier is in effect). Review your code. Use warnings and the <code class="inline"><span class="w">strict</span></code> pragma.</p> <h3 id="Unicode-in-Perl-on-EBCDIC">Unicode in Perl on EBCDIC</h3> <p>The way Unicode is handled on EBCDIC platforms is still experimental. On such platforms, references to UTF-8 encoding in this document and elsewhere should be read as meaning the UTF-EBCDIC specified in Unicode Technical Report 16, unless ASCII vs. EBCDIC issues are specifically discussed. There is no <code class="inline"><span class="w">utfebcdic</span></code> pragma or <code class="inline"><span class="q">":utfebcdic"</span></code> layer; rather, <code class="inline"><span class="q">"utf8"</span></code> and <code class="inline"><span class="q">":utf8"</span></code> are reused to mean the platform's "natural" 8-bit encoding of Unicode. See <a href="../perlebcdic/">perlebcdic</a> for more discussion of the issues.</p> <h3 id="Locales">Locales</h3> <p>See <a href="../perllocale/#Unicode-and-UTF-8">Unicode and UTF-8 in perllocale</a></p> <h3 id="When-Unicode-Does-Not-Happen">When Unicode Does Not Happen</h3> <p>While Perl does have extensive ways to input and output in Unicode, and a few other "entry points" like the <code class="inline"><span class="i">@ARGV</span></code> array (which can sometimes be interpreted as UTF-8), there are still many places where Unicode (in some encoding or another) could be given as arguments or received as results, or both, but it is not.</p> <p>The following are such interfaces. Also, see <a href="#The-%22Unicode-Bug%22">The Unicode Bug</a>. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (problematic) <code class="inline"><span class="w">encoding</span></code> pragma has been used.</p> <p>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for <code class="inline"><a class="l_k" href="../functions/qx/">qx</a></code> and <code class="inline"><a class="l_k" href="../functions/system/">system</a></code>: how well will the "command-line interface" (and which of them?) handle Unicode?</p> <ul> <li> <p><code class="inline"><a class="l_k" href="../functions/chdir/">chdir</a></code>, <code class="inline"><a class="l_k" href="../functions/chmod/">chmod</a></code>, <code class="inline"><a class="l_k" href="../functions/chown/">chown</a></code>, <code class="inline"><a class="l_k" href="../functions/chroot/">chroot</a></code>, <code class="inline"><a class="l_k" href="../functions/exec/">exec</a></code>, <code class="inline"><a class="l_k" href="../functions/link/">link</a></code>, <code class="inline"><a class="l_k" href="../functions/lstat/">lstat</a></code>, <code class="inline"><a class="l_k" href="../functions/mkdir/">mkdir</a></code>, <code class="inline"><a class="l_k" href="../functions/rename/">rename</a></code>, <code class="inline"><a class="l_k" href="../functions/rmdir/">rmdir</a></code>, <code class="inline"><a class="l_k" href="../functions/stat/">stat</a></code>, <code class="inline"><a class="l_k" href="../functions/symlink/">symlink</a></code>, <code class="inline"><a class="l_k" href="../functions/truncate/">truncate</a></code>, <code class="inline"><a class="l_k" href="../functions/unlink/">unlink</a></code>, <code class="inline"><a class="l_k" href="../functions/utime/">utime</a></code>, <code class="inline"><a class="l_k" href="../functions/-x/">-X</a></code></p> </li> <li> <p><code class="inline"><span class="i">%ENV</span></code> </p> </li> <li> <p><code class="inline"><a class="l_k" href="../functions/glob/">glob</a></code> (aka the <code class="inline"><span class="q">&lt;*&gt;</span></code> )</p> </li> <li> <p><code class="inline"><a class="l_k" href="../functions/open/">open</a></code>, <code class="inline"><a class="l_k" href="../functions/opendir/">opendir</a></code>, <code class="inline"><a class="l_k" href="../functions/sysopen/">sysopen</a></code></p> </li> <li> <p><code class="inline"><a class="l_k" href="../functions/qx/">qx</a></code> (aka the backtick operator), <code class="inline"><a class="l_k" href="../functions/system/">system</a></code></p> </li> <li> <p><code class="inline"><a class="l_k" href="../functions/readdir/">readdir</a></code>, <code class="inline"><a class="l_k" href="../functions/readlink/">readlink</a></code></p> </li> </ul> <h3 id="The-%22Unicode-Bug%22">The "Unicode Bug"</h3> <p>The term, "Unicode bug" has been applied to an inconsistency on ASCII platforms with the Unicode code points in the <code class="inline">Latin-1 Supplement</code> block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters have very different semantics in byte semantics versus character semantics, unless <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">feature</span> <span class="q">'unicode_strings'</span></code> is specified, directly or indirectly. (It is indirectly specified by a <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="v">v5.12</span></code> or higher.)</p> <p>In character semantics these upper-Latin1 characters are interpreted as Unicode code points, which means they have the same semantics as Latin-1 (ISO-8859-1).</p> <p>In byte semantics (without <code class="inline"><span class="w">unicode_strings</span></code> ), they are considered to be unassigned characters, meaning that the only semantics they have is their ordinal numbers, and that they are not members of various character classes. None are considered to match <code class="inline">\<span class="w">w</span></code> for example, but all match <code class="inline">\<span class="w">W</span></code> .</p> <p>Perl 5.12.0 added <code class="inline"><span class="w">unicode_strings</span></code> to force character semantics on these code points in some circumstances, which fixed portions of the bug; Perl 5.14.0 fixed almost all of it; and Perl 5.16.0 fixed the remainder (so far as we know, anyway). The lesson here is to enable <code class="inline"><span class="w">unicode_strings</span></code> to avoid the headaches described below.</p> <p>The old, problematic behavior affects these areas:</p> <ul> <li> <p>Changing the case of a scalar, that is, using <code class="inline"><a class="l_k" href="../functions/uc/">uc()</a></code>, <code class="inline"><a class="l_k" href="../functions/ucfirst/">ucfirst()</a></code>, <code class="inline"><a class="l_k" href="../functions/lc/">lc()</a></code>, and <code class="inline"><a class="l_k" href="../functions/lcfirst/">lcfirst()</a></code>, or <code class="inline">\<span class="w">L</span></code> , <code class="inline">\<span class="w">U</span></code> , <code class="inline">\<span class="w">u</span></code> and <code class="inline">\<span class="w">l</span></code> in double-quotish contexts, such as regular expression substitutions. Under <code class="inline"><span class="w">unicode_strings</span></code> starting in Perl 5.12.0, character semantics are generally used. See <a href="../functions/lc/">lc</a> for details on how this works in combination with various other pragmas.</p> </li> <li> <p>Using caseless (<code class="inline">/i</code>) regular expression matching. Starting in Perl 5.14.0, regular expressions compiled within the scope of <code class="inline"><span class="w">unicode_strings</span></code> use character semantics even when executed or compiled into larger regular expressions outside the scope.</p> </li> <li> <p>Matching any of several properties in regular expressions, namely <code class="inline">\<span class="w">b</span></code> , <code class="inline">\<span class="w">B</span></code> , <code class="inline">\s</code>, <code class="inline">\<span class="w">S</span></code> , <code class="inline">\<span class="w">w</span></code> , <code class="inline">\<span class="w">W</span></code> , and all the Posix character classes <i>except</i> <code class="inline"><span class="s">[</span><span class="s">[</span><span class="co">:</span><span class="w">ascii</span><span class="co">:</span><span class="s">]</span><span class="s">]</span></code> . Starting in Perl 5.14.0, regular expressions compiled within the scope of <code class="inline"><span class="w">unicode_strings</span></code> use character semantics even when executed or compiled into larger regular expressions outside the scope.</p> </li> <li> <p>In <code class="inline"><a class="l_k" href="../functions/quotemeta/">quotemeta</a></code> or its inline equivalent <code class="inline">\<span class="w">Q</span></code> , no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted. Starting in Perl 5.16.0, consistent quoting rules are used within the scope of <code class="inline"><span class="w">unicode_strings</span></code> , as described in <a href="../functions/quotemeta/">quotemeta</a>.</p> </li> </ul> <p>This behavior can lead to unexpected results in which a string's semantics suddenly change if a code point above 255 is appended to or removed from it, which changes the string's semantics from byte to character or vice versa. As an example, consider the following program and its output:</p> <pre class="verbatim" data-language="perl">$ perl -le'
         no feature 'unicode_strings';
         $s1 = "\xC2";
         $s2 = "\x{2660}";
         for ($s1, $s2, $s1.$s2) {
                 print /\w/ || 0;
         }
 '
0
0
1
</pre>
<p>If there's no <code class="inline">\<span class="w">w</span></code> in <code class="inline"><span class="w">s1</span></code> or in <code class="inline"><span class="w">s2</span></code> , why does their concatenation have one?</p> <p>This anomaly stems from Perl's attempt to not disturb older programs that didn't use Unicode, and hence had no semantics for characters outside of the ASCII range (except in a locale), along with Perl's desire to add Unicode support seamlessly. The result wasn't seamless: these characters were orphaned.</p> <p>For Perls earlier than those described above, or when a string is passed to a function outside the subpragma's scope, a workaround is to always call <a href="../utf8/#Utility-functions">utf8::upgrade($string) </a>, or to use the standard module <a href="../encode/">Encode</a>. Also, a scalar that has any characters whose ordinal is <code class="inline"><span class="n">0x100</span></code> or above, or which were specified using either of the <code class="inline">\<span class="i">N</span><span class="s">{</span>...<span class="s">}</span></code> notations, will automatically have character semantics.</p> <h3 id="Forcing-Unicode-in-Perl-(Or-Unforcing-Unicode-in-Perl)">Forcing Unicode in Perl (Or Unforcing Unicode in Perl)</h3> <p>Sometimes (see <a href="#When-Unicode-Does-Not-Happen">When Unicode Does Not Happen</a> or <a href="#The-%22Unicode-Bug%22">The Unicode Bug</a>) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The low-level calls <a href="../utf8/#Utility-functions">utf8::upgrade($bytestring) </a> and <a href="../utf8/#Utility-functions">utf8::downgrade($utf8string[, FAIL_OK]) </a> are the answers.</p> <p>Note that <code class="inline"><span class="i">utf8::downgrade</span><span class="s">(</span><span class="s">)</span></code> can fail if the string contains characters that don't fit into a byte.</p> <p>Calling either function on a string that already is in the desired state is a no-op.</p> <h3 id="Using-Unicode-in-XS">Using Unicode in XS</h3> <p>If you want to handle Perl Unicode in XS extensions, you may find the following C APIs useful. See also <a href="../perlguts/#Unicode-Support">Unicode Support in perlguts</a> for an explanation about Unicode at the XS level, and <a href="../perlapi/">perlapi</a> for the API details.</p> <ul> <li> <p><code class="inline"><span class="i">DO_UTF8</span><span class="s">(</span><span class="w">sv</span><span class="s">)</span></code> returns true if the <code class="inline"><span class="w">UTF8</span></code> flag is on and the bytes pragma is not in effect. <code class="inline"><span class="i">SvUTF8</span><span class="s">(</span><span class="w">sv</span><span class="s">)</span></code> returns true if the <code class="inline"><span class="w">UTF8</span></code> flag is on; the <code class="inline"><span class="w">bytes</span></code> pragma is ignored. The <code class="inline"><span class="w">UTF8</span></code> flag being on does <b>not</b> mean that there are any characters of code points greater than 255 (or 127) in the scalar or that there are even any characters in the scalar. What the <code class="inline"><span class="w">UTF8</span></code> flag means is that the sequence of octets in the representation of the scalar is the sequence of UTF-8 encoded code points of the characters of a string. The <code class="inline"><span class="w">UTF8</span></code> flag being off means that each octet in this representation encodes a single character with code point 0..255 within the string. Perl's Unicode model is not to use UTF-8 until it is absolutely necessary.</p> </li> <li> <p><code class="inline"><span class="i">uvchr_to_utf8</span><span class="s">(</span><span class="w">buf</span><span class="cm">,</span> <a class="l_k" href="../functions/chr/">chr</a><span class="s">)</span></code> writes a Unicode character code point into a buffer encoding the code point as UTF-8, and returns a pointer pointing after the UTF-8 bytes. It works appropriately on EBCDIC machines.</p> </li> <li> <p><code class="inline"><span class="i">utf8_to_uvchr_buf</span><span class="s">(</span><span class="w">buf</span><span class="cm">,</span> <span class="w">bufend</span><span class="cm">,</span> <span class="w">lenp</span><span class="s">)</span></code> reads UTF-8 encoded bytes from a buffer and returns the Unicode character code point and, optionally, the length of the UTF-8 byte sequence. It works appropriately on EBCDIC machines.</p> </li> <li> <p><code class="inline"><span class="i">utf8_length</span><span class="s">(</span><span class="w">start</span><span class="cm">,</span> <span class="w">end</span><span class="s">)</span></code> returns the length of the UTF-8 encoded buffer in characters. <code class="inline"><span class="i">sv_len_utf8</span><span class="s">(</span><span class="w">sv</span><span class="s">)</span></code> returns the length of the UTF-8 encoded scalar.</p> </li> <li> <p><code class="inline"><span class="i">sv_utf8_upgrade</span><span class="s">(</span><span class="w">sv</span><span class="s">)</span></code> converts the string of the scalar to its UTF-8 encoded form. <code class="inline"><span class="i">sv_utf8_downgrade</span><span class="s">(</span><span class="w">sv</span><span class="s">)</span></code> does the opposite, if possible. <code class="inline"><span class="i">sv_utf8_encode</span><span class="s">(</span><span class="w">sv</span><span class="s">)</span></code> is like sv_utf8_upgrade except that it does not set the <code class="inline"><span class="w">UTF8</span></code> flag. <code class="inline"><span class="i">sv_utf8_decode</span><span class="s">(</span><span class="s">)</span></code> does the opposite of <code class="inline"><span class="i">sv_utf8_encode</span><span class="s">(</span><span class="s">)</span></code> . Note that none of these are to be used as general-purpose encoding or decoding interfaces: <code class="inline"><a class="l_k" href="../functions/use/">use</a> <span class="w">Encode</span></code> for that. <code class="inline"><span class="i">sv_utf8_upgrade</span><span class="s">(</span><span class="s">)</span></code> is affected by the encoding pragma but <code class="inline"><span class="i">sv_utf8_downgrade</span><span class="s">(</span><span class="s">)</span></code> is not (since the encoding pragma is designed to be a one-way street).</p> </li> <li> <p><code class="inline"><span class="i">is_utf8_string</span><span class="s">(</span><span class="w">buf</span><span class="cm">,</span> <span class="w">len</span><span class="s">)</span></code> returns true if <code class="inline"><span class="w">len</span></code> bytes of the buffer are valid UTF-8.</p> </li> <li> <p><code class="inline"><span class="i">is_utf8_char_buf</span><span class="s">(</span><span class="w">buf</span><span class="cm">,</span> <span class="w">buf_end</span><span class="s">)</span></code> returns true if the pointer points to a valid UTF-8 character.</p> </li> <li> <p><code class="inline"><span class="i">UTF8SKIP</span><span class="s">(</span><span class="w">buf</span><span class="s">)</span></code> will return the number of bytes in the UTF-8 encoded character in the buffer. <code class="inline"><span class="i">UNISKIP</span><span class="s">(</span><a class="l_k" href="../functions/chr/">chr</a><span class="s">)</span></code> will return the number of bytes required to UTF-8-encode the Unicode character code point. <code class="inline"><span class="i">UTF8SKIP</span><span class="s">(</span><span class="s">)</span></code> is useful for example for iterating over the characters of a UTF-8 encoded buffer; <code class="inline"><span class="i">UNISKIP</span><span class="s">(</span><span class="s">)</span></code> is useful, for example, in computing the size required for a UTF-8 encoded buffer.</p> </li> <li> <p><code class="inline"><span class="i">utf8_distance</span><span class="s">(</span><span class="w">a</span><span class="cm">,</span> <span class="w">b</span><span class="s">)</span></code> will tell the distance in characters between the two pointers pointing to the same UTF-8 encoded buffer.</p> </li> <li> <p><code class="inline">utf8_hop(s, off)</code> will return a pointer to a UTF-8 encoded buffer that is <code class="inline"><span class="w">off</span></code> (positive or negative) Unicode characters displaced from the UTF-8 buffer <code class="inline"><a class="l_k" href="../functions/s/">s</a></code>. Be careful not to overstep the buffer: <code class="inline"><span class="i">utf8_hop</span><span class="s">(</span><span class="s">)</span></code> will merrily run off the end or the beginning of the buffer if told to do so.</p> </li> <li> <p><code class="inline"><span class="i">pv_uni_display</span><span class="s">(</span><span class="w">dsv</span><span class="cm">,</span> <span class="w">spv</span><span class="cm">,</span> <span class="w">len</span><span class="cm">,</span> <span class="w">pvlim</span><span class="cm">,</span> <span class="w">flags</span><span class="s">)</span></code> and <code class="inline"><span class="i">sv_uni_display</span><span class="s">(</span><span class="w">dsv</span><span class="cm">,</span> <span class="w">ssv</span><span class="cm">,</span> <span class="w">pvlim</span><span class="cm">,</span> <span class="w">flags</span><span class="s">)</span></code> are useful for debugging the output of Unicode strings and scalars. By default they are useful only for debugging--they display <b>all</b> characters as hexadecimal code points--but with the flags <code class="inline"><span class="w">UNI_DISPLAY_ISPRINT</span></code> , <code class="inline"><span class="w">UNI_DISPLAY_BACKSLASH</span></code> , and <code class="inline"><span class="w">UNI_DISPLAY_QQ</span></code> you can make the output more readable.</p> </li> <li> <p><code class="inline"><span class="i">foldEQ_utf8</span><span class="s">(</span><span class="w">s1</span><span class="cm">,</span> <span class="w">pe1</span><span class="cm">,</span> <span class="w">l1</span><span class="cm">,</span> <span class="w">u1</span><span class="cm">,</span> <span class="w">s2</span><span class="cm">,</span> <span class="w">pe2</span><span class="cm">,</span> <span class="w">l2</span><span class="cm">,</span> <span class="w">u2</span><span class="s">)</span></code> can be used to compare two strings case-insensitively in Unicode. For case-sensitive comparisons you can just use <code class="inline"><span class="i">memEQ</span><span class="s">(</span><span class="s">)</span></code> and <code class="inline"><span class="i">memNE</span><span class="s">(</span><span class="s">)</span></code> as usual, except if one string is in utf8 and the other isn't.</p> </li> </ul> <p>For more information, see <a href="../perlapi/">perlapi</a>, and <i>utf8.c</i> and <i>utf8.h</i> in the Perl source code distribution.</p> <h3 id="Hacking-Perl-to-work-on-earlier-Unicode-versions-(for-very-serious-hackers-only)">Hacking Perl to work on earlier Unicode versions (for very serious hackers only)</h3> <p>Perl by default comes with the latest supported Unicode version built in, but you can change to use any earlier one.</p> <p>Download the files in the desired version of Unicode from the Unicode web site <a href="http://www.unicode.org" target="_blank">http://www.unicode.org</a>). These should replace the existing files in <i>lib/unicore</i> in the Perl source tree. Follow the instructions in <i>README.perl</i> in that directory to change some of their names, and then build perl (see <a href="http://search.cpan.org/perldoc/INSTALL" target="_blank">INSTALL</a>).</p> <h2 id="BUGS">BUGS</h2> <h3 id="Interaction-with-Locales">Interaction with Locales</h3> <p>See <a href="../perllocale/#Unicode-and-UTF-8">Unicode and UTF-8 in perllocale</a></p> <h3 id="Problems-with-characters-in-the-Latin-1-Supplement-range">Problems with characters in the Latin-1 Supplement range</h3> <p>See <a href="#The-%22Unicode-Bug%22">The Unicode Bug</a></p> <h3 id="Interaction-with-Extensions">Interaction with Extensions</h3> <p>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</p> <p>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</p> <p>For affected functions, the simple strategy to avoid data corruption is to always make the encoding of the exchanged data explicit. Choose an encoding that you know the extension can handle. Convert arguments passed to the extensions to that encoding and convert results back from that encoding. Write wrapper functions that do the conversions for you, so you can later change the functions when the extension catches up.</p> <p>To provide an example, let's say the popular <code class="inline"><span class="w">Foo::Bar::escape_html</span></code> function doesn't deal with Unicode data yet. The wrapper function would convert the argument to raw UTF-8 and convert the result back to Perl's internal representation like so:</p> <pre class="verbatim" data-language="perl">sub my_escape_html ($) {
    my($what) = shift;
    return unless defined $what;
    Encode::decode_utf8(Foo::Bar::escape_html(
                                     Encode::encode_utf8($what)));
}
</pre>
<p>Sometimes, when the extension does not convert data but just stores and retrieves them, you will be able to use the otherwise dangerous <a href="../encode/#_utf8_on">Encode::_utf8_on() </a> function. Let's say the popular <code class="inline"><span class="w">Foo::Bar</span></code> extension, written in C, provides a <code class="inline"><span class="w">param</span></code> method that lets you store and retrieve data according to these prototypes:</p> <pre class="verbatim" data-language="perl">$self-&gt;param($name, $value);            # set a scalar
$value = $self-&gt;param($name);           # retrieve a scalar
</pre>
<p>If it does not yet provide support for any encoding, one could write a derived class with such a <code class="inline"><span class="w">param</span></code> method:</p> <pre class="verbatim" data-language="perl">sub param {
  my($self,$name,$value) = @_;
  utf8::upgrade($name);     # make sure it is UTF-8 encoded
  if (defined $value) {
    utf8::upgrade($value);  # make sure it is UTF-8 encoded
    return $self-&gt;SUPER::param($name,$value);
  } else {
    my $ret = $self-&gt;SUPER::param($name);
    Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
    return $ret;
  }
}
</pre>
<p>Some extensions provide filters on data entry/exit points, such as <code class="inline"><span class="w">DB_File::filter_store_key</span></code> and family. Look out for such filters in the documentation of your extensions, they can make the transition to Unicode data much easier.</p> <h3 id="Speed">Speed</h3> <p>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as <code class="inline"><a class="l_k" href="../functions/length/">length()</a></code>, <code class="inline"><a class="l_k" href="../functions/substr/">substr()</a></code> or <code class="inline"><a class="l_k" href="../functions/">index()</a></code>, or matching regular expressions can work <b>much</b> faster when the underlying data are byte-encoded.</p> <p>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which will hopefully make the slowness somewhat less spectacular, at least for some operations. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like <code class="inline">\<span class="i">p</span><span class="s">{</span><span class="w">Nd</span><span class="s">}</span></code> are known to be quite a bit slower (5-20 times) than their simpler counterparts like <code class="inline">\<span class="w">d</span></code> (then again, there are hundreds of Unicode characters matching <code class="inline"><span class="w">Nd</span></code> compared with the 10 ASCII characters matching <code class="inline"><span class="w">d</span></code> ).</p> <h3 id="Problems-on-EBCDIC-platforms">Problems on EBCDIC platforms</h3> <p>There are several known problems with Perl on EBCDIC platforms. If you want to use Perl there, send email to perlbug@perl.org.</p> <p>In earlier versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as <i>ISO 8859-1 (Latin-1)</i>, even if the old Unicode string used EBCDIC.</p> <p>If you find any of these, please report them as bugs.</p> <h3 id="Porting-code-from-perl-5.6.X">Porting code from perl-5.6.X</h3> <p>Perl 5.8 has a different Unicode model from 5.6. In 5.6 the programmer was required to use the <code class="inline"><span class="w">utf8</span></code> pragma to declare that a given scope expected to deal with Unicode data and had to make sure that only Unicode data were reaching that scope. If you have code that is working with 5.6, you will need some of the following adjustments to your code. The examples are written such that the code will continue to work under 5.6, so you should be safe to try them out.</p> <ul> <li> <p>A filehandle that should read or write UTF-8</p> <pre class="verbatim" data-language="perl">if ($] &gt; 5.008) {
  binmode $fh, ":encoding(utf8)";
}
</pre>
</li> <li> <p>A scalar that is going to be passed to some extension</p> <p>Be it <code class="inline"><span class="w">Compress::Zlib</span></code> , <code class="inline"><span class="w">Apache::Request</span></code> or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</p> <pre class="verbatim" data-language="perl">if ($] &gt; 5.008) {
  require Encode;
  $val = Encode::encode_utf8($val); # make octets
}
</pre>
</li> <li> <p>A scalar we got back from an extension</p> <p>If you believe the scalar comes back as UTF-8, you will most likely want the UTF8 flag restored:</p> <pre class="verbatim" data-language="perl">if ($] &gt; 5.008) {
  require Encode;
  $val = Encode::decode_utf8($val);
}
</pre>
</li> <li> <p>Same thing, if you are really sure it is UTF-8</p> <pre class="verbatim" data-language="perl">if ($] &gt; 5.008) {
  require Encode;
  Encode::_utf8_on($val);
}
</pre>
</li> <li> <p>A wrapper for <a href="http://search.cpan.org/perldoc/DBI" target="_blank">DBI</a> <code class="inline"><span class="w">fetchrow_array</span></code> and <code class="inline"><span class="w">fetchrow_hashref</span></code> </p> <p>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your <code class="inline"><span class="w">fetchrow_array</span></code> and <code class="inline"><span class="w">fetchrow_hashref</span></code> calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the <a href="http://search.cpan.org/perldoc/DBI" target="_blank">DBI documentation</a> to verify if that is still true.</p> <pre class="verbatim" data-language="perl">sub fetchrow {
  # $what is one of fetchrow_{array,hashref}
  my($self, $sth, $what) = @_;
  if ($] &lt; 5.008) {
    return $sth-&gt;$what;
  } else {
    require Encode;
    if (wantarray) {
      my @arr = $sth-&gt;$what;
      for (@arr) {
        defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_);
      }
      return @arr;
    } else {
      my $ret = $sth-&gt;$what;
      if (ref $ret) {
        for my $k (keys %$ret) {
          defined
          &amp;&amp; /[^\000-\177]/
          &amp;&amp; Encode::_utf8_on($_) for $ret-&gt;{$k};
        }
        return $ret;
      } else {
        defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_) for $ret;
        return $ret;
      }
    }
  }
}
</pre>
</li> <li> <p>A large scalar that you know can only contain ASCII</p> <p>Scalars that contain only ASCII and are marked as UTF-8 are sometimes a drag to your program. If you recognize such a situation, just remove the UTF8 flag:</p> <pre class="verbatim" data-language="perl">utf8::downgrade($val) if $] &gt; 5.008;
</pre>
</li> </ul> <h2 id="SEE-ALSO">SEE ALSO</h2> <p><a href="../perlunitut/">perlunitut</a>, <a href="../perluniintro/">perluniintro</a>, <a href="../perluniprops/">perluniprops</a>, <a href="../encode/">Encode</a>, <a href="../open/">open</a>, <a href="../utf8/">utf8</a>, <a href="../bytes/">bytes</a>, <a href="../perlretut/">perlretut</a>, <a href="../perlvar/#%24%7b%5eUNICODE%7d">${^UNICODE} in perlvar</a> <a href="http://www.unicode.org/reports/tr44" target="_blank">http://www.unicode.org/reports/tr44</a>).</p>
<div class="_attribution">
  <p class="_attribution-p">
     19932016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="http://perldoc.perl.org/5.20.2/perlunicode.html" class="_attribution-link" target="_blank">http://perldoc.perl.org/5.20.2/perlunicode.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
