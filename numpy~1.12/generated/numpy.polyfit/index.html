
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>numpy.polyfit() - NumPy 1.12 - W3cubDocs</title>
  
  <meta name="description" content=" Least squares polynomial fit. ">
  <meta name="keywords" content="numpy, polyfit, -, numpy~1.12">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/numpy~1.12/generated/numpy.polyfit/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/numpy~1.12.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/numpy~1.12/" class="_nav-link" title="" style="margin-left:0;">NumPy 1.12</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="numpy-polyfit">numpy.polyfit</h1> <dl class="function"> <dt id="numpy.polyfit">
<code>numpy.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.12.0/numpy/lib/polynomial.py#L398-L611" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Least squares polynomial fit.</p> <p>Fit a polynomial <code>p(x) = p[0] * x**deg + ... + p[deg]</code> of degree <code>deg</code> to points <code>(x, y)</code>. Returns a vector of coefficients <code>p</code> that minimises the squared error.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array_like, shape (M,)</p>  <p>x-coordinates of the M sample points <code>(x[i], y[i])</code>.</p>  <p><strong>y</strong> : array_like, shape (M,) or (M, K)</p>  <p>y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column.</p>  <p><strong>deg</strong> : int</p>  <p>Degree of the fitting polynomial</p>  <p><strong>rcond</strong> : float, optional</p>  <p>Relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. The default value is len(x)*eps, where eps is the relative precision of the float type, about 2e-16 in most cases.</p>  <p><strong>full</strong> : bool, optional</p>  <p>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</p>  <p><strong>w</strong> : array_like, shape (M,), optional</p>  <p>Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2).</p>  <p><strong>cov</strong> : bool, optional</p>  <p>Return the estimate and the covariance matrix of the estimate If full is True, then cov is not returned.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>p</strong> : ndarray, shape (deg + 1,) or (deg + 1, K)</p>  <p>Polynomial coefficients, highest power first. If <code>y</code> was 2-D, the coefficients for <code>k</code>-th data set are in <code>p[:,k]</code>.</p>  <p>residuals, rank, singular_values, rcond</p>  <p>Present only if <a class="reference internal" href="../numpy.full/#numpy.full" title="numpy.full"><code>full</code></a> = True. Residuals of the least-squares fit, the effective rank of the scaled Vandermonde coefficient matrix, its singular values, and the specified value of <code>rcond</code>. For more details, see <a class="reference internal" href="../numpy.linalg.lstsq/#numpy.linalg.lstsq" title="numpy.linalg.lstsq"><code>linalg.lstsq</code></a>.</p>  <p><strong>V</strong> : ndarray, shape (M,M) or (M,M,K)</p>  <p>Present only if <a class="reference internal" href="../numpy.full/#numpy.full" title="numpy.full"><code>full</code></a> = False and <code>cov`=True. The covariance matrix of the polynomial coefficient estimates. The diagonal of this matrix are the variance estimates for each coefficient. If y is a 2-D array, then the covariance matrix for the `k</code>-th data set are in <code>V[:,:,k]</code></p>  </td> </tr> <tr class="field-odd field">
<th class="field-name">Warns:</th>
<td class="field-body">
<p class="first"><strong>RankWarning</strong></p>  <p>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if <a class="reference internal" href="../numpy.full/#numpy.full" title="numpy.full"><code>full</code></a> = False.</p> <p>The warnings can be turned off by</p> <pre data-language="python">&gt;&gt;&gt; import warnings
&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)
</pre>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="../numpy.polyval/#numpy.polyval" title="numpy.polyval"><code>polyval</code></a>
</dt> <dd>Compute polynomial values.</dd> <dt>
 <a class="reference internal" href="../numpy.linalg.lstsq/#numpy.linalg.lstsq" title="numpy.linalg.lstsq"><code>linalg.lstsq</code></a>
</dt> <dd>Computes a least-squares fit.</dd> <dt>
 <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html#scipy.interpolate.UnivariateSpline" title="(in SciPy v0.18.1)" target="_blank"><code>scipy.interpolate.UnivariateSpline</code></a>
</dt> <dd>Computes spline fits.</dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The solution minimizes the squared error</p> <div class="math"> <p><img src="https://docs.scipy.org/doc/numpy-1.12.0/_images/math/3e125ffecb04217922f4cb0a04367165ebf64864.png" alt="E = \sum_{j=0}^k |p(x_j) - y_j|^2"></p> </div>
<p>in the equations:</p> <pre data-language="python">x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
...
x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]
</pre> <p>The coefficient matrix of the coefficients <code>p</code> is a Vandermonde matrix.</p> <p><a class="reference internal" href="#numpy.polyfit" title="numpy.polyfit"><code>polyfit</code></a> issues a <a class="reference internal" href="../numpy.rankwarning/#numpy.RankWarning" title="numpy.RankWarning"><code>RankWarning</code></a> when the least-squares fit is badly conditioned. This implies that the best fit is not well-defined due to numerical error. The results may be improved by lowering the polynomial degree or by replacing <code>x</code> by <code>x</code> - <code>x</code>.mean(). The <code>rcond</code> parameter can also be set to a value smaller than its default, but the resulting fit may be spurious: including contributions from the small singular values can add numerical noise to the result.</p> <p>Note that fitting polynomial coefficients is inherently badly conditioned when the degree of the polynomial is large or the interval of sample points is badly centered. The quality of the fit should always be checked in these cases. When polynomial fits are not satisfactory, splines may be a good alternative.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r58" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[R58]</a></td>
<td>Wikipedia, “Curve fitting”, <a class="reference external" href="http://en.wikipedia.org/wiki/Curve_fitting" target="_blank">http://en.wikipedia.org/wiki/Curve_fitting</a>
</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r59" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[R59]</a></td>
<td>Wikipedia, “Polynomial interpolation”, <a class="reference external" href="http://en.wikipedia.org/wiki/Polynomial_interpolation" target="_blank">http://en.wikipedia.org/wiki/Polynomial_interpolation</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
&gt;&gt;&gt; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
&gt;&gt;&gt; z = np.polyfit(x, y, 3)
&gt;&gt;&gt; z
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254])
</pre> <p>It is convenient to use <a class="reference internal" href="../numpy.poly1d/#numpy.poly1d" title="numpy.poly1d"><code>poly1d</code></a> objects for dealing with polynomials:</p> <pre data-language="python">&gt;&gt;&gt; p = np.poly1d(z)
&gt;&gt;&gt; p(0.5)
0.6143849206349179
&gt;&gt;&gt; p(3.5)
-0.34732142857143039
&gt;&gt;&gt; p(10)
22.579365079365115
</pre> <p>High-order polynomials may oscillate wildly:</p> <pre data-language="python">&gt;&gt;&gt; p30 = np.poly1d(np.polyfit(x, y, 30))
/... RankWarning: Polyfit may be poorly conditioned...
&gt;&gt;&gt; p30(4)
-0.80000000000000204
&gt;&gt;&gt; p30(5)
-0.99999999999999445
&gt;&gt;&gt; p30(4.5)
-0.10547061179440398
</pre> <p>Illustration:</p> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; xp = np.linspace(-2, 6, 100)
&gt;&gt;&gt; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
&gt;&gt;&gt; plt.ylim(-2,2)
(-2, 2)
&gt;&gt;&gt; plt.show()
</pre> <p>(<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.12.0/reference/generated/numpy-polyfit-1.py" target="_blank">Source code</a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.12.0/reference/generated/numpy-polyfit-1.png" target="_blank">png</a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.12.0/reference/generated/numpy-polyfit-1.pdf" target="_blank">pdf</a>)</p> <div class="figure"> <img alt="../../_images/numpy-polyfit-1.png" src="https://docs.scipy.org/doc/numpy-1.12.0/_images/numpy-polyfit-1.png"> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2008–2017 NumPy Developers<br>Licensed under the NumPy License.<br>
    <a href="https://docs.scipy.org/doc/numpy-1.12.0/reference/generated/numpy.polyfit.html" class="_attribution-link" target="_blank">https://docs.scipy.org/doc/numpy-1.12.0/reference/generated/numpy.polyfit.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
