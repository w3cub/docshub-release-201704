
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Scalars - NumPy 1.12 - W3cubDocs</title>
  
  <meta name="description" content="Python defines only one type of a particular data class (there is only one integer type, one floating-point type, etc.). This can be convenient in &hellip;">
  <meta name="keywords" content="scalars, -, numpy, numpy~1.12">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/numpy~1.12/arrays.scalars/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-50364fff564ce3b6327021805f3f00e2957b441cf27f576a7dd4ff63bbc47047.css">
  <script type="text/javascript" src="/assets/application-db64bfd54ceb42be11af7995804cf4902548419ceb79d509b0b7d62c22d98e6f.js"></script>
  <script src="/json/numpy~1.12.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/numpy~1.12/" class="_nav-link" title="" style="margin-left:0;">NumPy 1.12</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="arrays-scalars">Scalars</h1> <p id="scalars">Python defines only one type of a particular data class (there is only one integer type, one floating-point type, etc.). This can be convenient in applications that don’t need to be concerned with all the ways data can be represented in a computer. For scientific computing, however, more control is often needed.</p> <p>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python’s types.</p> <p>Array scalars have the same attributes and methods as <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a>. <a class="footnote-reference" href="#id2" id="id1">[1]</a> This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</p> <p>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, <code>isinstance(val, np.generic)</code> will return <code>True</code> if <em>val</em> is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example <code>isinstance(val, np.complexfloating)</code> will return <code>True</code> if <em>val</em> is a complex valued type, while <code>isinstance(val, np.flexible)</code> will return true if <em>val</em> is one of the flexible itemsize array types (<code>string</code>, <code>unicode</code>, <code>void</code>).</p> <div class="figure"> <img alt="../_images/dtype-hierarchy.png" src="https://docs.scipy.org/doc/numpy-1.12.0/_images/dtype-hierarchy.png"> <p class="caption"><strong>Figure:</strong> Hierarchy of type objects representing the array data types. Not shown are the two integer types <code>intp</code> and <code>uintp</code> which just point to the integer type that holds a pointer for the platform. All the number types can be obtained using bit-width names as well.</p> </div> <table class="docutils footnote" frame="void" id="id2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[1]</a></td>
<td>However, array scalars are immutable, so none of the array scalar attributes are settable.</td>
</tr>  </table>  <h2 id="arrays-scalars-character-codes">Built-in scalar types</h2> <p id="built-in-scalar-types">The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. <code>int8</code>, <code>float64</code>, <code>complex128</code>). Two aliases (<code>intp</code> and <code>uintp</code>) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</p> <p>Some of the scalar types are essentially equivalent to fundamental Python types and therefore inherit from them as well as from the generic array scalar type:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Array scalar type</th> <th class="head">Related Python type</th> </tr> </thead>  <tr class="row-even">
<td><code>int_</code></td> <td>
<code>IntType</code> (Python 2 only)</td> </tr> <tr class="row-odd">
<td><code>float_</code></td> <td><code>FloatType</code></td> </tr> <tr class="row-even">
<td><code>complex_</code></td> <td><code>ComplexType</code></td> </tr> <tr class="row-odd">
<td><code>str_</code></td> <td><code>StringType</code></td> </tr> <tr class="row-even">
<td><code>unicode_</code></td> <td><code>UnicodeType</code></td> </tr>  </table> <p>The <code>bool_</code> data type is very similar to the Python <code>BooleanType</code> but does not inherit from it because Python’s <code>BooleanType</code> does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The <code>bool_</code> type is not a subclass of the <code>int_</code> type (the <code>bool_</code> is not even a number type). This is different than Python’s default implementation of <a class="reference external" href="https://docs.python.org/dev/library/functions.html#bool" title="(in Python v3.7)" target="_blank"><code>bool</code></a> as a sub-class of int.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The <code>int_</code> type does <strong>not</strong> inherit from the <a class="reference external" href="https://docs.python.org/dev/library/functions.html#int" title="(in Python v3.7)" target="_blank"><code>int</code></a> built-in under Python 3, because type <a class="reference external" href="https://docs.python.org/dev/library/functions.html#int" title="(in Python v3.7)" target="_blank"><code>int</code></a> is no longer a fixed-width integer type.</p> </div> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">The default data type in NumPy is <code>float_</code>.</p> </div> <p>In the tables below, <code>platform?</code> means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</p> <p>Booleans:</p> <table class="docutils">  <thead valign="bottom"> <tr class="row-odd">
<th class="head">Type</th> <th class="head">Remarks</th> <th class="head">Character code</th> </tr> </thead>  <tr class="row-even">
<td><code>bool_</code></td> <td>compatible: Python bool</td> <td><code>'?'</code></td> </tr> <tr class="row-odd">
<td><code>bool8</code></td> <td>8 bits</td> <td> </td> </tr>  </table> <p>Integers:</p> <table class="docutils">   <tr class="row-odd">
<td><code>byte</code></td> <td>compatible: C char</td> <td><code>'b'</code></td> </tr> <tr class="row-even">
<td><code>short</code></td> <td>compatible: C short</td> <td><code>'h'</code></td> </tr> <tr class="row-odd">
<td><code>intc</code></td> <td>compatible: C int</td> <td><code>'i'</code></td> </tr> <tr class="row-even">
<td><code>int_</code></td> <td>compatible: Python int</td> <td><code>'l'</code></td> </tr> <tr class="row-odd">
<td><code>longlong</code></td> <td>compatible: C long long</td> <td><code>'q'</code></td> </tr> <tr class="row-even">
<td><code>intp</code></td> <td>large enough to fit a pointer</td> <td><code>'p'</code></td> </tr> <tr class="row-odd">
<td><code>int8</code></td> <td>8 bits</td> <td> </td> </tr> <tr class="row-even">
<td><code>int16</code></td> <td>16 bits</td> <td> </td> </tr> <tr class="row-odd">
<td><code>int32</code></td> <td>32 bits</td> <td> </td> </tr> <tr class="row-even">
<td><code>int64</code></td> <td>64 bits</td> <td> </td> </tr>  </table> <p>Unsigned integers:</p> <table class="docutils">   <tr class="row-odd">
<td><code>ubyte</code></td> <td>compatible: C unsigned char</td> <td><code>'B'</code></td> </tr> <tr class="row-even">
<td><code>ushort</code></td> <td>compatible: C unsigned short</td> <td><code>'H'</code></td> </tr> <tr class="row-odd">
<td><code>uintc</code></td> <td>compatible: C unsigned int</td> <td><code>'I'</code></td> </tr> <tr class="row-even">
<td><code>uint</code></td> <td>compatible: Python int</td> <td><code>'L'</code></td> </tr> <tr class="row-odd">
<td><code>ulonglong</code></td> <td>compatible: C long long</td> <td><code>'Q'</code></td> </tr> <tr class="row-even">
<td><code>uintp</code></td> <td>large enough to fit a pointer</td> <td><code>'P'</code></td> </tr> <tr class="row-odd">
<td><code>uint8</code></td> <td>8 bits</td> <td> </td> </tr> <tr class="row-even">
<td><code>uint16</code></td> <td>16 bits</td> <td> </td> </tr> <tr class="row-odd">
<td><code>uint32</code></td> <td>32 bits</td> <td> </td> </tr> <tr class="row-even">
<td><code>uint64</code></td> <td>64 bits</td> <td> </td> </tr>  </table> <p>Floating-point numbers:</p> <table class="docutils">   <tr class="row-odd">
<td><code>half</code></td> <td> </td> <td><code>'e'</code></td> </tr> <tr class="row-even">
<td><code>single</code></td> <td>compatible: C float</td> <td><code>'f'</code></td> </tr> <tr class="row-odd">
<td><code>double</code></td> <td>compatible: C double</td> <td> </td> </tr> <tr class="row-even">
<td><code>float_</code></td> <td>compatible: Python float</td> <td><code>'d'</code></td> </tr> <tr class="row-odd">
<td><code>longfloat</code></td> <td>compatible: C long float</td> <td><code>'g'</code></td> </tr> <tr class="row-even">
<td><code>float16</code></td> <td>16 bits</td> <td> </td> </tr> <tr class="row-odd">
<td><code>float32</code></td> <td>32 bits</td> <td> </td> </tr> <tr class="row-even">
<td><code>float64</code></td> <td>64 bits</td> <td> </td> </tr> <tr class="row-odd">
<td><code>float96</code></td> <td>96 bits, platform?</td> <td> </td> </tr> <tr class="row-even">
<td><code>float128</code></td> <td>128 bits, platform?</td> <td> </td> </tr>  </table> <p>Complex floating-point numbers:</p> <table class="docutils">   <tr class="row-odd">
<td><code>csingle</code></td> <td> </td> <td><code>'F'</code></td> </tr> <tr class="row-even">
<td><code>complex_</code></td> <td>compatible: Python complex</td> <td><code>'D'</code></td> </tr> <tr class="row-odd">
<td><code>clongfloat</code></td> <td> </td> <td><code>'G'</code></td> </tr> <tr class="row-even">
<td><code>complex64</code></td> <td>two 32-bit floats</td> <td> </td> </tr> <tr class="row-odd">
<td><code>complex128</code></td> <td>two 64-bit floats</td> <td> </td> </tr> <tr class="row-even">
<td><code>complex192</code></td> <td>two 96-bit floats, platform?</td> <td> </td> </tr> <tr class="row-odd">
<td><code>complex256</code></td> <td>two 128-bit floats, platform?</td> <td> </td> </tr>  </table> <p>Any Python object:</p> <table class="docutils">   <tr class="row-odd">
<td><code>object_</code></td> <td>any Python object</td> <td><code>'O'</code></td> </tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>The data actually stored in <code>object arrays</code> (<em>i.e.</em>, arrays having dtype <code>object_</code>) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python <a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#list" title="(in Python v3.7)" target="_blank"><code>lists</code></a>, in the sense that their contents need not be of the same Python type.</p> <p class="last">The object type is also special because an array containing <code>object_</code> items does not return an <code>object_</code> object on item access, but instead returns the actual object that the array item refers to.</p> </div> <p>The following data types are <code>flexible</code>. They have no predefined size: the data they describe can be of different length in different arrays. (In the character codes <code>#</code> is an integer denoting how many elements the data type consists of.)</p> <table class="docutils">   <tr class="row-odd">
<td><code>str_</code></td> <td>compatible: Python str</td> <td><code>'S#'</code></td> </tr> <tr class="row-even">
<td><code>unicode_</code></td> <td>compatible: Python unicode</td> <td><code>'U#'</code></td> </tr> <tr class="row-odd">
<td><code>void</code></td> <td> </td> <td><code>'V#'</code></td> </tr>  </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Numeric Compatibility: If you used old typecode characters in your Numeric code (which was never recommended), you will need to change some of them to the new characters. In particular, the needed changes are <code>c -&gt; S1</code>, <code>b -&gt; B</code>, <code>1 -&gt; b</code>, <code>s -&gt; h</code>, <code>w -&gt; H</code>, and <code>u -&gt; I</code>. These changes make the type character convention more consistent with other Python modules such as the <a class="reference external" href="https://docs.python.org/dev/library/struct.html#module-struct" title="(in Python v3.7)" target="_blank"><code>struct</code></a> module.</p> </div>   <h2 id="attributes">Attributes</h2> <p>The array scalar objects have an <code>array priority</code> of <a class="reference internal" href="../c-api.array/#c.NPY_SCALAR_PRIORITY" title="NPY_SCALAR_PRIORITY"><code>NPY_SCALAR_PRIORITY</code></a> (-1,000,000.0). They also do not (yet) have a <a class="reference internal" href="../generated/numpy.ndarray.ctypes/#numpy.ndarray.ctypes" title="numpy.ndarray.ctypes"><code>ctypes</code></a> attribute. Otherwise, they share the same attributes as arrays:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.flags/#numpy.generic.flags" title="numpy.generic.flags"><code>generic.flags</code></a></td> <td>integer value of flags</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.shape/#numpy.generic.shape" title="numpy.generic.shape"><code>generic.shape</code></a></td> <td>tuple of array dimensions</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.strides/#numpy.generic.strides" title="numpy.generic.strides"><code>generic.strides</code></a></td> <td>tuple of bytes steps in each dimension</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.ndim/#numpy.generic.ndim" title="numpy.generic.ndim"><code>generic.ndim</code></a></td> <td>number of array dimensions</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.data/#numpy.generic.data" title="numpy.generic.data"><code>generic.data</code></a></td> <td>pointer to start of data</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.size/#numpy.generic.size" title="numpy.generic.size"><code>generic.size</code></a></td> <td>number of elements in the gentype</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.itemsize/#numpy.generic.itemsize" title="numpy.generic.itemsize"><code>generic.itemsize</code></a></td> <td>length of one element in bytes</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.base/#numpy.generic.base" title="numpy.generic.base"><code>generic.base</code></a></td> <td>base object</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.dtype/#numpy.generic.dtype" title="numpy.generic.dtype"><code>generic.dtype</code></a></td> <td>get array data-descriptor</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.real/#numpy.generic.real" title="numpy.generic.real"><code>generic.real</code></a></td> <td>real part of scalar</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.imag/#numpy.generic.imag" title="numpy.generic.imag"><code>generic.imag</code></a></td> <td>imaginary part of scalar</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.flat/#numpy.generic.flat" title="numpy.generic.flat"><code>generic.flat</code></a></td> <td>a 1-d view of scalar</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.t/#numpy.generic.T" title="numpy.generic.T"><code>generic.T</code></a></td> <td>transpose</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.__array_interface__/#numpy.generic.__array_interface__" title="numpy.generic.__array_interface__"><code>generic.__array_interface__</code></a></td> <td>Array protocol: Python side</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.__array_struct__/#numpy.generic.__array_struct__" title="numpy.generic.__array_struct__"><code>generic.__array_struct__</code></a></td> <td>Array protocol: struct</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.__array_priority__/#numpy.generic.__array_priority__" title="numpy.generic.__array_priority__"><code>generic.__array_priority__</code></a></td> <td>Array priority.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.__array_wrap__/#numpy.generic.__array_wrap__" title="numpy.generic.__array_wrap__"><code>generic.__array_wrap__</code></a></td> <td>sc.__array_wrap__(obj) return scalar from array</td> </tr>  </table>   <h2 id="indexing">Indexing</h2> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../arrays.indexing/#arrays-indexing">Indexing</a>, <a class="reference internal" href="../arrays.dtypes/#arrays-dtypes">Data type objects (dtype)</a></p> </div> <p>Array scalars can be indexed like 0-dimensional arrays: if <em>x</em> is an array scalar,</p> <ul class="simple"> <li>
<code>x[()]</code> returns a 0-dimensional <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a>
</li> <li>
<code>x['field-name']</code> returns the array scalar in the field <em>field-name</em>. (<em>x</em> can have fields, for example, when it corresponds to a structured data type.)</li> </ul>   <h2 id="methods">Methods</h2> <p>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for <a class="reference internal" href="../ufuncs/#ufuncs">ufunc</a>, so that the error state used for ufuncs also carries over to the math on array scalars.</p> <p>The exceptions to the above rules are given below:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic/#numpy.generic" title="numpy.generic"><code>generic</code></a></td> <td>Base class for numpy scalar types.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.__array__/#numpy.generic.__array__" title="numpy.generic.__array__"><code>generic.__array__</code></a></td> <td>sc.__array__(<a href="#id3"><span class="problematic" id="id4">|</span></a>type) return 0-dim array</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.__array_wrap__/#numpy.generic.__array_wrap__" title="numpy.generic.__array_wrap__"><code>generic.__array_wrap__</code></a></td> <td>sc.__array_wrap__(obj) return scalar from array</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.squeeze/#numpy.generic.squeeze" title="numpy.generic.squeeze"><code>generic.squeeze</code></a></td> <td>Not implemented (virtual attribute)</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.byteswap/#numpy.generic.byteswap" title="numpy.generic.byteswap"><code>generic.byteswap</code></a></td> <td>Not implemented (virtual attribute)</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.__reduce__/#numpy.generic.__reduce__" title="numpy.generic.__reduce__"><code>generic.__reduce__</code></a></td> <td></td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.generic.__setstate__/#numpy.generic.__setstate__" title="numpy.generic.__setstate__"><code>generic.__setstate__</code></a></td> <td></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.generic.setflags/#numpy.generic.setflags" title="numpy.generic.setflags"><code>generic.setflags</code></a></td> <td>Not implemented (virtual attribute)</td> </tr>  </table>   <h2 id="defining-new-types">Defining new types</h2> <p>There are two ways to effectively define a new array scalar type (apart from composing structured types <a class="reference internal" href="../arrays.dtypes/#arrays-dtypes">dtypes</a> from the built-in scalar types): One way is to simply subclass the <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the <a class="reference internal" href="../c-api/#c-api">NumPy C-API</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2008–2017 NumPy Developers<br>Licensed under the NumPy License.<br>
    <a href="https://docs.scipy.org/doc/numpy-1.12.0/reference/arrays.scalars.html" class="_attribution-link" target="_blank">https://docs.scipy.org/doc/numpy-1.12.0/reference/arrays.scalars.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
</body>
</html>
